#    Copyright (C) 2021 by Kevin D. Woerner
##-# =KDW= ################# BUILDER $KWROOT/0lib/vkkcp.sh ##################
##-# =KDW= ############# SOURCE $KWROOT/codekdw/kw-lib/Kw.fwipp #############
##-# =KDW= #### THIS FILE CAN BE OVERWRITTEN BY KEVIN D. WOERNER OR HIS #####
##-# =KDW= ############ MINIONS AT *ANY* TIME. Caveat utilitor. #############
# 2021-05-14 kdw  For Changelog,See File Kw.varylog
true = 1;
false = 0;
cxkilogram = 1.0;
cxmeter = 1.0;
cxsecond = 1.0;
cxkelvin = 1.0;
cxampere = 1.0;
cxmole = 1.0;
cxcandela = 1.0;
cxbit = 1.0;
cxradian = 1.0;
cxmass = cxkilogram;
cxlength = cxmeter;
cxdistance = cxlength;
cxtemperature = cxkelvin;
cxtime = cxsecond;
cxangle = cxradian;
cxamount = cxmole;
cxcurrent = cxampere;
cxcharge = cxampere * cxsecond;
cxcoulomb = cxampere * cxsecond;
cxsteradian = (cxradian * cxradian);
cxmetre = cxmeter;
cxkg = cxkilogram;
cxrad = cxradian;
cxe = cxe(1.0);
cxtau = 8.0 * a((1.0) / (1.0)) / cxrad;
cxphi = 0.5 + sqrt(5.0) / 2.0;
cxtwoln = l(2.0);
cxtenln = l(10.0);
cxtwosqrt = sqrt(2.0);
cxeuler = 0.577215664901532860606512090082402431042159335939924;
cxfeigenbaum = 4.669201609102990671853203820466201617258185577475769;
cxapery = 1.202056903159594285399738161511449990764986292340499;
cxgammamin = 1.461632144968362341262659542325721328468196204006446;
cxpi = cxtau / 2.0;
cxyotta = (1.0 * 10^24);
cxzetta = (1.0 * 10^21);
cxexa = (1.0 * 10^18);
cxpeta = (1.0 * 10^15);
cxtera = (1.0 * 10^12);
cxgiga = (1.0 * 10^9);
cxmega = (1.0 * 10^6);
cxkilo = (1.0 * 10^3);
cxhecto = (1.0 * 10^2);
cxdeca = (1.0 * 10^1);
cxdeci = (1.0 * 10^-1);
cxcenti = (1.0 * 10^-2);
cxmilli = (1.0 * 10^-3);
cxmicro = (1.0 * 10^-6);
cxnano = (1.0 * 10^-9);
cxpico = (1.0 * 10^-12);
cxfemto = (1.0 * 10^-15);
cxatto = (1.0 * 10^-18);
cxzepto = (1.0 * 10^-21);
cxyocto = (1.0 * 10^-24);
cxkibi = 1024.0;
cxmebi = cxkibi * cxkibi;
cxgibi = cxmebi * cxkibi;
cxtebi = cxgibi * cxkibi;
cxpebi = cxtebi * cxkibi;
cxexbi = cxpebi * cxkibi;
cxzebi = cxexbi * cxkibi;
cxyobi = cxzebi * cxkibi;
cxmps = cxmeter / cxsecond;
cxmpss = cxmeter / (cxsecond * (cxsecond));
cxunitgm = cxmeter * (cxmps * (cxmps));
cxnewton = cxkilogram * cxmpss;
cxjoule = cxnewton * cxmeter;
cxpa = cxnewton / (cxmeter * (cxmeter));
cxwatt = cxjoule / cxsecond;
cxhertz = 1.0 / cxsecond;
cxhz = cxhertz;
cxamp = cxampere;
cxvolt = cxwatt / cxampere;
cxohm = cxvolt / cxampere;
cxhenry = cxohm * cxsecond;
cxfarad = cxcoulomb / cxvolt;
cxsiemens = 1.0 / cxohm;
cxweber = cxvolt * cxsecond;
cxtesla = cxweber / (cxmeter * (cxmeter));
cxlumen = cxcandela * cxsteradian;
cxlux = cxlumen / (cxmeter * (cxmeter));
cxboltzmann = (1.380649 * 10^-23) * cxjoule / cxkelvin;
cxboltzmann_err = 0.0;
cxboltzmann_rec = 1.0 / cxboltzmann;
cxboltzmann_rec_err = 0.0;
cxelementarycharge = (1.602176634 * 10^-19) * cxcoulomb;
cxelementarycharge_err = 0.0;
cxlight = (2.99792458 * 10^8) * cxmeter / cxsecond;
cxlight_err = 0.0;
cxlight_rec = 1.0 / cxlight;
cxlight_rec_err = 0.0;
cxavogadro = (6.02214076 * 10^23) / cxmole;
cxavogadro_err = 0.0;
cxavogadro_rec = 1.0 / cxavogadro;
cxavogadro_rec_err = 0.0;
cxplanck = (6.62607015 * 10^-34) * cxjoule * cxsecond;
cxplanck_err = 0.0;
cxplanck_rec = 1.0 / cxplanck;
cxplanck_rec_err = 0.0;
cxkcd = (6.83 * 10^2) * cxlumen / cxwatt;
cxkcd_err = 0.0;
cxdvcs_hz = (9.19263177 * 10^9) / cxsecond;
cxdvcs_wavelength = cxlight / cxdvcs_hz;
cxdvcs_energy = cxdvcs_hz * cxplanck;
cxdvcs_err = 0.0;
cxkb = cxboltzmann;
cxkb_err = cxboltzmann_err;
cxkb_rec = 1.0 / kB;
cxkb_rec_err = cxboltzmann_err;
cxelectron_charge = - cxelementarycharge;
cxelectron_charge_err = cxelementarycharge_err;
cxplanckbar = cxplanck / cxtau;
cxplanckbar_err = cxplanck_err;
cxh = cxplanck;
cxh_err = cxplanck_err;
cxh_rec = 1.0 / cxplanck;
cxh_rec_err = cxplanck_err;
cxc = cxlight;
cxc_err = cxlight_err;
cxc_rec = 1.0 / cxlight;
cxc_rec_err = cxlight_err;
cxhbar = cxplanckbar;
cxhbar_err = cxplanckbar_err;
cxgravity = 9.80665 * cxmpss;
cxgravity_err = 0.0;
cxatmosphere = (1.01325 * 10^5) * cxpa;
cxatmosphere_err = 0.0;
cxau = (1.495978707 * 10^11) * cxmeter;
cxau_err = 0.0;
cxjosephson = 2.0 * cxelementarycharge / cxplanck;
cxjosephson_err = 0.0;
cxvonklitzing = cxplanck / (cxelementarycharge * (cxelementarycharge));
cxvonklitzing_err = 0.0;
cxfaraday = cxelementarycharge * cxavogadro;
cxfaraday_err = 0.0;
cxfaraday_rec = 1.0 / cxfaraday;
cxfaraday_rec_err = 0.0;
cxgas = cxboltzmann * cxavogadro;
cxgas_err = 0.0;
cxgas_rec = 1.0 / cxgas;
cxgas_rec_err = 0.0;
cxfaradayconst = cxfaraday;
cxfaradayconst_err = cxfaraday_err;
cxfaradayconst_rec = 1.0 / cxfaradayconst;
cxfaradayconst_rec_err = cxfaraday_err;
cxgasconst = cxgas;
cxgasconst_err = cxgas_err;
cxgasconst_rec = 1.0 / cxgasconst;
cxgasconst_rec_err = cxgas_err;
cxgravitation = (6.67430 * 10^-11) * cxunitgm / cxkilogram;
cxgravitation_err = (2.2 * 10^-5);
cxgravitation_rec = 1.0 / cxgravitation;
cxgravitation_rec_err = (2.2 * 10^-5);
cxrydberg = (1.0973731568160 * 10^7) * cxlight / cxmeter;
cxrydberg_err = (1.9 * 10^-12);
cxrydberg_rec = 1.0 / cxrydberg;
cxrydberg_rec_err = (1.9 * 10^-12);
cxg = cxgravitation;
cxg_err = cxgravitation_err;
cxalpha = 1.0 / 137.035999206;
cxalpha_err = (8.1 * 10^-11);
cxalpha_rec = 1.0 / cxalpha;
cxalpha_rec_err = (8.1 * 10^-11);
cxalphasqrt = sqrt(cxalpha);
cxfltsig = 23;
cxfltman = 8;
cxflteps = (1.1920928955078125 * 10^-7);
cxfltmax = (3.402823466385288598 * 10^38);
cxdblmaxln = cxtwoln * 1024.0;
cxdblsig = scale * cxtenln / cxtwoln;
cxdbleps = cxe(cxtenln * (1.0 - scale));
cxdblmax = cxe(cxdblmaxln) * (1.0 - cxdbleps);
cxsi16max = 32767;
cxsi16min = -32768;
cxui16max = 65535;
cxsi32max = 2147483647;
cxsi32min = -2147483648;
cxui32max = 4294967295;
cxintmax = cxsi32max;
cxjewish_first_month = 7;
cxmonths_in_year = 12;
cxuvpv = cxmicro;
cxminute = 60.0 * cxsecond;
cxhour = 60.0 * cxminute;
cxday = 24.0 * cxhour;
cxweek = 7.0 * cxday;
cxflick = cxsecond / 705600000.0;
cxjday = cxday;
cxjyear = 365.25 * cxjday;
cxjcentury = 100.0 * cxjyear;
cxgyear = 365.2425 * cxday;
cxgyear_at_0j2k = 2000.0;
cxkwt = 0.1875 * cxsecond;
cxuet = cxsecond;
cxj2k = cxday;
cxj2kday = cxday;
cxjdsec_at_0gregorian = 1721058.5 * cxjday;
cxjdsec_at_0kwt = 2437240.66125 * cxjday;
cxjdsec_at_0j2k = 2451545.0 * cxjday;
cxjdsec_at_0uet = 2440587.5 * cxjday;
cxtt_at_0tai = 32.184 * cxsecond;
cxtt_at_0ut1 = 68.97 * cxsecond;
cxgram = 0.001 * cxkilogram;
cxcarat = 0.2 * cxgram;
cxtonne = 1000.0 * cxkilogram;
cxpound = 0.45359237 * cxkilogram;
cxlb = cxpound;
cxgrain = cxpound / 7000.0;
cxounce = 0.0625 * cxpound;
cxoz = cxounce;
cxstone = 14.0 * cxpound;
cxton = 2000.0 * cxpound;
cxmm = cxmilli * cxmeter;
cxinch = 0.0254 * cxmeter;
cxhand = 4.0 * cxinch;
cxfoot = 12.0 * cxinch;
cxsurveyfoot = 1200.0 * cxmeter / 3937.0;
cxfeet = cxfoot;
cxft = cxfoot;
cxyard = 3.0 * cxfeet;
cxhorse = 8.0 * cxfeet;
cxlink = 66.0 * cxsurveyfoot / 100.0;
cxchain = 100 * cxlink;
cxfurlong = 10 * cxchain;
cxmile = 5280.0 * cxfeet;
cxpoint = cxinch / 72.0;
cxstandardgravity = cxgravity;
cxgravitationnasa = (6.67259 * 10^-11) * cxunitgm / cxkilogram;
cxgravitationiers = (6.67428 * 10^-11) * cxunitgm / cxkilogram;
cxkgf = cxkilogram * cxgravity;
cxlbf = cxpound * cxgravity;
cxatm = cxatmosphere;
cxstandardatmosphere = cxatmosphere;
cxtorr = cxatmosphere / 760.0;
cxbar = (1.0 * 10^5) * cxpa;
cxmmhg = 13595.1 * cxkilogram * cxgravity * cxmm / (cxmeter * (cxmeter) *\
         (cxmeter));
cxinhg = cxmmhg * cxinch / cxmm;
cxpsi = cxpound * cxgravity / (cxinch * (cxinch));
cxdegc = cxkelvin;
cxdegf = cxkelvin / 1.8;
cxdegr = cxdegf;
cxk_at_0tempc = 273.15 * cxdegc;
cxk_at_0tempf = 459.67 * cxdegf;
cxk_at_0tempr = 0.0 * cxdegr;
cxtempf_at_0tempc = 32.0 * cxkelvin;
cxmach = 331.46 * cxmps;
cxmph = cxmile / cxhour;
cxhectare = 10000.0 * (cxmeter * (cxmeter));
cxare = 100.0 * (cxmeter * (cxmeter));
cxacre = (cxmile * (cxmile)) / 640.0;
cxbarn = (1.0 * 10^-28) * (cxmeter * (cxmeter));
cxliter = (cxmeter * (cxmeter) * (cxmeter)) / 1000.0;
cxlitre = cxliter;
cxgallon = 231.0 * (cxinch * (cxinch) * (cxinch));
cxquart = cxgallon / 4.0;
cxpint = cxquart / 2.0;
cxcup = cxpint / 2.0;
cxfloz = cxcup / 8.0;
cxtblsp = cxfloz / 2.0;
cxtsp = cxtblsp / 3.0;
cxbarrel = 42.0 * cxgallon;
cxdrygallon = 9.25 * 9.25 * cxpi * (cxinch * (cxinch) * (cxinch));
cxpeck = 2.0 * cxdrygallon;
cxbushel = 8.0 * cxdrygallon;
cxah = cxampere * cxhour;
cxcalorie = 4.184 * cxjoule;
cxcal_it = 4.1868 * cxjoule;
cxcal_th = cxcalorie;
cxcal = cxcalorie;
cxbtu_th = cxcal_th * cxpound * cxdegf / (cxgram * cxdegc);
cxbtu_it = cxcal_it * cxpound * cxdegf / (cxgram * cxdegc);
cxbtu = cxcalorie * cxpound * cxdegf / (cxgram * cxdegc);
cxhp = 550.0 * cxfoot * cxpound * cxgravity / cxsecond;
cxhorsepower = cxhp;
cxhpmetric = 75.0 * cxkilogram * cxgravity * cxmps;
cxelectronvolt = cxelementarycharge * cxvolt;
cxev = cxelectronvolt;
cxerg = (1.0 * 10^-7) * cxjoule;
cxfoe = (1.0 * 10^44) * cxjoule;
cxaaabattery_charge = 2.1 * cxah;
cxaaabattery_voltage = 1.5 * cxvolt;
cxaaabattery = cxaaabattery_charge * cxaaabattery_voltage;
cxaaabattery_energy = cxaaabattery;
cxaabattery_charge = 2.7 * cxah;
cxaabattery_voltage = 1.5 * cxvolt;
cxaabattery = cxaabattery_charge * cxaabattery_voltage;
cxaabattery_energy = cxaabattery;
cxcbattery_charge = 8.0 * cxah;
cxcbattery_voltage = 1.5 * cxvolt;
cxcbattery = cxcbattery_charge * cxcbattery_voltage;
cxcbattery_energy = cxcbattery;
cxdbattery_charge = 12.0 * cxah;
cxdbattery_voltage = 1.5 * cxvolt;
cxdbattery = cxdbattery_charge * cxdbattery_voltage;
cxdbattery_energy = cxdbattery;
cxninevolt_charge = 0.565 * cxah;
cxninevolt_voltage = 9.0 * cxvolt;
cxninevolt = cxninevolt_charge * cxninevolt_voltage;
cxninevolt_energy = cxninevolt;
cxninevoltbattery_charge = cxninevolt_charge;
cxninevoltbattery_voltage = cxninevolt_voltage;
cxninevoltbattery = cxninevoltbattery_charge * cxninevoltbattery_voltage;
cxninevoltbattery_energy = cxninevoltbattery;
cxphonebattery_charge = 3.0 * cxah;
cxphonebattery_voltage = 3.8 * cxvolt;
cxphonebattery = cxphonebattery_charge * cxphonebattery_voltage;
cxphonebattery_energy = cxphonebattery;
cxcarbattery_charge = 45.0 * cxah;
cxcarbattery_voltage = 12.0 * cxvolt;
cxcarbattery = cxcarbattery_charge * cxcarbattery_voltage;
cxcarbattery_energy = cxcarbattery;
cxmicrowave_hz = (2.45 * 10^9) * cxhertz;
cxmicrowave_wavelength = cxlight / cxmicrowave_hz;
cxmicrowave_energy = cxmicrowave_hz * cxplanck;
cxlf_hz = (1.0 * 10^5) * cxhertz;
cxlf_wavelength = cxlight / cxlf_hz;
cxlf_energy = cxlf_hz * cxplanck;
cxmf_hz = (1.0 * 10^6) * cxhertz;
cxmf_wavelength = cxlight / cxmf_hz;
cxmf_energy = cxmf_hz * cxplanck;
cxhf_hz = (1.0 * 10^7) * cxhertz;
cxhf_wavelength = cxlight / cxhf_hz;
cxhf_energy = cxhf_hz * cxplanck;
cxvhf_hz = (1.0 * 10^8) * cxhertz;
cxvhf_wavelength = cxlight / cxvhf_hz;
cxvhf_energy = cxvhf_hz * cxplanck;
cxuhf_hz = (1.0 * 10^9) * cxhertz;
cxuhf_wavelength = cxlight / cxuhf_hz;
cxuhf_energy = cxuhf_hz * cxplanck;
cxshf_hz = (1.0 * 10^10) * cxhertz;
cxshf_wavelength = cxlight / cxshf_hz;
cxshf_energy = cxshf_hz * cxplanck;
cxehf_hz = (1.0 * 10^11) * cxhertz;
cxehf_wavelength = cxlight / cxehf_hz;
cxehf_energy = cxehf_hz * cxplanck;
cxthf_hz = (1.0 * 10^12) * cxhertz;
cxthf_wavelength = cxlight / cxthf_hz;
cxthf_energy = cxthf_hz * cxplanck;
cxfir_hz = (1.0 * 10^12) * cxhertz;
cxfir_wavelength = cxlight / cxfir_hz;
cxfir_energy = cxfir_hz * cxplanck;
cxmir_hz = (1.0 * 10^13) * cxhertz;
cxmir_wavelength = cxlight / cxmir_hz;
cxmir_energy = cxmir_hz * cxplanck;
cxnir_hz = (1.0 * 10^14) * cxhertz;
cxnir_wavelength = cxlight / cxnir_hz;
cxnir_energy = cxnir_hz * cxplanck;
cxred_wavelength = (7.0 * 10^-7) * cxmeter;
cxred_hz = cxlight / cxred_wavelength;
cxred_energy = cxred_hz * cxplanck;
cxorange_wavelength = (6.2 * 10^-7) * cxmeter;
cxorange_hz = cxlight / cxorange_wavelength;
cxorange_energy = cxorange_hz * cxplanck;
cxyellow_wavelength = (5.8 * 10^-7) * cxmeter;
cxyellow_hz = cxlight / cxyellow_wavelength;
cxyellow_energy = cxyellow_hz * cxplanck;
cxyellowgreen_hz = (5.4 * 10^14) * cxhertz;
cxyellowgreen_wavelength = cxlight / cxyellowgreen_hz;
cxyellowgreen_energy = cxyellowgreen_hz * cxplanck;
cxgreen_wavelength = (5.3 * 10^-7) * cxmeter;
cxgreen_hz = cxlight / cxgreen_wavelength;
cxgreen_energy = cxgreen_hz * cxplanck;
cxblue_wavelength = (5.0 * 10^-7) * cxmeter;
cxblue_hz = cxlight / cxblue_wavelength;
cxblue_energy = cxblue_hz * cxplanck;
cxviolet_wavelength = (4.2 * 10^-7) * cxmeter;
cxviolet_hz = cxlight / cxviolet_wavelength;
cxviolet_energy = cxviolet_hz * cxplanck;
cxnuv_hz = (1.0 * 10^15) * cxhertz;
cxnuv_wavelength = cxlight / cxnuv_hz;
cxnuv_energy = cxnuv_hz * cxplanck;
cxeuv_hz = (1.0 * 10^16) * cxhertz;
cxeuv_wavelength = cxlight / cxeuv_hz;
cxeuv_energy = cxeuv_hz * cxplanck;
cxuva_wavelength = (3.6 * 10^-7) * cxmeter;
cxuva_hz = cxlight / cxuva_wavelength;
cxuva_energy = cxuva_hz * cxplanck;
cxuvb_wavelength = (3.0 * 10^-7) * cxmeter;
cxuvb_hz = cxlight / cxuvb_wavelength;
cxuvb_energy = cxuvb_hz * cxplanck;
cxuvc_wavelength = (1.9 * 10^-7) * cxmeter;
cxuvc_hz = cxlight / cxuvc_wavelength;
cxuvc_energy = cxuvc_hz * cxplanck;
cxsx_hz = (3.0 * 10^17) * cxhertz;
cxsx_wavelength = cxlight / cxsx_hz;
cxsx_energy = cxsx_hz * cxplanck;
cxsxx_wavelength = (1.0 * 10^-9) * cxmeter;
cxsxx_hz = cxlight / cxsxx_wavelength;
cxsxx_energy = cxsxx_hz * cxplanck;
cxhx_hz = (1.0 * 10^19) * cxhertz;
cxhx_wavelength = cxlight / cxhx_hz;
cxhx_energy = cxhx_hz * cxplanck;
cxgamma_hz = (1.0 * 10^20) * cxhertz;
cxgamma_wavelength = cxlight / cxgamma_hz;
cxgamma_energy = cxgamma_hz * cxplanck;
cxturn = cxtau * cxradian;
cxarcturn = cxturn;
cxarcradian = cxradian;
cxarcdegree = cxturn / 360.0;
cxarcminute = cxarcdegree / 60.0;
cxarcsecond = cxarcminute / 60.0;
cxarcgrad = cxturn / 400.0;
cxarcdeg = cxarcdegree;
cxarcmin = cxarcminute;
cxarcsec = cxarcsecond;
cxgrad = cxarcgrad;
cxsquaredegree = (cxarcdegree * (cxarcdegree));
cxsqdeg = cxsquaredegree;
cxspheresurface = 2.0 * cxtau * cxsteradian;
cxshannon = cxbit;
cxnat = cxbit / cxtwoln;
cxhartley = cxtenln / cxtwoln * cxbit;
cxhart = cxhartley;
cxdit = cxhartley;
cxban = cxhartley;
cxrpm = cxturn / cxminute;
cxrps = cxturn / cxsecond;
cxrph = cxturn / cxhour;
cxozfin = cxounce * cxgravity * cxinch;
cxlbfin = cxpound * cxgravity * cxinch;
cxlbfft = cxpound * cxgravity * cxfoot;
cxkgfm = cxkg * cxgravity * cxmeter;
cxnm_per_lbfin = cxlbfin / (cxnewton * cxmeter);
cxkgfm_per_lbfin = cxlbfin / (cxkg * cxgravity * cxmeter);
cxlbfinrpm_per_hp = cxhorsepower / (cxlbfin * cxrpm);
cxozfin_per_lbfin = cxpound / cxounce;
cxlbfft_per_lbfin = cxinch / cxfoot;
cxw_per_hp = cxhorsepower / cxwatt;
cxfinestructure = cxalpha;
cxfinestructure_err = cxalpha_err;
cxfinestructure_rec = 1.0 / cxfinestructure;
cxfinestructure_rec_err = cxalpha_err;
cxmagnetic = 2.0 * cxvonklitzing * cxalpha / cxlight;
cxmagnetic_err = cxalpha_err;
cxmu0 = cxmagnetic;
cxmu0_err = cxalpha_err;
cxelectric = 1.0 / ((cxlight * (cxlight)) * cxmu0);
cxelectric_err = cxalpha_err;
cxepsilon0 = cxelectric;
cxepsilon0_err = cxalpha_err;
cxcoulombconst = 1.0 / (2.0 * cxtau * cxelectric);
cxcoulombconst_err = cxalpha_err;
cxproton_radius = (8.414 * 10^-16) * cxmeter;
cxproton_radius_err = (2.2 * 10^-3);
cxmolarmass = (1.0 - (3.5 * 10^-10)) * cxgram / cxmole;
cxmolarmass_err = (3.0 * 10^-10);
cxdalton = cxmolarmass / cxavogadro;
cxdalton_err = cxmolarmass_err;
cxamu = cxdalton;
cxamu_err = cxdalton_err;
cxatomicmassunit = cxdalton;
cxatomicmassunit_err = cxdalton_err;
cxuamu = cxdalton;
cxuamu_err = cxdalton_err;
cxrydberg_hz = cxrydberg;
cxrydberg_wavelength = cxlight / cxrydberg_hz;
cxrydberg_energy = cxrydberg_hz * cxplanck;
cxelectron_massa = 2.0 * cxrydberg_hz * cxplanck / ((cxlight * cxalpha) *\
         (cxlight * cxalpha));
cxelectron_massa_err = 2.0 * cxalpha_err;
cxhi_hz = (1.4204057517667 * 10^9) * cxhertz;
cxhi_wavelength = cxlight / cxhi_hz;
cxhi_energy = cxhi_hz * cxplanck;
cxhydrogenline = cxhi_wavelength;
cxhydrogenline_err = (6.3 * 10^-13);
cxhi = cxlight / cxhi_hz;
cxhi_err = cxhydrogenline_err;
cxplanckmass = sqrt(cxhbar * cxlight / cxgravitation);
cxplanckcharge = cxelementarycharge / cxalphasqrt;
cxplanckenergy = cxplanckmass * (cxlight * (cxlight));
cxplancktemp = cxplanckenergy / cxboltzmann;
cxplancklength = cxhbar / (cxplanckmass * cxlight);
cxplancktime = cxplancklength / cxlight;
cxplanckfrequency = 1.0 / cxplancktime;
cxstefan = (cxtau * (cxtau) * (cxtau) * (cxtau) * (cxtau)) * (cxboltzmann\
         * (cxboltzmann) * (cxboltzmann) * (cxboltzmann)) / (240.0 *\
         (cxlight * (cxlight)) * (cxplanck * (cxplanck) * (cxplanck)));
cxstefan_err = 0.0;
cxpingpongball_radius = 0.02 * cxmeter;
cxgolfball_radius = 0.02135 * cxmeter;
cxtennisball_radius = 0.03325 * cxmeter;
cxbaseball_radius = 9.125 * cxinch / cxtau;
cxsoftball_radius = 12.0 * cxinch / cxtau;
cxsoccerball_radius = 0.69 * cxmeter / cxtau;
cxbasketball_radius = 0.75 * cxmeter / cxtau;
cxpingpongball_mass = 0.0027 * cxkg;
cxgolfball_mass = 0.04593 * cxkg;
cxtennisball_mass = 0.0577 * cxkg;
cxbaseball_mass = 0.1465 * cxkg;
cxsoftball_mass = 0.187 * cxkg;
cxbasketball_mass = 0.620 * cxkg;
cxsoccerball_mass = 0.430 * cxkg;
cxmarathon = 42195.0 * cxmeter;
cxpenny_height = (1.52 * 10^-3) * cxmeter;
cxnickel_height = (1.95 * 10^-3) * cxmeter;
cxdime_height = (1.35 * 10^-3) * cxmeter;
cxquarter_height = (1.75 * 10^-3) * cxmeter;
cxpenny_diameter = 0.75 * cxinch;
cxnickel_diameter = (2.121 * 10^-2) * cxmeter;
cxdime_diameter = (1.791 * 10^-2) * cxmeter;
cxquarter_diameter = (2.426 * 10^-2) * cxmeter;
cxpenny_mass = 2.5 * cxgram;
cxnickel_mass = 5.0 * cxgram;
cxdime_mass = 0.005 * cxpound;
cxquarter_mass = 0.0125 * cxpound;
cxmoon_month = 29.530587981 * cxday;
cxmilkyway_age = (8.3 * 10^9) * cxjyear;
cxastronomicalunit = cxau;
cxlightyear = cxlight * cxjyear;
cxparsec = 1296000.0 * cxastronomicalunit / cxtau;
cxproximacentauri = (39.9 * 10^15) * cxmeter;
cxmilkyway_radius = (6.0 * 10^4) * cxlightyear;
cxgalacticcenter = (2.64 * 10^4) * cxlightyear;
cxmilkyway_mass = (1.4 * 10^42) * cxkilogram;
cxsolarconstant = 1361.0 * cxwatt / (cxmeter * (cxmeter));
cxuniverse_age = (13.799 * 10^9) * cxjyear;
cxuniverse_radius = (14.26 * 10^9) * cxparsec;
cxuniverse_mass = (1.46 * 10^53) * cxkilogram;
cxeinstein = 4.0 * cxtau * cxgravitation / (cxlight * (cxlight) *\
         (cxlight) * (cxlight));
cxeinstein_err = cxgravitation_err;
cxhubble = (67.66 * 10^-3) * cxmeter / (cxsecond * cxparsec);
cxhubble_err = (6.0 * 10^-3);
cxhubbleradius = cxlight / cxhubble;
cxbhmasstemp = ((cxlight * (cxlight) * (cxlight)) * cxhbar / (4.0 * cxtau\
         * cxgravitation * cxboltzmann));
cxbhmass_radius = 0.5 * (cxlight * (cxlight)) / cxgravitation;
cxbhmass3_lifetime = (cxplanck * (cxlight * (cxlight) * (cxlight) *\
         (cxlight))) / (2560.0 * (cxtau * (cxtau)) * (cxgravitation *\
         (cxgravitation)));
cxbhradius2density = 1.5 * cxbhmass_radius / cxtau;
cxbhmass2_entropy = (cxplanck * cxlight) / (2.0 * cxtau * cxtau *\
         cxgravitation * cxboltzmann);
cxbhentropy_area = (cxtau * (cxlight * (cxlight) * (cxlight)) *\
         cxboltzmann) / (4.0 * cxplanck * cxgravitation);
cxbhmass2power = (cxlight * (cxlight) * (cxlight) * (cxlight) * (cxlight)\
         * (cxlight)) * cxplanck / (7680.0 * (cxtau * (cxtau)) *\
         (cxgravitation * (cxgravitation)));
cxbhmass2_area = cxbhmass2_entropy * cxbhentropy_area;
cxbhmass2_density = (cxbhmass_radius * (cxbhmass_radius)) *\
         cxbhradius2density;
cxbekensteininformation = ((cxtau * (cxtau)) * cxnat) / (cxplanck * cxlight);
cxbekensteinentropy = ((cxtau * (cxtau)) * cxboltzmann) / (cxplanck *\
         cxlight);
cxelevationmax = 8848.0 * cxmeter;
cxelevationmin = -10994.0 * cxmeter;
cxkpgboundary = (65.5 * 10^6) * cxjyear;
cxtrjboundary = (199.6 * 10^6) * cxjyear;
cxmilkyway_day = (250.0 * 10^6) * cxjyear;
cxptrboundary = (251.4 * 10^6) * cxjyear;
cxnpboundary = (542.0 * 10^6) * cxjyear;
cxlife_age = (3.85 * 10^9) * cxjyear;
cxgiantimpact = (4.533 * 10^9) * cxjyear;
cxearth_age = (4.56717 * 10^9) * cxjyear;
cxppq = (1.0 * 10^-15);
cxppt = (1.0 * 10^-12);
cxppb = (1.0 * 10^-9);
cxppm = (1.0 * 10^-6);
cxpermille = (1.0 * 10^-3);
cxpercent = (1.0 * 10^-2);
cxsolid_angle = cxsteradian;
cxspeed = cxlength / cxtime;
cxacceleration = cxspeed / cxtime;
cxforce = cxmass * cxacceleration;
cxenergy = cxforce * cxlength;
cxaction = cxenergy * cxtime;
cxpower = cxenergy / cxtime;
cxarea = (cxlength * (cxlength));
cxvolume = (cxlength * (cxlength) * (cxlength));
cxdensity = cxmass / cxvolume;
cxspecificheat = cxenergy / (cxmass * cxtemperature);
cxpressure = cxforce / cxarea;
cxviscosity = cxforce * cxtime / cxarea;
cxfrequency = 1 / cxtime;
cxvoltage = cxpower / cxcurrent;
cxresistance = cxvoltage / cxcurrent;
cxinductance = cxresistance * cxtime;
cxcapacitance = cxcharge / cxvoltage;
cxconductance = 1.0 / cxresistance;
cxmagneticflux = cxvoltage * cxtime;
cxmagneticinduction = cxmagneticflux / cxarea;
#include <time.h>
#   IIIIIIIIIIMPORT_MASTER-Function ################################# atan2 #
define atan2(yy,xx) {
   auto retvalu;
   if (0.0 < xx) {
      retvalu = a(yy / xx);
   } else if (xx < 0) {
      if (yy < 0.0) {
         retvalu = a(yy / xx) - cxtau / 2.0;
      } else if (0.0 < yy) {
         retvalu = a(yy / xx) + cxtau / 2.0;
      } else {
         retvalu = cxtau / 2.0;
      }
   } else {
      if (yy < 0.0) {
         retvalu = -cxtau / 4.0;
      } else if (0.0 < yy) {
         retvalu = cxtau / 4.0;
      } else {
         retvalu = 0.0;
      }
   }
   return(retvalu);
}
#   IIIIIIIIIIMPORT_MASTER-Function ################################# floor #
define floor(xx) {
   auto local_prev_scale,retvalu;
   local_prev_scale = scale;
   scale = 0;
   retvalu = xx / 1;
   if (xx < retvalu) {
      retvalu -= 1;
   }
   scale = local_prev_scale;
   return(retvalu);
}
#   IIIIIIIIIIMPORT_MASTER-Function ################################### log #
define log(xx)     { return(l(xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function ################################### exp #
define exp(xx)     { return(cxe(xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function ################################### pow #
define pow(xx,yy) { return(cxe(yy * l(xx))); }
#   IIIIIIIIIIMPORT_MASTER-Function ################################### cos #
define cos(xx)     { return(cxc(xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function ################################### sin #
define sin(xx)     { return(s(xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function ################################### tan #
define tan(xx)     { return(sin(xx) / cos(xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function ################################## ceil #
define ceil(xx)    { return(-floor(-xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function ################################# ceill #
define ceill(xx)   { return(ceil(xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function ################################ floorl #
define floorl(xx)  { return(floor(xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function ############################# lf_shiftl #
define lf_shiftl(xx,nn) {
   return(xx * (2 ^ nn));
}
#   IIIIIIIIIIMPORT_MASTER-Function ############################# lf_shiftr #
define lf_shiftr(xx,nn) {
   auto local_prev_scale,retvalu;
   local_prev_scale = scale;
   scale = 0;
   retvalu = xx / (2 ^ nn);
   scale = local_prev_scale;
   return(retvalu);
}
#   IIIIIIIIIIMPORT_MASTER-Function ################################### abs #
define abs(xx) {
   auto retvalu;
   if (xx < 0.0) {
      retvalu = -xx;
   } else {
      retvalu = xx;
   }
   return (retvalu);
}
#   IIIIIIIIIIMPORT_MASTER-Function ############################# lf_mod_bc #
define lf_mod_bc(xx,yy) {
   auto axx,ayy,retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   axx = abs(xx) / 1;
   ayy = abs(yy) / 1;
   retvalu = axx % ayy;
   if (xx < 0) {
      retvalu = ayy - retvalu;
   }
   scale = local_prev_scale;
   return(retvalu);
}
define id(xx) {
   return (xx);
}
define reci(xx) {
   return (1.0 / xx);
}
define neg(xx) {
   return (- xx);
}
define square(xx) {
   return (xx * xx);
}
define sq(xx) {
   return (xx * xx);
}
define sqinv(xx) {
   return (sqrt(xx));
}
define cube(xx) {
   return (xx * xx * xx);
}
define cu(xx) {
   return (xx * xx * xx);
}
define sign(xx) {
   auto retvalu;
   if (xx < 0.0) {
      retvalu = -1.0;
   } else if (0.0 < xx) {
      retvalu = 1.0;
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define stair(xx) {
   auto retvalu;
   if (xx < 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = 1.0;
   }
   return (retvalu);
}
define heaviside(xx) {
   auto retvalu;
   if (xx < 0.0) {
      retvalu = 0.0;
   } else if (0.0 < xx) {
      retvalu = 1.0;
   } else {
      retvalu = 0.5;
   }
   return (retvalu);
}
define divi(numer,denom,def_val) {
   auto retvalu;
   if (denom < 0.0 || 0.0 < denom) {
      retvalu = numer / denom;
   } else {
      retvalu = def_val;
   }
   return (retvalu);
}
define clip(xx) {
   auto retvalu;
   if (xx < 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = xx;
   }
   return (retvalu);
}
define clip2(xx,xlow,xhigh) {
   auto retvalu;
   if (xx <= xlow) {
      retvalu = xlow;
   } else if (xx <= xhigh) {
      retvalu = xx;
   } else {
      retvalu = xhigh;
   }
   return (retvalu);
}
define clip2x(xx,xa,xb) {
   auto retvalu;
   if (xb < xa) {
      if (xx <= xb || xa <= xx) {
         retvalu = xx;
      } else if (2.0 * xx < xa + xb) {
         retvalu = xb;
      } else {
         retvalu = xa;
      }
   } else {
      if (xx <= xa) {
         retvalu = xa;
      } else if (xx <= xb) {
         retvalu = xx;
      } else {
         retvalu = xb;
      }
   }
   return (retvalu);
}
define sba(xx) {
   auto retvalu;
   if (- 1.0 < xx && xx < 1.0) {
      retvalu = xx;
   } else {
      retvalu = 1.0 / xx;
   }
   return (retvalu);
}
define ratio(aa,bb) {
   auto rati;
   if (abs(aa) < abs(bb)) {
      rati = aa / bb;
   } else {
      rati = bb / aa;
   }
   return (rati);
}
define horner(xx,deg,*coefh_arr_pc[]) {
   auto jj,sum_curr;
   sum_curr = coefh_arr_pc[deg];
   for (jj = deg - 1; 0 <= jj; jj -= 1) {
      sum_curr *= xx;
      sum_curr += coefh_arr_pc[jj];
   }
   return (sum_curr);
}
define chebeval(xx,deg,*cheb_arr_pc[]) {
   auto ba,bb,bc,ii;
   xx *= 2.0;
   ba = cheb_arr_pc[deg];
   bb = 0.0;
   bc = 0.0;
   for (ii = deg - 1; 0 <= ii; ii -= 1) {
      bc = bb;
      bb = ba;
      ba = xx * bb - bc + cheb_arr_pc[ii];
   }
   return ((ba - bc) / 2.0);
}
define ln(xx) {
   return (log(xx));
}
define lg(xx) {
   return (log(xx) / cxtwoln);
}
define log10(xx) {
   return (log(xx) / log(10.0));
}
define logx(xx,bb) {
   return (log(xx) / log(bb));
}
define l10(xx) {
   return (log(xx) / log(10.0));
}
define log2(xx) {
   return (log(xx) / cxtwoln);
}
define fmod(xx,yymodulus) {
   auto retvalu,qu;
   if (yymodulus < 0.0 || 0.0 < yymodulus) {
      qu = xx / yymodulus;
      if (qu < 0.0) {
         retvalu = xx - ceil(qu) * yymodulus;
      } else {
         retvalu = xx - floor(qu) * yymodulus;
      }
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define modf(xx,*ret_int_arr_p[]) {
   auto retvalu,int_part;
   if (xx < 0.0) {
      int_part = ceil(xx);
   } else if (0.0 < xx) {
      int_part = floor(xx);
   } else {
      int_part = 0;
   }
   ret_int_arr_p[0] = xx - int_part;
   return (retvalu);
}
define fmody(xx,yymodulus) {
   auto retvalu;
   if (yymodulus < 0.0 || 0.0 < yymodulus) {
      retvalu = xx - floor(xx / yymodulus) * yymodulus;
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define fmodu(xx,yymodulus) {
   auto retvalu;
   if (yymodulus < 0.0 || 0.0 < yymodulus) {
      retvalu = fmod(xx,yymodulus);
      if (retvalu < 0.0) {
         retvalu += abs(yymodulus);
      }
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define remquou(xx,yymodulus,*ret_int_arr_p[]) {
   auto retvalu,qu,fl;
   if (yymodulus < 0.0 || 0.0 < yymodulus) {
      qu = xx / yymodulus;
      fl = floor(qu);
      retvalu = qu - fl;
   } else {
      fl = 0.0;
      retvalu = xx;
   }
   ret_int_arr_p[0] = fl;
   return (retvalu);
}
define fmods(xx,yymodulus) {
   auto retvalu,ayy,lim;
   if (yymodulus < 0.0 || 0.0 < yymodulus) {
      retvalu = fmod(xx,yymodulus);
      ayy = abs(yymodulus);
      lim = ayy / 2.0;
      if (retvalu < - lim) {
         retvalu += ayy;
      } else if (lim <= retvalu) {
         retvalu -= ayy;
      }
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define pow2(expo) {
   return (pow(2.0,expo));
}
define pow10(expo) {
   return (pow(10.0,expo));
}
define sigmoid(xx) {
   return (1.0 / (1.0 + exp(-xx)));
}
define sigmoidinv(xx) {
   return (- log(((1.0 / xx - 0.5) - 0.5)));
}
define sigmoid3(aa,bb,xx) {
   auto retvalu,alfa,xzero,taa;
   if (aa <= 0.0 || 1.0 <= aa || bb <= 0.0 || 1.0 <= bb) {
      retvalu = 0.0;
   } else {
      taa = log((1.0 - aa) / aa);
      alfa = log((1.0 - bb) / bb) - taa;
      xzero = -taa / alfa;
      retvalu = 1.0 / (1.0 + exp(alfa * (xx - xzero)));
   }
   return (retvalu);
}
define taninv3(aa,bb,xx) {
   auto retvalu,alfa,taa;
   if (aa <= 0.0 || 1.0 <= aa || bb <= 0.0 || 1.0 <= bb) {
      retvalu = 0.0;
   } else {
      taa = tan((aa - 0.5) * cxpi);
      alfa = tan((bb - 0.5) * cxpi) - taa;
      retvalu = taninv(alfa * xx + taa) / cxpi + 0.5;
   }
   return (retvalu);
}
define sigmoid3d(aa,bb,xx) {
   auto retvalu,alfa,xzero,taa,expa;
   if (aa <= 0.0 || 1.0 <= aa || bb <= 0.0 || 1.0 <= bb) {
      retvalu = 0.0;
   } else {
      taa = log((1.0 - aa) / aa);
      alfa = log((1.0 - bb) / bb) - taa;
      xzero = -taa / alfa;
      expa = exp(alfa * (xx - xzero));
      retvalu = -alfa * expa / square(1.0 + expa);
   }
   return (retvalu);
}
define sqrtx(xx) {
   auto retvalu;
   if (xx < 0.0) {
      retvalu = -sqrt(-xx);
   } else {
      retvalu = sqrt(xx);
   }
   return (retvalu);
}
define smooth(xx) {
   auto retvalu;
   if (xx <= -1.0) {
      retvalu = 0.0;
   } else if (1.0 <= xx) {
      retvalu = 1.0;
   } else {
      retvalu = sigmoid(4.0 * xx / (1.0 - xx * xx));
   }
   return (retvalu);
}
define hypot(xx,yy) {
   auto retvalu,axx,ayy;
   axx = abs(xx);
   ayy = abs(yy);
   if (axx < ayy) {
      retvalu = ayy;
      ayy = axx;
      axx = retvalu;
   }
   if (0.0 < axx) {
      if (ayy < cxdbleps * axx) {
         retvalu = axx;
      } else {
         ayy /= axx;
         retvalu = axx * sqrt(1.0 + ayy * ayy);
      }
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define hypot1(xx) {
   return (hypot(1.0,xx));
}
define hypot1inv(xx) {
   return (sqrt(xx * xx - 1.0));
}
define hypot3(xx,yy,zz) {
   return (sqrt(xx * xx + yy * yy + zz * zz));
}
define topyh(xx,yy) {
   auto retvalu,xsq,ysq;
   xsq = xx * xx;
   ysq = yy * yy;
   if (ysq <= 0.0) {
      retvalu = xx;
   } else if (xsq <= 0.0) {
      retvalu = yy;
   } else if (xsq < ysq) {
      xsq /= ysq;
      retvalu = -sign(xx) * sqrt(1.0 - xsq) * abs(yy);
   } else {
      ysq /= xsq;
      retvalu = sqrt(1.0 - ysq) * xx;
   }
   return (retvalu);
}
define topyh1(xx) {
   auto retvalu;
   if (xx < - 1.0 || 1.0 < xx) {
      retvalu = -sqrt(xx * xx - 1.0);
   } else {
      retvalu = sqrt(1.0 - xx * xx);
   }
   return (retvalu);
}
define cnv_dbl2si16(xx) {
   auto retvalu;
   if (xx <= cxsi16min) {
      retvalu = cxsi16min;
   } else if (xx <= cxsi16max) {
      retvalu = floorl(xx + 0.5);
   } else {
      retvalu = cxsi16max;
   }
   return (retvalu);
}
define k2tempc(temp_k) {
   return ((temp_k - cxk_at_0tempc) * cxkelvin / cxdegc);
}
define tempc2k(temp_c) {
   return (temp_c * cxdegc / cxkelvin + cxk_at_0tempc);
}
define k2tempf(temp_k) {
   return ((temp_k - cxk_at_0tempf) * cxkelvin / cxdegf);
}
define tempf2k(temp_f) {
   return (temp_f * cxdegf / cxkelvin + cxk_at_0tempf);
}
define k2tempr(temp_k) {
   return ((temp_k - cxk_at_0tempr) * cxkelvin / cxdegr);
}
define tempr2k(temp_r) {
   return (temp_r * cxdegr / cxkelvin + cxk_at_0tempr);
}
define tempf2tempc(temp_f) {
   return ((temp_f - cxtempf_at_0tempc) * cxdegf);
}
define tempc2tempf(temp_c) {
   return (temp_c / cxdegf + cxtempf_at_0tempc);
}
define iszero(xx) {
   return (0.0 <= xx && xx <= 0.0);
}
define iseven(xx) {
   return (fmodu(xx,2.0) < 1.0);
}
define isodd(xx) {
   return (1.0 <= fmodu(xx,2.0));
}
define ismult(xx,mult) {
   return (fmodu(xx,mult) < 1.0);
}
define ismultl(xx,mult) {
   auto retvalu_bol,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (xx % mult == 0) {
      retvalu_bol = true;
   } else {
      retvalu_bol = false;
   }
   scale = local_prev_scale;
   return (retvalu_bol);
}
define isgt(xx,yy) {
   return (yy < xx);
}
define islt(xx,yy) {
   return (xx < yy);
}
define isge(xx,yy) {
   return (yy <= xx);
}
define isle(xx,yy) {
   return (xx <= yy);
}
define ispos(xx) {
   return (0.0 < xx);
}
define isneg(xx) {
   return (xx < 0.0);
}
define iseq(xx,yy) {
   auto retvalu_bol,epsx,diffxy;
   retvalu_bol = false;
   if (iszero(xx)) {
      if (abs(yy) <= cxdbleps) {
         retvalu_bol = true;
      }
   } else {
      epsx = 2.0 * xx * cxdbleps;
      diffxy = xx - yy;
      if (epsx < 0.0) {
         epsx = -epsx;
      }
      if (- epsx <= diffxy && diffxy <= epsx) {
         retvalu_bol = true;
      }
   }
   return (retvalu_bol);
}
define isneq(xx,yy) {
   return (xx < yy || yy < xx);
}
define isint(xx) {
   return (iseq(xx,floor(xx)));
}
define isnegint(xx) {
   return (xx < 0.0 && iseq(xx,floor(xx)));
}
define isposint(xx) {
   return (0.0 < xx && iseq(xx,floor(xx)));
}
define ifzero(cond,tru_val,fal_val) {
   auto retvalu;
   if (cond < 0.0 || 0.0 < cond) {
      retvalu = fal_val;
   } else {
      retvalu = tru_val;
   }
   return (retvalu);
}
define isalmostequal(xx,yy,epsratio) {
   return (abs(xx - yy) <= abs(epsratio * xx));
}
define iswithin(xx,yy,delta) {
   return (xx - delta <= yy && yy <= xx + delta);
}
define isbetweenx(xx,min_xx,max_xx) {
   return (min_xx < xx && xx < max_xx);
}
define isbetween(xx,min_xx,max_xx) {
   return (min_xx <= xx && xx <= max_xx);
}
define isleapyear(gregyear) {
   auto retvalu_bol,rema;
   retvalu_bol = false;
   if ((gregyear % 4) == 0) {
      rema = (gregyear % 400);
      if (rema != 100 && rema != 200 && rema != 300) {
         retvalu_bol = true;
      }
   }
   return (retvalu_bol);
}
define isss(xx,yy) {
   auto retvalu_bol;
   if (0.0 < xx) {
      if (0.0 < yy) {
         retvalu_bol = true;
      } else {
         retvalu_bol = false;
      }
   } else if (xx < 0.0) {
      if (yy < 0.0) {
         retvalu_bol = true;
      } else {
         retvalu_bol = false;
      }
   } else {
      if (0.0 < yy || yy < 0.0) {
         retvalu_bol = false;
      } else {
         retvalu_bol = true;
      }
   }
   return (retvalu_bol);
}
define issignsame(xx,yy) {
   return (isss(xx,yy));
}
define isfloorsame(xx,yy,multy) {
   return (iseq(floor(xx * multy),floor(yy * multy)));
}
cxlc_magic_int = 2070108020;
cxlc_magic_int_not = 301040105;
define magicset() {
   return (cxlc_magic_int);
}
define magicnot() {
   return (cxlc_magic_int_not);
}
define ismagic(xx) {
   return (iseq(xx,magicset()));
}
define rtoz(xx) {
   auto retvalu;
   if (xx < 0.0) {
      retvalu = ceil(xx);
   } else {
      retvalu = floor(xx);
   }
   return (retvalu);
}
define rtoi(xx) {
   auto retvalu;
   if (0.0 <= xx) {
      retvalu = ceil(xx);
   } else {
      retvalu = floor(xx);
   }
   return (retvalu);
}
define bankers(xx) {
   auto retvalu;
   retvalu = floor(xx + 0.5);
   if (isint(xx + 0.5) && isodd(retvalu)) {
      retvalu -= 1.0;
   }
   return (retvalu);
}
define round(xx) {
   auto retvalu;
   retvalu = floor(xx + 0.5);
   return (retvalu);
}
define iround(xx) {
   auto retvalu;
   retvalu = floor(xx + 0.5);
   return (retvalu);
}
define round2(xx,yy) {
   auto retvalu;
   if (iszero(yy)) {
      retvalu = xx;
   } else {
      retvalu = round(xx / yy) * yy;
   }
   return (retvalu);
}
define roundy(xx,yy,shf) {
   auto retvalu;
   if (yy < 0.0 || 0.0 < yy) {
      retvalu = (round((xx - shf) / yy) * yy + shf);
   } else {
      retvalu = xx;
   }
   return (retvalu);
}
define rtomsd(fs,msds) {
   auto retvalu,signs,logi;
   if (iszero(fs)) {
      retvalu = 0.0;
   } else {
      if (fs < 0.0) {
         signs = -1.0;
         fs = -fs;
      } else {
         signs = 1.0;
      }
      logi = floor(log10(fs) - msds + 1.0);
      retvalu = signs * round2(fs,pow(10.0,logi));
   }
   return (retvalu);
}
define rto125(fs) {
   auto signs,tmpf,valu,pow_ten,retvalu;
   if (iszero(fs)) {
      retvalu = 0.0;
   } else {
      if (fs < 0.0) {
         signs = -1.0;
         fs = -fs;
      } else {
         signs = 1.0;
      }
      pow_ten = pow(10.0,floor(log10(fs)));
      tmpf = fs / pow_ten;
      if (tmpf < sqrt(2.0)) {
         valu = 1.0;
      } else if (tmpf < sqrt(10.0)) {
         valu = 2.0;
      } else if (tmpf < sqrt(50.0)) {
         valu = 5.0;
      } else {
         valu = 10.0;
      }
      retvalu = signs * pow_ten * valu;
   }
   return (retvalu);
}
define floor2(xx,yy) {
   auto retvalu;
   if (iszero(yy)) {
      retvalu = 0.0;
   } else {
      retvalu = floor(xx / abs(yy)) * abs(yy);
   }
   return (retvalu);
}
define ceil2(xx,yy) {
   auto retvalu;
   if (iszero(yy)) {
      retvalu = 0.0;
   } else {
      retvalu = ceil(xx / abs(yy)) * abs(yy);
   }
   return (retvalu);
}
define fmod2(xx,minn,maxx) {
   auto retvalu;
   if (iseq(maxx,minn)) {
      retvalu = 0.0;
   } else {
      retvalu = fmodu(xx - minn,maxx - minn) + minn;
   }
   return (retvalu);
}
define frac(xx) {
   return (xx - floor(xx));
}
define trunc(xx) {
   auto retvalu;
   if (0.0 <= xx) {
      retvalu = xx - floor(xx);
   } else {
      retvalu = xx - ceil(xx);
   }
   return (retvalu);
}
define fmul(xx,pp) {
   auto lpp;
   lpp = log(pp);
   return (exp(lpp * frac(log(xx) / lpp)));
}
define dist(xx,xmoduli) {
   auto retvalu,axx,axmoduli;
   axx = abs(xx);
   axmoduli = abs(xmoduli);
   retvalu = fmod(axx,axmoduli);
   if (axmoduli < 2.0 * retvalu) {
      retvalu = axmoduli - retvalu;
   }
   return (retvalu);
}
define ddist(xx,xmoduli) {
   auto retvalu,rema,axmoduli;
   if (iszero(xmoduli)) {
      retvalu = 0.0;
   } else {
      axmoduli = abs(xmoduli);
      rema = xx - floor(xx / axmoduli) * axmoduli;
      if (axmoduli < 2.0 * rema) {
         rema -= axmoduli;
      }
      retvalu = rema;
   }
   return (retvalu);
}
define sinc(xx_rad) {
   auto retvalu;
   if (xx_rad < 0.0 || 0.0 < xx_rad) {
      retvalu = sin(xx_rad) / xx_rad;
   } else {
      retvalu = 1.0;
   }
   return (retvalu);
}
define sincinv(yy) {
   auto min_yy,min_xx,start_xx,aa,bb,nrvx_ii,nrvx_yy,nrvx_xx,\
            nrvx_dy,nrvx_xp;
   min_xx = 4.4934094579090641753079882808139693729311345;
   min_yy = sinc(min_xx);
   if (yy <= min_yy) {
      nrvx_xx = min_xx;
   } else if (yy < 1.0) {
      aa = yy - min_yy;
      bb = 1.0 - yy;
      start_xx = (aa * sqrt(5.0 * bb) + bb * (min_xx - sqrt(6.0 * aa))) /\
               (1.0 - min_yy);
      nrvx_xx = start_xx;
      for (nrvx_ii = 0; nrvx_ii <= 20; nrvx_ii += 1) {
         nrvx_xp = nrvx_xx;
         nrvx_dy = cos(nrvx_xx) - yy;
         if (iszero(nrvx_dy)) {
            break;
         }
         nrvx_yy = sin(nrvx_xx) - yy * nrvx_xx;
         nrvx_xx -= nrvx_yy / nrvx_dy;
         if (iseq(nrvx_xp,nrvx_xx)) {
            break;
         }
      }
   } else {
      nrvx_xx = 0.0;
   }
   return (nrvx_xx);
}
define sincc(xx_rad) {
   auto trigsign,xr_rad,sum_curr,sum_prev,nxr_sqr,ii,term,retvalu;
   if (iszero(xx_rad)) {
      retvalu = 1.0;
   } else {
      xr_rad = fmod(xx_rad,cxtau);
      if (cxtau / 2.0 < xr_rad) {
         xr_rad = cxtau - xr_rad;
         trigsign = -1.0;
      } else {
         trigsign = 1.0;
      }
      if (cxtau / 4.0 < xr_rad) {
         xr_rad = cxtau / 2.0 - xr_rad;
      }
      nxr_sqr = -xr_rad * xr_rad;
      sum_curr = xr_rad;
      term = xr_rad;
      ii = 2;
      for (;;) {
         term *= nxr_sqr / (ii * (ii - 1.0));
         sum_prev = sum_curr;
         sum_curr += term;
         if (iseq(sum_curr,sum_prev)) {
            break; # loop AWAIT
         }
         ii += 2;
      }
      retvalu = trigsign * sum_curr * xr_rad / xx_rad;
   }
   return (retvalu);
}
define versin(circ_rad) {
   auto trigsign,xr_rad,xr_sqr,ii,sum_curr,term,sum_prev;
   xr_rad = fmod(circ_rad,cxtau);
   if (cxtau / 2.0 < xr_rad) {
      xr_rad = cxtau - xr_rad;
   }
   if (cxtau / 4.0 < xr_rad) {
      xr_rad = cxtau / 2.0 - xr_rad;
      trigsign = -1.0;
   } else {
      trigsign = 1.0;
   }
   xr_sqr = -xr_rad * xr_rad;
   sum_curr = 1.0 / 2.0;
   term = 1.0 / 2.0;
   ii = 4;
   for (;;) {
      term *= xr_sqr / (ii * (ii - 1.0));
      sum_prev = sum_curr;
      sum_curr += term;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      ii += 2;
   }
   sum_curr *= - xr_sqr;
   if (trigsign < 0.0) {
      sum_curr = 2.0 - sum_curr;
   }
   return (sum_curr);
}
define haversin(circ_rad) {
   return (versin(circ_rad) / 2.0);
}
define tur2deg(circ_tur) {
   return (circ_tur * cxturn / cxarcdeg);
}
define deg2tur(circ_deg) {
   return (circ_deg * cxarcdeg / cxturn);
}
define tur2rad(circ_tur) {
   return (circ_tur * cxturn / cxradian);
}
define rad2tur(circ_rad) {
   return (circ_rad * cxradian / cxturn);
}
define tur2sec(circ_tur) {
   return (circ_tur * cxturn / cxarcsec);
}
define sec2tur(circ_sec) {
   return (circ_sec * cxarcsec / cxturn);
}
define rad2deg(circ_rad) {
   return (circ_rad * cxradian / cxarcdeg);
}
define deg2rad(circ_deg) {
   return (circ_deg * cxarcdeg / cxradian);
}
define rad2sec(circ_rad) {
   return (circ_rad * cxradian / cxarcsec);
}
define sec2rad(circ_sec) {
   return (circ_sec * cxarcsec / cxradian);
}
define deg2sec(circ_deg) {
   return (circ_deg * cxarcdeg / cxarcsec);
}
define sec2deg(circ_sec) {
   return (circ_sec * cxarcsec / cxarcdeg);
}
define rad2dms(xx_rads) {
   auto dd_deg,mm_min,dg;
   dg = rad2deg(xx_rads);
   dd_deg = floor(dg);
   dg = (dg - dd_deg) * cxarcdeg / cxarcmin;
   mm_min = floor(dg);
   dg = (dg - mm_min) * cxarcmin / cxarcsec;
   return (dd_deg + (mm_min + dg / 100.0) / 100.0);
}
define rad2dms2(circ_rads) {
   auto dg,dd_deg_arr[],mm_min_arr[];
   dg = rad2deg(circ_rads);
   dg = modf(dg,dd_deg_arr[]) * cxarcdeg / cxarcmin;
   dg = modf(dg,mm_min_arr[]) * cxarcmin / cxarcsec;
   return (dd_deg_arr[0] + (mm_min_arr[0] + dg / 100.0) / 100.0);
}
define dms2rad(circ_dms) {
   auto dd_deg,mm_min,dg;
   dd_deg = floor(circ_dms);
   dg = (circ_dms - dd_deg) * 100.0;
   mm_min = floor(dg);
   dg = (dg - mm_min) * 100.0;
   return ((dg * cxarcsec + mm_min * cxarcmin + dd_deg * cxarcdeg) /\
            cxradian);
}
define deg2dms(circ_deg) {
   return (rad2dms(deg2rad(circ_deg)));
}
define dms2deg(circ_dms) {
   return (rad2deg(dms2rad(circ_dms)));
}
define cot(circ_rad) {
   return (cos(circ_rad) / sin(circ_rad));
}
define sec(circ_rad) {
   return (1.0 / cos(circ_rad));
}
define csc(circ_rad) {
   return (1.0 / sin(circ_rad));
}
define sininv(xx) {
   return (atan2(xx,topyh1(xx)));
}
define cosinv(xx) {
   return (atan2(topyh1(xx),xx));
}
define taninv(xx) {
   return (atan2(xx,1.0));
}
define cotinv(xx) {
   return (atan2(1.0,xx));
}
define secinv(xx) {
   return (atan2(sqrt(xx * xx - 1.0),sign(xx)));
}
define cscinv(xx) {
   return (atan2(sign(xx),sqrt(xx * xx - 1.0)));
}
define sinh(hyp_rad) {
   return ((exp(hyp_rad) - exp(-hyp_rad)) / 2.0);
}
define cosh(hyp_rad) {
   return ((exp(hyp_rad) + exp(-hyp_rad)) / 2.0);
}
define tanh(hyp_rad) {
   return (sinh(hyp_rad) / cosh(hyp_rad));
}
define coth(hyp_rad) {
   return (cosh(hyp_rad) / sinh(hyp_rad));
}
define sech(hyp_rad) {
   return (1.0 / cosh(hyp_rad));
}
define csch(hyp_rad) {
   return (1.0 / sinh(hyp_rad));
}
define gd(hyp_rad) {
   return (2.0 * atan2(exp(hyp_rad),1.0) - cxpi / 2.0);
}
define gdinv(xx) {
   auto xxn;
   xxn = fmods(xx,cxpi);
   return (log(abs((1.0 + sin(xxn)) / cos(xxn))));
}
define sinhinv(xx) {
   return (log(xx + sqrt(xx * xx + 1.0)));
}
define coshinv(xx) {
   return (log(xx + sqrt(xx * xx - 1.0)));
}
define tanhinv(xx) {
   return (log((1.0 + xx) / (1.0 - xx)) / 2.0);
}
define cothinv(xx) {
   return (log((xx + 1.0) / (xx - 1.0)) / 2.0);
}
define sechinv(xx) {
   return (log((1.0 + topyh1(xx)) / xx));
}
define cschinv(xx) {
   return (log((1.0 + sqrt(1.0 + xx * xx)) / xx));
}
define atan2h(xx,yy) {
   auto retvalu;
   if (abs(yy) <= abs(xx)) {
      retvalu = 0.0;
   } else {
      retvalu = log((yy + xx) / (yy - xx)) / 2.0;
   }
   return (retvalu);
}
define atan2u(xx,yy) {
   return (fmodu(atan2(xx,yy),tur2rad(1.0)));
}
define sind(circ_deg) {
   return (sin(deg2rad(circ_deg)));
}
define sindinv(xx) {
   return (rad2deg(sininv(xx)));
}
define cosd(circ_deg) {
   return (cos(deg2rad(circ_deg)));
}
define cosdinv(xx) {
   return (rad2deg(cosinv(xx)));
}
define tand(circ_deg) {
   return (tan(deg2rad(circ_deg)));
}
define tandinv(xx) {
   return (rad2deg(taninv(xx)));
}
define cotd(circ_deg) {
   return (cot(deg2rad(circ_deg)));
}
define cotdinv(xx) {
   return (rad2deg(cotinv(xx)));
}
define secd(circ_deg) {
   return (sec(deg2rad(circ_deg)));
}
define secdinv(xx) {
   return (rad2deg(secinv(xx)));
}
define cscd(circ_deg) {
   return (csc(deg2rad(circ_deg)));
}
define cscdinv(xx) {
   return (rad2deg(cscinv(xx)));
}
define atan2d(xx,yy) {
   return (rad2deg(atan2(xx,yy)));
}
define sint(circ_tur) {
   return (sin(tur2rad(circ_tur)));
}
define sintinv(xx) {
   return (rad2tur(sininv(xx)));
}
define cost(circ_tur) {
   return (cos(tur2rad(circ_tur)));
}
define costinv(xx) {
   return (rad2tur(cosinv(xx)));
}
define tant(circ_tur) {
   return (tan(tur2rad(circ_tur)));
}
define tantinv(xx) {
   return (rad2tur(taninv(xx)));
}
define cott(circ_tur) {
   return (cot(tur2rad(circ_tur)));
}
define cottinv(xx) {
   return (rad2tur(cotinv(xx)));
}
define sect(circ_tur) {
   return (sec(tur2rad(circ_tur)));
}
define sectinv(xx) {
   return (rad2tur(secinv(xx)));
}
define csct(circ_tur) {
   return (csc(tur2rad(circ_tur)));
}
define csctinv(xx) {
   return (rad2tur(cscinv(xx)));
}
define atan2t(xx,yy) {
   return (rad2tur(atan2(xx,yy)));
}
define sqrtxp1m1(xx) {
   auto retvalu;
   if (abs(xx) < 0.01) {
      retvalu = ((((((((-429.0 / 32768.0) * xx + 33.0 / 2048.0) * xx -\
               21.0 / 1024.0) * xx + 7.0 / 256.0) * xx - 5.0 / 128.0) *\
               xx + 1.0 / 16.0) * xx - 1.0 / 8.0) * xx + 1.0 / 2.0) * xx;
   } else {
      retvalu = sqrt(1.0 + xx) - 1.0;
   }
   return (retvalu);
}
define ln1p(xx) {
   auto retvalu,sum_curr,jj,start;
   if (0.1 < abs(xx)) {
      retvalu = log(1.0 + xx);
   } else if (iszero(xx)) {
      retvalu = 0.0;
   } else {
      start = ceil(abs(log(cxdbleps) / log(abs(xx))));
      if (start < 2) {
         start = 2;
      }
      sum_curr = 0.0;
      for (jj = start; 1 <= jj; jj -= 1) {
         sum_curr = 1.0 / jj - sum_curr * xx;
      }
      retvalu = sum_curr * xx;
   }
   return (retvalu);
}
define expm1(xx) {
   auto retvalu,sum_curr,jj,start;
   if (0.1 < abs(xx)) {
      retvalu = exp(xx) - 1.0;
   } else if (iszero(xx)) {
      retvalu = 0.0;
   } else {
      start = ceil(abs(log(cxdbleps) / log(abs(xx))));
      if (start < 2) {
         start = 2;
      }
      sum_curr = 0.0;
      for (jj = start; 1 <= jj; jj -= 1) {
         sum_curr = xx * (1.0 + sum_curr) / jj;
      }
      retvalu = sum_curr;
   }
   return (retvalu);
}
define cosm1(xx) {
   auto retvalu,sum_curr,jj,start,xr_sqr;
   if (0.1 < abs(xx)) {
      retvalu = cos(xx) - 1.0;
   } else if (iszero(xx)) {
      retvalu = 0.0;
   } else {
      start = ceil(abs(log(cxdbleps) / log(abs(xx))));
      if (start < 6) {
         start = 6;
      } else if (isodd(start)) {
         start += 1;
      }
      xr_sqr = -xx * xx;
      sum_curr = 1.0 / (start * (start + 1.0));
      for (jj = start; 2 <= jj; jj -= 2) {
         sum_curr += 1.0;
         sum_curr *= xr_sqr / (jj * (jj - 1.0));
      }
      retvalu = sum_curr;
   }
   return (retvalu);
}
define lns(xx) {
   auto aa,retvalu;
   aa = abs(xx);
   if (aa < 1.0 / cxdblmax) {
      retvalu = -cxdblmaxln - 1.0;
   } else {
      retvalu = log(aa);
   }
   return (retvalu);
}
define trip(xx) {
   auto retvalu,fx;
   fx = 4.0 * frac(xx);
   if (fx < 2.0) {
      retvalu = 1.0 - fx;
   } else {
      retvalu = fx - 3.0;
   }
   return (retvalu);
}
define lf_cbrtx_gt_zero(xx) {
   auto yy,zz;
   zz = 64.0 * xx / 27.0;
   yy = 1.0;
   while (zz <= 1.0) {
      zz *= 8.0;
      yy /= 2.0;
   }
   while (8.0 < zz) {
      zz /= 8.0;
      yy *= 2.0;
   }
   return (yy);
}
define cbrt(yy) {
   auto ayy,init_xx,nrvx_ii,nrvx_yy,nrvx_xx,nrvx_dy,nrvx_xp;
   ayy = abs(yy);
   if (0.0 < ayy) {
      init_xx = lf_cbrtx_gt_zero(ayy);
      if (yy < 0.0) {
         init_xx = -init_xx;
      }
      nrvx_xx = init_xx;
      for (nrvx_ii = 0; nrvx_ii <= 20; nrvx_ii += 1) {
         nrvx_xp = nrvx_xx;
         nrvx_dy = 3.0 * nrvx_xx * nrvx_xx;
         if (iszero(nrvx_dy)) {
            break;
         }
         nrvx_yy = nrvx_xx * nrvx_xx * nrvx_xx - yy;
         nrvx_xx -= nrvx_yy / nrvx_dy;
         if (iseq(nrvx_xp,nrvx_xx)) {
            break;
         }
      }
   } else {
      nrvx_xx = 0.0;
   }
   return (nrvx_xx);
}
define cuberoot(xx) {
   return (cbrt(xx));
}
define squareroot(xx) {
   return (sqrt(xx));
}
define print_array(arr_size,*data_arr_pc[]) {
   auto ii;
   for (ii = 0; ii <= arr_size - 1; ii += 1) {
      print data_arr_pc[ii];
      print " ";
   }
   return (arr_size);
}
define lf_continued_fraction(orig,show_diff) {
   auto whole,xx,epsilon,den_a,den_b,den_c,num_a,num_b,num_c,\
            diff,steps,appr;
   steps = 0;
   xx = orig;
   den_b = 0;
   num_b = 1;
   den_a = 1;
   num_a = 0;
   epsilon = cxdbleps / 2.0;
   for (;;) {
      whole = floorl(xx);
      den_c = den_b * whole + den_a;
      num_c = num_b * whole + num_a;
      den_a = den_b;
      num_a = num_b;
      den_b = den_c;
      num_b = num_c;
      steps += 1;
      appr = (1.0 * num_b / den_b);
      diff = orig - appr;
      print "";
      print whole;
      if (0 <= show_diff) {
         print "\t";
         print num_b;
         print " / ";
         print den_b;
         print "\t";
         print appr;
         if (0 < show_diff) {
            print "\t";
            print diff;
         }
         print "\n";
      } else {
         print " ";
      }
      if (iseq(xx,whole)) {
         break;
      }
      xx = 1.0 / (xx - whole);
      epsilon *= 2.0;
      if (abs(diff) < epsilon) {
         break; # loop AWAIT
      }
   }
   return (steps);
}
define contfra_print(orig) {
   return (lf_continued_fraction(orig,-1));
}
define contfrac_print(orig) {
   return (lf_continued_fraction(orig,0));
}
define contfracd_print(orig) {
   return (lf_continued_fraction(orig,1));
}
define num2char_print(num) {
   if (num < 32) {
      if (num < 16) {
         if (num < 8) {
            if (num < 4) {
               if (num < 2) {
                  if (num < 1) {
                     print "0";
                  } else {
                     print "1";
                  }
               } else if (num < 3) {
                  print "2";
               } else {
                  print "3";
               }
            } else if (num < 6) {
               if (num < 5) {
                  print "4";
               } else {
                  print "5";
               }
            } else if (num < 7) {
               print "6";
            } else {
               print "7";
            }
         } else if (num < 12) {
            if (num < 10) {
               if (num < 9) {
                  print "8";
               } else {
                  print "9";
               }
            } else if (num < 11) {
               print "a";
            } else {
               print "b";
            }
         } else if (num < 14) {
            if (num < 13) {
               print "cxc";
            } else {
               print "d";
            }
         } else if (num < 15) {
            print "cxe";
         } else {
            print "f";
         }
      } else if (num < 24) {
         if (num < 20) {
            if (num < 18) {
               if (num < 17) {
                  print "cxg";
               } else {
                  print "cxh";
               }
            } else if (num < 19) {
               print "i";
            } else {
               print "j";
            }
         } else if (num < 22) {
            if (num < 21) {
               print "k";
            } else {
               print "l";
            }
         } else if (num < 23) {
            print "m";
         } else {
            print "n";
         }
      } else if (num < 28) {
         if (num < 26) {
            if (num < 25) {
               print "o";
            } else {
               print "p";
            }
         } else if (num < 27) {
            print "q";
         } else {
            print "r";
         }
      } else if (num < 30) {
         if (num < 29) {
            print "s";
         } else {
            print "t";
         }
      } else if (num < 31) {
         print "u";
      } else {
         print "v";
      }
   } else if (num < 48) {
      if (num < 40) {
         if (num < 36) {
            if (num < 34) {
               if (num < 33) {
                  print "w";
               } else {
                  print "x";
               }
            } else if (num < 35) {
               print "y";
            } else {
               print "z";
            }
         } else if (num < 38) {
            if (num < 37) {
               print "A";
            } else {
               print "B";
            }
         } else if (num < 39) {
            print "C";
         } else {
            print "D";
         }
      } else if (num < 44) {
         if (num < 42) {
            if (num < 41) {
               print "E";
            } else {
               print "F";
            }
         } else if (num < 43) {
            print "G";
         } else {
            print "H";
         }
      } else if (num < 46) {
         if (num < 45) {
            print "I";
         } else {
            print "J";
         }
      } else if (num < 47) {
         print "K";
      } else {
         print "L";
      }
   } else if (num < 56) {
      if (num < 52) {
         if (num < 50) {
            if (num < 49) {
               print "M";
            } else {
               print "N";
            }
         } else if (num < 51) {
            print "O";
         } else {
            print "P";
         }
      } else if (num < 54) {
         if (num < 53) {
            print "Q";
         } else {
            print "R";
         }
      } else if (num < 55) {
         print "S";
      } else {
         print "T";
      }
   } else if (num < 60) {
      if (num < 58) {
         if (num < 57) {
            print "U";
         } else {
            print "V";
         }
      } else if (num < 59) {
         print "W";
      } else {
         print "X";
      }
   } else if (num < 62) {
      if (num < 61) {
         print "Y";
      } else {
         print "Z";
      }
   } else if (num < 63) {
      print "_";
   } else if (num < 64) {
      print "?";
   } else {
      print "(";
      print num;
      print ")";
   }
   return (num);
}
define base_out_print(num,baset) {
   auto digits_arr[],dig_count,ii,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (num < 0) {
      print "-";
      num = -num;
   }
   dig_count = 0;
   for (;;) {
      digits_arr[dig_count] = num % baset;
      dig_count += 1;
      num = floorl(num / baset);
      if (num == 0) {
         break; # loop AWAIT
      }
   }
   for (ii = dig_count - 1; 0 <= ii; ii -= 1) {
      bcdummy = num2char_print(digits_arr[ii]);
   }
   scale = local_prev_scale;
   return (dig_count);
}
define base_out_fix_print(num,baset,min_sz) {
   auto digits_arr[],dig_count,ii,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (num < 0) {
      num = -num;
   }
   dig_count = 0;
   for (;;) {
      digits_arr[dig_count] = num % baset;
      dig_count += 1;
      num = floorl(num / baset);
      if (num == 0) {
         break; # loop AWAIT
      }
   }
   for (ii = dig_count; ii <= min_sz - 1; ii += 1) {
      bcdummy = num2char_print(0);
   }
   for (ii = dig_count - 1; 0 <= ii; ii -= 1) {
      bcdummy = num2char_print(digits_arr[ii]);
   }
   scale = local_prev_scale;
   return (min_sz);
}
define base_outf_print(num,baset) {
   auto dig_count,ii,frc,dig,lim;
   dig_count = 0;
   if (num < 0.0) {
      print "-";
      num = -num;
      dig_count += 1;
   }
   dig_count += base_out_print(floorl(num),baset) + 1;
   print ".";
   lim = ceill(-lg(cxdbleps) / lg(baset));
   frc = frac(num) * baset;
   ii = 1;
   while (ii <= lim && ! iszero(frc)) {
      dig = floorl(frc);
      bcdummy = num2char_print(dig);
      frc -= dig;
      frc *= baset;
      ii += 1;
   }
   return (dig_count + lim);
}
define fvoa(payment,rate_per_paymt,num_pays) {
   auto ttp;
   ttp = pow(1.0 + rate_per_paymt,num_pays);
   return (payment * (ttp - 1.0) / rate_per_paymt);
}
define fvad(payment,rate_per_paymt,num_pays) {
   return (fvoa(payment,rate_per_paymt,num_pays) * (1.0 + rate_per_paymt));
}
define pvoa(payment,rate_per_paymt,num_pays) {
   auto ntp;
   ntp = pow(1.0 + rate_per_paymt,- num_pays);
   return (payment * (1.0 - ntp) / rate_per_paymt);
}
define pvad(payment,rate_per_paymt,num_pays) {
   auto ntp;
   ntp = pow(1.0 + rate_per_paymt,- num_pays);
   return (payment * (1.0 - ntp) / rate_per_paymt * (1.0 + rate_per_paymt));
}
define loanvalue(payment,rate_per_paymt,num_pays) {
   return (fvad(payment,rate_per_paymt,num_pays));
}
define loanpayment(loan_amt,rate_per_paymt,num_pays) {
   auto ttp;
   ttp = pow(1.0 + rate_per_paymt,num_pays);
   return (loan_amt * rate_per_paymt * ttp / (ttp - 1.0));
}
define loanrate(loan_amt,payment,num_pays) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_ii;
   scvx_dx = 0.01;
   scvx_xx = 0.05;
   scvx_yy = payment - loanpayment(loan_amt,scvx_xx,num_pays);
   for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
      scvx_xp = scvx_xx;
      scvx_yp = scvx_yy;
      scvx_xx += scvx_dx;
      if (iseq(scvx_xp,scvx_xx)) {
         break;
      }
      scvx_yy = payment - loanpayment(loan_amt,scvx_xx,num_pays);
      if (iseq(scvx_yy,scvx_yp)) {
         break;
      }
      scvx_dx *= - scvx_yy / (scvx_yy - scvx_yp);
   }
   return (scvx_xx);
}
define f21(aa,bb,cc,zz) {
   auto sum_curr,sum_prev,term,nn;
   if (1 < abs(zz)) {
      sum_curr = 0.0;
   } else {
      sum_curr = 1.0;
      term = 1.0;
      nn = 0;
      for (;;) {
         term *= ((aa + nn) * (bb + nn) * zz / ((cc + nn) * (1 + nn)));
         sum_prev = sum_curr;
         sum_curr += term;
         if (iseq(sum_curr,sum_prev)) {
            break; # loop AWAIT
         }
         nn += 1;
      }
   }
   return (sum_curr);
}
define f11(aa,bb,zz) {
   auto sum_curr,sum_prev,term,nn;
   if (1 < abs(zz)) {
      sum_curr = 0.0;
   } else {
      sum_curr = 1.0;
      term = 1.0;
      nn = 0;
      for (;;) {
         term *= ((aa + nn) * zz / ((bb + nn) * (1 + nn)));
         sum_prev = sum_curr;
         sum_curr += term;
         if (iseq(sum_curr,sum_prev)) {
            break; # loop AWAIT
         }
         nn += 1;
      }
   }
   return (sum_curr);
}
define lf_lambert_iter(xx,nearw_zero) {
   auto ii,eww,tnn,snn,unn,delta,wjj,wjj_prev;
   wjj = nearw_zero;
   ii = 0;
   for (;;) {
      eww = exp(wjj);
      tnn = wjj * eww - xx;
      snn = (wjj + 2.0) / (2.0 * (wjj + 1.0));
      unn = (wjj + 1.0) * eww;
      delta = tnn / (tnn * snn - unn);
      wjj_prev = wjj;
      wjj += delta;
      if (iseq(wjj,wjj_prev)) {
         break; # loop AWAIT
      }
      ii += 1;
      if (20 <= ii) {
         break; # loop AWAIT
      }
   }
   return (wjj);
}
define wp(xx) {
   auto tnn,snn,near_w,retvalu;
   if (xx <= - exp(-1.0)) {
      retvalu = -1.0;
   } else {
      if (xx < 3.0) {
         snn = e * xx + 1.0;
         near_w = cbrt(snn) - 1.0 + 0.025 * (snn / e);
      } else {
         snn = log(xx);
         tnn = log(log(xx));
         near_w = snn - tnn + tnn / snn;
      }
      retvalu = lf_lambert_iter(xx,near_w);
   }
   return (retvalu);
}
define wm(xx) {
   auto ii,near_w,retvalu,tnn,numer,denom;
   if (xx <= - exp(-1.0)) {
      retvalu = -1.0;
   } else {
      if (xx < - 0.303) {
         tnn = -sqrt(2.0 * (1.0 + e * xx));
         near_w = ((((((((((226287557.0 / 37623398400.0) * tnn - 1963.0 /\
                  204120.0) * tnn + 680863.0 / 43545600.0) * tnn - 221.0\
                  / 8505.0) * tnn + 769.0 / 17280.0) * tnn - 43.0 /\
                  540.0) * tnn + 11.0 / 72.0) * tnn - 1.0 / 3.0) * tnn +\
                  1.0) * tnn - 1.0);
      } else if (xx < - 0.0510129) {
         numer = (((6.5794931769023040 * 10^2) * xx + (2.5388810188892484\
                  * 10^2)) * xx - 7.8141767239074400);
         denom = ((((((1.4779341280760887 * 10^3) * xx +\
                  (9.6217849696986600 * 10^2)) * xx + (6.8260739999094280\
                  * 10^2)) * xx + (9.9985670831076100 * 10^1)) * xx -\
                  (6.0439587136908080 * 10^1)) * xx + 1.0);
         near_w = numer / denom;
      } else if (xx < 0.0) {
         near_w = log(-xx);
         for (ii = 0; ii <= 8; ii += 1) {
            near_w = log(xx / near_w);
         }
      } else {
         near_w = cxdblmax;
      }
      retvalu = lf_lambert_iter(xx,near_w);
   }
   return (retvalu);
}
define wpinv(zz) {
   return (zz * exp(zz));
}
define wminv(zz) {
   return (zz * exp(zz));
}
define sinintegral(xx) {
   auto sum_curr,sum_prev,term,kk,xsq;
   if (iszero(xx)) {
      sum_curr = 0.0;
   } else {
      sum_curr = xx;
      term = xx;
      xsq = xx * xx;
      kk = 3;
      for (;;) {
         term *= - xsq / (kk * (kk - 1.0));
         sum_prev = sum_curr;
         sum_curr += term / kk;
         if (iseq(sum_curr,sum_prev)) {
            break; # loop AWAIT
         }
         kk += 2;
      }
   }
   return (sum_curr);
}
define cosintegral(xx) {
   auto sum_curr,sum_prev,term,kk,xsq;
   if (iszero(xx)) {
      sum_curr = -cxdblmax;
   } else {
      sum_curr = cxeuler + log(abs(xx));
      term = 1.0;
      xsq = xx * xx;
      kk = 2;
      for (;;) {
         term *= - xsq / (kk * (kk - 1.0));
         sum_prev = sum_curr;
         sum_curr += term / kk;
         if (iseq(sum_curr,sum_prev)) {
            break; # loop AWAIT
         }
         kk += 2;
      }
   }
   return (sum_curr);
}
define ein(xx) {
   auto sum_curr,sum_prev,term,kk;
   sum_curr = 0;
   term = -1;
   kk = 1;
   for (;;) {
      term *= - xx / kk;
      sum_prev = sum_curr;
      sum_curr += term / kk;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      kk += 1;
   }
   return (sum_curr);
}
define expintegrali(xx) {
   auto retvalu;
   retvalu = cxeuler + log(abs(xx)) - ein(-xx);
   return (retvalu);
}
define expintegral1(xx) {
   auto retvalu;
   retvalu = ein(xx) - cxeuler - log(abs(xx));
   return (retvalu);
}
define expintegraln(nn,xx) {
   return (pow(xx,nn - 1) * uigamma(1 - nn,xx));
}
define logintegral(xx) {
   auto sum,lnx,yy,nn,sum_prev,limit,retvalu;
   if (xx <= 1.0) {
      retvalu = 0.0;
   } else {
      lnx = log(xx);
      sum = 0.0;
      yy = 1.0;
      limit = 1.6 * log(xx) + 40;
      nn = 1;
      for (;;) {
         yy *= lnx / nn;
         sum_prev = sum;
         sum += yy / nn;
         if (iseq(sum,sum_prev)) {
            break; # loop AWAIT
         }
         nn += 1;
         if (limit <= nn) {
            break; # loop AWAIT
         }
      }
      retvalu = cxeuler + log(lnx) + sum;
   }
   return (retvalu);
}
define carlsonrf(xx,yy,zz) {
   auto sqx,sqy,sqz,lmbd;
   for (;;) {
      sqx = sqrt(xx);
      sqy = sqrt(yy);
      sqz = sqrt(zz);
      lmbd = sqx * sqy + sqx * sqz + sqy * sqz;
      xx = (xx + lmbd) / 4.0;
      yy = (yy + lmbd) / 4.0;
      zz = (zz + lmbd) / 4.0;
      if (iseq(xx,yy) && iseq(yy,zz)) {
         break; # loop AWAIT
      }
   }
   return (1.0 / sqrt(xx));
}
define carlsonrc(xx,yy) {
   auto lmbd;
   for (;;) {
      lmbd = 2 * sqrt(xx * yy) + yy;
      xx = (xx + lmbd) / 4.0;
      yy = (yy + lmbd) / 4.0;
      if (iseq(xx,yy)) {
         break; # loop AWAIT
      }
   }
   return (1.0 / sqrt(xx));
}
define carlsonrj(xx,yy,zz,pp) {
   auto sqx,sqy,sqz,lmbd,pfour,alfa,beta,sigm;
   pfour = 1.0;
   sigm = 0.0;
   for (;;) {
      sqx = sqrt(xx);
      sqy = sqrt(yy);
      sqz = sqrt(zz);
      lmbd = sqx * sqy + sqx * sqz + sqy * sqz;
      alfa = pp * (sqx + sqy + sqz) + sqx * sqy * sqz;
      alfa *= alfa;
      beta = pp * (pp + lmbd) * (pp + lmbd);
      sigm += pfour * carlsonrc(alfa,beta);
      pfour /= 4.0;
      xx = (xx + lmbd) / 4.0;
      yy = (yy + lmbd) / 4.0;
      zz = (zz + lmbd) / 4.0;
      pp = (pp + lmbd) / 4.0;
      if (iseq(xx,yy) && iseq(yy,zz) && iseq(zz,pp)) {
         break; # loop AWAIT
      }
   }
   return (3.0 * sigm);
}
define carlsonrd(xx,yy,zz) {
   auto sqx,sqy,sqz,lmbd,pfour,alfa,beta,sigm;
   pfour = 1.0;
   sigm = 0.0;
   for (;;) {
      sqx = sqrt(xx);
      sqy = sqrt(yy);
      sqz = sqrt(zz);
      lmbd = sqx * sqy + sqx * sqz + sqy * sqz;
      alfa = zz * (sqx + sqy + sqz) + sqx * sqy * sqz;
      alfa *= alfa;
      beta = zz * (zz + lmbd) * (zz + lmbd);
      sigm += pfour * carlsonrc(alfa,beta);
      pfour /= 4.0;
      xx = (xx + lmbd) / 4.0;
      yy = (yy + lmbd) / 4.0;
      zz = (zz + lmbd) / 4.0;
      if (iseq(xx,yy) && iseq(yy,zz)) {
         break; # loop AWAIT
      }
   }
   return (3.0 * sigm);
}
define powi(xx,nn) {
   auto pp,xsq;
   pp = 1;
   xsq = xx;
   while (0 < nn) {
      if (isodd(nn)) {
         pp *= xsq;
      }
      xsq *= xsq;
      nn = lf_shiftr(nn,1);
   }
   return (pp);
}
define atothenmodp(naa,nn,pp) {
   auto retvalu,cc,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (pp == 0) {
      retvalu = 0;
   } else {
      if (pp < 0) {
         pp = -pp;
      }
      if (nn < 0) {
         nn = nn % pp;
         if (nn < 0) {
            nn += pp;
         }
      }
      retvalu = 1;
      cc = naa % pp;
      while (0 < nn) {
         if (isodd(nn)) {
            retvalu = (retvalu * cc) % pp;
            nn = (nn - 1) / 2;
         } else {
            nn /= 2;
         }
         cc = (cc * cc) % pp;
      }
   }
   scale = local_prev_scale;
   return (retvalu);
}
define atothenmodx(xaa,xnn,xpp) {
   return (frac(exp(xnn * log(xaa) - log(xpp))) * xpp);
}
define ctz(nn) {
   auto zero_count;
   zero_count = 0;
   while (0 == bitwiseand(nn,1)) {
      zero_count += 1;
      nn = lf_shiftr(nn,1);
   }
   return (zero_count);
}
define gcd(naa,nbb) {
   auto cc,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   naa = abs(naa);
   nbb = abs(nbb);
   if (nbb <= 0) {
      nbb = naa;
   } else {
      while (0 < naa) {
         cc = naa;
         naa = nbb % naa;
         nbb = cc;
      }
   }
   scale = local_prev_scale;
   return (nbb);
}
define gcda(array_count,*num_arr_pc[]) {
   auto ind,gc;
   gc = num_arr_pc[0];
   for (ind = 1; ind <= array_count - 1; ind += 1) {
      gc = gcd(gc,num_arr_pc[ind]);
   }
   return (gc);
}
define lcm(naa,nbb) {
   return (naa * nbb / gcd(naa,nbb));
}
define lcam(naa,nbb) {
   auto ii,jj;
   if (nbb < naa) {
      ii = naa;
      naa = nbb;
      nbb = ii;
   }
   ii = nbb;
   for (;;) {
      jj = mods(ii,naa);
      if (- 2 <= jj && jj <= 2) {
         break; # loop AWAIT
      }
      ii += nbb;
   }
   if (jj == -2) {
      ii += 1;
   } else if (0 <= jj) {
      ii -= 1;
   }
   return (ii);
}
define lcams(naa,nbb) {
   auto ii,jj;
   if (nbb < naa) {
      ii = naa;
      naa = nbb;
      nbb = ii;
   }
   ii = 2 * nbb;
   for (;;) {
      jj = mods(ii,naa);
      if (- 2 <= jj && jj <= 2) {
         break; # loop AWAIT
      }
      ii += nbb;
   }
   if (jj == -2) {
      ii += 1;
   } else if (0 <= jj) {
      ii -= 1;
   }
   return (ii);
}
define lcantim(naa,nbb) {
   auto hnaa,hnbb,ii,rema,odd_mask;
   if (isposint(naa) && isposint(nbb)) {
      odd_mask = 0;
      if (isodd(naa)) {
         odd_mask = 1;
      }
      if (isodd(nbb)) {
         odd_mask += 2;
      }
      if (2 == odd_mask || (nbb < naa && odd_mask != 1)) {
         ii = nbb;
         nbb = naa;
         naa = ii;
      }
      hnaa = floorl(naa / 2);
      hnbb = floorl(nbb / 2);
      ii = hnbb;
      for (;;) {
         rema = dist(ii,naa);
         if (rema == hnaa) {
            break;
         } else if (odd_mask == 3 && rema == hnaa + 1) {
            break;
         }
         ii += nbb;
         if (naa * nbb <= ii) {
            break; # loop AWAIT
         }
      }
      if (naa * nbb <= ii) {
         ii = 0;
      }
   } else {
      ii = 0;
   }
   return (ii);
}
define factor(number_to_factor,*ret_fctr_arr_p[]) {
   auto pp,fctr_ind,inc,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   fctr_ind = 0;
   number_to_factor = abs(number_to_factor);
   if (number_to_factor <= 3) {
      ret_fctr_arr_p[fctr_ind] = number_to_factor;
      fctr_ind = 1;
   } else {
      for (pp = 2; pp <= 3; pp += 1) {
         while (0 == number_to_factor % pp) {
            ret_fctr_arr_p[fctr_ind] = pp;
            fctr_ind += 1;
            number_to_factor /= pp;
         }
      }
      pp = 1;
      inc = 4;
      for (;;) {
         pp += inc;
         inc = 6 - inc;
         while (0 == number_to_factor % pp) {
            ret_fctr_arr_p[fctr_ind] = pp;
            fctr_ind += 1;
            number_to_factor /= pp;
         }
         if (number_to_factor < pp * pp) {
            break; # loop AWAIT
         }
      }
      if (1 < number_to_factor) {
         ret_fctr_arr_p[fctr_ind] = number_to_factor;
         fctr_ind += 1;
      }
   }
   scale = local_prev_scale;
   ret_fctr_arr_p[fctr_ind] = 0;
   return (fctr_ind);
}
define modulo(nxx,modyy) {
   auto retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   retvalu = nxx % modyy;
   if (retvalu < 0) {
      retvalu += abs(modyy);
   }
   scale = local_prev_scale;
   return (retvalu);
}
define mods(nxx,modyy) {
   auto retvalu,amodyy,anxx,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   amodyy = floorl(abs(modyy));
   anxx = abs(nxx);
   retvalu = anxx % amodyy;
   if (0 < retvalu) {
      while (amodyy < 2 * retvalu) {
         retvalu -= amodyy;
      }
   } else if (retvalu < 0) {
      while (2 * retvalu < - amodyy) {
         retvalu += amodyy;
      }
   }
   scale = local_prev_scale;
   return (retvalu);
}
define pfl(nn) {
   auto small_factor,lim,divid,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (nn < 2) {
      small_factor = 1;
   } else if (nn % 2 == 0) {
      small_factor = 2;
   } else if (nn % 3 == 0) {
      small_factor = 3;
   } else if (nn % 5 == 0) {
      small_factor = 5;
   } else if (nn % 7 == 0) {
      small_factor = 7;
   } else {
      lim = floorl(sqrt(nn));
      divid = 11;
      small_factor = nn;
      while (divid <= lim) {
         if (nn % divid == 0) {
            small_factor = divid;
            break;
         }
         divid += 2;
         if (nn % divid == 0) {
            small_factor = divid;
            break;
         }
         divid += 4;
      }
   }
   scale = local_prev_scale;
   return (small_factor);
}
define pfg(nn) {
   auto jj,ii;
   jj = nn;
   for (;;) {
      ii = pfl(jj);
      jj /= ii;
      if (jj == 1) {
         break; # loop AWAIT
      }
   }
   return (ii);
}
define isprime(nn) {
   auto retvalu_bol,ann;
   ann = abs(nn);
   if (ann == 2 || ann == 3 || ann == 5 || ann == 7) {
      retvalu_bol = true;
   } else if (ann < 11) {
      retvalu_bol = false;
   } else if (pfl(ann) == ann) {
      retvalu_bol = true;
   } else {
      retvalu_bol = false;
   }
   return (retvalu_bol);
}
define lf_primeprev(pp) {
   auto retvalu,rema,inc,qq,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (pp <= 7) {
      if (5 < pp) {
         retvalu = 5;
      } else if (3 < pp) {
         retvalu = 3;
      } else if (2 < pp) {
         retvalu = 2;
      } else {
         retvalu = -2;
      }
   } else {
      rema = pp % 6;
      qq = pp - rema;
      if (rema <= 1) {
         qq -= 1;
         inc = 4;
      } else {
         qq += 1;
         inc = 2;
      }
      while (! isprime(qq)) {
         qq -= inc;
         inc = 6 - inc;
      }
      retvalu = qq;
   }
   scale = local_prev_scale;
   return (retvalu);
}
define lf_primenext(pp) {
   auto retvalu,rema,inc,qq,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (pp < 7) {
      if (pp < 2) {
         retvalu = 2;
      } else if (pp < 3) {
         retvalu = 3;
      } else if (pp < 5) {
         retvalu = 5;
      } else {
         retvalu = 7;
      }
   } else {
      rema = (pp + 1) % 6;
      qq = (pp + 1) - rema;
      if (rema <= 1) {
         qq += 1;
         inc = 4;
      } else {
         qq += 5;
         inc = 2;
      }
      while (! isprime(qq)) {
         qq += inc;
         inc = 6 - inc;
      }
      retvalu = qq;
   }
   scale = local_prev_scale;
   return (retvalu);
}
define primeprev(pp) {
   auto retvalu;
   if (0 <= pp) {
      retvalu = lf_primeprev(pp);
   } else {
      retvalu = -lf_primenext(-pp);
   }
   return (retvalu);
}
define primenext(pp) {
   auto retvalu;
   if (0 <= pp) {
      retvalu = lf_primenext(pp);
   } else {
      retvalu = -lf_primeprev(-pp);
   }
   return (retvalu);
}
lv_pcf_end = 0;
lv_pcf_arr[0] = 0;
define primecount(xx) {
   # local-use Bc lv_pcf_arr[];
   # local-use Bc lv_pcf_end;
   auto retvalu,poss_prime,s_ind,ps_ind,pcf_val,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (xx < 7) {
      if (xx < 3) {
         if (xx < 2) {
            retvalu = 0;
         } else {
            retvalu = 1;
         }
      } else {
         if (xx < 5) {
            retvalu = 2;
         } else {
            retvalu = 3;
         }
      }
   } else {
      s_ind = floorl((xx - 5) / 2) - floorl((xx - 3) / 6);
      if (lv_pcf_end <= s_ind) {
         ps_ind = lv_pcf_end;
         if (lv_pcf_end <= 0) {
            pcf_val = 2;
         } else {
            pcf_val = lv_pcf_arr[lv_pcf_end - 1];
         }
         lv_pcf_end = ceil2(s_ind + 1,2);
         poss_prime = 3 * ps_ind - (ps_ind % 2) + 5;
         while (ps_ind <= s_ind) {
            if (isprime(poss_prime)) {
               pcf_val += 1;
            }
            lv_pcf_arr[ps_ind] = pcf_val;
            poss_prime += 2;
            ps_ind += 1;
            if (isprime(poss_prime)) {
               pcf_val += 1;
            }
            lv_pcf_arr[ps_ind] = pcf_val;
            poss_prime += 4;
            ps_ind += 1;
         }
      }
      retvalu = lv_pcf_arr[s_ind];
   }
   scale = local_prev_scale;
   return (retvalu);
}
define pcf(xx) {
   return (primecount(xx));
}
define primecountx(xx) {
   auto retvalu,poss_prime,inc,pcf_val;
   if (xx < 7) {
      if (xx < 3) {
         if (xx < 2) {
            retvalu = 0;
         } else {
            retvalu = 1;
         }
      } else {
         if (xx < 5) {
            retvalu = 2;
         } else {
            retvalu = 3;
         }
      }
   } else {
      pcf_val = 4;
      poss_prime = 11;
      inc = 2;
      while (poss_prime <= xx) {
         if (isprime(poss_prime)) {
            pcf_val += 1;
         }
         poss_prime += inc;
         inc = 6 - inc;
      }
      retvalu = pcf_val;
   }
   return (retvalu);
}
define eta(xx) {
   auto sum,sump,tt,nn,kk,s_ind,retvalu,pm_one,ps_arr[],\
            temp_arr[],term;
   if (0 < xx) {
      tt = 0;
      term = -log(cxdbleps) / xx;
      if (term < log(4000)) {
         kk = ceill(exp(term));
         sum = 0;
         pm_one = -1.0;
         nn = 1;
         for (;;) {
            pm_one = -pm_one;
            term = pm_one * pow(nn,- xx);
            tt += 1;
            sump = sum;
            sum += term;
            if (iseq(sump,sum)) {
               break; # loop AWAIT
            }
            nn += 1;
            if (kk <= nn) {
               break; # loop AWAIT
            }
         }
         retvalu = sum - 0.5 * term;
      } else {
         sum = 0;
         pm_one = -1.0;
         ps_arr[0] = -pow(2,- xx);
         tt += 1;
         temp_arr[0] = ps_arr[0];
         nn = 1;
         for (;;) {
            pm_one = -pm_one;
            ps_arr[nn] = ps_arr[nn - 1] + pm_one * pow(nn + 2,- xx);
            tt += 1;
            temp_arr[nn] = ps_arr[nn];
            for (kk = nn - 1; 0 <= kk; kk -= 1) {
               temp_arr[kk] = (temp_arr[kk] + temp_arr[kk + 1]) / 2.0;
            }
            sump = sum;
            sum = temp_arr[0];
            if (iseq(sump,sum)) {
               break; # loop AWAIT
            }
            nn += 1;
            if (400 <= nn) {
               break; # loop AWAIT
            }
         }
         s_ind = floorl(nn / 3);
         sum = (4 * temp_arr[s_ind] + 3 * temp_arr[s_ind + 1]) / 7;
         retvalu = sum + 1.0;
      }
   } else if (xx < 0) {
      retvalu = 0.0;
   } else {
      retvalu = 0.5;
   }
   return (retvalu);
}
define zeta(xx) {
   auto retvalu;
   if (1 < xx) {
      retvalu = eta(xx) / (1.0 - pow(2.0,1.0 - xx));
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define fibo3(nn,fib_a,fib_b) {
   auto ii,tt,retvalu;
   if (nn == 0) {
      retvalu = fib_a;
   } else {
      for (ii = 2; ii <= nn; ii += 1) {
         tt = fib_b;
         fib_b += fib_a;
         fib_a = tt;
      }
      retvalu = fib_b;
   }
   return (retvalu);
}
define fibo(nn) {
   return (fibo3(nn,0,1));
}
define fibox(xx) {
   auto zz,retvalu;
   if (log(cxdblmax) / log(cxphi) < abs(xx)) {
      retvalu = 0.0;
   } else {
      zz = pow(cxphi,xx);
      retvalu = (zz - cos(cxpi * xx) / zz) / sqrt(5.0);
   }
   return (retvalu);
}
define fiboxinv(yy) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_ii,x_init;
   if (yy <= 0) {
      scvx_xx = 0.0;
   } else {
      if (yy <= 0.2) {
         x_init = 0.075;
      } else if (yy <= 0.896946387424606) {
         x_init = 0.8 * yy - 0.15;
      } else if (yy <= 1.009824331847821) {
         x_init = 0.92;
      } else {
         x_init = log(yy * sqrt(5.0)) / log(cxphi);
      }
      scvx_dx = 0.05;
      scvx_xx = x_init;
      scvx_yy = yy - fibox(scvx_xx);
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = yy - fibox(scvx_xx);
         if (iseq(scvx_yy,scvx_yp)) {
            break;
         }
         scvx_dx *= - scvx_yy / (scvx_yy - scvx_yp);
      }
   }
   return (scvx_xx);
}
define lucas(nn) {
   return (fibo3(nn,2,1));
}
define lucasx(xx) {
   auto zz,retvalu;
   if (log(cxdblmax) / log(cxphi) < abs(xx)) {
      retvalu = 0.0;
   } else {
      zz = pow(cxphi,xx);
      retvalu = (zz + cos(cxpi * xx) / zz);
   }
   return (retvalu);
}
define fusc(nn) {
   auto naa,nbb;
   naa = 1;
   nbb = 0;
   while (0 < nn) {
      if (isodd(nn)) {
         nbb += naa;
      } else {
         naa += nbb;
      }
      nn = lf_shiftr(nn,1);
   }
   return (nbb);
}
define tn(nn,xx) {
   auto retvalu,tnm_a,tnm_b,tnn,kk;
   if (nn == 0) {
      retvalu = 1.0;
   } else if (nn == 1) {
      retvalu = xx;
   } else if (nn == 2) {
      retvalu = 2.0 * xx * xx - 1.0;
   } else {
      tnm_a = 2.0 * xx * xx - 1.0;
      tnm_b = xx;
      tnn = tnm_a;
      for (kk = 3; kk <= nn; kk += 1) {
         tnn = (2.0 * xx * tnm_a) - tnm_b;
         tnm_b = tnm_a;
         tnm_a = tnn;
      }
      retvalu = tnn;
   }
   return (retvalu);
}
define un(nn,xx) {
   auto retvalu,tnm_a,tnm_b,tnn,kk;
   if (nn == 0) {
      retvalu = 1.0;
   } else if (nn == 1) {
      retvalu = 2.0 * xx;
   } else {
      tnm_a = 2.0 * xx;
      tnm_b = 1.0;
      tnn = tnm_a;
      for (kk = 2; kk <= nn; kk += 1) {
         tnn = (2.0 * xx * tnm_a) - tnm_b;
         tnm_b = tnm_a;
         tnm_a = tnn;
      }
      retvalu = tnn;
   }
   return (retvalu);
}
define tri(nn) {
   return (nn * (nn + 1) / 2);
}
define triinv(nn) {
   auto retvalu;
   if (- 0.125 < nn) {
      retvalu = (sqrt(8.0 * nn + 1.0) - 1.0) / 2.0;
   } else {
      retvalu = -0.5;
   }
   return (retvalu);
}
define polynum(ss,nn) {
   return ((ss - 2) * nn * (nn - 1) / 2 + nn);
}
define polycnum(ss,nn) {
   return (ss * nn * (nn - 1) / 2 + 1);
}
define tetranum(ss,nn) {
   return (nn * (nn + 1) * ((ss - 2) * nn + 5 - ss) / 6);
}
define tetracnum(ss,nn) {
   return (nn * (ss * nn * nn + 6 - ss) / 6);
}
define minkowski(xx) {
   auto pp,qq,rr,ss,ff,gg,dd,yy;
   pp = floor(xx);
   qq = 1;
   rr = pp + 1;
   ss = 1;
   dd = 1.0;
   yy = pp;
   for (;;) {
      dd /= 2.0;
      ff = pp + rr;
      gg = qq + ss;
      if (xx < ff / gg) {
         rr = ff;
         ss = gg;
      } else {
         yy += dd;
         pp = ff;
         qq = gg;
      }
      if (iseq(yy + dd,yy)) {
         break; # loop AWAIT
      }
   }
   return (yy);
}
define cantorxx(nbb,ee,xx) {
   auto yy,rest,dd,ulmt;
   if (ee < 0.0 || nbb < 0.0 || 1.0 < ee + nbb) {
      yy = xx;
   } else {
      ulmt = 1.0 - ee;
      yy = floor(xx);
      rest = (xx - yy);
      dd = 0.5;
      for (;;) {
         if (ulmt <= rest) {
            yy += dd;
            rest = frac((rest - ulmt) / ee);
         } else if (nbb <= rest) {
            yy += dd;
            break;
         } else {
            rest = frac(rest / nbb);
         }
         dd /= 2.0;
         if (iseq(yy + dd,yy) || iszero(rest)) {
            break; # loop AWAIT
         }
      }
   }
   return (yy);
}
define cantor(xx) {
   return (cantorxx(1.0 / 3.0,1.0 / 3.0,xx));
}
define cantorul(bb,ee,xx) {
   return (pow(0.5,log(xx) / log(bb) + 0.0 * ee));
}
define cantorll(bb,ee,xx) {
   return (pow(0.5,log(xx / (1.0 - ee)) / log(bb) + 1.0));
}
define dlogx(naa,nbb,nn) {
   auto ii,pp,retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   pp = naa;
   retvalu = -1;
   for (ii = 1; ii <= nn; ii += 1) {
      if (pp == nbb) {
         retvalu = ii;
         break;
      }
      pp = (pp * naa) % nn;
   }
   scale = local_prev_scale;
   return (retvalu);
}
define dlog(naa,nbb,nn) {
   auto sqnn,cur,atothesqnn,atothens,ii,log_arr[],retvalu,\
            local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (naa == nbb) {
      retvalu = 1;
   } else if (naa <= 0 || nbb <= 0 || nn <= 0) {
      retvalu = -1;
   } else if (1 < gcd(naa,nn)) {
      retvalu = dlogx(naa,nbb,nn);
   } else if (! isprimitiveroot(naa,nn)) {
      retvalu = dlogx(naa,nbb,nn);
   } else {
      sqnn = ceill(sqrt(nn));
      for (ii = 0; ii <= nn - 1; ii += 1) {
         log_arr[ii] = 0;
      }
      atothesqnn = atothenmodp(naa,sqnn,nn);
      cur = atothesqnn;
      for (ii = 1; ii <= sqnn; ii += 1) {
         if (log_arr[cur] == 0) {
            log_arr[cur] = ii;
         }
         cur = (cur * atothesqnn) % nn;
      }
      cur = nbb % nn;
      retvalu = -1;
      for (ii = 0; ii <= sqnn; ii += 1) {
         if (0 < log_arr[cur]) {
            atothens = log_arr[cur] * sqnn - ii;
            if (atothens < nn) {
               retvalu = atothens;
               break;
            }
         }
         cur = (cur * naa) % nn;
      }
   }
   scale = local_prev_scale;
   return (retvalu);
}
define dlog1(naa,nn) {
   return (dlog(naa,1,nn));
}
lv_mertens_end = 0;
lv_mertens_arr[0] = 0;
define mertens(nn) {
   # local-use Bc lv_mertens_arr[];
   # local-use Bc lv_mertens_end;
   auto retvalu,kk;
   if (nn < 0) {
      retvalu = 0;
   } else {
      if (lv_mertens_end <= 0) {
         lv_mertens_end = 4;
         lv_mertens_arr[0] = 0;
         lv_mertens_arr[1] = 1;
         lv_mertens_arr[2] = 0;
         lv_mertens_arr[3] = -1;
      }
      if (lv_mertens_end <= nn) {
         kk = lv_mertens_end;
         lv_mertens_end = nn + 1;
         while (kk < lv_mertens_end) {
            lv_mertens_arr[kk] = lv_mertens_arr[kk - 1] + mobius(kk);
            kk += 1;
         }
      }
      retvalu = lv_mertens_arr[nn];
   }
   return (retvalu);
}
define has_primitiveroot_f(array_size,*fac_arr_pc[]) {
   auto ind;
   ind = 0;
   if (1 < array_size) {
      if (fac_arr_pc[0] == 2) {
         ind += 1;
      }
      if (2 < fac_arr_pc[ind]) {
         while (ind < array_size - 1) {
            if (fac_arr_pc[ind] < fac_arr_pc[ind + 1]) {
               break;
            }
            ind += 1;
         }
      }
   }
   return (ind == (array_size - 1));
}
define sigma0_f(array_size,*fac_arr_pc[]) {
   auto ind,retvalu,exp_i;
   retvalu = 1;
   exp_i = 2;
   for (ind = 0; ind <= array_size - 2; ind += 1) {
      if (fac_arr_pc[ind] == fac_arr_pc[ind + 1]) {
         exp_i += 1;
      } else {
         retvalu *= exp_i;
         exp_i = 2;
      }
   }
   return (retvalu * exp_i);
}
define sigma1_f(array_size,*fac_arr_pc[]) {
   auto ind,retvalu,exp_i,prm_prev,prm_curr;
   retvalu = 1;
   exp_i = 2;
   prm_prev = fac_arr_pc[0];
   for (ind = 1; ind <= array_size - 1; ind += 1) {
      prm_curr = fac_arr_pc[ind];
      if (prm_prev == prm_curr) {
         exp_i += 1;
      } else {
         retvalu *= (powi(prm_prev,exp_i) - 1) / (prm_prev - 1);
         exp_i = 2;
         prm_prev = prm_curr;
      }
   }
   return (retvalu * (powi(prm_prev,exp_i) - 1) / (prm_prev - 1));
}
define sigma_f(powy,array_size,*fac_arr_pc[]) {
   auto ind,retvalu,exp_i,prm_curr,prm_prev,pw;
   if (powy == 0) {
      retvalu = sigma0_f(array_size,fac_arr_pc[]);
   } else if (powy == 1) {
      retvalu = sigma1_f(array_size,fac_arr_pc[]);
   } else {
      retvalu = 1;
      exp_i = 2;
      prm_prev = fac_arr_pc[0];
      for (ind = 1; ind <= array_size - 1; ind += 1) {
         prm_curr = fac_arr_pc[ind];
         if (prm_prev == prm_curr) {
            exp_i += 1;
         } else {
            pw = powi(prm_prev,powy);
            retvalu *= ((powi(pw,exp_i) - 1) / (pw - 1));
            exp_i = 2;
            prm_prev = prm_curr;
         }
      }
      pw = powi(prm_prev,powy);
      retvalu *= ((powi(pw,exp_i) - 1) / (pw - 1));
   }
   return (retvalu);
}
define ispractical_f(array_size,*fac_arr_pc[]) {
   auto ind,sgma,exp_i,prm_curr,prm_prev,retvalu_bol;
   if (2 < fac_arr_pc[0]) {
      retvalu_bol = false;
   } else {
      retvalu_bol = true;
      sgma = 1;
      exp_i = 2;
      prm_prev = fac_arr_pc[0];
      for (ind = 1; ind <= array_size - 1; ind += 1) {
         prm_curr = fac_arr_pc[ind];
         if (prm_prev == prm_curr) {
            exp_i += 1;
         } else {
            sgma *= (powi(prm_prev,exp_i) - 1) / (prm_prev - 1);
            if (1 + sgma < prm_curr) {
               retvalu_bol = false;
               break;
            }
            exp_i = 2;
            prm_prev = prm_curr;
         }
      }
   }
   return (retvalu_bol);
}
define issquarefree_f(array_size,*fac_arr_pc[]) {
   auto ind,retvalu_bol;
   retvalu_bol = true;
   for (ind = 1; ind <= array_size - 1; ind += 1) {
      if (fac_arr_pc[ind - 1] == fac_arr_pc[ind]) {
         retvalu_bol = false;
         break;
      }
   }
   return (retvalu_bol);
}
define totient_f(array_size,*fac_arr_pc[]) {
   auto ind,retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   retvalu = 1;
   for (ind = 0; ind <= array_size - 2; ind += 1) {
      if (fac_arr_pc[ind] == fac_arr_pc[ind + 1]) {
         retvalu *= fac_arr_pc[ind];
      } else {
         retvalu *= (fac_arr_pc[ind] - 1);
      }
   }
   retvalu *= (fac_arr_pc[array_size - 1] - 1);
   scale = local_prev_scale;
   return (retvalu);
}
define mobius_f(array_size,*fac_arr_pc[]) {
   auto retvalu,ind;
   if (iseven(array_size)) {
      retvalu = 1;
   } else {
      retvalu = -1;
   }
   for (ind = 1; ind <= array_size - 1; ind += 1) {
      if (fac_arr_pc[ind - 1] == fac_arr_pc[ind]) {
         retvalu = 0;
         break;
      }
   }
   return (retvalu);
}
define prime0_f(array_size,*fac_arr_pc[]) {
   auto ind,prm_curr,prm_prev,retvalu;
   retvalu = 1;
   prm_prev = fac_arr_pc[0];
   for (ind = 1; ind <= array_size - 1; ind += 1) {
      prm_curr = fac_arr_pc[ind];
      if (prm_prev < prm_curr) {
         retvalu += 1;
      }
      prm_prev = prm_curr;
   }
   return (retvalu);
}
cxlc_factors_cnt = 65;
define factor_print(nn) {
   auto ind,fac_arr[],array_size;
   array_size = factor(nn,fac_arr[]);
   print nn;
   print ":";
   for (ind = 0; ind <= array_size - 1; ind += 1) {
      print " ";
      print fac_arr[ind];
   }
   print "\n";
   return (array_size);
}
define mobius(nn) {
   auto array_size,fac_arr[];
   array_size = factor(nn,fac_arr[]);
   return (mobius_f(array_size,fac_arr[]));
}
define isprimitiveroot(naa,nn) {
   auto toti,array_size_toti,ind,prm,retvalu_bol,fac_arr[];
   if (naa <= 1 || 1 < gcd(naa,nn)) {
      retvalu_bol = false;
   } else if (naa == 2) {
      retvalu_bol = isodd(nn);
   } else {
      toti = totient(nn);
      array_size_toti = factor(toti,fac_arr[]);
      if (atothenmodp(naa,toti / fac_arr[0],nn) == 1) {
         retvalu_bol = false;
      } else {
         retvalu_bol = true;
         for (ind = 1; ind <= array_size_toti - 1; ind += 1) {
            if (fac_arr[ind - 1] != fac_arr[ind]) {
               prm = fac_arr[ind];
               if (atothenmodp(naa,toti / prm,nn) == 1) {
                  retvalu_bol = false;
                  break;
               }
            }
         }
      }
   }
   return (retvalu_bol);
}
define prime0(nn) {
   auto array_size,fac_arr[];
   array_size = factor(nn,fac_arr[]);
   return (prime0_f(array_size,fac_arr[]));
}
define prime1(nn) {
   auto fac_arr[];
   return (factor(nn,fac_arr[]));
}
define sigma0(nn) {
   auto array_size,fac_arr[];
   array_size = factor(nn,fac_arr[]);
   return (sigma0_f(array_size,fac_arr[]));
}
define sigma1(nn) {
   auto array_size,fac_arr[];
   array_size = factor(nn,fac_arr[]);
   return (sigma1_f(array_size,fac_arr[]));
}
define sigma(powy,nn) {
   auto array_size,fac_arr[],retvalu;
   if (nn <= 1) {
      retvalu = nn;
   } else if (powy == 0) {
      retvalu = sigma0(nn);
   } else if (powy == 1) {
      retvalu = sigma1(nn);
   } else {
      array_size = factor(nn,fac_arr[]);
      retvalu = sigma_f(powy,array_size,fac_arr[]);
   }
   return (retvalu);
}
define totient(nn) {
   auto fac_arr[],array_size;
   array_size = factor(nn,fac_arr[]);
   return (totient_f(array_size,fac_arr[]));
}
define has_primitiveroot(nn) {
   auto array_size,fac_arr[],retvalu_bol;
   if (nn < 2) {
      retvalu_bol = false;
   } else {
      array_size = factor(nn,fac_arr[]);
      retvalu_bol = has_primitiveroot_f(array_size,fac_arr[]);
   }
   return (retvalu_bol);
}
define issquarefree(nn) {
   auto array_size,fac_arr[],retvalu_bol;
   if (nn < 1) {
      retvalu_bol = false;
   } else if (nn < 3) {
      retvalu_bol = true;
   } else {
      array_size = factor(nn,fac_arr[]);
      retvalu_bol = issquarefree_f(array_size,fac_arr[]);
   }
   return (retvalu_bol);
}
define ispractical(nn) {
   auto array_size,fac_arr[],retvalu_bol;
   if (nn < 1) {
      retvalu_bol = false;
   } else if (nn < 3) {
      retvalu_bol = true;
   } else {
      array_size = factor(nn,fac_arr[]);
      retvalu_bol = ispractical_f(array_size,fac_arr[]);
   }
   return (retvalu_bol);
}
define primitiveroot(nn) {
   auto ind,array_size_toti,toti,ii,fac_arr[],prm,retvalu,\
            local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (nn < 2) {
      retvalu = 0;
   } else if (nn < 5) {
      retvalu = nn - 1;
   } else if (! has_primitiveroot(nn)) {
      retvalu = 0;
   } else {
      toti = totient(nn);
      array_size_toti = factor(toti,fac_arr[]);
      ii = 2;
      retvalu = 0;
      while (ii < nn && retvalu <= 0) {
         if (gcd(ii,nn) == 1) {
            retvalu = ii;
            prm = 0;
            for (ind = 0; ind <= array_size_toti - 1; ind += 1) {
               if (prm != fac_arr[ind]) {
                  prm = fac_arr[ind];
                  if (atothenmodp(ii,toti / prm,nn) == 1) {
                     retvalu = 0;
                     break;
                  }
               }
            }
         }
         ii += 1;
      }
   }
   scale = local_prev_scale;
   return (retvalu);
}
define carmichael(nn) {
   auto ind,array_size,lmbd,prm,pk,fac_arr[],local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (nn < 8) {
      lmbd = totient(nn);
   } else {
      array_size = factor(nn,fac_arr[]);
      ind = 0;
      while (ind < array_size && fac_arr[ind] == 2) {
         ind += 1;
      }
      if (2 < ind) {
         lmbd = lf_shiftl(1,ind - 2);
      } else {
         lmbd = 1;
      }
      while (ind < array_size) {
         prm = fac_arr[ind];
         pk = prm - 1;
         while (ind < array_size - 1 && prm == fac_arr[ind + 1]) {
            ind += 1;
            pk *= prm;
         }
         lmbd = lcm(lmbd,pk);
         ind += 1;
      }
   }
   scale = local_prev_scale;
   return (lmbd);
}
define znorder(naa,nn) {
   auto ind,fac_arr[],array_sizekk,kk,ab,ek,prm_i,exp_i,\
            local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (nn == 0 || naa == 0) {
      kk = 0;
   } else {
      if (nn < 0) {
         nn = -nn;
      }
      while (naa < 0) {
         naa += nn;
      }
      if (nn <= 1) {
         kk = nn;
      } else if (naa <= 1) {
         kk = naa;
      } else if (1 < gcd(naa,nn)) {
         kk = 0;
      } else {
         kk = carmichael(nn);
         array_sizekk = factor(kk,fac_arr[]);
         exp_i = 1;
         for (ind = 0; ind <= array_sizekk - 1; ind += 1) {
            prm_i = fac_arr[ind];
            kk /= prm_i;
            if (ind + 1 < array_sizekk && prm_i == fac_arr[ind + 1]) {
               exp_i += 1;
            } else {
               ab = atothenmodp(naa,kk,nn);
               for (ek = 0; ek <= exp_i; ek += 1) {
                  if (ab == 1) {
                     break;
                  }
                  kk *= prm_i;
                  ab = atothenmodp(ab,prm_i,nn);
               }
               if (exp_i < ek) {
                  kk = 0;
                  break;
               }
               exp_i = 1;
            }
         }
      }
   }
   scale = local_prev_scale;
   return (kk);
}
define repetendlen(denm,basee) {
   auto gdn,retvalu;
   for (;;) {
      gdn = gcd(denm,basee);
      denm /= gdn;
      if (1 == gdn) {
         break; # loop AWAIT
      }
   }
   if (denm == 1) {
      retvalu = 0;
   } else {
      retvalu = znorder(basee,denm);
   }
   return (retvalu);
}
define kevy_print(den,start,basee) {
   auto numer,valu,leny,rema,overall_len,baseek,log_start;
   log_start = floorl(log(start) / log(basee) + 1);
   baseek = pow(basee,log_start);
   overall_len = (dlog(basee,den,den * baseek - 1) + 3) * log_start;
   auto local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   leny = 0;
   numer = start;
   valu = start;
   for (;;) {
      bcdummy = base_out_fix_print(valu,basee,log_start);
      leny += log_start;
      valu = floorl(numer / den);
      rema = numer % den;
      numer = rema * baseek + valu;
      if (numer == start) {
         break;
      }
      if (2 * overall_len < leny) {
         break; # loop AWAIT
      }
   }
   scale = local_prev_scale;
   return (leny);
}
define eulerphi(nn) {
   return (totient(nn));
}
define znorder__1(nbb,mdls) {
   auto nn,pp,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (1 < gcd(nbb,mdls)) {
      nn = 0;
   } else {
      pp = 1;
      nn = 1;
      for (;;) {
         pp = (pp * nbb) % mdls;
         if (pp == 1) {
            break; # loop AWAIT
         }
         nn += 1;
         if (mdls <= nn) {
            break; # loop AWAIT
         }
      }
   }
   scale = local_prev_scale;
   return (nn);
}
define bkn(nbb,kk) {
   return (znorder(nbb,kk * nbb - 1));
}
define bkbn(nbb,kk,cc) {
   auto mdls,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   mdls = kk * nbb - 1;
   if (mdls % cc == 0) {
      mdls /= cc;
   }
   scale = local_prev_scale;
   return (znorder(nbb,mdls));
}
lv_li_two = 0;
define lix(xx) {
   # local-use Bc lv_li_two;
   if (lv_li_two <= 0) {
      lv_li_two = logintegral(2.0);
   }
   return (logintegral(xx) - lv_li_two);
}
define lixinv(yy) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_ii,x_init;
   x_init = yy / log(yy);
   scvx_dx = 0.05;
   scvx_xx = x_init;
   scvx_yy = yy - lix(scvx_xx);
   for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
      scvx_xp = scvx_xx;
      scvx_yp = scvx_yy;
      scvx_xx += scvx_dx;
      if (iseq(scvx_xp,scvx_xx)) {
         break;
      }
      scvx_yy = yy - lix(scvx_xx);
      if (iseq(scvx_yy,scvx_yp)) {
         break;
      }
      scvx_dx *= - scvx_yy / (scvx_yy - scvx_yp);
   }
   return (scvx_xx);
}
define lf_n2primish(nn) {
   auto retvalu;
   if (nn == 0) {
      retvalu = 0;
   } else if (nn < 3) {
      retvalu = nn + 1;
   } else if (isodd(nn)) {
      retvalu = 3 * nn - 4;
   } else {
      retvalu = 3 * nn - 5;
   }
   return (retvalu);
}
define n2primish(nn) {
   auto retvalu;
   if (0 < nn) {
      retvalu = lf_n2primish(nn);
   } else {
      retvalu = -lf_n2primish(-nn);
   }
   return (retvalu);
}
define primenth__1(nn) {
   auto logn,loglogn,retvalu;
   if (nn < 0) {
      retvalu = 0;
   } else if (nn < 4.25) {
      retvalu = 1.6 * nn + 0.1;
   } else {
      logn = log(nn);
      loglogn = log(logn);
      retvalu = nn * (logn + loglogn - 1.0 + (loglogn - 2.0) / logn -\
               ((loglogn - 6.0) * loglogn + 11.0) / (2.0 * logn * logn))\
               + 3.5 * sqrt(nn) + 10;
   }
   return (retvalu);
}
define reimann(nn) {
   auto retvalu,sum,sum_prev,ii,lim;
   if (nn < 2) {
      retvalu = 0;
   } else {
      sum = lix(nn);
      lim = 10 * lg(nn);
      ii = 2;
      for (;;) {
         sum_prev = sum;
         sum += mobius(ii) * lix(pow(nn,1.0 / ii)) / ii;
         if (iseq(sum,sum_prev)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (lim <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = sum;
   }
   return (retvalu);
}
define primenth(nn) {
   auto ii,pp,rmndr,inc,prime_arr[];
   if (nn < 5) {
      if (nn < 1) {
         pp = 0;
      } else if (nn < 2) {
         pp = 2;
      } else if (nn < 3) {
         pp = 3;
      } else if (nn < 4) {
         pp = 5;
      } else {
         pp = 7;
      }
   } else {
      if (1024 <= nn) {
         prime_arr[0] = 8161;
         prime_arr[1] = 17863;
         prime_arr[2] = 38873;
         prime_arr[3] = 84017;
         prime_arr[4] = 180503;
         prime_arr[5] = 386093;
         prime_arr[6] = 821641;
         prime_arr[7] = 1742537;
         prime_arr[8] = 3681131;
         prime_arr[9] = 7754077;
         prime_arr[10] = 16290047;
         prime_arr[11] = 34136029;
         prime_arr[12] = 71378569;
         prime_arr[13] = 148948139;
         prime_arr[14] = 310248241;
         prime_arr[15] = 645155197;
         prime_arr[16] = 1339484197;
         prime_arr[17] = 2777105129;
         prime_arr[18] = 5750079047;
         prime_arr[19] = 11891268401;
         prime_arr[20] = 24563311309;
         prime_arr[21] = 50685770167;
         prime_arr[22] = 104484802057;
         ii = floorl(lg(nn + 1) - 10);
         if (22 <= ii) {
            ii = 22;
         }
         pp = prime_arr[ii];
         ii = round(pow(2,ii + 10));
         rmndr = fmodu(pp,6);
         if (iseq(rmndr,5)) {
            inc = 2;
         } else if (iseq(rmndr,1)) {
            inc = 4;
         } else {
            halt;
         }
      } else {
         pp = 11;
         ii = 5;
         inc = 2;
      }
      while (ii < nn) {
         for (;;) {
            pp += inc;
            inc = 6 - inc;
            if (isprime(pp)) {
               break; # loop AWAIT
            }
         }
         ii += 1;
      }
   }
   return (pp);
}
define bessjv(vv,xx) {
   auto sum,sum_prev,term,ff,xxsqr_div_four,avv;
   if (xx < 0.0) {
      sum = 0.0;
   } else {
      avv = vv;
      if (isposint(-vv)) {
         avv = abs(vv);
      }
      xxsqr_div_four = (xx * xx / 4.0);
      term = pow(xx / 2.0,avv) / tgamma(avv + 1.0);
      sum = term;
      ff = 1;
      for (;;) {
         term *= - xxsqr_div_four / (ff * (avv + ff));
         sum_prev = sum;
         sum += term;
         if (iseq(sum,sum_prev)) {
            break; # loop AWAIT
         }
         ff += 1;
      }
      if (isposint(-vv) && isodd(vv)) {
         sum = -sum;
      }
   }
   return (sum);
}
define bessyv(vv,xx) {
   auto retvalu,vvpi;
   if (isint(vv)) {
      retvalu = bessyn(vv,xx);
   } else {
      vvpi = cxpi * vv;
      retvalu = (cos(vvpi) * bessjv(vv,xx) - bessjv(-vv,xx)) / sin(vvpi);
   }
   return (retvalu);
}
define bessi0(xx) {
   auto yy,retvalu;
   if (xx < 7.75) {
      yy = xx * xx / 4.0;
      retvalu = (((((((((((((((((1.1497640034400735733456400 * 10^-29) *\
               yy + (2.0732014503197852176921968 * 10^-27)) * yy +\
               (5.9203280572170548134753422 * 10^-25)) * yy +\
               (1.3141332422663039834197910 * 10^-22)) * yy +\
               (2.5791926805873898803749321 * 10^-20)) * yy +\
               (4.3583591008893599099577755 * 10^-18)) * yy +\
               (6.2760839879536225394314453 * 10^-16)) * yy +\
               (7.5940582595094190098755663 * 10^-14)) * yy +\
               (7.5940584360755226536109511 * 10^-12)) * yy +\
               (6.1511873265092916275099070 * 10^-10)) * yy +\
               (3.9367598891475388547279760 * 10^-8)) * yy +\
               (1.9290123456788994104574754 * 10^-6)) * yy +\
               (6.9444444444444568581891535 * 10^-5)) * yy +\
               (1.7361111111111110294015271 * 10^-3)) * yy +\
               (2.7777777777777777805664954 * 10^-2)) * yy +\
               (2.4999999999999999999629693 * 10^-1)) * yy +\
               1.0000000000000000000000801) * yy + 1.0;
   } else {
      yy = 1.0 / xx;
      retvalu = (((((((((((((((((((((((1.6069467093441596329340754 *\
               10^16) * yy - (2.1363029690365351606041265 * 10^16)) * yy\
               + (1.3012646806421079076251950 * 10^16)) * yy -\
               (4.8049082153027457378879746 * 10^15)) * yy +\
               (1.1989242681178569338129044 * 10^15)) * yy -\
               (2.1323049786724612220362154 * 10^14)) * yy +\
               (2.7752144774934763122129261 * 10^13)) * yy -\
               (2.6632742974569782078420204 * 10^12)) * yy +\
               (1.8592340458074104721496236 * 10^11)) * yy -\
               (8.9270060370015930749184222 * 10^9)) * yy +\
               (2.3518420447411254516178388 * 10^8)) * yy +\
               (2.6092888649549172879282592 * 10^6)) * yy -\
               (5.9355022509673600842060002 * 10^5)) * yy +\
               (3.1275740782277570164423916 * 10^4)) * yy -\
               (1.0026890180180668595066918 * 10^3)) * yy +\
               (2.2725199603010833194037016 * 10^1)) * yy -\
               (1.0699095472110916094973951 * 10^-1)) * yy +\
               (9.4085204199017869159183831 * 10^-2)) * yy +\
               (4.4718622769244715693031735 * 10^-2)) * yy +\
               (2.9219501690198775910219311 * 10^-2)) * yy +\
               (2.8050628884163787533196746 * 10^-2)) * yy +\
               (4.9867785050353992900698488 * 10^-2)) * yy +\
               (3.9894228040143265335649948 * 10^-1));
      retvalu *= exp(xx) / sqrt(xx);
   }
   return (retvalu);
}
define bessi1(xx) {
   auto yy,aa,retvalu;
   if (xx < 7.75) {
      yy = xx * xx / 4.0;
      aa = (((((((((((((1.332898928162290861 * 10^-23) * yy +\
               (1.625212890947171108 * 10^-21)) * yy +\
               (3.410720494727771276 * 10^-19)) * yy +\
               (5.220157095351373194 * 10^-17)) * yy +\
               (6.904822652741917551 * 10^-15)) * yy +\
               (7.593969849687574339 * 10^-13)) * yy +\
               (6.834657311305621830 * 10^-11)) * yy +\
               (4.920949692800671435 * 10^-9)) * yy +\
               (2.755731926254790268 * 10^-7)) * yy +\
               (1.157407407354987232 * 10^-5)) * yy +\
               (3.472222222225921045 * 10^-4)) * yy +\
               (6.944444444444341983 * 10^-3)) * yy +\
               (8.333333333333333803 * 10^-2));
      retvalu = ((aa * yy + 0.5) * yy + 1.0) * xx / 2.0;
   } else if (xx < 500.0) {
      yy = 1.0 / xx;
      retvalu = ((((((((((((((((((((((-(2.213318202179221945 * 10^15)) *\
               yy + (3.146401654361325073 * 10^15)) * yy -\
               (2.067285045778906105 * 10^15)) * yy +\
               (8.325554073334618015 * 10^14)) * yy -\
               (2.298849639457172489 * 10^14)) * yy +\
               (4.614040809616582764 * 10^13)) * yy -\
               (6.967602516005787001 * 10^12)) * yy +\
               (8.087824484994859552 * 10^11)) * yy -\
               (7.313784438967834057 * 10^10)) * yy +\
               (5.192386898222206474 * 10^9)) * yy -\
               (2.903390398236656519 * 10^8)) * yy +\
               (1.277677779341446497 * 10^7)) * yy -\
               (4.404655582443487334 * 10^5)) * yy +\
               (1.178785865993440669 * 10^4)) * yy -\
               (2.426181371595021021 * 10^2)) * yy +\
               3.458284470977172076) * yy - (1.528189554374492735 *\
               10^-1)) * yy - (5.719036414430205390 * 10^-2)) * yy -\
               (4.090895951581637791 * 10^-2)) * yy -\
               (4.675104253598537322 * 10^-2)) * yy -\
               (1.496033551613111533 * 10^-1)) * yy +\
               (3.989422804014406054 * 10^-1)) * exp(xx) / sqrt(xx);
   } else {
      yy = 1.0 / xx;
      aa = exp(xx / 2.0);
      retvalu = (((((-(5.843630344778927582 * 10^-2)) * yy -\
               (4.090421597376992892 * 10^-2)) * yy -\
               (4.675105322571775911 * 10^-2)) * yy -\
               (1.496033551467584157 * 10^-1)) * yy +\
               (3.989422804014314820 * 10^-1)) * aa / sqrt(xx);
      retvalu *= aa;
   }
   return (retvalu);
}
define bessk0(arg) {
   auto retvalu,sumf,sumg,sump,sumq,xx,xz;
   xx = arg;
   if (xx <= 0.0) {
      retvalu = cxdblmax;
   } else if (xx < cxdbleps) {
      retvalu = 0.11593151565841244858684731328185 - log(xx);
   } else if (xx <= 1.0) {
      xz = xx * xx;
      sump = (((((5.8599221412826100000 * 10^-4) * xz +\
               (1.3166052564989571850 * 10^-1)) * xz +\
               (1.1999463724910714109 * 10^1)) * xz +\
               (4.6850901201934832188 * 10^2)) * xz +\
               (5.9169059852270512312 * 10^3)) * xz +\
               (2.4708152720399552679 * 10^3);
      sumq = ((1.0) * xz - (2.4994418972832303646 * 10^2)) * xz +\
               (2.1312714303849120380 * 10^4);
      sumf = (((-1.6414452837299064100) * xz - (2.9601657892958843866 *\
               10^2)) * xz - (1.7733784684952985886 * 10^4)) * xz -\
               (4.0320340761145482298 * 10^5);
      sumg = ((1.0 * xz - (2.5064972445877992730 * 10^2)) * xz +\
               (2.9865713163054025489 * 10^4)) * xz -\
               (1.6128136304458193998 * 10^6);
      retvalu = sump / sumq - log(xx) * (xz * sumf / sumg + 1.0);
   } else if (xx < cxdblmaxln) {
      xz = 1.0 / xx;
      sump = (((((((((1.1394980557384778174 * 10^2) * xz +\
               (3.6832589957340267940 * 10^3)) * xz +\
               (3.1075408980684392399 * 10^4)) * xz +\
               (1.0577068948034021957 * 10^5)) * xz +\
               (1.7398867902565686251 * 10^5)) * xz +\
               (1.5097646353289914539 * 10^5)) * xz +\
               (7.1557062783764037541 * 10^4)) * xz +\
               (1.8321525870183537725 * 10^4)) * xz +\
               (2.3444738764199315021 * 10^3)) * xz +\
               (1.1600249425076035558 * 10^2);
      sumq = ((((((((((1.0) * xz + (2.0013443064949242491 * 10^2)) * xz +\
               (4.4329628889746408858 * 10^3)) * xz +\
               (3.1474655750295278825 * 10^4)) * xz +\
               (9.7418829762268075784 * 10^4)) * xz +\
               (1.5144644673520157801 * 10^5)) * xz +\
               (1.2689839587977598727 * 10^5)) * xz +\
               (5.8824616785857027752 * 10^4)) * xz +\
               (1.4847228371802360957 * 10^4)) * xz +\
               (1.8821890840982713696 * 10^3)) * xz +\
               (9.2556599177304839811 * 10^1);
      retvalu = sump / sumq / sqrt(xx) * exp(-xx);
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define bessk1(arg) {
   auto retvalu,sumf,sumg,sump,sumq,xx,xz;
   xx = arg;
   if (xx < cxdbleps) {
      retvalu = cxdblmax;
   } else if (xx < cxdbleps) {
      retvalu = 1.0 / xx;
   } else if (xx <= 1.0) {
      xz = xx * xx;
      sump = (((((4.8127070456878442310 * 10^-1) * xz +\
               (9.9991373567429309922 * 10^1)) * xz +\
               (7.1885382604084798576 * 10^3)) * xz +\
               (1.7733324035147015630 * 10^5)) * xz +\
               (7.1938920065420586101 * 10^5)) * xz -\
               (2.2149374878243304548 * 10^6);
      sumq = (((1.0) * xz - (2.8143915754538725829 * 10^2)) * xz +\
               (3.7264298672067697862 * 10^4)) * xz -\
               (2.2149374878243304548 * 10^6);
      sumf = ((((-(2.2795590826955002390 * 10^-1)) * xz -\
               (5.3103913335180275253 * 10^1)) * xz -\
               (4.5051623763436087023 * 10^3)) * xz -\
               (1.4758069205414222471 * 10^5)) * xz -\
               (1.3531161492785421328 * 10^6);
      sumg = (((1.0) * xz - (3.0507151578787595807 * 10^2)) * xz +\
               (4.3117653211351080007 * 10^4)) * xz -\
               (2.7062322985570842656 * 10^6);
      retvalu = (xz * log(xx) * sumf / sumg + sump / sumq) / xx;
   } else if (xx < cxdblmaxln) {
      xz = 1.0 / xx;
      sump = ((((((((((6.4257745859173138767 * 10^-2) * xz +\
               7.5584584631176030810) * xz + (1.3182609918569941308 *\
               10^2)) * xz + (8.1094256146537402173 * 10^2)) * xz +\
               (2.3123742209168871550 * 10^3)) * xz +\
               (3.4540675585544584407 * 10^3)) * xz +\
               (2.8590657697910288226 * 10^3)) * xz +\
               (1.3319486433183221990 * 10^3)) * xz +\
               (3.4122953486801312910 * 10^2)) * xz +\
               (4.4137176114230414036 * 10^1)) * xz + 2.2196792496874548962;
      sumq = (((((((((1.0) * xz + (3.6001069306861518855 * 10^1)) * xz +\
               (3.3031020088765390854 * 10^2)) * xz +\
               (1.2082692316002348638 * 10^3)) * xz +\
               (2.1181000487171943810 * 10^3)) * xz +\
               (1.9448440788918006154 * 10^3)) * xz +\
               (9.6929165726802648634 * 10^2)) * xz +\
               (2.5951223655579051357 * 10^2)) * xz +\
               (3.4552228452758912848 * 10^1)) * xz + 1.7710478032601086579;
      retvalu = sump / sumq / sqrt(xx);
      retvalu = retvalu * exp(-xx);
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define bessjn_ps(nn,xx) {
   auto sum,sum_prev,term,ff,xxsqr_div_four,ann;
   if (nn < 0) {
      ann = -nn;
   } else {
      ann = nn;
   }
   term = pow(xx / 2.0,ann) / factorial(ann);
   xxsqr_div_four = -(xx * xx / 4.0);
   sum = term;
   ff = 1;
   for (;;) {
      term *= xxsqr_div_four / (ff * (ann + ff));
      sum_prev = sum;
      sum += term;
      if (iseq(sum,sum_prev)) {
         break; # loop AWAIT
      }
      ff += 1;
   }
   if (nn < 0 && isodd(nn)) {
      sum = -sum;
   }
   return (sum);
}
define bessin_ps(nn,xx) {
   auto sum,sum_prev,term,ff,xxsqr_div_four,ann;
   if (nn < 0) {
      ann = -nn;
   } else {
      ann = nn;
   }
   term = pow(xx / 2.0,ann) / factorial(ann);
   xxsqr_div_four = xx * xx / 4.0;
   sum = term;
   ff = 1;
   for (;;) {
      term *= xxsqr_div_four / (ff * (ann + ff));
      sum_prev = sum;
      sum += term;
      if (iseq(sum,sum_prev)) {
         break; # loop AWAIT
      }
      ff += 1;
   }
   return (sum);
}
define lf_besucjy0_xge5(xx,jfunc) {
   auto ww,pp,qq,zz,xn,denom,numer;
   ww = 5.0 / xx;
   zz = 25.0 / (xx * xx);
   numer = (((((((7.96936729297347051624 * 10^-4) * zz +\
            (8.28352392107440799803 * 10^-2)) * zz +\
            1.23953371646414299388) * zz + 5.44725003058768775090) * zz +\
            8.74716500199817011941) * zz + 5.30324038235394892183) * zz +\
            (9.99999999999999997821 * 10^-1));
   denom = (((((((9.24408810558863637013 * 10^-4) * zz +\
            (8.56288474354474431428 * 10^-2)) * zz +\
            1.25352743901058953537) * zz + 5.47097740330417105182) * zz +\
            8.76190883237069594232) * zz + 5.30605288235394617618) * zz +\
            1.00000000000000000218);
   pp = numer / denom;
   numer = ((((((((-(1.13663838898469149931 * 10^-2)) * zz -\
            1.28252718670509318512) * zz - (1.95539544257735972385 *\
            10^1)) * zz - (9.32060152123768231369 * 10^1)) * zz -\
            (1.77681167980488050595 * 10^2)) * zz -\
            (1.47077505154951170175 * 10^2)) * zz -\
            (5.14105326766599330220 * 10^1)) * zz - 6.05014350600728481186);
   denom = ((((((((1.0) * zz + (6.43178256118178023184 * 10^1)) * zz +\
            (8.56430025976980587198 * 10^2)) * zz +\
            (3.88240183605401609683 * 10^3)) * zz +\
            (7.24046774195652478189 * 10^3)) * zz +\
            (5.93072701187316984827 * 10^3)) * zz +\
            (2.06209331660327847417 * 10^3)) * zz +\
            (2.42005740240291393179 * 10^2));
   qq = numer / denom;
   xn = xx - cxpi / 4.0;
   if (jfunc < 1) {
      pp = pp * cos(xn) - ww * qq * sin(xn);
   } else {
      pp = pp * sin(xn) + ww * qq * cos(xn);
   }
   return (pp * cxtwosqrt / sqrt(cxpi * xx));
}
define lf_besucjy1_xge5(xx,jfunc) {
   auto ww,pp,qq,zz,xn,denom,numer;
   ww = 5.0 / xx;
   zz = 25.0 / (xx * xx);
   numer = (((((((7.62125616208173112003 * 10^-4) * zz +\
            (7.31397056940917570436 * 10^-2)) * zz +\
            1.12719608129684925192) * zz + 5.11207951146807644818) * zz +\
            8.42404590141772420927) * zz + 5.21451598682361504063) * zz +\
            1.00000000000000000254);
   denom = (((((((5.71323128072548699714 * 10^-4) * zz +\
            (6.88455908754495404082 * 10^-2)) * zz +\
            1.10514232634061696926) * zz + 5.07386386128601488557) * zz +\
            8.39985554327604159757) * zz + 5.20982848682361821619) * zz +\
            (9.99999999999999997461 * 10^-1));
   pp = numer / denom;
   numer = ((((((((5.10862594750176621635 * 10^-2) * zz +\
            4.98213872951233449420) * zz + (7.58238284132545283818 *\
            10^1)) * zz + (3.66779609360150777800 * 10^2)) * zz +\
            (7.10856304998926107277 * 10^2)) * zz +\
            (5.97489612400613639965 * 10^2)) * zz +\
            (2.11688757100572135698 * 10^2)) * zz +\
            (2.52070205858023719784 * 10^1));
   denom = ((((((((1.0) * zz + (7.42373277035675149943 * 10^1)) * zz +\
            (1.05644886038262816351 * 10^3)) * zz +\
            (4.98641058337653607651 * 10^3)) * zz +\
            (9.56231892404756170795 * 10^3)) * zz +\
            (7.99704160447350683650 * 10^3)) * zz +\
            (2.82619278517639096600 * 10^3)) * zz +\
            (3.36093607810698293419 * 10^2));
   qq = numer / denom;
   xn = xx - 3.0 * cxpi / 4.0;
   if (jfunc < 1) {
      pp = pp * cos(xn) - ww * qq * sin(xn);
   } else {
      pp = pp * sin(xn) + ww * qq * cos(xn);
   }
   return (pp * cxtwosqrt / sqrt(cxpi * xx));
}
define bessj0(xx) {
   auto zz,denom,numer,retvalu;
   if (xx < 0.0) {
      xx = -xx;
   }
   zz = xx * xx;
   if (xx < (1.0 * 10^-5)) {
      retvalu = 1.0 - zz / 4.0;
   } else if (xx < 5.0) {
      numer = ((((-(4.79443220978201773821 * 10^9)) * zz +\
               (1.95617491946556577543 * 10^12)) * zz -\
               (2.49248344360967716204 * 10^14)) * zz +\
               (9.70862251047306323952 * 10^15));
      denom = (((((((((1.0) * zz + (4.99563147152651017219 * 10^2)) * zz\
               + (1.73785401676374683123 * 10^5)) * zz +\
               (4.84409658339962045305 * 10^7)) * zz +\
               (1.11855537045356834862 * 10^10)) * zz +\
               (2.11277520115489217587 * 10^12)) * zz +\
               (3.10518229857422583814 * 10^14)) * zz +\
               (3.18121955943204943306 * 10^16)) * zz +\
               (1.71086294081043136091 * 10^18));
      retvalu = (zz - 5.783185962946784521175) * (zz -\
               30.4712623436620863991) * numer / denom;
   } else {
      retvalu = lf_besucjy0_xge5(xx,0);
   }
   return (retvalu);
}
define bessj1(xx) {
   auto ww,zz,denom,numer,retvalu;
   ww = xx;
   if (ww < 0.0) {
      ww = -ww;
   }
   if (ww < 5.0) {
      zz = ww * ww;
      numer = ((((-(8.99971225705559398224 * 10^8)) * zz +\
               (4.52228297998194034323 * 10^11)) * zz -\
               (7.27494245221818276015 * 10^13)) * zz +\
               (3.68295732863852883286 * 10^15));
      denom = (((((((((1.0) * zz + (6.20836478118054335476 * 10^2)) * zz\
               + (2.56987256757748830383 * 10^5)) * zz +\
               (8.35146791431949253037 * 10^7)) * zz +\
               (2.21511595479792499675 * 10^10)) * zz +\
               (4.74914122079991414898 * 10^12)) * zz +\
               (7.84369607876235854894 * 10^14)) * zz +\
               (8.95222336184627338078 * 10^16)) * zz +\
               (5.32278620332680085395 * 10^18));
      retvalu = numer / denom * xx * (zz - 14.6819706421238932572) * (zz\
               - 49.2184563216946036703);
   } else {
      retvalu = lf_besucjy1_xge5(xx,0);
   }
   return (retvalu);
}
define bessy0(xx) {
   auto zz,denom,numer,retvalu;
   if (xx <= 0.0) {
      retvalu = cxdblmax;
   } else {
      zz = xx * xx;
      if (xx < (1.0 * 10^-5)) {
         retvalu = 1.0 - zz / 4.0;
      } else if (xx < 5.0) {
         numer = ((((((((1.55924367855235737965 * 10^4) * zz -\
                  (1.46639295903971606143 * 10^7)) * zz +\
                  (5.43526477051876500413 * 10^9)) * zz -\
                  (9.82136065717911466409 * 10^11)) * zz +\
                  (8.75906394395366999549 * 10^13)) * zz -\
                  (3.46628303384729719441 * 10^15)) * zz +\
                  (4.42733268572569800351 * 10^16)) * zz -\
                  (1.84950800436986690637 * 10^16));
         denom = ((((((((1.0) * zz + (1.04128353664259848412 * 10^3)) *\
                  zz + (6.26107330137134956842 * 10^5)) * zz +\
                  (2.68919633393814121987 * 10^8)) * zz +\
                  (8.64002487103935000337 * 10^10)) * zz +\
                  (2.02979612750105546709 * 10^13)) * zz +\
                  (3.17157752842975028269 * 10^15)) * zz +\
                  (2.50596256172653059228 * 10^17));
         retvalu = numer / denom + 2.0 * log(xx) * bessj0(xx) / cxpi;
      } else {
         retvalu = lf_besucjy0_xge5(xx,1);
      }
   }
   return (retvalu);
}
define bessy1(xx) {
   auto ww,zz,denom,numer,retvalu;
   ww = xx;
   if (xx <= 0.0) {
      retvalu = -cxdblmax;
   } else if (ww <= 5.0) {
      zz = ww * ww;
      numer = ((((((1.2632047479017802640 * 10^9) * zz -\
               (6.47355876379160291031 * 10^11)) * zz +\
               (1.14509511541823727583 * 10^14)) * zz -\
               (8.12770255501325109621 * 10^15)) * zz +\
               (2.02439475713594898196 * 10^17)) * zz -\
               (7.78877196265950026825 * 10^17));
      denom = (((((((((1.0) * zz + (5.94301592346128195359 * 10^2)) * zz\
               + (2.35564092943068577943 * 10^5)) * zz +\
               (7.34811944459721705660 * 10^7)) * zz +\
               (1.87601316108706159478 * 10^10)) * zz +\
               (3.88231277496238566008 * 10^12)) * zz +\
               (6.20557727146953693363 * 10^14)) * zz +\
               (6.87141087355300489866 * 10^16)) * zz +\
               (3.97270608116560655612 * 10^18));
      retvalu = xx * numer / denom + 2.0 * (bessj1(xx) * log(xx) - 1.0 /\
               xx) / cxpi;
   } else {
      retvalu = lf_besucjy1_xge5(xx,1);
   }
   return (retvalu);
}
define lf_bess_ucrecur(nn,xx,fzero,fone) {
   auto av,bv,cv,tox,ii;
   if (nn <= 0) {
      cv = fzero;
   } else if (nn == 1) {
      cv = fone;
   } else {
      tox = 2.0 / xx;
      av = fzero;
      bv = fone;
      for (ii = 1; ii <= nn - 1; ii += 1) {
         cv = tox * ii * bv - av;
         av = bv;
         bv = cv;
      }
   }
   return (cv);
}
define lf_limi(nn) {
   return (nn + floor(sqrt(40.0 * nn)));
}
define lf_bess_ucrecur2(nn,xx) {
   auto tox,bzp,bzc,bzm,sjm,jj,flipflop,limi,retvalu;
   flipflop = 0;
   sjm = 0.0;
   tox = 2.0 / abs(xx);
   retvalu = 0.0;
   bzp = 0.0;
   bzc = 1.0;
   limi = lf_limi(nn);
   if (isodd(limi)) {
      limi -= 1;
   }
   for (jj = limi; 1 <= jj; jj -= 1) {
      bzm = jj * tox * bzc - bzp;
      bzp = bzc;
      bzc = bzm;
      if (flipflop == 0) {
         flipflop = 1;
      } else {
         sjm += bzc;
         flipflop = 0;
      }
      if (jj == nn) {
         retvalu = bzp;
      }
   }
   sjm = 2.0 * sjm - bzc;
   retvalu /= sjm;
   return (retvalu);
}
define bessin(nn,xx) {
   auto jj,limi,bzc,bzm,bzp,tox,retvalu,axx;
   if (nn < 0 || iszero(xx)) {
      retvalu = 0.0;
   } else if (nn == 0) {
      axx = abs(xx);
      retvalu = bessi0(axx);
   } else if (nn == 1) {
      axx = abs(xx);
      retvalu = bessi1(axx);
   } else {
      tox = 2.0 / abs(xx);
      retvalu = 0.0;
      bzp = 0.0;
      bzc = 1.0;
      limi = 2 * lf_limi(nn);
      for (jj = limi; 1 <= jj; jj -= 1) {
         bzm = bzp + jj * tox * bzc;
         bzp = bzc;
         bzc = bzm;
         if (jj == nn) {
            retvalu = bzp;
         }
      }
      retvalu *= bessi0(xx) / bzc;
   }
   if (xx < 0.0 && isodd(nn)) {
      retvalu = -retvalu;
   }
   return (retvalu);
}
define bessjn(nn,xx) {
   auto retvalu;
   if (nn == 0) {
      retvalu = bessj0(xx);
   } else if (nn == 1) {
      retvalu = bessj1(xx);
   } else if (nn < abs(xx)) {
      retvalu = lf_bess_ucrecur(nn,xx,bessj0(xx),bessj1(xx));
   } else {
      retvalu = lf_bess_ucrecur2(nn,xx);
   }
   return (retvalu);
}
define bessyn(nn,xx) {
   auto retvalu;
   if (nn == 0) {
      retvalu = bessy0(xx);
   } else if (nn == 1) {
      retvalu = bessy1(xx);
   } else {
      retvalu = lf_bess_ucrecur(nn,xx,bessy0(xx),bessy1(xx));
   }
   return (retvalu);
}
define besskn(nn,xx) {
   auto retvalu;
   if (nn < 0 || iszero(xx)) {
      retvalu = 0.0;
   } else if (nn == 0) {
      retvalu = bessk0(xx);
   } else if (nn == 1) {
      retvalu = bessk1(xx);
   } else {
      retvalu = lf_bess_ucrecur(nn,xx,bessk0(xx),bessk1(xx));
   }
   return (retvalu);
}
define bessyn_ps(nn,xx) {
   auto retvalu,sum,sum_prev,term,hn,kk,xxsqr_div_four;
   if (nn < 0 || iszero(xx)) {
      retvalu = 0.0;
   } else if (nn == 0) {
      xxsqr_div_four = xx * xx / 4.0;
      sum = (log(xx / 2.0) + cxeuler) * bessjn(0,xx);
      term = -1;
      hn = 0.0;
      kk = 1;
      for (;;) {
         hn += 1.0 / kk;
         term *= - xxsqr_div_four / (kk * kk);
         sum_prev = sum;
         sum += term * hn;
         if (iseq(sum,sum_prev)) {
            break; # loop AWAIT
         }
         kk += 1;
      }
      retvalu = 2.0 * sum / cxpi;
   } else if (nn == 1) {
      retvalu = bessy1(xx);
   } else {
      retvalu = lf_bess_ucrecur(nn,xx,bessy0(xx),bessy1(xx));
   }
   return (retvalu);
}
define bessy1__1(xx) {
   auto numer,denom,zz,ww,yy,retvalu;
   if (iszero(xx)) {
      retvalu = -cxdblmax;
   } else if (xx < 8.0) {
      yy = xx * xx;
      numer = ((((((8.511937935 * 10^3) * yy - (4.237922726 * 10^6)) * yy\
               + (7.349264551 * 10^8)) * yy - (5.153438139 * 10^10)) * yy\
               + (1.275274390 * 10^12)) * yy - (4.900604943 * 10^12));
      denom = (((((((1.0) * yy + (3.549632885 * 10^2)) * yy +\
               (1.020426050 * 10^5)) * yy + (2.245904002 * 10^7)) * yy +\
               (3.733650367 * 10^9)) * yy + (4.244419664 * 10^11)) * yy +\
               (2.499580570 * 10^13));
      retvalu = 2.0 * (bessjn(1,xx) * log(xx) - 1.0 / xx) / cxpi + xx *\
               (numer / denom);
   } else {
      zz = 8.0 / xx;
      yy = zz * zz;
      numer = (((((-(2.403370190 * 10^-7)) * yy + (2.457520174 * 10^-6))\
               * yy - (3.516396496 * 10^-5)) * yy + (1.831050000 *\
               10^-3)) * yy + 1.0);
      denom = (((((1.057874120 * 10^-7) * yy - (8.822898700 * 10^-7)) *\
               yy + (8.449199096 * 10^-6)) * yy - (2.002690873 * 10^-4))\
               * yy + (4.687499995 * 10^-2));
      ww = xx - 0.75 * cxpi;
      retvalu = cxtwosqrt / sqrt(cxpi * xx) * (sin(ww) * numer + zz *\
               cos(ww) * denom);
   }
   return (retvalu);
}
define lf_bess_lcrecur(nn,xx,fzero,fone) {
   auto av,bv,cv,ii;
   if (nn <= 0) {
      cv = fzero;
   } else if (nn == 1) {
      cv = fone;
   } else {
      av = fzero;
      bv = fone;
      for (ii = 1; ii <= nn - 1; ii += 1) {
         cv = (2.0 * ii + 1.0) * bv / xx - av;
         av = bv;
         bv = cv;
      }
   }
   return (cv);
}
define bess_jn(nn,xx) {
   auto retvalu,jk_a,jk_b;
   if (iszero(xx)) {
      if (nn == 0) {
         retvalu = 1.0;
      } else {
         retvalu = 0.0;
      }
   } else {
      jk_a = sin(xx) / xx;
      jk_b = (sin(xx) - xx * cos(xx)) / (xx * xx);
      if (nn <= 0) {
         retvalu = jk_a;
      } else if (nn <= 1) {
         retvalu = jk_b;
      } else {
         retvalu = lf_bess_lcrecur(nn,xx,jk_a,jk_b);
      }
   }
   return (retvalu);
}
define bess_yn(nn,xx) {
   auto retvalu,yk_a,yk_b;
   if (iszero(xx)) {
      if (nn == 0) {
         retvalu = 1.0;
      } else {
         retvalu = 0.0;
      }
   } else {
      yk_a = -cos(xx) / xx;
      yk_b = (-cos(xx) - xx * sin(xx)) / (xx * xx);
      if (nn <= 0) {
         retvalu = yk_a;
      } else if (nn <= 1) {
         retvalu = yk_b;
      } else {
         retvalu = lf_bess_lcrecur(nn,xx,yk_a,yk_b);
      }
   }
   return (retvalu);
}
lv_partitionr_arr[0] = 0;
lv_partitionr_end = 0;
define partition(nn) {
   # local-use Bc lv_partitionr_arr[];
   # local-use Bc lv_partitionr_end;
   auto retvalu,jj,ii,kk,sum,ssign;
   if (nn < 0) {
      retvalu = 0.0;
   } else {
      if (lv_partitionr_end <= 0) {
         lv_partitionr_end = 6;
         lv_partitionr_arr[0] = 1.0;
         lv_partitionr_arr[1] = 1.0;
         lv_partitionr_arr[2] = 2.0;
         lv_partitionr_arr[3] = 3.0;
         lv_partitionr_arr[4] = 5.0;
         lv_partitionr_arr[5] = 7.0;
      }
      if (lv_partitionr_end <= nn) {
         ii = lv_partitionr_end;
         lv_partitionr_end = nn + 1;
         while (ii < lv_partitionr_end) {
            sum = 0.0;
            ssign = 1.0;
            kk = 1;
            jj = ii - 1;
            while (0 <= jj) {
               sum += ssign * lv_partitionr_arr[jj];
               jj -= kk;
               if (jj < 0) {
                  break;
               }
               sum += ssign * lv_partitionr_arr[jj];
               ssign = -ssign;
               kk += 1;
               jj -= (2 * kk - 1);
            }
            lv_partitionr_arr[ii] = sum;
            ii += 1;
         }
      }
      retvalu = lv_partitionr_arr[nn];
   }
   return (retvalu);
}
lv_partitionq_arr[0] = 0;
lv_partitionq_end = 0;
define partitionq(nn) {
   # local-use Bc lv_partitionq_arr[];
   # local-use Bc lv_partitionq_end;
   auto retvalu,jj,ii,kk,sum,ssign,ee;
   if (nn < 0) {
      retvalu = 0.0;
   } else {
      if (lv_partitionq_end <= 0) {
         lv_partitionq_end = 6;
         lv_partitionq_arr[0] = 1.0;
         lv_partitionq_arr[1] = 1.0;
         lv_partitionq_arr[2] = 1.0;
         lv_partitionq_arr[3] = 2.0;
         lv_partitionq_arr[4] = 2.0;
         lv_partitionq_arr[5] = 3.0;
      }
      if (lv_partitionq_end <= nn) {
         ii = lv_partitionq_end;
         lv_partitionq_end = nn + 1;
         while (ii < lv_partitionq_end) {
            sum = 0.0;
            ssign = 1.0;
            kk = 1;
            jj = ii - 1;
            while (0 <= jj) {
               sum += ssign * lv_partitionq_arr[jj];
               jj -= kk;
               if (jj < 0) {
                  break;
               }
               sum += ssign * lv_partitionq_arr[jj];
               ssign = -ssign;
               kk += 1;
               jj -= (2 * kk - 1);
            }
            ee = round(sqrt(1.0 + 12.0 * ii) / 6.0);
            if (ii == (3 * ee * ee - ee) || ii == (3 * ee * ee + ee)) {
               if (isodd(ee)) {
                  sum -= 1.0;
               } else {
                  sum += 1.0;
               }
            }
            lv_partitionq_arr[ii] = sum;
            ii += 1;
         }
      }
      retvalu = lv_partitionq_arr[nn];
   }
   return (retvalu);
}
define bitwisenot(xx) {
   auto retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   retvalu = -1 - xx;
   scale = local_prev_scale;
   return (retvalu);
}
define bitwiseand(xx,yy) {
   auto retvalu,nn,tt,aa,bb,qxx,qyy,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   nn = 0;
   xx /= 1;
   yy /= 1;
   if (xx < 0) {
      xx = -1 - xx;
      nn = 1;
   }
   if (yy < 0) {
      tt = -1 - yy;
      yy = xx;
      xx = tt;
      nn = 1;
   }
   retvalu = 0;
   tt = 1;
   while (0 < xx || 0 < yy) {
      qxx = xx / 4;
      qyy = yy / 4;
      aa = xx - 4 * qxx;
      if (0 < nn) {
         aa = 3 - aa;
      }
      bb = yy - 4 * qyy;
      if (aa != bb) {
         aa += bb - 3;
         if (aa < 0) {
            aa = 0;
         }
      }
      retvalu += tt * aa;
      tt *= 4;
      xx = qxx;
      yy = qyy;
   }
   scale = local_prev_scale;
   return (retvalu);
}
define bitwiseor(xx,yy) {
   auto retvalu,tt,aa,bb,cc,qxx,qyy,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   xx /= 1;
   yy /= 1;
   retvalu = 0;
   tt = 1;
   while (0 < xx || 0 < yy) {
      qxx = xx / 4;
      qyy = yy / 4;
      aa = xx - 4 * qxx;
      bb = yy - 4 * qyy;
      if (aa != bb) {
         aa += bb;
         if (3 < aa) {
            aa = 3;
         }
      }
      retvalu += tt * aa;
      tt *= 4;
      xx = qxx;
      yy = qyy;
   }
   scale = local_prev_scale;
   return (retvalu);
}
define bitwisexor(xx,yy) {
   auto retvalu,nn,tt,aa,bb,cc,qxx,qyy,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   nn = 0;
   xx /= 1;
   yy /= 1;
   if (xx < 0) {
      xx = -1 - xx;
      nn = 1 - nn;
   }
   if (yy < 0) {
      yy = -1 - yy;
      nn = 1 - nn;
   }
   retvalu = 0;
   tt = 1;
   while (0 < xx || 0 < yy) {
      qxx = xx / 4;
      qyy = yy / 4;
      aa = xx - 4 * qxx;
      bb = yy - 4 * qyy;
      cc = aa + bb;
      if (iseven(cc)) {
         cc = aa + 4 - bb;
      }
      retvalu += tt * (cc % 4);
      tt *= 4;
      xx = qxx;
      yy = qyy;
   }
   if (0 < nn) {
      retvalu = -1 - retvalu;
   }
   scale = local_prev_scale;
   return (retvalu);
}
define bitshiftl(hexnumber,shift_count) {
   auto retvalu;
   if (shift_count < 0) {
      retvalu = lf_shiftr(hexnumber,- shift_count);
   } else if (0 < shift_count) {
      retvalu = lf_shiftl(hexnumber,shift_count);
   } else {
      retvalu = hexnumber;
   }
   return (retvalu);
}
define bitshiftr(hexnumber,shift_count) {
   auto retvalu;
   if (shift_count < 0) {
      retvalu = lf_shiftl(hexnumber,- shift_count);
   } else if (0 < shift_count) {
      retvalu = lf_shiftr(hexnumber,shift_count);
   } else {
      retvalu = hexnumber;
   }
   return (retvalu);
}
define bits_count(hexnumber) {
   auto bit_counter,bitmask;
   bitmask = 1;
   bit_counter = 0;
   while (bitmask <= hexnumber) {
      if (bitwiseand(bitmask,hexnumber) != 0) {
         bit_counter += 1;
      }
      bitmask = lf_shiftl(bitmask,1);
   }
   return (bit_counter);
}
define bits_ls1b(orig) {
   auto divisor,retvalu;
   if (orig == 0) {
      retvalu = 0;
   } else {
      divisor = 1;
      while (0 == bitwiseand(divisor,orig)) {
         divisor *= 2;
      }
      retvalu = divisor;
   }
   return (retvalu);
}
define bits_ms1b(orig) {
   auto divisor,retvalu;
   if (orig == 0) {
      retvalu = 0;
   } else {
      divisor = -2;
      while (bitwiseand(divisor,orig) != 0) {
         divisor *= 2;
      }
      retvalu = -divisor / 2;
   }
   return (retvalu);
}
define bits_ls1bpos(orig) {
   auto divisor,retvalu,bit_count;
   if (orig == 0) {
      retvalu = -1;
   } else {
      divisor = 1;
      bit_count = 0;
      while (0 == bitwiseand(divisor,orig)) {
         divisor *= 2;
         bit_count += 1;
      }
      retvalu = bit_count;
   }
   return (retvalu);
}
define bits_ms1bpos(orig) {
   auto divisor,retvalu,bit_count;
   if (orig == 0) {
      retvalu = 0;
   } else {
      divisor = -2;
      bit_count = 0;
      while (bitwiseand(divisor,orig) != 0) {
         divisor *= 2;
         bit_count += 1;
      }
      retvalu = bit_count;
   }
   return (retvalu);
}
define bits_assign(orig,value_to_set,which_mask) {
   auto divisor,retvalu,tempo,tempv;
   if (which_mask == 0) {
      retvalu = orig;
   } else {
      divisor = bits_ls1bpos(which_mask);
      tempo = bitwiseand(orig,bitwisenot(which_mask));
      tempv = lf_shiftl(value_to_set,divisor);
      retvalu = bitwiseor(tempo,bitwiseand(tempv,which_mask));
   }
   return (retvalu);
}
define bits_get(vall,mask) {
   return (bitwiseand(vall,mask) / bits_ls1b(mask));
}
define bits_set(vall,mask) {
   return (bitwiseand(vall * bits_ls1b(mask),mask));
}
define lf_calerf(xx,jint) {
   auto result,retvalu,absx,numer,denom,rsqrpi,rxsq,xsq,flag;
   absx = abs(xx);
   xsq = xx * xx;
   flag = 0;
   if (absx <= 0.46875) {
      numer = (((((1.85777706184603153 * 10^-1) * xsq +\
               3.16112374387056560) * xsq + (1.13864154151050156 * 10^2))\
               * xsq + (3.77485237685302021 * 10^2)) * xsq +\
               (3.20937758913846947 * 10^3));
      denom = (((((1.00000000000000000) * xsq + (2.36012909523441209 *\
               10^1)) * xsq + (2.44024637934444173 * 10^2)) * xsq +\
               (1.28261652607737228 * 10^3)) * xsq + (2.84423683343917062\
               * 10^3));
      retvalu = xx * numer / denom;
      if (jint == 1) {
         retvalu = 1.0 - retvalu;
      } else if (jint == 2) {
         retvalu = exp(xsq) * (1.0 - retvalu);
      }
      flag = 1;
   } else if (absx <= 4.0) {
      numer = (((((((((2.15311535474403846 * 10^-8) * absx +\
               (5.64188496988670089 * 10^-1)) * absx +\
               8.88314979438837594) * absx + (6.61191906371416295 *\
               10^1)) * absx + (2.98635138197400131 * 10^2)) * absx +\
               (8.81952221241769090 * 10^2)) * absx +\
               (1.71204761263407058 * 10^3)) * absx +\
               (2.05107837782607147 * 10^3)) * absx +\
               (1.23033935479799725 * 10^3));
      denom = (((((((((1.00000000000000000) * absx + (1.57449261107098347\
               * 10^1)) * absx + (1.17693950891312499 * 10^2)) * absx +\
               (5.37181101862009858 * 10^2)) * absx +\
               (1.62138957456669019 * 10^3)) * absx +\
               (3.29079923573345963 * 10^3)) * absx +\
               (4.36261909014324716 * 10^3)) * absx +\
               (3.43936767414372164 * 10^3)) * absx +\
               (1.23033935480374942 * 10^3));
      result = numer / denom;
   } else {
      rsqrpi = sqrt(1.0 / cxpi);
      if (jint != 2 && sqrt(log(cxdblmax)) <= absx) {
         result = 0.0;
      } else if (jint == 2 && (6.71 * 10^7) <= absx) {
         if (cxdblmax / 8.0 <= absx) {
            result = 0.0;
         } else {
            result = rsqrpi / absx;
         }
      } else {
         rxsq = 1.0 / (absx * absx);
         numer = ((((((-(1.63153871373020978 * 10^2)) * rxsq -\
                  (3.05326634961232344 * 10^3)) * rxsq -\
                  (3.60344899949804439 * 10^3)) * rxsq -\
                  (1.25781726111229246 * 10^3)) * rxsq -\
                  (1.60837851487422766 * 10^2)) * rxsq -\
                  6.58749161529837803);
         denom = ((((((1.00000000000000000 * 10^4) * rxsq +\
                  (2.56852019228982242 * 10^4)) * rxsq +\
                  (1.87295284992346047 * 10^4)) * rxsq +\
                  (5.27905102951428412 * 10^3)) * rxsq +\
                  (6.05183413124413191 * 10^2)) * rxsq +\
                  (2.33520497626869185 * 10^1));
         result = (rsqrpi + rxsq * numer / denom) / absx;
      }
   }
   if (flag == 0) {
      if (jint == 2) {
         if (xx < - sqrt(log(cxdblmax))) {
            retvalu = cxdblmax;
         } else if (xx < 0.0) {
            retvalu = 2.0 * exp(xsq) - result;
         } else {
            retvalu = result;
         }
      } else {
         result *= exp(-xsq);
         if (jint == 0) {
            if (0.0 <= xx) {
               retvalu = (0.5 - result) + 0.5;
            } else {
               retvalu = -((0.5 - result) + 0.5);
            }
         } else if (jint == 1) {
            if (xx < 0.0) {
               retvalu = 2.0 - result;
            } else {
               retvalu = result;
            }
         } else {
            retvalu = 0.0;
         }
      }
   }
   return (retvalu);
}
define erf(xx) {
   return (lf_calerf(xx,0));
}
define erfc(xx) {
   return (lf_calerf(xx,1));
}
define erfcx(xx) {
   return (lf_calerf(xx,2));
}
define erfcinv(yy_orig) {
   auto retvalu,xx,yy,xx_pr,dx,cc,uu,ii;
   if (yy_orig <= 0.0) {
      retvalu = cxdblmax / 2.0;
   } else if (2.0 <= yy_orig) {
      retvalu = -(cxdblmax / 2.0);
   } else if (iszero(yy_orig - 1.0)) {
      retvalu = 0.0;
   } else {
      if (1.0 < yy_orig) {
         yy = 2.0 - yy_orig;
      } else {
         yy = yy_orig;
      }
      dx = 1.0;
      xx = 0.0;
      cc = -sqrt(cxtau / 8.0);
      ii = 0;
      for (;;) {
         uu = cc * (erfcx(xx) - yy * exp(xx * xx));
         dx = -uu / (1.0 + uu * xx);
         xx_pr = xx;
         xx += dx;
         if (iseq(xx_pr,xx)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      if (1.0 < yy_orig) {
         retvalu = -xx;
      } else {
         retvalu = xx;
      }
   }
   return (retvalu);
}
define erfcxinv(yy) {
   auto xx,xx_pr,dx,cc,ex,df,uu,ii;
   xx = 0.0;
   if (! iszero(yy - 1.0)) {
      dx = 1.0;
      cc = sqrt(8.0 / cxtau);
      ii = 0;
      for (;;) {
         ex = erfcx(xx);
         df = 2.0 * xx * ex - cc;
         uu = (ex - yy) / df;
         dx = -uu / (1.0 - uu * (xx + ex / df));
         xx_pr = xx;
         xx += dx;
         if (iseq(xx_pr,xx)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
   }
   return (xx);
}
define erfinv(yy) {
   auto retvalu,xx,xx_pr,dx,cc,uu,ii;
   if (iszero(yy)) {
      retvalu = 0.0;
   } else if (0.5 < yy) {
      retvalu = erfcinv(1.0 - yy);
   } else if (yy < - 0.5) {
      retvalu = -erfcinv(1.0 + yy);
   } else {
      dx = 1.0;
      xx = 0.0;
      cc = sqrt(cxtau / 8.0);
      ii = 0;
      for (;;) {
         uu = cc * (erf(xx) - yy) * exp(xx * xx);
         dx = -uu / (1.0 + uu * xx);
         xx_pr = xx;
         xx += dx;
         if (iseq(xx_pr,xx)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xx;
   }
   return (retvalu);
}
define erf__1(xx) {
   auto tt,ans,ply;
   tt = (1.0 / (1.0 + (0.5 * abs(xx))));
   ply = ((((((((((1.70872770 * 10^-1) * tt - (8.22152230 * 10^-1)) * tt\
            + 1.48851587) * tt - 1.13520398) * tt + (2.78868070 * 10^-1))\
            * tt - (1.86288060 * 10^-1)) * tt + (9.67841800 * 10^-2)) *\
            tt + (3.74091960 * 10^-1)) * tt + 1.00002368) * tt - 1.26551223);
   ans = 1.0 - tt * exp((-xx * xx) + ply);
   if (xx < 0.0) {
      ans = -ans;
   }
   return (ans);
}
define erf__2(xx) {
   auto tt,ans,ply;
   tt = 1.0 / (1.0 + 0.3275911 * abs(xx));
   ply = ((((((1.061405429) * tt - 1.453152027) * tt + 1.421413741) * tt\
            - (2.844967360 * 10^-1)) * tt + (2.548295920 * 10^-1)) * tt +\
            0.000000000);
   ans = 1.0 - exp(-xx * xx) * ply;
   if (xx < 0.0) {
      ans = -ans;
   }
   return (ans);
}
define erf__3(xx) {
   auto axx,xxsq,sum_curr,factx,nn,add_arr[],kk;
   axx = abs(xx);
   xxsq = xx * xx;
   if (axx < 4.4) {
      factx = 1.0;
      add_arr[0] = 1;
      nn = 1;
      for (;;) {
         factx *= - xxsq / nn;
         add_arr[nn] = factx / (2.0 * nn + 1.0);
         if (abs(add_arr[nn]) < cxdbleps) {
            break; # loop AWAIT
         }
         nn += 1;
         if (79 <= nn) {
            break; # loop AWAIT
         }
      }
      sum_curr = 0.0;
      for (kk = nn; 0 <= kk; kk -= 1) {
         sum_curr += add_arr[kk];
      }
      sum_curr *= (2.0 * xx / sqrt(cxpi));
   } else {
      factx = -exp(-xxsq) / sqrt(cxpi);
      sum_curr = 0.0;
      kk = round(xxsq);
      for (nn = 1; nn <= kk - 1; nn += 1) {
         factx *= -(2.0 * nn - 1.0) / (2.0 * xxsq);
         sum_curr += factx;
      }
      sum_curr += 1.0 - exp(-xxsq) / sqrt(cxpi) / axx;
      if (xx < 0.0) {
         sum_curr = -sum_curr;
      }
   }
   return (sum_curr);
}
define erf__4(xx) {
   auto xxsq,axx,sum_prev,sum_curr,nn,kk,twonnpone,factx,factz,\
            twoxxsq,term,denom;
   axx = abs(xx);
   xxsq = xx * xx;
   twoxxsq = 2.0 * xxsq;
   sum_curr = 0.0;
   if (axx < 4.4) {
      factz = (2.0 * xx / sqrt(cxpi));
      factx = factz;
      nn = 3;
      for (;;) {
         twonnpone = 2 * nn + 1;
         factx *= xxsq * xxsq / ((nn - 1.0) * nn);
         denom = 4.0 * nn * nn - 1.0;
         term = factx * (twonnpone * (nn - xxsq) + twoxxsq) / denom;
         sum_prev = sum_curr;
         sum_curr += term;
         if (iseq(sum_prev,sum_curr)) {
            break; # loop AWAIT
         }
         nn += 2;
      }
      sum_curr += (1.0 - xxsq / 3.0) * factz;
   } else {
      factx = -exp(-xxsq) / (xx * sqrt(cxpi));
      kk = round(xxsq);
      for (nn = 1; nn <= kk - 5; nn += 2) {
         factx *= nn * (nn + 1.0) / (twoxxsq * twoxxsq);
         term = factx * (1.0 - (2.0 * nn + 1.0) / twoxxsq);
         sum_prev = sum_curr;
         sum_curr += term;
         if (iseq(sum_prev,sum_curr)) {
            break;
         }
      }
      sum_curr += 1.0 - exp(-xxsq) / sqrt(cxpi) / axx;
      if (xx < 0.0) {
         sum_curr = -sum_curr;
      }
   }
   return (sum_curr);
}
define lgamma__1(xx) {
   auto aa_arr[],sum,ii,tt,retvalu,qq;
   if (xx <= 0.0 && isint(xx)) {
      retvalu = log(cxdblmax);
   } else {
      if (xx < 0.0) {
         qq = 1.0 - xx;
      } else {
         qq = xx;
      }
      aa_arr[0] = (5.7156235665862923517 * 10^1);
      aa_arr[1] = -(5.9597960355475491248 * 10^1);
      aa_arr[2] = (1.4136097974741747174 * 10^1);
      aa_arr[3] = -(4.9191381609762019978 * 10^-1);
      aa_arr[4] = (3.3994649984811888699 * 10^-5);
      aa_arr[5] = (4.6523628927048575665 * 10^-5);
      aa_arr[6] = -(9.8374475304879564677 * 10^-5);
      aa_arr[7] = (1.5808870322491248884 * 10^-4);
      aa_arr[8] = -(2.1026444172410488319 * 10^-4);
      aa_arr[9] = (2.1743961811521264320 * 10^-4);
      aa_arr[10] = -(1.6431810653676389022 * 10^-4);
      aa_arr[11] = (8.4418223983852743293 * 10^-5);
      aa_arr[12] = -(2.6190838401581408670 * 10^-5);
      aa_arr[13] = (3.6899182659531622704 * 10^-6);
      sum = 0.99999999999999709182;
      for (ii = 0; ii <= 13; ii += 1) {
         sum += aa_arr[ii] / (qq + ii);
      }
      tt = qq + 607.0 / 128.0 - 0.5;
      qq = log(cxtau) / 2.0 + (qq - 0.5) * log(tt) + log(sum) - tt;
      if (xx < 0.0) {
         retvalu = log(cxpi / abs(sin(2.0 * cxtau * xx))) - qq;
      } else {
         retvalu = qq;
      }
   }
   return (retvalu);
}
define lgammainv(yy) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_ii,yy_fixed,\
            xx_init;
   yy_fixed = yy / cxpi + log(yy + 0.5);
   xx_init = yy_fixed + cxpi - 0.5;
   scvx_dx = 0.01;
   scvx_xx = xx_init;
   scvx_yy = yy - lgamma(scvx_xx);
   for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
      scvx_xp = scvx_xx;
      scvx_yp = scvx_yy;
      scvx_xx += scvx_dx;
      if (iseq(scvx_xp,scvx_xx)) {
         break;
      }
      scvx_yy = yy - lgamma(scvx_xx);
      if (iseq(scvx_yy,scvx_yp)) {
         break;
      }
      scvx_dx *= - scvx_yy / (scvx_yy - scvx_yp);
   }
   return (scvx_xx);
}
define lf_lgamma_gt_zero(xx) {
   auto retvalu,zz,pp,uu,denom,numer;
   if (xx < 13.0) {
      zz = 1.0;
      pp = 0.0;
      uu = xx;
      while (3.0 <= uu) {
         pp -= 1.0;
         uu = xx + pp;
         zz *= uu;
      }
      while (uu < 2.0) {
         zz /= uu;
         pp += 1.0;
         uu = xx + pp;
      }
      if (zz < 0.0) {
         zz = -zz;
      }
      if (iseq(uu,2.0)) {
         retvalu = log(zz);
      } else {
         pp -= 2.0;
         xx += pp;
         numer = ((((((-(1.37825152569120859100 * 10^3)) * xx -\
                  (3.88016315134637840924 * 10^4)) * xx -\
                  (3.31612992738871184744 * 10^5)) * xx -\
                  (1.16237097492762307383 * 10^6)) * xx -\
                  (1.72173700820839662146 * 10^6)) * xx -\
                  (8.53555664245765465627 * 10^5));
         denom = (((((((1.0) * xx - (3.51815701436523470549 * 10^2)) * xx\
                  - (1.70642106651881159223 * 10^4)) * xx -\
                  (2.20528590553854454839 * 10^5)) * xx -\
                  (1.13933444367982507207 * 10^6)) * xx -\
                  (2.53252307177582951285 * 10^6)) * xx -\
                  (2.01889141433532773231 * 10^6));
         retvalu = log(zz) + xx * numer / denom;
      }
   } else {
      uu = (xx - 0.5) * log(xx) - xx + log(sqrt(cxtau));
      if ((1.0 * 10^8) < xx) {
         retvalu = uu;
      } else {
         pp = 1.0 / (xx * xx);
         if (1000.0 < xx) {
            zz = (((7.9365079365079365079365 * 10^-4) * pp -\
                     (2.7777777777777777777778 * 10^-3)) * pp +\
                     (8.3333333333333333333333 * 10^-2));
         } else {
            zz = (((((8.11614167470508450300 * 10^-4) * pp -\
                     (5.95061904284301438324 * 10^-4)) * pp +\
                     (7.93650340457716943945 * 10^-4)) * pp -\
                     (2.77777777300996872050 * 10^-3)) * pp +\
                     (8.33333333333331927722 * 10^-2));
         }
         retvalu = uu + zz / xx;
      }
   }
   return (retvalu);
}
define lgamma(zz) {
   auto retvalu;
   if (zz <= 0.0) {
      if (isint(zz)) {
         retvalu = log(cxdblmax);
      } else {
         retvalu = (log(cxpi / abs(sin(2.0 * cxtau * zz))) -\
                  lf_lgamma_gt_zero(1.0 - zz));
      }
   } else {
      retvalu = lf_lgamma_gt_zero(zz);
   }
   return (retvalu);
}
define lf_eval_cont(xx,deg,*coeff_arr_pc[]) {
   auto sum,ii;
   sum = xx;
   for (ii = deg; 0 <= ii; ii -= 1) {
      sum = xx + coeff_arr_pc[ii] / sum;
   }
   return (sum);
}
define lgamma__2(zz) {
   auto retvalu,aa_arr[],sum;
   if (zz <= 0.0) {
      if (isint(zz)) {
         retvalu = log(cxdblmax);
      } else {
         retvalu = (log(cxpi / abs(sin(2.0 * cxtau * zz))) - lgamma(1.0 -\
                  zz));
      }
   } else {
      aa_arr[0] = 1.0 / 12.0;
      aa_arr[1] = 1.0 / 30.0;
      aa_arr[2] = 53.0 / 210.0;
      aa_arr[3] = 195.0 / 371.0;
      aa_arr[4] = 229999.0 / 22737.0;
      aa_arr[5] = 29944523.0 / 19733142.0;
      aa_arr[6] = 109535241009.0 / 48264275462.0;
      aa_arr[7] = 29404527905795295658.0 / 9769214287853155785.0;
      aa_arr[8] = 455377030420113432210116914702.0 /\
               113084128923675014537885725485.0;
      sum = 0.0;
      while (zz <= 6.0) {
         sum += log(zz);
         zz += 1.0;
      }
      sum -= lf_eval_cont(zz,8,aa_arr[]);
      retvalu = (log(cxtau) / 2.0 + (zz - 0.5) * log(zz) - 2.0 * zz - sum);
   }
   return (retvalu);
}
define lpermx(nn,rr) {
   return (lgamma(nn + 1.0) - lgamma(nn - rr + 1.0));
}
define permx(nn,rr) {
   return (exp(lpermx(nn,rr)));
}
define lcombx(nn,rr) {
   return (lpermx(nn,rr) - lgamma(rr + 1.0));
}
define combx(nn,rr) {
   return (exp(lcombx(nn,rr)));
}
define birthdayx(nn,rr) {
   return (exp(lpermx(nn,rr) - log(nn) * rr));
}
define tgamma__1(xx) {
   auto zz,rslt,denom,numer;
   if (isposint(1.0 - xx)) {
      rslt = cxdblmax;
   } else {
      zz = 1.0;
      while (3.0 <= xx) {
         xx -= 1.0;
         zz *= xx;
      }
      while (xx < 2.0) {
         if (abs(xx) < (1.0 * 10^-9)) {
            break;
         }
         zz /= xx;
         xx += 1.0;
      }
      if (iseq(xx,0.0)) {
         rslt = cxdblmax;
      } else if (xx < 2.0) {
         rslt = zz / ((1.0 + cxeuler * xx) * xx);
      } else if (iseq(xx,2.0)) {
         rslt = zz;
      } else {
         xx -= 2.0;
         numer = (((((((1.60119522476751861407 * 10^-4) * xx +\
                  (1.19135147006586384913 * 10^-3)) * xx +\
                  (1.04213797561761569935 * 10^-2)) * xx +\
                  (4.76367800457137231464 * 10^-2)) * xx +\
                  (2.07448227648435975150 * 10^-1)) * xx +\
                  (4.94214826801497100753 * 10^-1)) * xx +\
                  (9.99999999999999996796 * 10^-1));
         denom = ((((((((-(2.31581873324120129819 * 10^-5)) * xx +\
                  (5.39605580493303397842 * 10^-4)) * xx -\
                  (4.45641913851797240494 * 10^-3)) * xx +\
                  (1.18139785222060435552 * 10^-2)) * xx +\
                  (3.58236398605498653373 * 10^-2)) * xx -\
                  (2.34591795718243348568 * 10^-1)) * xx +\
                  (7.14304917030273074085 * 10^-2)) * xx +\
                  1.00000000000000000320);
         rslt = zz * numer / denom;
      }
   }
   return (rslt);
}
define tgamma(xx) {
   auto retvalu,tmp;
   if (xx < 0.0) {
      if (isint(xx)) {
         retvalu = cxdblmax;
      } else {
         tmp = exp(lgamma(1.0 - xx));
         retvalu = cxpi / (sin(cxpi * xx) * tmp);
      }
   } else {
      retvalu = exp(lgamma(xx));
   }
   return (retvalu);
}
define tgammainv(yy) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_ii,kk,cc,pp,\
            xx_init;
   kk = cxgammamin;
   cc = sqrt(cxtau) / e - tgamma(kk);
   pp = log((yy + cc) / sqrt(cxtau));
   xx_init = pp / wp(pp / e) + 0.5;
   scvx_dx = 0.01;
   scvx_xx = xx_init;
   scvx_yy = yy - tgamma(scvx_xx);
   for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
      scvx_xp = scvx_xx;
      scvx_yp = scvx_yy;
      scvx_xx += scvx_dx;
      if (iseq(scvx_xp,scvx_xx)) {
         break;
      }
      scvx_yy = yy - tgamma(scvx_xx);
      if (iseq(scvx_yy,scvx_yp)) {
         break;
      }
      scvx_dx *= - scvx_yy / (scvx_yy - scvx_yp);
   }
   return (scvx_xx);
}
define lf_gamma_shift(xx,yy) {
   auto prod;
   if (isposint(1.0 - yy)) {
      prod = cxdblmax;
   } else {
      prod = 1.0;
      while (yy < xx - 0.0001) {
         prod *= yy;
         yy += 1.0;
      }
      while (xx + 0.0001 < yy) {
         yy -= 1.0;
         prod /= yy;
      }
   }
   return (prod);
}
define lf_tgamma_gt_half(xx) {
   auto ii,sum,yy,pp_arr[],ex;
   yy = xx - floor(xx) + 1.0;
   pp_arr[0] = (5.716400188274341379136 * 10^3);
   pp_arr[1] = -(1.481530426768413909044 * 10^4);
   pp_arr[2] = (1.429149277657478554025 * 10^4);
   pp_arr[3] = -(6.348160217641458813289 * 10^3);
   pp_arr[4] = (1.301608286058321874105 * 10^3);
   pp_arr[5] = -(1.081767053514369634679 * 10^2);
   pp_arr[6] = 2.605696505611755827729;
   pp_arr[7] = -(7.423452510201416151527 * 10^-3);
   pp_arr[8] = (5.384136432509564062961 * 10^-8);
   pp_arr[9] = -(4.023533141268236372067 * 10^-9);
   sum = 1.000000000000000174663;
   for (ii = 0; ii <= 9; ii += 1) {
      sum += pp_arr[ii] / (yy + ii);
   }
   ex = log(yy + 8.5) * (yy - 0.5) - yy - 8.5;
   return (sqrt(cxtau) * sum * lf_gamma_shift(xx,yy) * exp(ex));
}
define tgamma__2(xx) {
   auto ii,sum,pp_arr[],yy,rslt,ex;
   if (isposint(1.0 - xx)) {
      rslt = cxdblmax;
   } else {
      yy = xx - floor(xx) + 2.0;
      pp_arr[0] = (7.61800917294715 * 10^1);
      pp_arr[1] = -(8.65053203294168 * 10^1);
      pp_arr[2] = (2.40140982408309 * 10^1);
      pp_arr[3] = -1.23173957245015;
      pp_arr[4] = (1.20865097386618 * 10^-3);
      pp_arr[5] = -(5.395239384953 * 10^-6);
      sum = 1.00000000019001;
      for (ii = 0; ii <= 5; ii += 1) {
         sum += pp_arr[ii] / (yy + ii);
      }
      ex = log(yy + 4.5) * (yy - 0.5) - yy - 4.5;
      rslt = sqrt(cxtau) * sum * lf_gamma_shift(xx,yy) * exp(ex);
   }
   return (rslt);
}
define tgamma__3(xx) {
   auto retvalu;
   if (isposint(1.0 - xx)) {
      retvalu = cxdblmax;
   } else if (xx < 0.5) {
      retvalu = cxpi / (sin(cxpi * xx) * lf_tgamma_gt_half(1.0 - xx));
   } else {
      retvalu = lf_tgamma_gt_half(xx);
   }
   return (retvalu);
}
define tgamma__stirling(xx) {
   auto yy,ryy,sc,ply;
   sc = 1.0;
   while (xx < 10.0) {
      sc /= xx;
      xx += 1.0;
   }
   yy = xx - 1.0;
   ryy = 1.0 / yy;
   ply = (((((((-5246819.0 / 75246796800.0) * ryy + 163879.0 /\
            209018880.0) * ryy - 571.0 / 2488320.0) * ryy - 139.0 /\
            51840) * ryy + 1.0 / 288.0) * ryy + 1.0 / 12.0) * ryy + 1.0);
   return (sc * pow(yy / e,yy) * sqrt(cxtau * yy) * ply);
}
define tgammadouble(xx) {
   auto xxh;
   xxh = (xx - 1.0) / 2.0;
   return (pow(2.0,xxh) * tgamma(xxh + 1.0) * pow(2.0 / cxpi,(1.0 -\
            cos(cxtau * xxh)) / 4.0));
}
define lf_ligamma_xxleaa(aa,xx) {
   auto kk,rr,sum_curr,sum_prev;
   sum_curr = exp(aa * log(xx) - xx) / aa;
   rr = sum_curr;
   for (kk = 1; kk <= 100; kk += 1) {
      rr *= xx / (aa + kk);
      sum_prev = sum_curr;
      sum_curr += rr;
      if (iseq(sum_prev,sum_curr)) {
         break;
      }
   }
   return (sum_curr);
}
define lf_uigamma_aalexx(aa,xx) {
   auto jj,pp,ipp,sum_curr,tt;
   sum_curr = 0.0;
   pp = 47.0 / sqrt(xx - 0.75);
   ipp = floor(pp);
   for (jj = ipp; 1 <= jj; jj -= 1) {
      tt = xx + sum_curr;
      sum_curr = (jj - aa) * tt / (tt + jj);
   }
   return (exp(aa * log(xx) - xx) / (xx + sum_curr));
}
define ligamma(aa,xx) {
   auto retvalu;
   if (xx <= 0.0) {
      retvalu = 0.0;
   } else if (aa <= 0.0) {
      retvalu = cxdblmax;
   } else if (xx <= 1.1 || xx <= aa) {
      retvalu = lf_ligamma_xxleaa(aa,xx);
   } else {
      retvalu = tgamma(aa) - lf_uigamma_aalexx(aa,xx);
   }
   return (retvalu);
}
define uigamma(aa,xx) {
   auto retvalu;
   if (aa <= 0.0) {
      retvalu = cxdblmax;
   } else if (xx <= 0.0) {
      retvalu = tgamma(aa);
   } else if (xx <= 1.1 || xx <= aa) {
      retvalu = tgamma(aa) - lf_ligamma_xxleaa(aa,xx);
   } else {
      retvalu = lf_uigamma_aalexx(aa,xx);
   }
   return (retvalu);
}
define rligamma(aa,xx) {
   auto retvalu;
   if (xx <= 0.0) {
      retvalu = 0.0;
   } else if (aa <= 0.0) {
      retvalu = cxdblmax;
   } else {
      retvalu = ligamma(aa,xx) / tgamma(aa);
   }
   return (retvalu);
}
define ruigamma(aa,xx) {
   auto retvalu;
   if (aa <= 0.0) {
      retvalu = cxdblmax;
   } else if (xx <= 0.0) {
      retvalu = 1.0;
   } else {
      retvalu = uigamma(aa,xx) / tgamma(aa);
   }
   return (retvalu);
}
define uigamma__1(aa,xx) {
   auto ans,ax,cc,yc,rr,tt,yy,zz,pk,pkma,pkmb,qk,qkma,qkmb,\
            retvalu;
   if (xx <= 0.0 || aa <= 0.0) {
      retvalu = 1.0;
   } else {
      ax = aa * log(xx) - xx - lgamma(aa);
      if (ax < - cxdblmaxln) {
         retvalu = 0.0;
      } else {
         ax = exp(ax);
         if (xx < 1.0 || xx < aa) {
            rr = aa;
            cc = 1.0;
            ans = 1.0;
            for (;;) {
               rr += 1.0;
               cc *= xx / rr;
               ans += cc;
               if (cc / ans < cxdbleps) {
                  break; # loop AWAIT
               }
            }
            retvalu = 1.0 - ans * ax / aa;
         } else {
            yy = 1.0 - aa;
            zz = xx + yy + 1.0;
            cc = 0.0;
            pkmb = 1.0;
            qkmb = xx;
            pkma = xx + 1.0;
            qkma = zz * xx;
            ans = pkma / qkma;
            for (;;) {
               cc += 1.0;
               yy += 1.0;
               zz += 2.0;
               yc = yy * cc;
               pk = pkma * zz - pkmb * yc;
               qk = qkma * zz - qkmb * yc;
               if (! iszero(qk)) {
                  rr = pk / qk;
                  tt = abs((ans - rr) / rr);
                  ans = rr;
               } else {
                  tt = 1.0;
               }
               pkmb = pkma;
               pkma = pk;
               qkmb = qkma;
               qkma = qk;
               if (1.0 / cxdbleps < abs(pk)) {
                  pkmb *= cxdbleps;
                  pkma *= cxdbleps;
                  qkmb *= cxdbleps;
                  qkma *= cxdbleps;
               }
               if (tt <= cxdbleps) {
                  break; # loop AWAIT
               }
            }
            retvalu = ans * ax;
         }
      }
   }
   return (retvalu);
}
define uigammainv(aa,yy) {
   auto dd,tt,xx,scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_ii;
   dd = 1.0 / (9.0 * aa);
   tt = 1.0 - dd - gau_quantile(yy) * sqrt(dd);
   xx = aa * pow(tt,3);
   scvx_dx = 0.1;
   scvx_xx = xx;
   scvx_yy = yy - uigamma(aa,scvx_xx);
   for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
      scvx_xp = scvx_xx;
      scvx_yp = scvx_yy;
      scvx_xx += scvx_dx;
      if (iseq(scvx_xp,scvx_xx)) {
         break;
      }
      scvx_yy = yy - uigamma(aa,scvx_xx);
      if (iseq(scvx_yy,scvx_yp)) {
         break;
      }
      scvx_dx *= - scvx_yy / (scvx_yy - scvx_yp);
   }
   return (scvx_xx);
}
define ligammainv(aa,yy) {
   return (uigammainv(aa,1.0 - yy));
}
define lbeta(aa,bb) {
   return (lgamma(aa) + lgamma(bb) - lgamma(aa + bb));
}
define beta(aa,bb) {
   auto retvalu,lbe;
   lbe = lbeta(aa,bb);
   if (cxdblmaxln < lbe) {
      retvalu = cxdblmax;
   } else if (- cxdblmaxln < lbe) {
      retvalu = exp(lbe);
   } else {
      retvalu = -cxdblmax;
   }
   return (retvalu);
}
define betainc(aa,bb,xx) {
   auto sum_curr,sum_prev,compx,new_xx,pp,qq,term,ai,rx,temp,\
            log_beta,retvalu,indx,ns,psq;
   if (xx <= 0.0) {
      retvalu = 0.0;
   } else if (aa <= 0.0 || bb <= 0.0 || 1.0 <= xx) {
      retvalu = 1.0;
   } else {
      psq = aa + bb;
      if (aa < psq * xx) {
         new_xx = 1.0 - xx;
         compx = xx;
         pp = bb;
         qq = aa;
         indx = 0;
      } else {
         new_xx = xx;
         compx = 1.0 - xx;
         pp = aa;
         qq = bb;
         indx = 1;
      }
      term = 1.0;
      sum_curr = 1.0;
      ai = 1.0;
      ns = floor(qq + compx * psq);
      rx = new_xx / compx;
      temp = qq - ai;
      if (ns == 0) {
         rx = new_xx;
      }
      for (;;) {
         term *= temp * rx / (pp + ai);
         ai += 1.0;
         ns -= 1;
         if (0 <= ns) {
            temp = qq - ai;
            if (ns == 0) {
               rx = new_xx;
            }
         } else {
            temp = psq;
            psq += 1.0;
         }
         sum_prev = sum_curr;
         sum_curr += term;
         if (iseq(sum_curr,sum_prev)) {
            break; # loop AWAIT
         }
      }
      log_beta = lgamma(aa) + lgamma(bb) - lgamma(aa + bb);
      retvalu = sum_curr * exp(pp * log(new_xx) + (qq - 1.0) * log(compx)\
               - log_beta) / pp;
      if (indx == 0) {
         retvalu = 1.0 - retvalu;
      }
   }
   return (retvalu);
}
define betainc__1(aa,bb,xx) {
   auto retvalu,lbeta_ab,front,ff,cc,dd,ii,jj,kk,numerator,den,cd;
   if (xx <= 0.0) {
      retvalu = 0.0;
   } else if (aa <= 0.0 || bb <= 0.0 || 1.0 <= xx) {
      retvalu = 1.0;
   } else if ((aa + 1.0) / (aa + bb + 2.0) < xx) {
      retvalu = 1.0 - betainc__1(bb,aa,1.0 - xx);
   } else if (aa <= 0) {
      retvalu = 0.0;
   } else {
      lbeta_ab = lbeta(aa,bb);
      front = exp(log(xx) * aa + log(1.0 - xx) * bb - lbeta_ab) / aa;
      ff = 1.0;
      cc = 1.0;
      dd = 0.0;
      jj = 0;
      ii = 0;
      for (;;) {
         if (ii == 0) {
            numerator = 1.0;
         } else if (jj == 0) {
            kk = ii / 2;
            den = (aa + 2.0 * kk - 1.0) * (aa + 2.0 * kk);
            numerator = (kk * (bb - kk) * xx) / den;
         } else {
            kk = (ii - 1) / 2;
            den = (aa + 2.0 * kk) * (aa + 2.0 * kk + 1.0);
            numerator = -((aa + kk) * (aa + bb + kk) * xx) / den;
         }
         dd = 1.0 + numerator * dd;
         if (abs(dd) < cxdbleps * cxdbleps) {
            dd = cxdbleps * cxdbleps;
         }
         dd = 1.0 / dd;
         cc = 1.0 + numerator / cc;
         if (abs(cc) < cxdbleps * cxdbleps) {
            cc = cxdbleps * cxdbleps;
         }
         cd = cc * dd;
         ff *= cd;
         jj = 1 - ii;
         if (abs(1.0 - cd) < cxdbleps) {
            break; # loop AWAIT
         }
         ii += 1;
         if (200 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = front * (ff - 1.0);
   }
   return (retvalu);
}
define lf_digamma_gt_zero(xx) {
   auto rec_xx_sqr,shift,sxx,ii,sumy;
   shift = 0.0;
   sxx = xx;
   while (sxx < 8.0) {
      shift -= 1.0 / sxx;
      sxx += 1.0;
   }
   rec_xx_sqr = 1.0 / (sxx * sxx);
   sumy = 0.0;
   for (ii = 14; 2 <= ii; ii -= 2) {
      sumy *= rec_xx_sqr;
      sumy += - bernoulli(ii) / ii;
   }
   return ((shift + log(sxx) - 1.0 / (2.0 * sxx) + rec_xx_sqr * sumy));
}
define digamma(xx) {
   auto sxx,retvalu;
   if (xx <= 0.0) {
      if (isint(xx)) {
         retvalu = cxdblmax;
      } else {
         sxx = 2.0 * xx;
         retvalu = lf_digamma_gt_zero(1.0 - xx) - cxpi / tan(sxx);
      }
   } else {
      retvalu = lf_digamma_gt_zero(xx);
   }
   return (retvalu);
}
define digammainv(yy) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_ii;
   scvx_dx = 0.1;
   scvx_xx = exp(yy);
   scvx_yy = yy - digamma(scvx_xx);
   for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
      scvx_xp = scvx_xx;
      scvx_yp = scvx_yy;
      scvx_xx += scvx_dx;
      if (iseq(scvx_xp,scvx_xx)) {
         break;
      }
      scvx_yy = yy - digamma(scvx_xx);
      if (iseq(scvx_yy,scvx_yp)) {
         break;
      }
      scvx_dx *= - scvx_yy / (scvx_yy - scvx_yp);
   }
   return (scvx_xx);
}
define lf_digamma_gt_zero__1(xx) {
   auto gg,aa_arr[],sxx,term,lnarg,numer,denom,ii;
   gg = 9.6565781537733158945718737389;
   aa_arr[0] = (1.144005294538510956673085217 * 10^4);
   aa_arr[1] = -(3.239880201523183350535979104 * 10^4);
   aa_arr[2] = (3.505145235055716665660834611 * 10^4);
   aa_arr[3] = -(1.816413095412607026106469185 * 10^4);
   aa_arr[4] = (4.632329905366668184091382704 * 10^3);
   aa_arr[5] = -(5.369767777033567805557478696 * 10^2);
   aa_arr[6] = (2.287544733951810076451548089 * 10^1);
   aa_arr[7] = -(2.179257487388651155600822204 * 10^-1);
   aa_arr[8] = (1.083148362725893688606893534 * 10^-4);
   numer = 0.0;
   denom = 1.0;
   for (ii = 8; 0 <= ii; ii -= 1) {
      sxx = xx + ii;
      term = aa_arr[ii] / sxx;
      denom += term;
      numer += term / sxx;
   }
   lnarg = (gg + xx - 0.5);
   return (log(lnarg) - (gg / lnarg) - numer / denom);
}
define digamma__1(xx) {
   auto sxx,retvalu;
   if (xx <= 0.0) {
      if (isint(xx)) {
         retvalu = cxdblmax;
      } else {
         sxx = 2.0 * xx;
         retvalu = lf_digamma_gt_zero__1(1.0 - xx) - cxpi / tan(sxx);
      }
   } else {
      retvalu = lf_digamma_gt_zero__1(xx);
   }
   return (retvalu);
}
define factorialinv(yy) {
   return (tgammainv(yy) - 1.0);
}
define facinv(yy) {
   return (tgammainv(yy) - 1.0);
}
define hn(xx) {
   auto sum,kk,fxx;
   if (0.0 < xx) {
      fxx = floor(xx);
      sum = 0.0;
      for (kk = fxx; 1 <= kk; kk -= 1) {
         sum += 1.0 / kk;
      }
   } else {
      sum = 0.0;
   }
   return (sum);
}
define hn__1(xx) {
   auto yy,retvalu;
   if (0.0 < xx) {
      yy = 1.0 / (xx * xx);
      retvalu = ((((((-5.0 / (66.0 * 10.0)) * yy + 1.0 / (30.0 * 8.0)) *\
               yy - 1.0 / (42.0 * 6.0)) * yy + 1.0 / (30.0 * 4.0)) * yy -\
               1.0 / (6.0 * 2.0)) * yy + cxeuler) + log(xx) + 0.5 / xx;
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define hnm(xx,vv) {
   auto sum,kk,fxx;
   fxx = floor(xx);
   sum = 0.0;
   for (kk = fxx; 1 <= kk; kk -= 1) {
      sum += 1.0 / pow(kk,vv);
   }
   return (sum);
}
lv_factorial_arr[0] = 0;
lv_factorial_end = 0;
define factorial(nn) {
   # local-use Bc lv_factorial_end;
   # local-use Bc lv_factorial_arr[];
   auto ii,retvalu;
   if (nn < 0) {
      retvalu = 0;
   } else {
      if (lv_factorial_end <= 0) {
         lv_factorial_end = 6;
         lv_factorial_arr[0] = 1;
         lv_factorial_arr[1] = 1;
         lv_factorial_arr[2] = 2;
         lv_factorial_arr[3] = 6;
         lv_factorial_arr[4] = 24;
         lv_factorial_arr[5] = 120;
      }
      if (lv_factorial_end <= nn) {
         ii = lv_factorial_end;
         lv_factorial_end = nn + 1;
         while (ii < lv_factorial_end) {
            lv_factorial_arr[ii] = (ii * lv_factorial_arr[ii - 1]);
            ii += 1;
         }
      }
      retvalu = lv_factorial_arr[nn];
   }
   return (retvalu);
}
lv_factorial_b_arr[0] = 0;
lv_factorial_b_end = 0;
define factorialdouble(nn) {
   # local-use Bc lv_factorial_b_end;
   # local-use Bc lv_factorial_b_arr[];
   auto retvalu,ii;
   if (nn < 0) {
      retvalu = 0;
   } else {
      if (lv_factorial_b_end <= 0) {
         lv_factorial_b_end = 6;
         lv_factorial_b_arr[0] = 1;
         lv_factorial_b_arr[1] = 1;
         lv_factorial_b_arr[2] = 2;
         lv_factorial_b_arr[3] = 3;
         lv_factorial_b_arr[4] = 8;
         lv_factorial_b_arr[5] = 15;
      }
      if (lv_factorial_b_end <= nn) {
         ii = lv_factorial_b_end;
         lv_factorial_b_end = nn + 1;
         while (ii < lv_factorial_b_end) {
            lv_factorial_b_arr[ii] = ii * lv_factorial_b_arr[ii - 2];
            ii += 1;
         }
      }
      retvalu = lv_factorial_b_arr[nn];
   }
   return (retvalu);
}
define fac(nn) {
   return (factorial(nn));
}
define factorialt(n_things,r_each) {
   auto ii,retvalu;
   retvalu = 1.0;
   for (ii = r_each + 1; ii <= n_things; ii += 1) {
      retvalu *= ii;
   }
   return (retvalu);
}
define comb(n_things,r_each) {
   auto ii,retvalu;
   if (r_each < 0 || n_things < r_each) {
      retvalu = 0.0;
   } else {
      if (2 * r_each < n_things) {
         r_each = n_things - r_each;
      }
      retvalu = 1.0;
      for (ii = r_each + 1; ii <= n_things; ii += 1) {
         retvalu *= ii;
         retvalu /= (ii - r_each);
      }
   }
   return (retvalu);
}
define perm(n_things,r_each) {
   return (factorialt(n_things,n_things - r_each));
}
define combination(n_things,r_each) {
   return (comb(n_things,r_each));
}
define permutation(n_things,r_each) {
   return (perm(n_things,r_each));
}
lv_catalan_arr[0] = 0;
lv_catalan_end = 0;
define catalan(nn) {
   # local-use Bc lv_catalan_end;
   # local-use Bc lv_catalan_arr[];
   auto kk,retvalu;
   if (nn < 0) {
      retvalu = 0;
   } else {
      if (lv_catalan_end <= 0) {
         lv_catalan_end = 1;
         lv_catalan_arr[0] = 1;
      }
      if (lv_catalan_end <= nn) {
         kk = lv_catalan_end;
         lv_catalan_end = nn + 1;
         while (kk < lv_catalan_end) {
            lv_catalan_arr[kk] = (2.0 * (2.0 * kk - 1.0) *\
                     lv_catalan_arr[kk - 1] / (kk + 1.0));
            kk += 1;
         }
      }
      retvalu = lv_catalan_arr[nn];
   }
   return (retvalu);
}
lv_supercatalan_arr[0] = 0;
lv_supercatalan_end = 0;
define supercatalan(nn) {
   # local-use Bc lv_supercatalan_end;
   # local-use Bc lv_supercatalan_arr[];
   auto kk,retvalu;
   if (nn < 0) {
      retvalu = 0;
   } else {
      if (lv_supercatalan_end <= 0) {
         lv_supercatalan_end = 3;
         lv_supercatalan_arr[0] = 1;
         lv_supercatalan_arr[1] = 1;
         lv_supercatalan_arr[2] = 1;
      }
      if (lv_supercatalan_end <= nn) {
         kk = lv_supercatalan_end;
         lv_supercatalan_end = nn + 1;
         while (kk < lv_supercatalan_end) {
            lv_supercatalan_arr[kk] = (((6 * kk - 9) *\
                     lv_supercatalan_arr[kk - 1] - (kk - 3) *\
                     lv_supercatalan_arr[kk - 2]) / kk);
            kk += 1;
         }
      }
      retvalu = lv_supercatalan_arr[nn];
   }
   return (retvalu);
}
lv_bell_arr[0] = 0;
lv_bell_x_arr[0] = 0;
lv_bell_end = 0;
define bell(nn) {
   # local-use Bc lv_bell_end;
   # local-use Bc lv_bell_arr[];
   # local-use Bc lv_bell_x_arr[];
   auto jj,kk,retvalu;
   if (nn < 0) {
      retvalu = 0;
   } else {
      if (lv_bell_end <= 0) {
         lv_bell_end = 3;
         lv_bell_arr[0] = 1;
         lv_bell_arr[1] = 1;
         lv_bell_arr[2] = 2;
         lv_bell_x_arr[0] = 2;
         lv_bell_x_arr[1] = 1;
      }
      if (lv_bell_end <= nn) {
         kk = lv_bell_end;
         lv_bell_end = nn + 1;
         while (kk < lv_bell_end) {
            lv_bell_x_arr[kk - 1] = lv_bell_x_arr[0];
            for (jj = kk - 2; 0 <= jj; jj -= 1) {
               lv_bell_x_arr[jj] += lv_bell_x_arr[jj + 1];
            }
            lv_bell_arr[kk] = lv_bell_x_arr[0];
            kk += 1;
         }
      }
      retvalu = lv_bell_arr[nn];
   }
   return (retvalu);
}
define bellx(xxn) {
   auto sum,kk,sum_prev,den;
   kk = 0;
   sum = 0.0;
   den = 1.0;
   for (;;) {
      kk += 1;
      den *= kk;
      sum_prev = sum;
      sum += pow(kk,xxn) / den;
      if (iseq(sum_prev,sum)) {
         break; # loop AWAIT
      }
   }
   return (sum / e);
}
define fubini(nn) {
   auto ii,sum,retvalu;
   if (nn < 0) {
      retvalu = 0;
   } else if (nn == 0) {
      retvalu = 1;
   } else {
      sum = 1.0 / (2.0 * cxtwoln * cxtwoln);
      for (ii = 2; ii <= nn; ii += 1) {
         sum *= ii / cxtwoln;
      }
      retvalu = round(sum);
   }
   return (retvalu);
}
define d2lt_d1(xx,yy) {
   auto retvalu;
   if (0 <= yy && yy <= xx) {
      retvalu = yy + (xx * (xx + 1)) / 2;
   } else {
      retvalu = -1;
   }
   return (retvalu);
}
define d1lt_d2(nn,*ret_arr_p[]) {
   auto basee;
   if (nn <= 0) {
      ret_arr_p[0] = 0;
      ret_arr_p[1] = 0;
   } else {
      basee = floorl((sqrt(1 + 8.0 * nn) - 1) / 2);
      ret_arr_p[1] = nn - basee * (basee + 1) / 2;
      ret_arr_p[0] = basee;
   }
   return (ret_arr_p[0]);
}
define d2ur_d1(xx,yy) {
   auto retvalu,suma;
   if (0 <= xx && 0 <= yy) {
      suma = (yy + xx);
      retvalu = suma * (suma + 1) / 2 + yy;
   } else {
      retvalu = -1;
   }
   return (retvalu);
}
define d1ur_d2(nn,*ret_arr_p[]) {
   auto basee,y_coord;
   if (nn <= 0) {
      ret_arr_p[0] = 0;
      ret_arr_p[1] = 0;
   } else {
      basee = floorl((sqrt(1 + 8.0 * nn) - 1) / 2);
      y_coord = nn - basee * (basee + 1) / 2;
      ret_arr_p[1] = y_coord;
      ret_arr_p[0] = basee - y_coord;
   }
   return (ret_arr_p[0]);
}
define d2diamond_d1(xx,yy) {
   auto ss,tt,retvalu;
   if (0 == yy && xx == 0) {
      retvalu = 0;
   } else {
      ss = abs(xx) + abs(yy);
      tt = 2 * ss * (ss - 1) + 1;
      if (0 < xx) {
         retvalu = tt + ss + yy - 1;
      } else {
         retvalu = tt + 3 * ss - yy - 1;
      }
   }
   return (retvalu);
}
define d1diamond_d2(nn,*ret_arr_p[]) {
   auto ss,ssq,x_coord;
   if (nn <= 0) {
      x_coord = 0;
      ret_arr_p[1] = 0;
   } else {
      ss = floorl(sqrt(nn) / cxtwosqrt);
      ssq = 2 * ss * ss;
      if (nn <= ssq + 2 * ss) {
         ret_arr_p[1] = ssq - nn + ss;
         x_coord = ssq - nn;
         if (ss < - x_coord) {
            x_coord = -x_coord - 2 * ss;
         }
      } else {
         ret_arr_p[1] = nn - ssq - 3 * ss - 1;
         x_coord = nn - ssq - 2 * ss;
         if (ss < x_coord) {
            x_coord = -x_coord + 2 * ss + 2;
         }
      }
   }
   ret_arr_p[0] = x_coord;
   return (x_coord);
}
define d2spiral_d1(xx,yy) {
   auto retvalu;
   if (xx == 0 && yy == 0) {
      retvalu = 0;
   } else if (abs(xx) <= abs(yy)) {
      retvalu = (4 * yy - 1) * yy - xx;
      if (yy < 0) {
         retvalu -= 2 * (yy - xx);
      }
   } else {
      retvalu = (4 * xx - 1) * xx - yy;
      if (0 < xx) {
         retvalu -= 2 * (xx - yy);
      }
   }
   return (retvalu);
}
define d1spiral_d2(nn,*ret_arr_p[]) {
   auto sqrtnn,newdd,fxd;
   if (nn <= 0) {
      ret_arr_p[0] = 0;
      ret_arr_p[1] = 0;
   } else {
      sqrtnn = floorl(sqrt(nn));
      if (iseven(sqrtnn)) {
         fxd = -sqrtnn / 2;
      } else {
         fxd = (sqrtnn + 1) / 2;
      }
      newdd = nn - sqrtnn * sqrtnn;
      if (newdd <= sqrtnn) {
         ret_arr_p[0] = fxd;
         if (fxd < 0) {
            ret_arr_p[1] = -fxd - newdd;
         } else {
            ret_arr_p[1] = -fxd + newdd + 1;
         }
      } else {
         ret_arr_p[1] = fxd;
         newdd -= sqrtnn;
         if (fxd < 0) {
            ret_arr_p[0] = fxd + newdd;
         } else {
            ret_arr_p[0] = fxd - newdd;
         }
      }
   }
   return (ret_arr_p[0]);
}
define d2hypot_d1(xx,yy) {
   auto retvalu,xlim,dist,distsq,count,ixx,nyy,nyysq,xmax;
   if (0 <= yy && yy <= xx) {
      distsq = xx * xx + yy * yy;
      dist = sqrt(distsq);
      xlim = floorl(dist / cxtwosqrt);
      xmax = floorl(dist);
      count = 0;
      for (ixx = xlim; ixx <= xmax; ixx += 1) {
         nyysq = distsq - ixx * ixx;
         nyy = ceill(sqrt(nyysq));
         if (ixx < nyy) {
            count += ixx + 1;
         } else {
            count += nyy;
            if (ixx < xx && nyy * nyy == nyysq) {
               count += 1;
            }
         }
      }
      retvalu = count + (xlim) * (xlim + 1) / 2;
   } else {
      retvalu = -1;
   }
   return (retvalu);
}
define binomialx(xnn,xkk) {
   return (tgamma(xnn + 1) / (tgamma(xkk + 1) * tgamma(xnn + 1 - xkk)));
}
lv_binom_arr[0] = 0;
lv_binom_end = 0;
lv_binom_max = 0;
define binomial(nn,kk) {
   # local-use Bc lv_binom_arr[];
   # local-use Bc lv_binom_end;
   # local-use Bc lv_binom_max;
   auto rz_ind,lz_ind,rr,ul_ind,retvalu;
   if (nn < kk || nn < 0 || kk < 0) {
      retvalu = 0;
   } else {
      if (lv_binom_end <= 0) {
         lv_binom_max = 2;
         lv_binom_end = d2lt_d1(lv_binom_max,0);
         lv_binom_arr[0] = 1;
         lv_binom_arr[1] = 1;
         lv_binom_arr[2] = 1;
      }
      rr = lv_binom_max;
      if (rr < nn + 1) {
         lv_binom_end = d2lt_d1(nn + 1,0);
         while (rr <= nn) {
            ul_ind = d2lt_d1(rr - 1,0);
            lz_ind = ul_ind + rr;
            lv_binom_arr[lz_ind] = 1;
            rz_ind = lz_ind + rr;
            while (lz_ind < rz_ind) {
               lv_binom_arr[rz_ind] = lv_binom_arr[lz_ind];
               rz_ind -= 1;
               lz_ind += 1;
               lv_binom_arr[lz_ind] = (lv_binom_arr[ul_ind] +\
                        lv_binom_arr[ul_ind + 1]);
               ul_ind += 1;
            }
            rr += 1;
         }
         lv_binom_max = rr;
      }
      retvalu = lv_binom_arr[d2lt_d1(nn,kk)];
   }
   return (retvalu);
}
lv_euler_arr[0] = 0;
lv_euler_end = 0;
lv_euler_max = 0;
define eulerian(nn,kk) {
   # local-use Bc lv_euler_arr[];
   # local-use Bc lv_euler_end;
   # local-use Bc lv_euler_max;
   auto jj,ii,lz_ind,rz_ind,ul_ind,retvalu;
   if (nn < kk || nn < 0 || kk < 0) {
      retvalu = 0;
   } else {
      if (lv_euler_end <= 0) {
         lv_euler_max = 3;
         lv_euler_end = d2lt_d1(lv_euler_max,0);
         lv_euler_arr[0] = 0;
         lv_euler_arr[1] = 1;
         lv_euler_arr[2] = 0;
         lv_euler_arr[3] = 1;
         lv_euler_arr[4] = 1;
         lv_euler_arr[5] = 0;
      }
      ii = lv_euler_max;
      if (ii < nn + 1) {
         lv_euler_end = d2lt_d1(nn + 1,0);
         while (ii <= nn) {
            lz_ind = d2lt_d1(ii,0);
            lv_euler_arr[lz_ind] = 1;
            lv_euler_arr[lz_ind + ii] = 0;
            rz_ind = lz_ind + ii - 1;
            ul_ind = d2lt_d1(ii - 1,0);
            jj = 1;
            while (lz_ind < rz_ind) {
               lv_euler_arr[rz_ind] = lv_euler_arr[lz_ind];
               lz_ind += 1;
               lv_euler_arr[lz_ind] = ((ii - jj) * lv_euler_arr[ul_ind] +\
                        (jj + 1) * lv_euler_arr[ul_ind + 1]);
               ul_ind += 1;
               rz_ind -= 1;
               jj += 1;
            }
            ii += 1;
            lv_euler_max = ii;
         }
      }
      retvalu = lv_euler_arr[d2lt_d1(nn,kk)];
   }
   return (retvalu);
}
lv_entringer_arr[0] = 0;
lv_entringer_end = 0;
lv_entringer_max = 0;
define entringer(nn,kk) {
   # local-use Bc lv_entringer_arr[];
   # local-use Bc lv_entringer_max;
   # local-use Bc lv_entringer_end;
   auto ii,inda,jj,retvalu;
   if (nn <= 0 || kk < 0 || nn < kk) {
      retvalu = 0;
   } else {
      if (lv_entringer_end <= 0) {
         lv_entringer_max = 1;
         lv_entringer_end = d2lt_d1(lv_entringer_max,0);
         lv_entringer_arr[0] = 1;
      }
      jj = lv_entringer_max;
      if (jj < nn + 1) {
         lv_entringer_end = d2lt_d1(nn + 1,0);
         while (jj <= nn) {
            inda = d2lt_d1(jj,0);
            lv_entringer_arr[inda] = 0;
            for (ii = 1; ii <= jj; ii += 1) {
               lv_entringer_arr[inda + ii] = lv_entringer_arr[inda - ii]\
                        + lv_entringer_arr[inda + ii - 1];
            }
            jj += 1;
            lv_entringer_max = jj;
         }
      }
      retvalu = lv_entringer_arr[d2lt_d1(nn,kk)];
   }
   return (retvalu);
}
define zigzag(nn) {
   return (entringer(nn,nn));
}
define zig(nn) {
   return (zigzag(2 * nn));
}
define zag(nn) {
   return (zigzag(2 * nn - 1));
}
define eulerx(nn) {
   auto retvalu;
   if (nn <= 0 || isodd(nn)) {
      retvalu = 0;
   } else {
      retvalu = entringer(nn,nn);
   }
   return (retvalu);
}
define ballot(xmm,xnn) {
   return (abs(xnn - xmm) / (xmm + xnn));
}
define ballots(xmm,xnn) {
   auto retvalu;
   if (xmm < xnn) {
      retvalu = (xnn - xmm + 1.0) / (xnn + 1.0);
   } else {
      retvalu = (xmm - xnn + 1.0) / (xmm + 1.0);
   }
   return (retvalu);
}
lv_stir_a_arr[0] = 0;
lv_stir_a_end = 0;
lv_stir_a_max = 0;
define stirling1(nn,kk) {
   # local-use Bc lv_stir_a_arr[];
   # local-use Bc lv_stir_a_end;
   # local-use Bc lv_stir_a_max;
   auto col_k,ul_ind,cz_ind,ii,retvalu;
   if (nn < 0 || kk < 0 || nn < kk) {
      retvalu = 0;
   } else {
      if (lv_stir_a_max <= 0) {
         lv_stir_a_max = 2;
         lv_stir_a_end = d2lt_d1(lv_stir_a_max,0);
         lv_stir_a_arr[0] = 1;
         lv_stir_a_arr[1] = 0;
         lv_stir_a_arr[2] = 1;
      }
      ii = lv_stir_a_max;
      if (ii < nn + 1) {
         lv_stir_a_end = d2lt_d1(nn + 1,0);
         while (ii <= nn) {
            cz_ind = d2lt_d1(ii,0);
            lv_stir_a_arr[cz_ind] = 0;
            cz_ind += 1;
            ul_ind = d2lt_d1(ii - 1,0);
            for (col_k = 1; col_k <= ii - 1; col_k += 1) {
               lv_stir_a_arr[cz_ind] = (lv_stir_a_arr[ul_ind] - (ii - 1)\
                        * lv_stir_a_arr[ul_ind + 1]);
               ul_ind += 1;
               cz_ind += 1;
            }
            lv_stir_a_arr[cz_ind] = 1;
            ii += 1;
            lv_stir_a_max = ii;
         }
      }
      retvalu = lv_stir_a_arr[d2lt_d1(nn,kk)];
   }
   return (retvalu);
}
lv_stir_b_arr[0] = 0;
lv_stir_b_end = 0;
lv_stir_b_max = 0;
define stirling2(nn,kk) {
   # local-use Bc lv_stir_b_arr[];
   # local-use Bc lv_stir_b_end;
   # local-use Bc lv_stir_b_max;
   auto col_k,ul_ind,cz_ind,ii,retvalu;
   if (nn < kk || nn < 0 || kk < 0) {
      retvalu = 0;
   } else {
      if (lv_stir_b_end <= 0) {
         lv_stir_b_max = 2;
         lv_stir_b_end = d2lt_d1(lv_stir_b_max,0);
         lv_stir_b_arr[0] = 1;
         lv_stir_b_arr[1] = 0;
         lv_stir_b_arr[2] = 1;
      }
      ii = lv_stir_b_max;
      if (ii < nn + 1) {
         lv_stir_b_end = d2lt_d1(nn + 1,0);
         while (ii <= nn) {
            cz_ind = d2lt_d1(ii,0);
            lv_stir_b_arr[cz_ind] = 0;
            cz_ind += 1;
            ul_ind = d2lt_d1(ii - 1,0);
            for (col_k = 1; col_k <= ii - 1; col_k += 1) {
               lv_stir_b_arr[cz_ind] = (lv_stir_b_arr[ul_ind] + col_k *\
                        lv_stir_b_arr[ul_ind + 1]);
               ul_ind += 1;
               cz_ind += 1;
            }
            lv_stir_b_arr[cz_ind] = 1;
            ii += 1;
            lv_stir_b_max = ii;
         }
      }
      retvalu = lv_stir_b_arr[d2lt_d1(nn,kk)];
   }
   return (retvalu);
}
lv_bern_n_arr[0] = 0;
lv_bern_d_arr[0] = 0;
lv_bern_end = 0;
define bernoulli(nn) {
   # local-use Bc lv_bern_n_arr[];
   # local-use Bc lv_bern_d_arr[];
   # local-use Bc lv_bern_end;
   auto retvalu,sz_ind,coeff,sumn,sumd,jj,ii,gdn,nsumn,nsumd,\
            xkk,nnhalf;
   if (nn == 1) {
      retvalu = -0.5;
   } else if (nn < 0 || isodd(nn)) {
      retvalu = 0.0;
   } else {
      if (lv_bern_end <= 0) {
         lv_bern_end = 3;
         lv_bern_n_arr[0] = 1;
         lv_bern_n_arr[1] = 1;
         lv_bern_n_arr[2] = -1;
         lv_bern_d_arr[0] = 1;
         lv_bern_d_arr[1] = 6;
         lv_bern_d_arr[2] = 30;
      }
      nnhalf = floorl(nn / 2);
      if (lv_bern_end <= nnhalf) {
         ii = lv_bern_end;
         lv_bern_end = nnhalf + 1;
         while (ii < lv_bern_end) {
            sz_ind = 2 * ii;
            coeff = ((sz_ind + 1) * sz_ind) / 2;
            sumn = 1.0 - sz_ind;
            sumd = 2.0;
            for (jj = 1; jj <= ii - 1; jj += 1) {
               nsumn = round(sumn * lv_bern_d_arr[jj] + sumd * coeff *\
                        lv_bern_n_arr[jj]);
               nsumd = round(sumd * lv_bern_d_arr[jj]);
               gdn = gcd(nsumn,nsumd);
               sumn = nsumn / gdn;
               sumd = nsumd / gdn;
               xkk = 2 * jj;
               coeff *= (sz_ind - xkk + 1.0) / (xkk + 1.0);
               coeff *= (sz_ind - xkk) / (xkk + 2.0);
               coeff = round(coeff);
            }
            sumd *= (sz_ind + 1);
            gdn = gcd(sumn,sumd);
            lv_bern_n_arr[ii] = -sumn / gdn;
            lv_bern_d_arr[ii] = sumd / gdn;
            ii += 1;
         }
      }
      retvalu = lv_bern_n_arr[nnhalf] / lv_bern_d_arr[nnhalf];
   }
   return (retvalu);
}
define bernoullin(nn) {
   # local-use Bc lv_bern_n_arr[];
   # local-use Bc lv_bern_d_arr[];
   auto retvalu;
   if (nn == 1) {
      retvalu = -1;
   } else if (isodd(nn) || nn < 0) {
      retvalu = 0;
   } else {
      retvalu = bernoulli(nn);
      retvalu = lv_bern_n_arr[nn / 2];
   }
   return (retvalu);
}
define bernoullid(nn) {
   # local-use Bc lv_bern_n_arr[];
   # local-use Bc lv_bern_d_arr[];
   auto retvalu;
   if (nn == 1) {
      retvalu = 2;
   } else if (isodd(nn) || nn < 0) {
      retvalu = 1;
   } else {
      retvalu = bernoulli(nn);
      retvalu = lv_bern_d_arr[nn / 2];
   }
   return (retvalu);
}
define birthday(xnn,xrr) {
   auto prob,ii;
   prob = 1.0;
   for (ii = 1; ii <= xrr - 1; ii += 1) {
      prob *= (xnn - ii) / xnn;
   }
   return (prob);
}
define birthdayinv(xnn,xprob) {
   auto xrr,cprob;
   cprob = 1.0;
   xrr = 1.0;
   while (xprob < cprob) {
      cprob *= (xnn - xrr) / xnn;
      xrr += 1;
   }
   return (xrr);
}
define n2perm(nth,nn,*ret_perm_arr_p[]) {
   auto ii,jj,kk,nthmod,pat_arr[],source_arr[],sz_ind,\
            local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   nthmod = modulo(nth,factorial(nn));
   kk = nthmod;
   for (ii = 1; ii <= nn; ii += 1) {
      pat_arr[nn - ii] = kk % ii;
      kk = floor(kk / ii);
      source_arr[ii - 1] = ii - 1;
   }
   for (ii = 0; ii <= nn - 1; ii += 1) {
      sz_ind = pat_arr[ii];
      ret_perm_arr_p[ii] = source_arr[sz_ind];
      for (jj = sz_ind; jj <= nn - ii - 2; jj += 1) {
         source_arr[jj] = source_arr[jj + 1];
      }
   }
   scale = local_prev_scale;
   return (nthmod);
}
define n2comb(nth,nn,rr,*ret_comb_arr_p[]) {
   auto kk,cc,qq,ss,pp,nthmod,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   nthmod = modulo(nth,comb(nn,rr));
   kk = comb(nn,rr) - nthmod;
   for (ss = 0; ss <= rr - 1; ss += 1) {
      pp = rr - ss;
      cc = 1;
      qq = 1;
      while (cc < kk) {
         kk -= cc;
         cc = (cc * pp) / qq;
         qq += 1;
         pp += 1;
      }
      ret_comb_arr_p[ss] = nn - pp;
   }
   scale = local_prev_scale;
   return (nthmod);
}
define n2perm_print(nth,nn) {
   auto perm_arr[],jj;
   jj = n2perm(nth,nn,perm_arr[]);
   bcdummy = print_array(nn,perm_arr[]);
   return (jj);
}
define n2comb_print(nth,nn,rr) {
   auto comb_arr[],jj;
   jj = n2comb(nth,nn,rr,comb_arr[]);
   bcdummy = print_array(rr,comb_arr[]);
   return (jj);
}
define pochhammer(nn,xx) {
   auto retvalu,ii;
   if (0 < nn) {
      retvalu = xx;
      for (ii = 1; ii <= nn; ii += 1) {
         retvalu *= (xx + ii);
      }
   } else if (nn < 0) {
      retvalu = xx;
      for (ii = -1; nn <= ii; ii -= 1) {
         retvalu *= (xx + ii);
      }
   } else {
      retvalu = 1.0;
   }
   return (retvalu);
}
define days_in_month(g_year,g_month) {
   auto retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (g_month == 2) {
      if (isleapyear(g_year)) {
         retvalu = 29;
      } else {
         retvalu = 28;
      }
   } else if ((6 * g_month + 1) % 11 < 5) {
      retvalu = 30;
   } else {
      retvalu = 31;
   }
   scale = local_prev_scale;
   return (retvalu);
}
define sec2dhms(seconds) {
   auto dy,hr,mn,tm,sg;
   if (seconds < 0.0) {
      sg = -1.0;
   } else {
      sg = 1.0;
   }
   dy = floor(seconds * cxsecond / cxday);
   tm = (seconds * cxsecond / cxday - dy) * cxday / cxhour;
   hr = floor(tm);
   tm = (tm - hr) * cxhour / cxminute;
   mn = floor(tm);
   tm = (tm - mn) * cxminute / cxsecond;
   return (dy + sg * (hr + (mn + tm / 100.0) / 100.0) / 100.0);
}
define day2dhms(dayfrac) {
   auto dy,hr,mn,tm,sg;
   if (dayfrac < 0.0) {
      sg = -1.0;
   } else {
      sg = 1.0;
   }
   dy = floor(dayfrac);
   tm = (dayfrac - dy) * cxday / cxhour;
   hr = floor(tm);
   tm = (tm - hr) * cxhour / cxminute;
   mn = floor(tm);
   tm = (tm - mn) * cxminute / cxsecond;
   return (dy + sg * (hr + (mn + tm / 100.0) / 100.0) / 100.0);
}
define day2dhmsinv(xx_hms) {
   auto dy,hr,mn,tm;
   dy = floor(xx_hms);
   tm = (xx_hms - dy) * 100.0;
   hr = floor(tm);
   tm = (tm - hr) * 100.0;
   mn = floor(tm);
   tm = (tm - mn) * 100.0;
   return (dy + (hr * cxhour + mn * cxminute + tm * cxsecond) / cxday);
}
define hms2day(hourx,minutex,secondx) {
   return ((secondx * cxsecond + minutex * cxminute + hourx * cxhour) /\
            cxday);
}
define hour2day(hourx) {
   return (hourx * cxhour / cxday);
}
define day2hour(dayx) {
   return (dayx * cxday / cxhour);
}
define jd2kwt(jjdtime) {
   return ((jjdtime * cxjday - cxjdsec_at_0kwt) / cxkwt);
}
define jd2j2k(jjdtime) {
   return ((jjdtime * cxjday - cxjdsec_at_0j2k) / cxj2kday);
}
define jd2uet(jjdtime) {
   return ((jjdtime * cxjday - cxjdsec_at_0uet) / cxuet);
}
define kwt2jd(kwttime) {
   return ((kwttime * cxkwt + cxjdsec_at_0kwt) / cxjday);
}
define uet2jd(uettime) {
   return ((uettime * cxuet + cxjdsec_at_0uet) / cxjday);
}
define j2k2jd(jtwoktm) {
   return ((jtwoktm * cxj2kday + cxjdsec_at_0j2k) / cxjday);
}
define j2k2kwt(jtwoktm) {
   return (jd2kwt(j2k2jd(jtwoktm)));
}
define j2k2uet(jtwoktm) {
   return (jd2uet(j2k2jd(jtwoktm)));
}
define kwt2j2k(kwttime) {
   return (jd2j2k(kwt2jd(kwttime)));
}
define kwt2uet(kwttime) {
   return (jd2uet(kwt2jd(kwttime)));
}
define uet2kwt(uettime) {
   return (jd2kwt(uet2jd(uettime)));
}
define uet2j2k(uettime) {
   return (jd2j2k(uet2jd(uettime)));
}
define jd2dow(jjd) {
   auto jjtemp;
   jjtemp = floor(jjd + 1.5);
   return (jjtemp % 7);
}
define j2k2dow(jtwok) {
   auto jjtemp;
   jjtemp = floor(jtwok + 6.5);
   return (jjtemp % 7);
}
define ymd2doy(g_year,g_month,g_daymon) {
   auto delta;
   if (2 < g_month) {
      delta = floor(30.6001 * g_month - 32.3);
      if (isleapyear(g_year)) {
         delta += 1;
      }
   } else if (g_month == 2) {
      delta = 31;
   } else {
      delta = 0;
   }
   return (delta + g_daymon);
}
define ymd2j2k__1(g_year,g_month,g_day) {
   auto yr,mn,jtwok,jcen,dayoffset;
   yr = g_year - cxgyear_at_0j2k;
   mn = g_month;
   if (mn < 3) {
      mn += cxmonths_in_year;
      yr -= 1;
   }
   jcen = floor(yr / 100);
   dayoffset = jcen - floor(jcen / 4.0) + 31.3;
   jtwok = (floor(yr * cxjyear / cxjday) + floor(30.6001 * mn -\
            dayoffset) + g_day - 1.5);
   return (jtwok);
}
define ymd2j2k(g_year,g_month,g_day) {
   auto yr,mn,jtwok,jcen;
   yr = g_year - cxgyear_at_0j2k;
   mn = g_month;
   jcen = floor((yr - 1) / 100);
   jtwok = (floor(yr * cxjyear / cxjday - 0.001) + floor(jcen / 4.0) -\
            jcen + ymd2doy(yr,mn,g_day) - 0.5);
   return (jtwok);
}
define ymd2jd(g_year,g_month,g_day) {
   return (j2k2jd(ymd2j2k(g_year,g_month,g_day)));
}
define ymd2dow(g_year,g_month,g_daymon) {
   return (jd2dow(ymd2jd(g_year,g_month,g_daymon)));
}
define doomsday(g_year) {
   auto cc,yy,lps,anchor,retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   cc = floor(g_year / 100);
   anchor = (cc % 4) * 5 + 2;
   yy = g_year % 100;
   lps = floor(yy / 4);
   retvalu = (anchor + yy + lps) % 7;
   scale = local_prev_scale;
   return (retvalu);
}
cxlc_gd_year = 0;
cxlc_gd_month = 1;
cxlc_gd_day = 2;
cxlc_gd_hour = 3;
cxlc_gd_min = 4;
cxlc_gd_sec = 5;
cxlc_gd_dow = 6;
cxlc_gd_num = 7;
cxlc_gd_jd = 8;
cxlc_gd_cnt = 9;
lv_ymdhms_arr[0] = 0;
define jd2ymdhms(jjulid) {
   # local-use Bc lv_ymdhms_arr[];
   auto jcent,bbdays,bdiff,g_years,month_next,ftime_frac,dtime_rem,\
            ijulian;
   lv_ymdhms_arr[cxlc_gd_jd] = jjulid;
   ftime_frac = frac(jjulid + 0.5);
   ijulian = floor(jjulid + 0.5);
   jcent = floor(((ijulian - 60.5) * cxjday - cxjdsec_at_0gregorian) /\
            (100.0 * cxgyear));
   bbdays = ijulian + jcent - floor(jcent / 4.0);
   g_years = floor((bbdays + 1399.9) * cxjday / cxjyear);
   bdiff = bbdays - floor(g_years * cxjyear / cxjday) + 1522;
   month_next = floor(bdiff / 30.6001);
   dtime_rem = bdiff - floor(30.6001 * month_next) + ftime_frac;
   lv_ymdhms_arr[cxlc_gd_year] = g_years - 4716.0;
   if (13 < month_next) {
      lv_ymdhms_arr[cxlc_gd_month] = month_next - 13;
   } else {
      lv_ymdhms_arr[cxlc_gd_month] = month_next - 1;
   }
   if (lv_ymdhms_arr[cxlc_gd_month] < 3) {
      lv_ymdhms_arr[cxlc_gd_year] += 1;
   }
   lv_ymdhms_arr[cxlc_gd_day] = floor(dtime_rem);
   dtime_rem = cxday / cxhour * frac(dtime_rem);
   lv_ymdhms_arr[cxlc_gd_hour] = floor(dtime_rem);
   dtime_rem = cxhour / cxminute * frac(dtime_rem);
   lv_ymdhms_arr[cxlc_gd_min] = floor(dtime_rem);
   dtime_rem = cxminute / cxsecond * frac(dtime_rem);
   lv_ymdhms_arr[cxlc_gd_sec] = dtime_rem;
   lv_ymdhms_arr[cxlc_gd_dow] = floor(fmod(ijulian + 1.0,7.0));
   dtime_rem = (lv_ymdhms_arr[cxlc_gd_month] * 100.0 +\
            lv_ymdhms_arr[cxlc_gd_day] + lv_ymdhms_arr[cxlc_gd_hour] /\
            100.0 + lv_ymdhms_arr[cxlc_gd_min] / 10000.0 +\
            lv_ymdhms_arr[cxlc_gd_sec] / 1000000.0);
   ftime_frac = lv_ymdhms_arr[cxlc_gd_year] * 10000.0;
   if (ftime_frac < 0.0) {
      lv_ymdhms_arr[cxlc_gd_num] = ftime_frac - dtime_rem;
   } else {
      lv_ymdhms_arr[cxlc_gd_num] = ftime_frac + dtime_rem;
   }
   return (lv_ymdhms_arr[cxlc_gd_num]);
}
define j2k2ymdhms(jtwokd) {
   return (jd2ymdhms(j2k2jd(jtwokd)));
}
define ymdhms_get(indexp) {
   # local-use Bc lv_ymdhms_arr[];
   auto retvalu;
   if (cxlc_gd_year <= indexp && indexp < cxlc_gd_cnt) {
      retvalu = lv_ymdhms_arr[indexp];
   } else {
      retvalu = -1;
   }
   return (retvalu);
}
define jd2ymdhmsinv() {
   # local-use Bc lv_ymdhms_arr[];
   return (ymd2jd(lv_ymdhms_arr[cxlc_gd_year],\
            lv_ymdhms_arr[cxlc_gd_month],lv_ymdhms_arr[cxlc_gd_day]) +\
            hms2day(lv_ymdhms_arr[cxlc_gd_hour],\
            lv_ymdhms_arr[cxlc_gd_min],lv_ymdhms_arr[cxlc_gd_sec]) *\
            cxday / cxjday);
}
define jd264_print(jjulid) {
   bcdummy = jd2ymdhms(jjulid);
   bcdummy = base_out_print(ymdhms_get(cxlc_gd_year),64);
   bcdummy = base_out_print(ymdhms_get(cxlc_gd_month),64);
   bcdummy = base_out_print(ymdhms_get(cxlc_gd_day),64);
   bcdummy = base_out_print(ymdhms_get(cxlc_gd_hour),64);
   bcdummy = base_out_print(ymdhms_get(cxlc_gd_min),64);
   bcdummy = base_outf_print(ymdhms_get(cxlc_gd_sec),64);
   return (jjulid);
}
define ymdhms2jd(ymdhmsx) {
   auto xx_arr[],ys;
   ys = ymdhmsx * (1.0 + cxdbleps);
   xx_arr[cxlc_gd_year] = floor(ys / 10000.0);
   if (ys < 0) {
      ys = -ys;
   }
   xx_arr[cxlc_gd_month] = fmodu(floor(ys / 100.0),100.0);
   xx_arr[cxlc_gd_day] = fmodu(floor(ys),100.0);
   xx_arr[cxlc_gd_hour] = fmodu(floor(ys * 100.0),100.0);
   xx_arr[cxlc_gd_min] = fmodu(floor(ys * 10000.0),100.0);
   xx_arr[cxlc_gd_sec] = frac(ys * 10000.0) * 100.0;
   return (ymd2jd(xx_arr[cxlc_gd_year],xx_arr[cxlc_gd_month],\
            xx_arr[cxlc_gd_day]) + hms2day(xx_arr[cxlc_gd_hour],\
            xx_arr[cxlc_gd_min],xx_arr[cxlc_gd_sec]) * cxday / cxjday);
}
define ymdhms2j2k(ymdhmsx) {
   return (jd2j2k(ymdhms2jd(ymdhmsx)));
}
define clocksec(secnds) {
   return (frac(secnds / cxminute) * cxtau);
}
define clockmin(secnds) {
   return (frac(secnds / cxhour) * cxtau);
}
define clockhour(secnds) {
   return (frac(secnds / (cxday / 2)) * cxtau);
}
define clocksum(secnds) {
   auto sc,mn,hr;
   sc = clocksec(secnds);
   mn = clockmin(secnds);
   hr = clockhour(secnds);
   return (dist(sc - mn,cxtau) + dist(hr - mn,cxtau) + dist(sc - hr,\
            cxtau));
}
define clockstdev(secnds) {
   auto sc,mn,hr,da,db,dc;
   sc = clocksec(secnds);
   mn = clockmin(secnds);
   hr = clockhour(secnds);
   da = dist(sc - mn,cxtau);
   db = dist(hr - mn,cxtau);
   dc = dist(sc - hr,cxtau);
   return (sqrt((da * da + db * db + dc * dc - square(da + db + dc) /\
            3.0) / 2.0));
}
cxlc_halaqim_per_hour = 1080;
cxlx_halaqim = cxhour / cxlc_halaqim_per_hour;
cxlc_year_per_metonic = 19;
define date_easter(g_year) {
   auto century,ii,dow,kk,jj,skipped_leap,modmet,leap_years,\
            local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   century = floor(g_year / 100);
   modmet = g_year % cxlc_year_per_metonic;
   skipped_leap = century - floor(century / 4);
   leap_years = floor(g_year / 4);
   kk = floor((century + 8) / 25 - 1);
   jj = floor((century - kk) / 3);
   ii = (skipped_leap - jj + cxlc_year_per_metonic * modmet + 15) % 30;
   if (28 < ii || (ii == 28 && 10 < modmet)) {
      ii -= 1;
   }
   dow = (g_year + leap_years + ii + 2 - skipped_leap) % 7;
   scale = local_prev_scale;
   return (ii - dow + 28);
}
define date_rosh_hashanah(g_year) {
   auto aa,dos,day_of_september,parts,doww,am;
   aa = (12 * g_year + 12) % cxlc_year_per_metonic;
   am = round(cxmoon_month / cxlx_halaqim) * aa - 1565.0 * g_year;
   dos = floor(g_year / 100) - floor(g_year / 400) - 2 + (g_year % 4) /\
            4.0 + (am - 445405) / (cxlc_year_per_metonic * cxday /\
            cxlx_halaqim);
   day_of_september = floor(dos);
   parts = (dos - day_of_september) * cxday / cxlx_halaqim;
   doww = ymd2dow(g_year,9,day_of_september);
   if (doww == 0 || doww == 3 || doww == 5) {
      day_of_september += 1;
   } else if (doww == 1 && 11 < aa && 23269 <= parts) {
      day_of_september += 1;
   } else if (doww == 2 && 6 < aa && 16404 <= parts) {
      day_of_september += 2;
   }
   return (day_of_september - 0.25);
}
define jewish2jdx(hebyear) {
   auto months_el,halaqims_el,hour_el,hq_left,days_left,alt_days,\
            alt_dow,hymod,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   hymod = (hebyear - 1) % cxlc_year_per_metonic;
   months_el = (235 * floor((hebyear - 1) / cxlc_year_per_metonic) + 12 *\
            hymod + floor((7 * hymod + 1) / cxlc_year_per_metonic));
   halaqims_el = 204 + (793 * (months_el % cxlc_halaqim_per_hour));
   hour_el = (5 + (12 * months_el) + 793 * floor(months_el /\
            cxlc_halaqim_per_hour) + floor(halaqims_el /\
            cxlc_halaqim_per_hour));
   days_left = floor(hour_el / (cxday / cxhour)) + 1 + 29 * months_el;
   alt_days = days_left + 347996;
   alt_dow = (alt_days % iround(cxweek / cxday));
   hq_left = (halaqims_el % cxlc_halaqim_per_hour);
   scale = local_prev_scale;
   hq_left += cxday * frac(hour_el * cxhour / cxday) / cxlx_halaqim;
   if (19440 <= hq_left) {
      if (0 == alt_dow || 2 == alt_dow || 4 == alt_dow) {
         alt_days += 2;
      } else {
         alt_days += 1;
      }
   } else if (0 == alt_dow) {
      if (9924 <= hq_left) {
         if (! isjewishleap(hebyear)) {
            alt_days += 2;
         }
      }
   } else if (6 == alt_dow) {
      if (16789 <= hq_left && isjewishleap(hebyear - 1)) {
         alt_days += 1;
      }
   } else if (1 == alt_dow || 3 == alt_dow || 5 == alt_dow) {
      alt_days += 1;
   }
   return (alt_days + 0.25);
}
define isjewishleap(hebyear) {
   return ((7 * hebyear + 1) % cxlc_year_per_metonic < 7);
}
define date_pesach(g_year) {
   auto rh;
   rh = date_rosh_hashanah(g_year);
   return (rh + 21);
}
define g2jewish(g_year) {
   return (g_year + 3761);
}
define jewish2g(hebyear) {
   return (hebyear - 3760);
}
define jewish_months_in_year(hebyear) {
   auto miy;
   if (isjewishleap(hebyear)) {
      miy = 13;
   } else {
      miy = 12;
   }
   return (miy);
}
define jewish_yearlength(hebyear) {
   auto g_year,retvalu;
   g_year = jewish2g(hebyear - 1);
   retvalu = (floor(cxjyear / cxjday) + (date_rosh_hashanah(g_year + 1) -\
            date_rosh_hashanah(g_year)));
   if (isleapyear(g_year + 1)) {
      retvalu += 1;
   }
   return (retvalu);
}
define jewish2jd(hebyear) {
   auto gregyear;
   gregyear = jewish2g(hebyear - 1);
   return (ymd2jd(gregyear,9,date_rosh_hashanah(gregyear)));
}
define isjewish8short(hebyear) {
   auto remten,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   remten = jewish_yearlength(hebyear) % 10;
   scale = local_prev_scale;
   return (remten != 5);
}
define isjewish9short(hebyear) {
   auto remten,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   remten = jewish_yearlength(hebyear) % 10;
   scale = local_prev_scale;
   return (remten == 3);
}
define jewish_monthlength(hebyear,hebmonth) {
   auto retvalu;
   retvalu = 30;
   if (hebmonth < 1 || 13 < hebmonth) {
      retvalu = 0;
   } else if (hebmonth < 8) {
      if (iseven(hebmonth)) {
         retvalu = 29;
      }
   } else if (hebmonth == 8) {
      if (isjewish8short(hebyear)) {
         retvalu = 29;
      }
   } else if (hebmonth == 9) {
      if (isjewish9short(hebyear)) {
         retvalu = 29;
      }
   } else if (hebmonth == 10) {
      retvalu = 29;
   } else if (hebmonth == 11) {
      retvalu = 30;
   } else if (hebmonth == 12) {
      if (! isjewishleap(hebyear)) {
         retvalu = 29;
      }
   } else if (hebmonth == 13 && isjewishleap(hebyear)) {
      retvalu = 29;
   } else {
      retvalu = 0;
   }
   return (retvalu);
}
define jewish_monthbegin(hebyear,hmonth) {
   auto g_year,g_month,hm,gdate;
   g_year = jewish2g(hebyear - 1);
   g_month = 9;
   if (hmonth < cxjewish_first_month) {
      g_year += 1;
      gdate = date_rosh_hashanah(g_year);
      for (hm = cxjewish_first_month - 1; hmonth <= hm; hm -= 1) {
         g_month -= 1;
         gdate += (days_in_month(g_year,g_month) -\
                  jewish_monthlength(hebyear,hm));
      }
   } else {
      gdate = date_rosh_hashanah(g_year);
      for (hm = cxjewish_first_month; hm <= hmonth - 1; hm += 1) {
         gdate -= (days_in_month(g_year,g_month) -\
                  jewish_monthlength(hebyear,hm));
         g_month += 1;
         if (cxmonths_in_year < g_month) {
            g_month = 1;
            g_year += 1;
         }
      }
   }
   return (gdate);
}
define jewishymd2jd(hebyear,hebmonth,hebday) {
   auto jds,hfirst,hmon,moninyear;
   moninyear = jewish_months_in_year(hebyear);
   if (1 <= hebmonth && hebmonth <= moninyear) {
      jds = jewish2jd(hebyear);
      hfirst = cxjewish_first_month;
      hmon = cxjewish_first_month;
      while (hmon != hebmonth) {
         jds += jewish_monthlength(hebyear,hmon);
         hmon += 1;
         if (moninyear < hmon) {
            hmon = 1;
         } else if (hmon == hfirst) {
            hebyear += 1;
            moninyear = jewish_months_in_year(hebyear);
         }
      }
   } else {
      jds = 0;
   }
   return (jds + hebday - 1.0);
}
define amean(xa,xb) {
   return ((xa + xb) / 2.0);
}
define amean1(xa) {
   return ((xa + 1.0) / 2.0);
}
define lmean(xa,xb) {
   auto retvalu,diffy;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      diffy = xa - xb;
      if (0.0001 < abs(diffy)) {
         retvalu = diffy / log(xa / xb);
      } else {
         retvalu = diffy / ln1p(diffy / xb);
      }
   }
   return (retvalu);
}
define lmean1(xa) {
   return (lmean(1.0,xa));
}
define pmean(pp,xa,xb) {
   auto retvalu;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else if (iszero(pp)) {
      retvalu = sqrt(xa * xb);
   } else {
      retvalu = pow((pow(xa,pp) + pow(xb,pp)) / 2.0,1.0 / pp);
   }
   return (retvalu);
}
define gmean(xa,xb) {
   auto retvalu;
   if (xa < 0.0 || xb < 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      retvalu = sqrt(xa * xb);
   }
   return (retvalu);
}
define gmean1(xa) {
   return (gmean(1.0,xa));
}
define hmean(xa,xb) {
   auto retvalu;
   if (xa < 0.0 || xb < 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      retvalu = 2.0 * xa * xb / (xa + xb);
   }
   return (retvalu);
}
define hmean1(xa) {
   return (hmean(1.0,xa));
}
define qmean(xa,xb) {
   auto retvalu;
   if (xa < 0.0 || xb < 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      retvalu = sqrt((xa * xa + xb * xb) / 2.0);
   }
   return (retvalu);
}
define qmean1(xa) {
   return (qmean(1.0,xa));
}
define heronianmean(xa,xb) {
   auto retvalu;
   if (xa < 0.0 || xb < 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      retvalu = (xa + xb + sqrt(xa * xb)) / 3.0;
   }
   return (retvalu);
}
define heronianmean1(xa) {
   return (heronianmean(1.0,xa));
}
define agmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = sqrt(xa * xb);
         xa = (xa + xb) / 2.0;
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff < cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define agmean1(xa) {
   return (agmean(1.0,xa));
}
define ahmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = 2.0 * xa * xb / (xa + xb);
         xa = (xa + xb) / 2.0;
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff < cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define ahmean1(xa) {
   return (ahmean(1.0,xa));
}
define almean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = lmean(xa,xb);
         xa = (xa + xb) / 2.0;
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff < cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define almean1(xa) {
   return (almean(1.0,xa));
}
define aqmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = (xa + xb) / 2.0;
         xa = qmean(xa,xb);
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff < cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define aqmean1(xa) {
   return (aqmean(1.0,xa));
}
define ghmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = 2.0 * xa * xb / (xa + xb);
         xa = sqrt(xa * xb);
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff < cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define ghmean1(xa) {
   return (ghmean(1.0,xa));
}
define glmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = sqrt(xa * xb);
         xa = lmean(xa,xb);
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff < cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define glmean1(xa) {
   return (glmean(1.0,xa));
}
define gqmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = sqrt(xa * xb);
         xa = qmean(xa,xb);
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff < cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define gqmean1(xa) {
   return (gqmean(1.0,xa));
}
define hlmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = 2.0 * xa * xb / (xa + xb);
         xa = lmean(xa,xb);
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff < cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define hlmean1(xa) {
   return (hlmean(1.0,xa));
}
define hqmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = 2.0 * xa * xb / (xa + xb);
         xa = qmean(xa,xb);
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff < cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define hqmean1(xa) {
   return (hqmean(1.0,xa));
}
define lqmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = lmean(xa,xb);
         xa = qmean(xa,xb);
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff < cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define lqmean1(xa) {
   return (lqmean(1.0,xa));
}
define agmean__1(xa,xb) {
   auto ii,retvalu,xtmp,xsgn;
   xsgn = 1.0;
   ii = 0;
   for (;;) {
      xtmp = xa;
      xa = (xa + xb) / 2.0;
      xb = sqrt(abs(xtmp * xb)) * sign(xa);
      if (iswithin(xa,xb,10.0 * cxdbleps)) {
         break; # loop AWAIT
      }
      ii += 1;
      if (20 <= ii) {
         break; # loop AWAIT
      }
   }
   retvalu = xsgn * xtmp;
   return (retvalu);
}
define agcmean(*xa_arr_pc[],*xb_arr_pc[],*ret_arr_p[]) {
   auto gg_arr[],aa_arr[],tt_arr[],pr_arr[],pr_len,pr_theta;
   gg_arr[0] = xa_arr_pc[0];
   gg_arr[1] = xa_arr_pc[1];
   aa_arr[0] = xb_arr_pc[0];
   aa_arr[1] = xb_arr_pc[1];
   for (;;) {
      tt_arr[0] = (aa_arr[0] + gg_arr[0]) / 2;
      tt_arr[1] = (aa_arr[1] + gg_arr[1]) / 2;
      pr_arr[0] = aa_arr[0] * gg_arr[0] - aa_arr[1] * gg_arr[1];
      pr_arr[1] = aa_arr[1] * gg_arr[0] + aa_arr[0] * gg_arr[1];
      pr_len = sqrt(hypot(pr_arr[0],pr_arr[1]));
      pr_theta = atan2(pr_arr[1],pr_arr[0]) / 2.0;
      gg_arr[0] = pr_len * cos(pr_theta);
      gg_arr[1] = pr_len * sin(pr_theta);
      aa_arr[0] = tt_arr[0];
      aa_arr[1] = tt_arr[1];
      if (aa_arr[0] * gg_arr[0] + aa_arr[1] * gg_arr[1] < 0.0) {
         gg_arr[0] = -gg_arr[0];
         gg_arr[1] = -gg_arr[1];
      }
      if (iseq(gg_arr[0],aa_arr[0]) && iseq(gg_arr[1],aa_arr[1])) {
         break; # loop AWAIT
      }
   }
   ret_arr_p[0] = gg_arr[0];
   ret_arr_p[1] = gg_arr[1];
   return (hypot(gg_arr[0],gg_arr[1]));
}
define aghmean(xa,xb,xc) {
   auto ii,ta,tb,tc,retvalu;
   if (xa <= 0.0 || xb <= 0.0 || xc <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb) && iseq(xa,xc)) {
      retvalu = xa;
   } else {
      ii = 0;
      for (;;) {
         ta = xa;
         tb = xb;
         tc = xc;
         xa = (ta + tb + tc) / 3.0;
         xb = cuberoot(ta * tb * tc);
         xc = 3.0 / (1.0 / ta + 1.0 / tb + 1.0 / tc);
         if (iswithin(xa,xc,10.0 * cxdbleps)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xb;
   }
   return (retvalu);
}
define rms(xa,xb) {
   return (sqrt((xa * xa + xb * xb) / 2.0));
}
define agmeaninva(aa,gg) {
   auto new_aa;
   if (gg < aa) {
      new_aa = aa + sqrt(aa * aa - gg * gg);
   } else {
      new_aa = gg + sqrt(gg * gg - aa * aa);
   }
   return (new_aa);
}
define agmeaninvg(aa,gg) {
   auto new_gg;
   if (gg < aa) {
      new_gg = gg * gg / aa;
   } else {
      new_gg = aa * aa / gg;
   }
   return (new_gg);
}
define agmean1inv(yy) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_ii,x_init,dx,cc;
   if (yy <= 0.0) {
      scvx_xx = 0.0;
   } else if (yy < 0.0022) {
      scvx_xx = 1.0 / cxdblmax;
   } else {
      if (yy <= 0.5) {
         x_init = 4.0 * exp(cxpi / (-2.0 * yy));
      } else if (yy < 2.1) {
         cc = yy - 1.0;
         x_init = ((((((((-0.09765625) * cc + 0.12890625) * cc + 0.1875)\
                  * cc + 0.1875) * cc - 0.25) * cc + 0.5) * cc + 2.0) *\
                  cc + 1.0);
      } else {
         cc = -(cxpi / 2.0);
         x_init = yy * wm(cc / (4.0 * yy)) / cc;
      }
      if (yy < 0.06) {
         dx = x_init * 0.1;
      } else {
         dx = x_init * 0.5;
      }
      scvx_dx = dx;
      scvx_xx = x_init;
      scvx_yy = yy - agmean1(scvx_xx);
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = yy - agmean1(scvx_xx);
         if (iseq(scvx_yy,scvx_yp)) {
            break;
         }
         scvx_dx *= - scvx_yy / (scvx_yy - scvx_yp);
      }
   }
   return (scvx_xx);
}
define ghmean1inv(yy) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_ii,x_init;
   if (yy <= 0.0) {
      scvx_xx = 0.0;
   } else {
      if (yy < 0.073) {
         x_init = 0.352 * yy;
      } else {
         x_init = (exp(cxpi * yy / 2.0) - exp(-yy * yy * 0.2)) / 4.0;
      }
      scvx_dx = 0.3;
      scvx_xx = x_init;
      scvx_yy = yy - ghmean1(scvx_xx);
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = yy - ghmean1(scvx_xx);
         if (iseq(scvx_yy,scvx_yp)) {
            break;
         }
         scvx_dx *= - scvx_yy / (scvx_yy - scvx_yp);
      }
   }
   return (scvx_xx);
}
define contraharmonic(nn,*val_arr_pc[]) {
   auto denom,numer,ii;
   numer = 0.0;
   denom = 0.0;
   for (ii = 0; ii <= nn - 1; ii += 1) {
      denom += val_arr_pc[ii] * val_arr_pc[ii];
      numer += val_arr_pc[ii];
   }
   return (denom / numer);
}
cxlc_knuth_max = 1073741823;
cxlc_knuth_quality_cnt = 1009;
cxlc_knuth_kk_cnt = 100;
cxlc_knuth_ll = 37;
cxlc_knuth_tt = 70;
cxlc_knuth_array_cnt = 1100;
lv_ranz_ind = -3;
lv_ranz_magic = 0.0;
lv_ranz_arr[0] = 0;
lv_ran_a_arr[0] = 0;
lv_ran_x_arr[0] = 0;
define lf_ran_cycle(nn) {
   # local-use Bc lv_ran_x_arr[];
   # local-use Bc lv_ran_a_arr[];
   auto aa,bb,cc,mody,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   aa = 0;
   while (aa < cxlc_knuth_kk_cnt) {
      lv_ran_a_arr[aa] = lv_ran_x_arr[aa];
      aa += 1;
   }
   bb = 0;
   cc = (cxlc_knuth_kk_cnt - cxlc_knuth_ll);
   while (aa < nn) {
      mody = lv_ran_a_arr[bb] - lv_ran_a_arr[cc];
      lv_ran_a_arr[aa] = bitwiseand(cxlc_knuth_max,mody);
      aa += 1;
      bb += 1;
      cc += 1;
   }
   aa = 0;
   while (aa < cxlc_knuth_ll) {
      mody = lv_ran_a_arr[bb] - lv_ran_a_arr[cc];
      lv_ran_x_arr[aa] = bitwiseand(cxlc_knuth_max,mody);
      aa += 1;
      bb += 1;
      cc += 1;
   }
   cc = 0;
   while (aa < cxlc_knuth_kk_cnt) {
      mody = lv_ran_a_arr[bb] - lv_ran_x_arr[cc];
      lv_ran_x_arr[aa] = bitwiseand(cxlc_knuth_max,mody);
      aa += 1;
      bb += 1;
      cc += 1;
   }
   scale = local_prev_scale;
   return (bb);
}
define lf_fill_ranz() {
   # local-use Bc lv_ranz_magic;
   # local-use Bc lv_ranz_ind;
   # local-use Bc lv_ranz_arr[];
   # local-use Bc lv_ran_a_arr[];
   auto jj;
   bcdummy = lf_ran_cycle(cxlc_knuth_quality_cnt);
   for (jj = 0; jj <= cxlc_knuth_quality_cnt - 1; jj += 1) {
      lv_ranz_arr[jj] = lv_ran_a_arr[jj];
   }
   lv_ranz_arr[cxlc_knuth_kk_cnt] = -1;
   lv_ranz_ind = 0;
   lv_ranz_magic = magicset();
   return (lv_ranz_arr[0]);
}
define lf_next_ranz() {
   # local-use Bc lv_ranz_magic;
   # local-use Bc lv_ranz_ind;
   # local-use Bc lv_ranz_arr[];
   if (! ismagic(lv_ranz_magic)) {
      bcdummy = rand_init(timee());
   } else if (lv_ranz_arr[lv_ranz_ind] < 0) {
      bcdummy = lf_fill_ranz();
   }
   lv_ranz_ind += 1;
   return (lv_ranz_arr[lv_ranz_ind - 1]);
}
define rand_init_array(seed_size,*seed_arr_pc[]) {
   # local-use Bc lv_ran_x_arr[];
   auto tt,jj,kk,dd,rnd_arr[],rndss,rndx,rndff,seed_ind,bitmask,\
            local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   rndss = bitwiseand((seed_arr_pc[0] + 2),(cxlc_knuth_max - 1));
   for (jj = 0; jj <= cxlc_knuth_kk_cnt - 1; jj += 1) {
      rnd_arr[jj] = rndss;
      rndss = lf_shiftl(rndss,1);
      if (cxlc_knuth_max < rndss) {
         rndss -= (cxlc_knuth_max - 1);
      }
   }
   rndff = 0;
   seed_ind = 0;
   bitmask = 0;
   for (jj = 0; jj <= cxlc_knuth_kk_cnt - 1; jj += 1) {
      if (bitmask <= 1) {
         seed_ind += 1;
         if (seed_size <= seed_ind) {
            break;
         }
         rndff = seed_arr_pc[seed_ind];
         bitmask = lf_shiftl(1,30);
      }
      if (bitwiseand(rndff,bitmask) != 0) {
         rnd_arr[jj] = bitwisexor(bitmask,rnd_arr[jj]);
      }
      bitmask = lf_shiftr(bitmask,1);
   }
   rnd_arr[1] += 1;
   rndss = bitwiseand(seed_arr_pc[0],cxlc_knuth_max);
   tt = cxlc_knuth_tt - 1;
   while (0 < tt) {
      for (jj = cxlc_knuth_kk_cnt - 1; 1 <= jj; jj -= 1) {
         rnd_arr[jj + jj] = rnd_arr[jj];
         rnd_arr[jj + jj - 1] = 0;
      }
      jj = cxlc_knuth_kk_cnt + cxlc_knuth_kk_cnt - 2;
      dd = cxlc_knuth_kk_cnt + cxlc_knuth_ll - 2;
      kk = cxlc_knuth_kk_cnt - 2;
      while (0 <= kk) {
         rndx = rnd_arr[dd] - rnd_arr[jj];
         rnd_arr[dd] = bitwiseand(rndx,cxlc_knuth_max);
         rndx = rnd_arr[kk] - rnd_arr[jj];
         rnd_arr[kk] = bitwiseand(rndx,cxlc_knuth_max);
         dd -= 1;
         kk -= 1;
         jj -= 1;
      }
      if (isodd(rndss)) {
         for (jj = cxlc_knuth_kk_cnt; 1 <= jj; jj -= 1) {
            rnd_arr[jj] = rnd_arr[jj - 1];
         }
         rnd_arr[0] = rnd_arr[cxlc_knuth_kk_cnt];
         jj = rnd_arr[cxlc_knuth_ll] - rnd_arr[0];
         rnd_arr[cxlc_knuth_ll] = bitwiseand(cxlc_knuth_max,jj);
         rndss = lf_shiftr(rndss,1);
      } else if (rndss == 0) {
         tt -= 1;
      } else {
         rndss = lf_shiftr(rndss,1);
      }
   }
   kk = (cxlc_knuth_kk_cnt - cxlc_knuth_ll);
   jj = 0;
   while (jj < cxlc_knuth_ll) {
      lv_ran_x_arr[kk] = rnd_arr[jj];
      kk += 1;
      jj += 1;
   }
   kk = 0;
   while (jj < cxlc_knuth_kk_cnt) {
      lv_ran_x_arr[kk] = rnd_arr[jj];
      kk += 1;
      jj += 1;
   }
   for (jj = 0; jj <= 9; jj += 1) {
      bcdummy = lf_ran_cycle(2 * cxlc_knuth_kk_cnt - 1);
   }
   scale = local_prev_scale;
   bcdummy = lf_fill_ranz();
   return 0;
}
define rand_init(seed) {
   auto sd_arr[];
   sd_arr[0] = floor(seed);
   sd_arr[1] = floor(frac(seed) * cxintmax);
   bcdummy = rand_init_array(2,sd_arr[]);
   return (seed);
}
define randl(nn) {
   auto max_allowed,rndm,retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   max_allowed = cxlc_knuth_max - (cxlc_knuth_max % nn);
   for (;;) {
      rndm = lf_next_ranz();
      if (rndm < max_allowed) {
         break; # loop AWAIT
      }
   }
   retvalu = rndm % nn;
   scale = local_prev_scale;
   return (retvalu);
}
define randd() {
   return ((lf_next_ranz() + lf_next_ranz() / (cxlc_knuth_max + 1.0)) /\
            (cxlc_knuth_max + 1.0));
}
define int_pdf(para_nn,xx) {
   auto retvalu,ff;
   if (xx < 0.0 || para_nn < xx || (! isint(xx))) {
      retvalu = 0.0;
   } else {
      ff = floor(para_nn);
      if (isint(para_nn)) {
         if (xx < para_nn) {
            retvalu = 1.0 / para_nn;
         } else {
            retvalu = 0.0;
         }
      } else {
         if (xx < ff) {
            retvalu = 1.0 / para_nn;
         } else {
            retvalu = 1.0 - ff / para_nn;
         }
      }
   }
   return (retvalu);
}
define int_cdf(para_nn,xx) {
   auto retvalu,ff;
   if (xx <= 0.0) {
      retvalu = 0.0;
   } else if (para_nn <= xx) {
      retvalu = 1.0;
   } else {
      ff = floor(para_nn);
      if (xx < ff) {
         retvalu = (floor(xx) + 1) / para_nn;
      } else {
         retvalu = 1;
      }
   }
   return (retvalu);
}
define int_quantile(para_nn,probx) {
   auto retvalu;
   if (probx <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 - frac(para_nn) / para_nn <= probx) {
      retvalu = ceil(para_nn - 1);
   } else {
      retvalu = floor(para_nn * probx + 1);
   }
   return (retvalu);
}
define int_rand(para_nn) {
   auto retvalu;
   if (para_nn <= 1) {
      retvalu = 0;
   } else {
      retvalu = floorl(randd() * para_nn);
   }
   return (retvalu);
}
define normal_pdf(xx) {
   return (exp(-xx * xx / 2.0) / (sqrt(cxtau)));
}
define normal_cdf(xx) {
   return (erf(xx / cxtwosqrt) / 2.0 + 0.5);
}
define normal_cdf__1(xx) {
   auto retvalu,sum_curr,sum_prev,bb,xx_sqr,ii;
   if (xx <= -10.0) {
      retvalu = 0.0;
   } else if (10.0 <= xx) {
      retvalu = 1.0;
   } else if (iszero(xx)) {
      retvalu = 0.5;
   } else {
      sum_curr = 0.0;
      bb = 1.0 / xx;
      xx_sqr = xx * xx;
      ii = 0;
      for (;;) {
         bb *= xx_sqr / (2.0 * ii + 1.0);
         sum_prev = sum_curr;
         sum_curr += bb;
         if (iseq(sum_prev,sum_curr)) {
            break; # loop AWAIT
         }
         ii += 1;
      }
      retvalu = (sum_curr * exp(-0.5 * (xx_sqr + log(cxtau))) + 0.5);
   }
   return (retvalu);
}
define normal_quantile(probx) {
   return (cxtwosqrt * erfinv(2.0 * probx - 1.0));
}
lv_rand_gau_magic = 0.0;
lv_rand_gau_prev = 0.0;
define normal_rand() {
   # local-use Bc lv_rand_gau_magic;
   # local-use Bc lv_rand_gau_prev;
   auto retvalu,uua,uub,ww;
   if (ismagic(lv_rand_gau_magic)) {
      lv_rand_gau_magic = magicnot();
      retvalu = lv_rand_gau_prev;
   } else {
      for (;;) {
         uua = randd() - 0.5;
         uub = randd() - 0.5;
         ww = uua * uua + uub * uub;
         if (isbetweenx(ww,0.0,0.25)) {
            break; # loop AWAIT
         }
      }
      ww = sqrt(-2.0 * log(4.0 * ww) / ww);
      lv_rand_gau_prev = uub * ww;
      lv_rand_gau_magic = magicset();
      retvalu = uua * ww;
   }
   return (retvalu);
}
define gau_pdf(xx) {
   return (normal_pdf(xx));
}
define gau_cdf(xx) {
   return (normal_cdf(xx));
}
define gau_quantile(probx) {
   return (normal_quantile(probx));
}
define gau_rand() {
   return (normal_rand());
}
define normal_quantile__1(probx) {
   auto retvalu,p_low,qq,rr,denom,numer;
   p_low = 0.02425;
   if (probx <= 0.0) {
      retvalu = -(cxdblmax);
   } else if (1.0 <= probx) {
      retvalu = cxdblmax;
   } else if (p_low <= probx && probx <= 1.0 - p_low) {
      qq = probx - 0.5;
      rr = qq * qq;
      numer = ((((((-(3.96968302866538 * 10^1)) * rr + (2.20946098424521\
               * 10^2)) * rr - (2.75928510446969 * 10^2)) * rr +\
               (1.38357751867269 * 10^2)) * rr - (3.06647980661472 *\
               10^1)) * rr + 2.50662827745924);
      denom = ((((((-(5.44760987982241 * 10^1)) * rr + (1.61585836858041\
               * 10^2)) * rr - (1.55698979859887 * 10^2)) * rr +\
               (6.68013118877197 * 10^1)) * rr - (1.32806815528857 *\
               10^1)) * rr + 1.00000000000000);
      retvalu = (qq * numer / denom);
   } else {
      if (probx < p_low) {
         rr = sqrt(-2.0 * log(probx));
         qq = 1.0;
      } else {
         rr = sqrt(-2.0 * log(1 - probx));
         qq = -1.0;
      }
      numer = ((((((-(7.78489400243029 * 10^-3)) * rr - (3.22396458041136\
               * 10^-1)) * rr - 2.40075827716184) * rr -\
               2.54973253934373) * rr + 4.37466414146497) * rr +\
               2.93816398269878);
      denom = (((((7.78469570904146 * 10^-3) * rr + (3.22467129070040 *\
               10^-1)) * rr + 2.44513413714300) * rr + 3.75440866190742)\
               * rr + 1.00000000000000);
      retvalu = qq * numer / denom;
   }
   return (retvalu);
}
define uni_pdf(max_x,xxp) {
   auto retvalu;
   if (max_x <= 0.0 || xxp <= 0.0 || max_x <= xxp) {
      retvalu = 0.0;
   } else {
      retvalu = 1.0 / max_x;
   }
   return (retvalu);
}
define uni_cdf(max_x,xxp) {
   auto retvalu;
   if (max_x <= 0.0 || xxp < 0.0) {
      retvalu = 0.0;
   } else if (max_x < xxp) {
      retvalu = 1.0;
   } else {
      retvalu = xxp / max_x;
   }
   return (retvalu);
}
define uni_quantile(max_x,probx) {
   auto retvalu;
   if (probx < 0.0 || max_x <= 0.0) {
      retvalu = 0.0;
   } else if (max_x < probx) {
      retvalu = 1.0;
   } else {
      retvalu = probx * max_x;
   }
   return (retvalu);
}
define uni_rand(max_x) {
   return (uni_quantile(max_x,randd()));
}
define exp_pdf(para_scaling,xxp) {
   auto retvalu;
   if (xxp < 0.0 || para_scaling <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = para_scaling * exp(-para_scaling * xxp);
   }
   return (retvalu);
}
define exp_cdf(para_scaling,xxp) {
   auto retvalu;
   if (xxp < 0.0 || para_scaling <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = 1.0 - exp(-para_scaling * xxp);
   }
   return (retvalu);
}
define exp_quantile(para_scaling,probx) {
   auto retvalu;
   if (probx <= 0.0 || para_scaling <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= probx) {
      retvalu = cxdblmax;
   } else {
      retvalu = -log(1.0 - probx) / para_scaling;
   }
   return (retvalu);
}
define exp_rand(para_scaling) {
   return (- log(randd()) / para_scaling);
}
define poi_pdf(meanx,xxp) {
   auto kk,retvalu;
   if (xxp < 0.0 || meanx <= 0.0) {
      retvalu = 0.0;
   } else {
      kk = floor(xxp);
      retvalu = pow(meanx,kk) * exp(-meanx) / factorial(kk);
   }
   return (retvalu);
}
define poi_cdf(meanx,xxp) {
   auto ii,kk,sum,term,retvalu;
   if (xxp <= 0.0 || meanx <= 0.0) {
      retvalu = 0.0;
   } else if (1000.0 < xxp / meanx) {
      retvalu = 1;
   } else {
      term = exp(-meanx);
      sum = term;
      kk = floorl(xxp);
      for (ii = 1; ii <= kk; ii += 1) {
         term *= meanx / ii;
         sum += term;
      }
      retvalu = sum;
   }
   return (retvalu);
}
define poi_quantile(meanx,probx) {
   auto ii,sum,prevsum,term,retvalu;
   if (probx <= 0.0 || meanx <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= probx) {
      retvalu = cxdblmax;
   } else {
      prevsum = 0.0;
      term = exp(-meanx);
      sum = term;
      ii = 0;
      while (sum <= probx) {
         ii += 1;
         term *= meanx / ii;
         prevsum = sum;
         sum += term;
      }
      if (sum - probx < probx - prevsum) {
         retvalu = ii;
      } else {
         retvalu = ii - 1;
      }
   }
   return (retvalu);
}
define poi_rand(meanx) {
   auto prob,poi,sum,nn;
   prob = randd();
   poi = exp(-meanx);
   sum = poi;
   nn = 0;
   while (sum < prob) {
      nn += 1;
      poi *= meanx / nn;
      sum += poi;
   }
   return (nn);
}
define geo_pdf(prob,kk) {
   auto retvalu;
   if (kk < 0 || prob < 0.0 || 1.0 <= prob) {
      retvalu = 0.0;
   } else {
      retvalu = pow(1.0 - prob,kk) * prob;
   }
   return (retvalu);
}
define geo_cdf(prob,kk) {
   auto retvalu;
   if (kk <= -1 || prob < 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= prob) {
      retvalu = 1.0;
   } else {
      retvalu = 1.0 - pow(1.0 - prob,kk + 1);
   }
   return (retvalu);
}
define geo_quantile(prob,probx) {
   auto retvalu;
   if (probx <= 0.0 || 1.0 <= probx || prob <= 0.0 || 1.0 <= prob) {
      retvalu = 0.0;
   } else {
      retvalu = log(1.0 - probx) / log(1.0 - prob) - 1.0;
   }
   return (retvalu);
}
define geo_rand(prob) {
   return (floorl(log(randd()) / log(1.0 - prob)));
}
define cauchy_pdf(para_scaling,xx) {
   return (1.0 / (cxpi * para_scaling * (1.0 + (square(xx /\
            para_scaling)))));
}
define cauchy_cdf(para_scaling,xx) {
   return (taninv(xx / para_scaling) / cxpi + 0.5);
}
define cauchy_quantile(para_scaling,probx) {
   return (para_scaling * tan((probx - 0.5) * cxpi));
}
define cauchy_rand(para_scaling) {
   return (cauchy_quantile(para_scaling,randd()));
}
define logistic_pdf(ss,xx) {
   auto exs,retvalu;
   if (ss <= 0.0) {
      retvalu = 0.0;
   } else {
      exs = exp(-xx / ss);
      retvalu = exs / (ss * pow(1.0 + exs,2.0));
   }
   return (retvalu);
}
define logistic_cdf(ss,xx) {
   auto retvalu;
   if (ss <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = 1.0 / (1.0 + exp(-xx / ss));
   }
   return (retvalu);
}
define logistic_quantile(ss,probx) {
   auto retvalu;
   if (probx <= 0.0 || ss <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= probx) {
      retvalu = 1.0;
   } else {
      retvalu = -ss * log(1.0 / probx - 1.0);
   }
   return (retvalu);
}
define logistic_rand(ss) {
   return (- ss * log(1.0 / randd() - 1.0));
}
define tri_pdf(pp,xxp) {
   auto retvalu;
   if (pp < 0.0 || 1.0 < pp) {
      retvalu = 0.0;
   } else {
      if (xxp < 0.0 || 1.0 < xxp) {
         retvalu = 0.0;
      } else if (xxp < pp) {
         retvalu = divi(2.0 * xxp,pp,2.0);
      } else {
         retvalu = divi(2.0 * (1.0 - xxp),1.0 - pp,2.0);
      }
   }
   return (retvalu);
}
define tri_cdf(pp,xxp) {
   auto retvalu;
   if (pp < 0.0 || 1.0 < pp) {
      retvalu = 0.0;
   } else {
      if (xxp <= 0.0) {
         retvalu = 0.0;
      } else if (xxp < pp) {
         retvalu = xxp * xxp / pp;
      } else if (xxp < 1.0) {
         retvalu = 1.0 - square(1.0 - xxp) / (1.0 - pp);
      } else {
         retvalu = 1.0;
      }
   }
   return (retvalu);
}
define tri_quantile(pp,probx) {
   auto retvalu;
   if (pp < 0.0 || 1.0 < pp) {
      retvalu = 0.0;
   } else {
      if (probx <= 0.0) {
         retvalu = 0.0;
      } else if (probx < pp) {
         retvalu = sqrt(probx * pp);
      } else if (probx < 1.0) {
         retvalu = 1.0 - sqrt((1.0 - probx) * (1.0 - pp));
      } else {
         retvalu = 1.0;
      }
   }
   return (retvalu);
}
define tri_rand(pp) {
   auto xxp,yy;
   xxp = randd();
   yy = randd();
   if (xxp < pp) {
      if (2.0 * xxp < pp * yy) {
         xxp = pp - xxp;
      }
   } else {
      if ((pp - 1.0) * yy < 2.0 * (xxp - 1.0)) {
         xxp = (pp + 1.0) - xxp;
      }
   }
   return (xxp);
}
define trap_pdf(prob_a,prob_b,xx) {
   auto retvalu;
   if (xx < 0.0 || 1.0 < xx || prob_a < 0.0 || prob_b < prob_a || 1.0 <\
            prob_b) {
      retvalu = 0.0;
   } else {
      if (xx < prob_a) {
         retvalu = xx / prob_a;
      } else if (xx <= prob_b) {
         retvalu = 1.0;
      } else {
         retvalu = (1.0 - xx) / (1.0 - prob_b);
      }
   }
   return (retvalu * 2.0 / (1.0 + prob_b - prob_a));
}
define trap_cdf(prob_a,prob_b,xx) {
   auto ff,retvalu;
   if (prob_a < 0.0 || prob_b < prob_a || 1.0 < prob_b) {
      retvalu = 0.0;
   } else if (xx <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= xx) {
      retvalu = 1.0;
   } else {
      ff = 2.0 / (1.0 + prob_b - prob_a);
      if (xx < prob_a) {
         retvalu = ff * xx * xx / (2.0 * prob_a);
      } else if (xx < prob_b) {
         retvalu = ff * (xx - prob_a / 2.0);
      } else {
         retvalu = 1.0 - ff * square(1.0 - xx) / (2.0 * (1.0 - prob_b));
      }
   }
   return (retvalu);
}
define trap_quantile(prob_a,prob_b,xx) {
   auto ff,retvalu;
   if (prob_a < 0.0 || prob_b < prob_a || 1.0 < prob_b) {
      retvalu = 0.0;
   } else if (xx <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= xx) {
      retvalu = 1.0;
   } else {
      ff = 2.0 / (1.0 + prob_b - prob_a);
      if (xx < prob_a * ff / 2.0) {
         retvalu = sqrt((2.0 * prob_a * xx) / ff);
      } else if (xx < 1.0 - ff * (1.0 - prob_b) / 2.0) {
         retvalu = xx / ff + prob_a / 2.0;
      } else {
         retvalu = 1.0 - sqrt(2.0 * (1.0 - prob_b) * (1.0 - xx) / ff);
      }
   }
   return (retvalu);
}
define trap_rand(prob_a,prob_b) {
   auto xx,retvalu;
   retvalu = -1;
   for (;;) {
      xx = randd();
      if (xx < prob_a) {
         if (randd() * prob_a < xx) {
            retvalu = xx;
         }
      } else if (xx <= prob_b) {
         retvalu = xx;
      } else {
         if (randd() * (1.0 - prob_b) < (1.0 - xx)) {
            retvalu = xx;
         }
      }
      if (0.0 <= retvalu) {
         break; # loop AWAIT
      }
   }
   return (retvalu);
}
define pareto_pdf(para_shape,para_scaling,xx) {
   return (para_shape * pow(para_scaling / xx,para_shape) / xx);
}
define pareto_cdf(para_shape,para_scaling,xx) {
   return (1.0 - pow(para_scaling / xx,para_shape));
}
define pareto_quantile(para_shape,para_scaling,probx) {
   return (para_scaling / pow(1.0 - probx,1.0 / para_shape));
}
define pareto_rand(para_shape,para_scaling) {
   return (para_scaling / pow(randd(),1.0 / para_shape));
}
define gompertz_pdf(para_shape,para_scaling,xx) {
   return (exp(para_scaling * xx + para_shape * (1 - exp(para_scaling *\
            xx))) * para_scaling * para_shape);
}
define gompertz_cdf(para_shape,para_scaling,xx) {
   return (1.0 - exp(para_shape * (1.0 - exp(para_scaling * xx))));
}
define gompertz_quantile(para_shape,para_scaling,probx) {
   return (log(1 - log(1.0 - probx) / para_shape) / para_scaling);
}
define gompertz_rand(para_shape,para_scaling) {
   return (gompertz_quantile(para_shape,para_scaling,randd()));
}
define zipf_pdf(ss,max_kk,kk) {
   auto retvalu;
   if (kk <= 0.0 || max_kk < kk) {
      retvalu = 0.0;
   } else {
      retvalu = 1.0 / (pow(kk,ss) * hnm(max_kk,ss));
   }
   return (retvalu);
}
define zipf_cdf(ss,max_kk,kk) {
   auto retvalu;
   if (kk <= 0.0) {
      retvalu = 0.0;
   } else if (max_kk < kk) {
      retvalu = 1.0;
   } else {
      retvalu = hnm(kk,ss) / hnm(max_kk,ss);
   }
   return (retvalu);
}
define zipf_quantile(ss,max_kk,probx) {
   auto ii,summ,target;
   target = probx * hnm(max_kk,ss);
   summ = 0.0;
   ii = 1;
   for (;;) {
      summ += 1.0 / pow(ii,ss);
      if (target <= summ) {
         break; # loop AWAIT
      }
      ii += 1;
   }
   return (ii);
}
define zipf_rand(ss,max_kk) {
   return (zipf_quantile(ss,max_kk,randd()));
}
define beta_pdf(para_shape_a,para_shape_b,xx) {
   return (pow(xx,para_shape_a - 1.0) * pow((1.0 - xx),para_shape_b -\
            1.0) / beta(para_shape_a,para_shape_b));
}
define beta_cdf(para_shape_a,para_shape_b,xx) {
   return (betainc(para_shape_a,para_shape_b,xx));
}
define beta_quantile(para_shape_a,para_shape_b,probx) {
   auto retvalu,scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_ii;
   if (probx <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= probx) {
      retvalu = 1.0;
   } else {
      scvx_dx = 0.50;
      scvx_xx = 0.25;
      scvx_yy = probx - beta_cdf(para_shape_a,para_shape_b,scvx_xx);
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = probx - beta_cdf(para_shape_a,para_shape_b,scvx_xx);
         if (iseq(scvx_yy,scvx_yp)) {
            break;
         }
         scvx_dx *= - scvx_yy / (scvx_yy - scvx_yp);
      }
      retvalu = scvx_xx;
   }
   return (retvalu);
}
define beta_rand(para_shape_a,para_shape_b) {
   return (beta_quantile(para_shape_a,para_shape_b,randd()));
}
define gamma_pdf(para_shape,xxp) {
   auto retvalu;
   if (xxp <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = exp(log(xxp) * (para_shape - 1.0) - xxp) /\
               tgamma(para_shape);
   }
   return (retvalu);
}
define gamma_cdf(para_shape,xxp) {
   auto retvalu,rr,ii,sum;
   if (xxp <= 0.0 || para_shape <= 0.0) {
      retvalu = 0.0;
   } else if (isint(para_shape)) {
      sum = 1.0;
      rr = 1.0;
      for (ii = 1; ii <= para_shape - 1; ii += 1) {
         rr *= xxp / ii;
         sum += rr;
      }
      retvalu = 1.0 - exp(-xxp) * sum;
   } else {
      retvalu = rligamma(para_shape,xxp);
   }
   return (retvalu);
}
define gamma_rand(para_shape) {
   auto i_shape,f_shape,rval,jj,ee,gg,yy,ff,xx,vv,qq,pp;
   i_shape = floor(para_shape);
   rval = 1.0;
   if (para_shape < 5) {
      for (jj = 1; jj <= i_shape; jj += 1) {
         rval *= randd();
      }
      rval = -log(rval);
      f_shape = para_shape - i_shape;
      if (0.00001 < f_shape) {
         pp = e / (f_shape + e);
         for (;;) {
            vv = log(randd());
            if (randd() < pp) {
               xx = exp(vv / f_shape);
               qq = exp(-xx);
            } else {
               xx = 1.0 - vv;
               qq = exp(log(xx) * (f_shape - 1));
            }
            if (randd() < qq) {
               break; # loop AWAIT
            }
         }
         rval += xx;
      }
   } else {
      ee = para_shape - 1.0;
      gg = sqrt(para_shape + ee);
      yy = 0.0;
      ff = 0.0;
      while (rval <= 0.0 || (1.0 + yy * yy) * exp(ee * log(rval / ee) -\
               ff) < randd()) {
         xx = cxpi * randd();
         yy = sin(xx) / cos(xx);
         ff = gg * yy;
         rval = ff + ee;
      }
   }
   return (rval);
}
define chisqr_pdf(df,xxp) {
   auto retvalu;
   if (xxp <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = exp((log(xxp / 2.0) * df - xxp) / 2.0) / (xxp * tgamma(df\
               / 2.0));
   }
   return (retvalu);
}
define chisqr_cdf(df,xxp) {
   auto retvalu;
   if (xxp <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = (1.0 - ruigamma(df / 2.0,xxp / 2.0));
   }
   return (retvalu);
}
define chisqr_rand(df) {
   auto sum,vv,jj;
   sum = 0.0;
   for (jj = 1; jj <= df; jj += 1) {
      vv = gau_rand();
      sum += vv * vv;
   }
   if (! isint(df)) {
      sum += gamma_rand(frac(df) / 2.0) * 2.0;
   }
   return (sum);
}
define binomial_pdf(prob_a,success,trial) {
   auto retvalu;
   if (success < 0 || trial < success) {
      retvalu = 0.0;
   } else {
      retvalu = comb(trial,success) * pow(prob_a,success) * pow(1.0 -\
               prob_a,trial - success);
   }
   return (retvalu);
}
define binomial_cdf(prob_a,success,trial) {
   auto lsum,sfactor,ss,mu,kk;
   if (prob_a <= 0.0 || success < 0) {
      lsum = 0.0;
   } else if (1.0 <= prob_a || trial <= success) {
      lsum = 1.0;
   } else {
      if (trial <= 2 * success) {
         ss = trial - success - 1;
         prob_a = 1.0 - prob_a;
      } else {
         ss = success;
      }
      sfactor = pow(1.0 - prob_a,trial);
      mu = prob_a / (1.0 - prob_a);
      lsum = 0.0;
      for (kk = 0; kk <= ss; kk += 1) {
         lsum += sfactor;
         sfactor *= (mu * (trial - kk)) / (kk + 1.0);
      }
      if (ss != success) {
         lsum = 1.0 - lsum;
      }
   }
   return (lsum);
}
define binomial_rand(prob_a,rr) {
   auto successes;
   successes = 0.0;
   while (0 < rr) {
      if (randd() < prob_a) {
         successes += 1;
      }
      rr -= 1;
   }
   return (successes);
}
define benford_pdf(max_kk,kk) {
   auto retvalu;
   if (kk <= 0.0 || max_kk <= kk) {
      retvalu = 0.0;
   } else {
      retvalu = log(1.0 + 1.0 / kk) / log(max_kk);
   }
   return (retvalu);
}
define benford_cdf(max_kk,kk) {
   auto retvalu;
   if (kk <= 0.0) {
      retvalu = 0.0;
   } else if (max_kk <= kk) {
      retvalu = 1.0;
   } else {
      retvalu = log(kk + 1.0) / log(max_kk);
   }
   return (retvalu);
}
define benford_rand(max_kk) {
   auto ii,summ,target;
   target = randd();
   summ = 0.0;
   ii = 1;
   for (;;) {
      summ += log(1.0 + 1.0 / ii) / log(max_kk);
      if (target <= summ) {
         break; # loop AWAIT
      }
      ii += 1;
   }
   return (ii);
}
define nbd_pdf(prob_a,rsuccesses,kfailures) {
   return (comb(rsuccesses + kfailures - 1,kfailures) * pow(prob_a,\
            rsuccesses) * pow(1.0 - prob_a,kfailures));
}
define nbd_cdf(prob_a,rsuccesses,kfailures) {
   return (1.0 - betainc(kfailures + 1,rsuccesses,1.0 - prob_a));
}
define nbd_rand(prob_a,rsuccesses) {
   auto failures,rr;
   rr = rsuccesses;
   failures = 0;
   while (0 < rr) {
      if (randd() <= prob_a) {
         rr -= 1;
      } else {
         failures += 1;
      }
   }
   return (failures);
}
define polya_pdf(prob_a,rsuccesses,kfailures) {
   return (combx(rsuccesses + kfailures - 1,kfailures) * pow(1.0 -\
            prob_a,kfailures) * pow(prob_a,rsuccesses));
}
define polya_cdf(prob_a,rsuccesses,kfailures) {
   return (1.0 - betainc(kfailures + 1,rsuccesses,1.0 - prob_a));
}
define polya_rand(tt,probx) {
   auto nn,ff,rr,uu,qq;
   nn = 0;
   ff = tt - 1;
   qq = exp(tt * log(probx));
   rr = qq;
   uu = randd();
   while (rr <= uu) {
      nn += 1;
      ff += 1;
      qq *= (1.0 - probx) * ff / nn;
      rr += qq;
   }
   return (nn);
}
define zeta_pdf(ss,ixxp) {
   auto retvalu;
   if (ixxp <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = 1.0 / (zeta(ss) * pow(ixxp,ss));
   }
   return (retvalu);
}
define zeta_cdf(ss,ixxp) {
   auto retvalu;
   if (ixxp <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = hnm(ixxp,ss) / zeta(ss);
   }
   return (retvalu);
}
define ks_cdf(para_nn,xx) {
   auto retvalu,two_tt_sqr,kk,sum,tt;
   if (para_nn <= 0 || xx <= 0.0) {
      retvalu = 0.0;
   } else {
      if (30 < para_nn) {
         tt = xx;
         two_tt_sqr = 2.0 * tt * tt;
         sum = exp(-two_tt_sqr) * (1.0 - 2.0 * tt / (3.0 * sqrt(para_nn))\
                  - two_tt_sqr * (two_tt_sqr / 9.0 - 1.0 / 3.0) / para_nn);
         retvalu = 1.0 - sum;
      } else {
         tt = xx * sqrt(para_nn);
         sum = 0.0;
         kk = para_nn;
         while (tt < kk) {
            sum += comb(para_nn,kk) * pow(kk - tt,kk) * pow(tt +\
                     para_nn - kk,para_nn - kk - 1);
            kk -= 1;
         }
         retvalu = 1.0 - sum * tt / pow(para_nn,para_nn);
      }
   }
   return (retvalu);
}
define ks_a_cdf(xx) {
   auto sum,sum_prev,vv,kk,retvalu;
   if (xx < 0.0001) {
      retvalu = 0.0;
   } else {
      sum = 0.0;
      vv = -square(cxpi / xx) / 8.0;
      kk = 1;
      for (;;) {
         sum_prev = sum;
         sum += exp(vv * kk * kk);
         if (iseq(sum,sum_prev)) {
            break; # loop AWAIT
         }
         kk += 2;
      }
      retvalu = sum * sqrt(cxtau) / xx;
   }
   return (retvalu);
}
define ks_b_cdf(para_nn,xx) {
   auto retvalu,nxx;
   if (xx < 0.0001 || para_nn <= 0) {
      retvalu = 0.0;
   } else {
      nxx = xx + (2.0 * sqrt(para_nn) + 3.0 * xx - 3.0) / (12.0 * para_nn);
      retvalu = ks_a_cdf(nxx);
   }
   return (retvalu);
}
define ks_quantile(para_nn,probx) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_ii;
   if (! isbetween(probx,0.0,1.0)) {
      scvx_xx = 0.0;
   } else {
      scvx_dx = 0.5;
      scvx_xx = 0.25;
      scvx_yy = probx - ks_cdf(para_nn,scvx_xx);
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = probx - ks_cdf(para_nn,scvx_xx);
         if (iseq(scvx_yy,scvx_yp)) {
            break;
         }
         scvx_dx *= - scvx_yy / (scvx_yy - scvx_yp);
      }
   }
   return (scvx_xx);
}
define t_pdf(dfn,xx) {
   return (tgamma((dfn + 1.0) / 2.0) * pow((1.0 + square(xx) / dfn),\
            (-(dfn + 1.0) / 2.0)) / (sqrt(dfn * cxpi) * tgamma(dfn / 2.0)));
}
define lf_subtprob(para_nnx,xx) {
   auto aa,bb,ww,zz,yy,ii,para_nn,retvalu;
   para_nn = floorl(abs(para_nnx));
   ww = atan2(xx,sqrt(para_nn));
   zz = square(cos(ww));
   yy = 1.0;
   ii = para_nn - 2.0;
   while (2.0 <= ii) {
      yy = 1.0 + (ii - 1.0) / ii * zz * yy;
      ii -= 2.0;
   }
   if (iseven(para_nn)) {
      aa = sin(ww) / 2.0;
      bb = 0.5;
   } else {
      if (para_nn == 1) {
         aa = 0.0;
      } else {
         aa = sin(ww) * cos(ww) / cxpi;
      }
      bb = 0.5 + ww / cxpi;
   }
   retvalu = bb + aa * yy;
   if (1.0 < retvalu) {
      retvalu = 1.0;
   }
   return (retvalu);
}
define t_cdf(dfx,xx) {
   return (lf_subtprob(dfx,xx));
}
define lf_t_quantile(ndfx,probx) {
   auto ux,uxsq,aa_x,bb_x,cc_x,dd_x,ee_x,retvalu,delta,pp_a,\
            nn_a,out_sign;
   if (probx < 0.5) {
      probx = 1.0 - probx;
      out_sign = -1;
   } else {
      out_sign = 1;
   }
   ux = normal_quantile(probx);
   uxsq = square(ux);
   aa_x = ((1.0) * uxsq + 1.0) / 4.0;
   bb_x = (((5.0) * uxsq + 16.0) * uxsq + 3.0) / 96.0;
   cc_x = ((((3.0) * uxsq + 19.0) * uxsq + 17.0) * uxsq - 15.0) / 384.0;
   dd_x = (((((79.0) * uxsq + 776.0) * uxsq + 1482.0) * uxsq - 1920.0) *\
            uxsq - 945.0) / 92160.0;
   ee_x = ((((((27.0) * uxsq + 339.0) * uxsq + 930.0) * uxsq - 1782.0) *\
            uxsq - 765.0) * uxsq - 17955.0) / 368640.0;
   retvalu = ux * (1.0 + (aa_x + (bb_x + (cc_x + (dd_x + ee_x / ndfx) /\
            ndfx) / ndfx) / ndfx) / ndfx);
   if (ndfx <= square(log10(probx)) + 3.0) {
      nn_a = ndfx + 1.0;
      for (;;) {
         pp_a = lf_subtprob(ndfx,retvalu);
         ee_x = (nn_a * log(nn_a / (ndfx + square(retvalu))) + log(ndfx /\
                  nn_a / cxtau) - 1.0 + (1.0 / nn_a - 1.0 / ndfx) / 6.0)\
                  / 2.0;
         if (cxdblmaxln / 2.0 < ee_x) {
            delta = 0.0;
         } else {
            delta = (pp_a - probx) / exp(ee_x);
         }
         retvalu -= delta;
         aa_x = abs(delta) * 10000.0;
         if (iszero(retvalu) || aa_x < retvalu) {
            break; # loop AWAIT
         }
      }
   }
   return (out_sign * retvalu);
}
define t_quantile(dfx,probx) {
   auto ndfx,retvalu;
   ndfx = floor(abs(dfx));
   if (iszero(probx - 0.5)) {
      retvalu = 0.0;
   } else if (probx <= 0.0) {
      retvalu = -cxdblmax;
   } else if (1.0 <= probx) {
      retvalu = cxdblmax;
   } else {
      retvalu = lf_t_quantile(ndfx,probx);
   }
   return (retvalu);
}
define t_cdf__1(dfx,xx) {
   auto zz,yy;
   yy = sqrt(dfx + xx * xx);
   zz = (xx + yy) / (2.0 * yy);
   return (betainc__1(dfx / 2.0,dfx / 2.0,zz));
}
define t_quantile__1(dfx,probx) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_ii;
   if (! isbetween(probx,0.0,1.0)) {
      scvx_xx = 0.0;
   } else {
      scvx_dx = 0.5;
      scvx_xx = 0.25;
      scvx_yy = probx - t_cdf(dfx,scvx_xx);
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = probx - t_cdf(dfx,scvx_xx);
         if (iseq(scvx_yy,scvx_yp)) {
            break;
         }
         scvx_dx *= - scvx_yy / (scvx_yy - scvx_yp);
      }
   }
   return (scvx_xx);
}
define f_cdf(dfn_a,dfn_b,xx) {
   auto aa,bb,gg;
   aa = dfn_a / 2.0;
   bb = dfn_b / 2.0;
   gg = aa * xx;
   return (beta_cdf(aa,bb,gg / (bb + gg)));
}
define lf_subfprob(dfn_a,dfn_b,xx) {
   auto retvalu,zx,ax,bx,yx,ix,pp_a;
   if (xx <= 0.0) {
      retvalu = 1.0;
   } else if (iseven(dfn_b)) {
      zx = dfn_b / (dfn_b + dfn_a * xx);
      ax = 1.0;
      for (ix = dfn_b - 2; 2 <= ix; ix -= 2) {
         ax = 1.0 + (dfn_a + ix - 2.0) / ix * zx * ax;
      }
      retvalu = 1.0 - (pow(1.0 - zx,dfn_a / 2.0) * ax);
   } else if (iseven(dfn_a)) {
      zx = dfn_a * xx / (dfn_b + dfn_a * xx);
      ax = 1.0;
      for (ix = dfn_a - 2; 2 <= ix; ix -= 2) {
         ax = 1.0 + (dfn_b + ix - 2.0) / ix * zx * ax;
      }
      retvalu = pow(1.0 - zx,dfn_b / 2.0) * ax;
   } else {
      yx = atan2(sqrt(dfn_a * xx / dfn_b),1.0);
      zx = square(sin(yx));
      if (dfn_a == 1) {
         ax = 0.0;
      } else {
         ax = 1.0;
      }
      for (ix = dfn_a - 2; 3 <= ix; ix -= 2) {
         ax = 1.0 + (dfn_b + ix - 2.0) / ix * zx * ax;
      }
      bx = cxpi;
      for (ix = 2; ix <= dfn_b - 1; ix += 2) {
         bx *= (ix - 1.0) / ix;
      }
      pp_a = 2.0 / bx * sin(yx) * pow(cos(yx),dfn_b) * ax;
      zx = square(cos(yx));
      if (dfn_b == 1) {
         ax = 0.0;
      } else {
         ax = 1.0;
      }
      for (ix = dfn_b - 2; 3 <= ix; ix -= 2) {
         ax = 1.0 + (ix - 1.0) / ix * zx * ax;
      }
      retvalu = pp_a + 1.0 - 4.0 * (yx + sin(yx) * cos(yx) * ax) / cxtau;
      if (retvalu < 0.0) {
         retvalu = 0.0;
      }
   }
   return (retvalu);
}
define lf_subf_two(nx,qq,pp) {
   auto uu,nxs,xx_prev,xx,zz;
   uu = chisqr_cdf(nx,pp);
   nxs = nx - 2.0;
   xx = (uu / nx * (1.0 + ((uu - nxs) / 2.0 + (((4.0 * uu - 11.0 * nxs) *\
            uu + nxs * (7.0 * nx - 10.0)) / 24.0 + (((2.0 * uu - 10.0 *\
            nxs) * uu + nxs * (17.0 * nx - 26.0)) * uu - nxs * nxs * (9.0\
            * nx - 6.0)) / 48.0 / qq) / qq) / qq));
   for (;;) {
      if (xx <= 0.0) {
         break;
      }
      zz = exp(((nx + qq) * log((nx + qq) / (nx * xx + qq)) + (nx - 2.0)\
               * log(xx) + log(nx * qq / (nx + qq)) - cxtwoln -\
               log(cxtau) - (1.0 / nx + 1.0 / qq - 1.0 / (nx + qq)) /\
               6.0) / 2.0);
      xx_prev = xx;
      xx += (lf_subfprob(nx,qq,xx) - pp) / zz;
      if (iswithin(xx,xx_prev,0.00001)) {
         break; # loop AWAIT
      }
   }
   return (xx);
}
define lf_subfx(nx,jj,pp) {
   auto retvalu,uu,aa;
   if (iseq(pp,1.0)) {
      retvalu = 0.0;
   } else if (jj == 0) {
      retvalu = 1.0 / square(t_quantile(nx,0.5 - pp / 2.0));
   } else if (nx == 1) {
      retvalu = square(t_quantile(jj,pp / 2.0));
   } else if (jj == 2) {
      uu = chisqr_cdf(jj,1.0 - pp);
      aa = jj - 2.0;
      retvalu = 1.0 / (uu / jj * (1.0 + ((uu - aa) / 2.0 + (((4.0 * uu -\
               11.0 * aa) * uu + aa * (7.0 * jj - 10)) / 24.0 + (((2.0 *\
               uu - 10.0 * aa) * uu + aa * (17.0 * jj - 26)) * uu - aa *\
               aa * (9.0 * jj - 6.0)) / 48.0 / nx) / nx) / nx));
   } else if (jj < nx) {
      retvalu = 1.0 / lf_subf_two(jj,nx,1.0 - pp);
   } else {
      retvalu = lf_subf_two(nx,jj,pp);
   }
   return (retvalu);
}
define f_quantile(dfn_a,dfn_b,probx) {
   return (lf_subfx(dfn_a,dfn_b,1.0 - probx));
}
define f_quantile__1(dfn_a,dfn_b,probx) {
   auto retvalu,scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_ii;
   if (probx <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= probx) {
      retvalu = 1.0;
   } else {
      scvx_dx = 0.50;
      scvx_xx = 0.25;
      scvx_yy = probx - f_cdf(dfn_a,dfn_b,scvx_xx);
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = probx - f_cdf(dfn_a,dfn_b,scvx_xx);
         if (iseq(scvx_yy,scvx_yp)) {
            break;
         }
         scvx_dx *= - scvx_yy / (scvx_yy - scvx_yp);
      }
      retvalu = scvx_xx;
   }
   return (retvalu);
}
define mb_pdf(aa,xx) {
   return (sqrt(4 / cxtau) * xx * xx * exp(-xx * xx / (2 * aa * aa)) /\
            (aa * aa * aa));
}
define mb_cdf(aa,xx) {
   return (erf(xx / (cxtwosqrt * aa)) - sqrt(4 / cxtau) * xx * exp(-xx *\
            xx / (2 * aa * aa)) / aa);
}
define maxwell_boltzmann_pdf(cxtemperature,molecular_mass,velocity) {
   auto aa;
   aa = sqrt(cxboltzmann * cxtemperature / molecular_mass);
   return (mb_pdf(aa,velocity));
}
define maxwell_boltzmann_cdf(cxtemperature,molecular_mass,velocity) {
   auto aa;
   aa = sqrt(cxboltzmann * cxtemperature / molecular_mass);
   return (mb_cdf(aa,velocity));
}
define maxwell_juttner_pdf(cxtemperature,molecular_mass,velocity) {
   auto gmm,bt,rtht,dn,retvalu;
   if (cxtemperature <= 0.0 || velocity <= 0.0 || cxlight <= velocity ||\
            molecular_mass <= 0.0) {
      retvalu = 0.0;
   } else {
      rtht = (molecular_mass * cxlight * cxlight) / (cxboltzmann *\
               cxtemperature);
      bt = velocity / cxlight;
      gmm = 1.0 / topyh1(bt);
      dn = besskn(2,rtht);
      if (iszero(dn)) {
         retvalu = 0.0;
      } else {
         retvalu = gmm * gmm * bt * rtht * exp(-gmm * rtht) / dn;
      }
   }
   return (retvalu);
}
define blackbodyl_pdf(wavelen) {
   auto retvalu;
   if (wavelen <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = pow(wavelen,-5.0) / (exp(1.0 / wavelen) - 1.0);
   }
   return (retvalu * 15.0 / pow(cxpi,4.0));
}
define blackbodyf_pdf(freq) {
   auto retvalu;
   if (freq <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = pow(freq,3.0) / (exp(freq) - 1.0);
   }
   return (retvalu * 15.0 / pow(cxpi,4.0));
}
define ints_rand(para_nn,*prob_arr_pc[]) {
   auto sum,p_ind,rndm,hh;
   sum = 0.0;
   for (p_ind = 0; p_ind <= para_nn - 1; p_ind += 1) {
      sum += prob_arr_pc[p_ind];
   }
   rndm = randd();
   hh = 0.0;
   for (p_ind = 0; p_ind <= para_nn - 1; p_ind += 1) {
      hh += prob_arr_pc[p_ind] / sum;
      if (rndm < hh) {
         break;
      }
   }
   return (p_ind);
}
define lf_num2norm(numm) {
   auto retvalu;
   if (numm <= 1) {
      retvalu = 0.0;
   } else {
      retvalu = 3.0 * sqrt(log(numm)) - 1.4 - (0.5 * log(numm) - 0.39) /\
               numm;
   }
   return (retvalu);
}
define stdev2spread(numm,stdevx) {
   auto retvalu;
   if (numm <= 1 || iszero(stdevx)) {
      retvalu = 0.0;
   } else {
      retvalu = (stdevx * lf_num2norm(numm));
   }
   return (retvalu);
}
define spread2stdev(numm,spread) {
   auto retvalu;
   if (numm <= 1 || iszero(spread)) {
      retvalu = 0.0;
   } else {
      retvalu = (spread / lf_num2norm(numm));
   }
   return (retvalu);
}
define maxabs(nn,*data_arr_pc[]) {
   auto ii,maxaby,amaxaby,atemp;
   maxaby = data_arr_pc[0];
   amaxaby = abs(maxaby);
   for (ii = 1; ii <= nn - 1; ii += 1) {
      atemp = abs(data_arr_pc[ii]);
      if (amaxaby < atemp) {
         maxaby = data_arr_pc[ii];
         amaxaby = atemp;
      }
   }
   return (maxaby);
}
define minabs(nn,*data_arr_pc[]) {
   auto ii,minaby,aminaby,atemp;
   minaby = data_arr_pc[0];
   aminaby = abs(minaby);
   for (ii = 1; ii <= nn - 1; ii += 1) {
      atemp = abs(data_arr_pc[ii]);
      if (atemp < aminaby) {
         minaby = data_arr_pc[ii];
         aminaby = atemp;
      }
   }
   return (minaby);
}
define maxabsoffset(offset,nn,*data_arr_pc[]) {
   auto ii,maxaby,delta;
   maxaby = data_arr_pc[0] - offset;
   for (ii = 1; ii <= nn - 1; ii += 1) {
      delta = data_arr_pc[ii] - offset;
      if (abs(maxaby) < abs(delta)) {
         maxaby = delta;
      }
   }
   return (maxaby + offset);
}
define minabsoffset(offset,nn,*data_arr_pc[]) {
   auto ii,minaby,delta;
   minaby = data_arr_pc[0] - offset;
   for (ii = 1; ii <= nn - 1; ii += 1) {
      delta = data_arr_pc[ii] - offset;
      if (abs(delta) < abs(minaby)) {
         minaby = delta;
      }
   }
   return (minaby + offset);
}
define mini(num,*data_arr_pc[]) {
   auto curr,tmp,ii;
   curr = data_arr_pc[0];
   for (ii = 1; ii <= num - 1; ii += 1) {
      tmp = data_arr_pc[ii];
      if (tmp < curr) {
         curr = tmp;
      }
   }
   return (curr);
}
define maxi(num,*data_arr_pc[]) {
   auto curr,tmp,ii;
   curr = data_arr_pc[0];
   for (ii = 1; ii <= num - 1; ii += 1) {
      tmp = data_arr_pc[ii];
      if (curr < tmp) {
         curr = tmp;
      }
   }
   return (curr);
}
define maxmin(num,*data_arr_pc[],*ret_maxmin_arr_p[]) {
   auto tmp,ii,maxx,minn;
   minn = data_arr_pc[0];
   maxx = data_arr_pc[0];
   for (ii = 1; ii <= num - 1; ii += 1) {
      tmp = data_arr_pc[ii];
      if (minn < tmp) {
         minn = tmp;
      }
      if (tmp < maxx) {
         maxx = tmp;
      }
   }
   ret_maxmin_arr_p[0] = maxx;
   ret_maxmin_arr_p[1] = minn;
   return (maxx - minn);
}
define min2(value_a,value_b) {
   auto retvalu;
   if (value_a < value_b) {
      retvalu = value_a;
   } else {
      retvalu = value_b;
   }
   return (retvalu);
}
define max2(value_a,value_b) {
   auto retvalu;
   if (value_b < value_a) {
      retvalu = value_a;
   } else {
      retvalu = value_b;
   }
   return (retvalu);
}
define minabs2(value_a,value_b) {
   auto retvalu;
   if (abs(value_a) < abs(value_b)) {
      retvalu = value_a;
   } else {
      retvalu = value_b;
   }
   return (retvalu);
}
define maxabs2(value_a,value_b) {
   auto retvalu;
   if (abs(value_b) < abs(value_a)) {
      retvalu = value_a;
   } else {
      retvalu = value_b;
   }
   return (retvalu);
}
define variance(nn,*xx_arr_pc[]) {
   auto ii,delta,meanx,variancex;
   meanx = 0.0;
   variancex = 0.0;
   for (ii = 0; ii <= nn - 1; ii += 1) {
      delta = xx_arr_pc[ii] - meanx;
      meanx += delta / (ii + 1.0);
      variancex += delta * (xx_arr_pc[ii] - meanx);
   }
   if (2 <= nn) {
      variancex /= (nn - 1.0);
   } else {
      variancex = 0.0;
   }
   return (variancex);
}
define mean(nn,*xx_arr_pc[]) {
   auto ii,delta,meanx;
   meanx = 0.0;
   for (ii = 0; ii <= nn - 1; ii += 1) {
      delta = xx_arr_pc[ii] - meanx;
      meanx += delta / (ii + 1.0);
   }
   return (meanx);
}
cxlc_stts_num = 0;
cxlc_stts_mean = 1;
cxlc_stts_msq = 2;
cxlc_stts_max = 3;
cxlc_stts_min = 4;
cxlc_stts_magic = 5;
cxlc_stts_cnt = 6;
cxlc_stts_key_cnt = 100;
lv_sttx_mtrx[0][0] = 0;
define lf_stts_is_inited(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   auto vll,ii,jj,retvalu_bol;
   vll = lv_sttx_mtrx[0][cxlc_stts_magic];
   if (vll != magicset() && vll != magicnot()) {
      for (ii = 0; ii <= cxlc_stts_key_cnt - 1; ii += 1) {
         for (jj = 0; jj <= cxlc_stts_magic - 1; jj += 1) {
            lv_sttx_mtrx[ii][jj] = 0.0;
         }
         lv_sttx_mtrx[0][cxlc_stts_magic] = magicnot();
      }
   }
   if (cxlc_stts_key_cnt <= ix_hndl) {
      retvalu_bol = false;
   } else {
      vll = lv_sttx_mtrx[ix_hndl][cxlc_stts_magic];
      retvalu_bol = ismagic(vll);
   }
   return (retvalu_bol);
}
define lf_stts_find_empty() {
   auto ix_hndl;
   ix_hndl = 0;
   while (lf_stts_is_inited(ix_hndl)) {
      ix_hndl += 1;
   }
   if (cxlc_stts_key_cnt <= ix_hndl) {
      halt;
   }
   return (ix_hndl);
}
define stts_init(ix_hndl,n_count,meanx,var,minim,maxim) {
   # local-use Bc lv_sttx_mtrx[];
   lv_sttx_mtrx[ix_hndl][cxlc_stts_num] = n_count;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_mean] = meanx;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] = var * (n_count - 1.0);
   lv_sttx_mtrx[ix_hndl][cxlc_stts_min] = minim;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_max] = maxim;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_magic] = magicset();
   return (ix_hndl);
}
define stts_initx(ix_hndl,num_count,meanx,msq,minim,maxim) {
   # local-use Bc lv_sttx_mtrx[];
   lv_sttx_mtrx[ix_hndl][cxlc_stts_num] = num_count;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_mean] = meanx;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] = msq;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_min] = minim;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_max] = maxim;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_magic] = magicset();
   return (ix_hndl);
}
define stts_reset(ix_hndl) {
   return (stts_init(ix_hndl,0.0,0.0,0.0,1.0,0.0));
}
define stts_new() {
   auto ix_hndl;
   ix_hndl = lf_stts_find_empty();
   return (stts_reset(ix_hndl));
}
define stts_delete(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   lv_sttx_mtrx[ix_hndl][cxlc_stts_magic] = magicnot();
   return (ix_hndl);
}
define sttscount(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   return (lv_sttx_mtrx[ix_hndl][cxlc_stts_num]);
}
define sttsmean(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   return (lv_sttx_mtrx[ix_hndl][cxlc_stts_mean]);
}
define sttsmsq(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   return (lv_sttx_mtrx[ix_hndl][cxlc_stts_msq]);
}
define sttsmax(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   return (lv_sttx_mtrx[ix_hndl][cxlc_stts_max]);
}
define sttsmin(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   return (lv_sttx_mtrx[ix_hndl][cxlc_stts_min]);
}
define sttsmagic(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   return (lv_sttx_mtrx[ix_hndl][cxlc_stts_magic]);
}
define sttssum(ix_hndl) {
   return (sttsmean(ix_hndl) * sttscount(ix_hndl));
}
define sttsvar(ix_hndl) {
   auto retvalu;
   if (abs(sttscount(ix_hndl)) <= 1.0) {
      retvalu = 0.0;
   } else {
      retvalu = (sttsmsq(ix_hndl) / (abs(sttscount(ix_hndl) - 1.0)));
   }
   return (retvalu);
}
define sttsstdev(ix_hndl) {
   auto retvalu;
   if (sttscount(ix_hndl) <= 1.0) {
      retvalu = 0.0;
   } else {
      retvalu = (sqrt(sttsmsq(ix_hndl) / (sttscount(ix_hndl) - 1.0)));
   }
   return (retvalu);
}
define sttsstdevmean(ix_hndl) {
   auto retvalu;
   if (sttscount(ix_hndl) <= 1.0 || sttsmsq(ix_hndl) <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = (sqrt(sttsmsq(ix_hndl)) / (sttscount(ix_hndl) - 1.0));
   }
   return (retvalu);
}
define sttsspread(ix_hndl) {
   return (sttsmax(ix_hndl) - sttsmin(ix_hndl));
}
define stts_update(ix_hndl,new_data) {
   # local-use Bc lv_sttx_mtrx[];
   auto delta,numy;
   if (! lf_stts_is_inited(ix_hndl)) {
      halt;
   }
   delta = new_data - lv_sttx_mtrx[ix_hndl][cxlc_stts_mean];
   lv_sttx_mtrx[ix_hndl][cxlc_stts_num] += 1.0;
   numy = lv_sttx_mtrx[ix_hndl][cxlc_stts_num];
   lv_sttx_mtrx[ix_hndl][cxlc_stts_mean] += (delta / numy);
   lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] += (delta * (new_data -\
            lv_sttx_mtrx[ix_hndl][cxlc_stts_mean]));
   if ((numy < 2.0 || sttsspread(ix_hndl) < 0.0)) {
      lv_sttx_mtrx[ix_hndl][cxlc_stts_min] = new_data;
      lv_sttx_mtrx[ix_hndl][cxlc_stts_max] = new_data;
   } else {
      if (new_data < lv_sttx_mtrx[ix_hndl][cxlc_stts_min]) {
         lv_sttx_mtrx[ix_hndl][cxlc_stts_min] = new_data;
      }
      if (lv_sttx_mtrx[ix_hndl][cxlc_stts_max] < new_data) {
         lv_sttx_mtrx[ix_hndl][cxlc_stts_max] = new_data;
      }
   }
   return (delta);
}
define stts_downdate(ix_hndl,old_data) {
   auto delt,men;
   if (! lf_stts_is_inited(ix_hndl)) {
      halt;
   }
   men = lv_sttx_mtrx[ix_hndl][cxlc_stts_mean];
   delt = old_data - men;
   if (0.0 < lv_sttx_mtrx[ix_hndl][cxlc_stts_num]) {
      lv_sttx_mtrx[ix_hndl][cxlc_stts_num] -= 1;
      if (0.0 < lv_sttx_mtrx[ix_hndl][cxlc_stts_num]) {
         men -= delt / lv_sttx_mtrx[ix_hndl][cxlc_stts_num];
         lv_sttx_mtrx[ix_hndl][cxlc_stts_mean] = men;
         lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] -= delt * (old_data - men);
         if (lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] < 0.0) {
            lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] = 0.0;
         }
      } else {
         lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] = 0.0;
         lv_sttx_mtrx[ix_hndl][cxlc_stts_mean] = 0.0;
      }
   }
   return (delt);
}
define stts_updatex(ix_hndl,nn,*data_arr_pc[]) {
   auto ii,retvalu;
   retvalu = 0.0;
   for (ii = 0; ii <= nn - 1; ii += 1) {
      retvalu += stts_update(ix_hndl,data_arr_pc[ii]);
   }
   return (retvalu);
}
define stts_newx(nn,*data_arr_pc[]) {
   auto ihndl,ii;
   ihndl = stts_new();
   for (ii = 0; ii <= nn - 1; ii += 1) {
      bcdummy = stts_update(ihndl,data_arr_pc[ii]);
   }
   return (ihndl);
}
define stts_shift(ix_hndl,data_shift) {
   # local-use Bc lv_sttx_mtrx[];
   lv_sttx_mtrx[ix_hndl][cxlc_stts_max] += data_shift;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_min] += data_shift;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_mean] += data_shift;
   return (ix_hndl);
}
define stts_scale(ix_hndl,xfactor) {
   # local-use Bc lv_sttx_mtrx[];
   auto newmax,newmin;
   if (0 < xfactor) {
      newmax = lv_sttx_mtrx[ix_hndl][cxlc_stts_max] * xfactor;
      newmin = lv_sttx_mtrx[ix_hndl][cxlc_stts_min] * xfactor;
   } else {
      newmax = lv_sttx_mtrx[ix_hndl][cxlc_stts_min] * xfactor;
      newmin = lv_sttx_mtrx[ix_hndl][cxlc_stts_max] * xfactor;
   }
   lv_sttx_mtrx[ix_hndl][cxlc_stts_min] = newmin;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_max] = newmax;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_mean] *= xfactor;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] *= xfactor * xfactor;
   return (ix_hndl);
}
define stts_copy(hto,hfrom) {
   # local-use Bc lv_sttx_mtrx[];
   auto ii;
   for (ii = 0; ii <= cxlc_stts_cnt - 1; ii += 1) {
      lv_sttx_mtrx[hto][ii] = lv_sttx_mtrx[hfrom][ii];
   }
   return (hto);
}
define stts_update2(ix_hnda,ix_hndb) {
   auto delta,ncount,nb,nmean,nmsqr,bmin,bmax,amin,amax;
   if (! lf_stts_is_inited(ix_hndb)) {
      halt;
   }
   nb = sttscount(ix_hndb);
   if (! iszero(nb)) {
      if (! lf_stts_is_inited(ix_hnda)) {
         halt;
      }
      if (iszero(sttscount(ix_hnda))) {
         bcdummy = stts_copy(ix_hnda,ix_hndb);
      } else {
         delta = sttsmean(ix_hndb) - sttsmean(ix_hnda);
         ncount = nb + sttscount(ix_hnda);
         nmean = sttsmean(ix_hnda) + delta * nb / ncount;
         nmsqr = (sttsmsq(ix_hnda) + sttsmsq(ix_hndb) + delta * delta *\
                  sttscount(ix_hnda) * nb / ncount);
         amin = sttsmin(ix_hnda);
         amax = sttsmax(ix_hnda);
         bmin = sttsmin(ix_hndb);
         bmax = sttsmax(ix_hndb);
         if (amax < amin) {
            amin = bmin;
            amax = bmax;
         } else {
            if (bmin < amin) {
               amin = bmin;
            }
            if (amax < bmax) {
               amax = bmax;
            }
         }
         bcdummy = stts_init(ix_hnda,ncount,nmean,nmsqr / (ncount -\
                  1.0),amin,amax);
      }
   }
   return (ix_hnda);
}
cxlc_sttsc_xx = 0;
cxlc_sttsc_yy = 1;
cxlc_sttsc_covar = 2;
cxlc_sttsc_magic = 3;
cxlc_sttsc_cnt = 4;
lv_crx_mtrx[0][0] = 0;
define lf_corr_is_init(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   auto retvalu_bol,vll;
   if (cxlc_stts_key_cnt <= ix_chnd) {
      retvalu_bol = false;
   } else {
      vll = lv_crx_mtrx[ix_chnd][cxlc_sttsc_magic];
      retvalu_bol = ismagic(vll);
   }
   return (retvalu_bol);
}
define lf_corr_find_empty() {
   auto ix_chnd;
   ix_chnd = 0;
   while (lf_corr_is_init(ix_chnd)) {
      ix_chnd += 1;
   }
   if (cxlc_stts_key_cnt <= ix_chnd) {
      halt;
   }
   return (ix_chnd);
}
define corr_new() {
   # local-use Bc lv_crx_mtrx[];
   auto ix_chnd;
   ix_chnd = lf_corr_find_empty();
   lv_crx_mtrx[ix_chnd][cxlc_sttsc_xx] = stts_new();
   lv_crx_mtrx[ix_chnd][cxlc_sttsc_yy] = stts_new();
   lv_crx_mtrx[ix_chnd][cxlc_sttsc_covar] = 0.0;
   lv_crx_mtrx[ix_chnd][cxlc_sttsc_magic] = magicset();
   return (ix_chnd);
}
define corr_delete(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   lv_crx_mtrx[ix_chnd][cxlc_sttsc_magic] = magicnot();
   bcdummy = stts_delete(lv_crx_mtrx[ix_chnd][cxlc_sttsc_xx]);
   bcdummy = stts_delete(lv_crx_mtrx[ix_chnd][cxlc_sttsc_yy]);
   return (ix_chnd);
}
define corr_handlex(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   return (lv_crx_mtrx[ix_chnd][cxlc_sttsc_xx]);
}
define corr_handley(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   return (lv_crx_mtrx[ix_chnd][cxlc_sttsc_yy]);
}
define corr_update(ix_chnd,xx,yy) {
   # local-use Bc lv_crx_mtrx[];
   auto num,ddxx,ddyy,yyhnd,xxhnd;
   yyhnd = lv_crx_mtrx[ix_chnd][cxlc_sttsc_yy];
   xxhnd = lv_crx_mtrx[ix_chnd][cxlc_sttsc_xx];
   num = sttscount(xxhnd);
   ddxx = stts_update(xxhnd,xx);
   ddyy = stts_update(yyhnd,yy);
   lv_crx_mtrx[ix_chnd][cxlc_sttsc_covar] += (ddxx * ddyy * num / (num +\
            1.0));
   return (lv_crx_mtrx[ix_chnd][cxlc_sttsc_covar]);
}
define corrslope(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   auto den,retvalu,xxhnd;
   xxhnd = lv_crx_mtrx[ix_chnd][cxlc_sttsc_xx];
   den = sttsmsq(xxhnd);
   if (iszero(den)) {
      retvalu = 0.0;
   } else {
      retvalu = lv_crx_mtrx[ix_chnd][cxlc_sttsc_covar] / den;
   }
   return (retvalu);
}
define corry0(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   auto retvalu,yyhnd,xxhnd;
   yyhnd = lv_crx_mtrx[ix_chnd][cxlc_sttsc_yy];
   xxhnd = lv_crx_mtrx[ix_chnd][cxlc_sttsc_xx];
   retvalu = (sttsmean(yyhnd) - corrslope(ix_chnd) * sttsmean(xxhnd));
   return (retvalu);
}
define corrcorr(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   auto retvalu,xxmsq,yymsq,den;
   xxmsq = sttsmsq(lv_crx_mtrx[ix_chnd][cxlc_sttsc_xx]);
   yymsq = sttsmsq(lv_crx_mtrx[ix_chnd][cxlc_sttsc_yy]);
   den = xxmsq * yymsq;
   if (iszero(den)) {
      retvalu = 0.0;
   } else {
      retvalu = (lv_crx_mtrx[ix_chnd][cxlc_sttsc_covar] / sqrt(den));
   }
   return (retvalu);
}
define corrstderr(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   auto yyhnd,diff,retvalu;
   yyhnd = lv_crx_mtrx[ix_chnd][cxlc_sttsc_yy];
   diff = sttsmsq(yyhnd) - (corrslope(ix_chnd) *\
            lv_crx_mtrx[ix_chnd][cxlc_sttsc_covar]);
   if (diff < 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = sqrt(diff / (sttscount(yyhnd) - 2.0));
   }
   return (retvalu);
}
define fit_poly(num_points,*pts_arr_pc[],*ret_coeff_arr_p[]) {
   auto i_ind,j_ind,k_ind,prod,cc_arr[];
   for (j_ind = 0; j_ind <= num_points - 1; j_ind += 1) {
      cc_arr[j_ind] = pts_arr_pc[2 * j_ind + 1];
   }
   for (j_ind = 1; j_ind <= num_points - 1; j_ind += 1) {
      k_ind = num_points - 1 - j_ind;
      for (i_ind = num_points - 1; j_ind <= i_ind; i_ind -= 1) {
         cc_arr[i_ind] = ((cc_arr[i_ind - 1] - cc_arr[i_ind]) /\
                  (pts_arr_pc[2 * k_ind] - pts_arr_pc[2 * i_ind]));
         k_ind -= 1;
      }
   }
   for (j_ind = 0; j_ind <= num_points - 2; j_ind += 1) {
      for (i_ind = num_points - 2; j_ind <= i_ind; i_ind -= 1) {
         prod = cc_arr[i_ind + 1] * pts_arr_pc[2 * (i_ind - j_ind)];
         cc_arr[i_ind] -= prod;
      }
   }
   for (j_ind = 0; j_ind <= num_points - 1; j_ind += 1) {
      ret_coeff_arr_p[j_ind] = cc_arr[j_ind];
   }
   return (num_points);
}
cxlc_parabola_x_axis = 0;
cxlc_parabola_y_extrema = 1;
cxlc_parabola_real_roots = 2;
cxlc_parabola_root_a = 3;
cxlc_parabola_root_b = 4;
cxlc_parabola_coeff_c = 5;
cxlc_parabola_coeff_b = 6;
cxlc_parabola_coeff_a = 7;
lv_parabola_arr[0] = 0;
define parabola_solve(xx_a,yy_a,xx_b,yy_b,xx_c,yy_c) {
   # local-use Bc lv_parabola_arr[];
   auto pts_arr[],cc_arr[],disc,axis,yyextrema,real_roots,roots_arr[];
   pts_arr[0] = xx_a;
   pts_arr[1] = yy_a;
   pts_arr[2] = xx_b;
   pts_arr[3] = yy_b;
   pts_arr[4] = xx_c;
   pts_arr[5] = yy_c;
   bcdummy = fit_poly(3,pts_arr[],cc_arr[]);
   roots_arr[0] = cxdblmax;
   roots_arr[1] = cxdblmax;
   if (iszero(cc_arr[2])) {
      axis = cxdblmax;
      if (iszero(cc_arr[1])) {
         yyextrema = cc_arr[0];
         real_roots = 0;
      } else {
         yyextrema = cxdblmax;
         real_roots = 1;
         roots_arr[0] = (-cc_arr[0] / cc_arr[1]);
      }
   } else {
      axis = (-cc_arr[1] / (2.0 * cc_arr[2]));
      yyextrema = (cc_arr[0] + xx_a * (cc_arr[1] + xx_a * cc_arr[2]));
      disc = (cc_arr[1] * cc_arr[1] - 4.0 * cc_arr[2] * cc_arr[0]);
      if (iszero(disc)) {
         real_roots = 1;
         roots_arr[0] = axis;
      } else if (0 < disc) {
         disc = sqrt(disc) / (2.0 * cc_arr[2]);
         real_roots = 2;
         roots_arr[0] = axis - disc;
         roots_arr[1] = axis + disc;
      } else {
         real_roots = 0;
      }
   }
   lv_parabola_arr[cxlc_parabola_x_axis] = axis;
   lv_parabola_arr[cxlc_parabola_y_extrema] = yyextrema;
   lv_parabola_arr[cxlc_parabola_real_roots] = real_roots;
   lv_parabola_arr[cxlc_parabola_root_a] = roots_arr[0];
   lv_parabola_arr[cxlc_parabola_root_b] = roots_arr[1];
   lv_parabola_arr[cxlc_parabola_coeff_c] = cc_arr[0];
   lv_parabola_arr[cxlc_parabola_coeff_b] = cc_arr[1];
   lv_parabola_arr[cxlc_parabola_coeff_a] = cc_arr[2];
   return (axis);
}
define parabola_get(ii_ind) {
   # local-use Bc lv_parabola_arr[];
   auto retvalu;
   if (0 <= ii_ind && ii_ind <= 7) {
      retvalu = lv_parabola_arr[ii_ind];
   } else {
      retvalu = 0;
   }
   return (retvalu);
}
define parabola_roots(ii_ind) {
   auto retvalu;
   if (0 <= ii_ind && ii_ind <= 1) {
      retvalu = parabola_get(ii_ind + cxlc_parabola_root_a);
   } else {
      retvalu = cxdblmax;
   }
   return (retvalu);
}
define parabola_yextrema() {
   return (parabola_get(cxlc_parabola_y_extrema));
}
define parabola_xaxis() {
   return (parabola_get(cxlc_parabola_x_axis));
}
define parabola_realroots() {
   return (parabola_get(cxlc_parabola_real_roots));
}
cxlc_circle_x = 0;
cxlc_circle_y = 1;
cxlc_circle_radius = 2;
lv_circle_arr[0] = 0;
define circle_solve(x_a,y_a,x_b,y_b,x_c,y_c) {
   # local-use Bc lv_circle_arr[];
   auto y_ba,x_ba,y_ca,x_ca,det,xy_ba,xy_ca,center_x,center_y,\
            radius;
   y_ba = y_b - y_a;
   x_ba = x_b - x_a;
   y_ca = y_c - y_a;
   x_ca = x_c - x_a;
   det = 2.0 * (y_ba * x_ca - y_ca * x_ba);
   if (! iszero(det)) {
      xy_ba = y_ba * (y_a + y_b) + x_ba * (x_a + x_b);
      xy_ca = y_ca * (y_a + y_c) + x_ca * (x_a + x_c);
      center_x = (y_ba * xy_ca - y_ca * xy_ba) / det;
      center_y = (x_ca * xy_ba - x_ba * xy_ca) / det;
      radius = hypot(center_x - x_a,center_y - y_a);
   } else {
      center_x = cxdblmax;
      center_y = cxdblmax;
      radius = cxdblmax;
   }
   lv_circle_arr[cxlc_circle_x] = center_x;
   lv_circle_arr[cxlc_circle_y] = center_y;
   lv_circle_arr[cxlc_circle_radius] = radius;
   return (radius);
}
define circle_get(ii_ind) {
   # local-use Bc lv_circle_arr[];
   auto retvalu;
   if (0 <= ii_ind && ii_ind <= 2) {
      retvalu = lv_circle_arr[ii_ind];
   } else {
      retvalu = 0;
   }
   return (retvalu);
}
define fit_minmax(num_points,*pt_arr_pc[],*ret_coeff_arr_p[]) {
   auto xxp_arr[],yyp_arr[],i_ind,j_ind,k_ind,this_spr,nx_spr,nx_a\
            ,nx_b,dxx,dyy,pty,epsxx,epsyy,slope_t,intercept_t,\
            max_dyy,min_dyy;
   epsxx = 0.0;
   epsyy = 0.0;
   for (j_ind = 0; j_ind <= num_points - 1; j_ind += 1) {
      xxp_arr[j_ind] = pt_arr_pc[2 * j_ind];
      yyp_arr[j_ind] = pt_arr_pc[2 * j_ind + 1];
      if (epsxx < abs(xxp_arr[j_ind])) {
         epsxx = abs(xxp_arr[j_ind]);
      }
      if (epsyy < abs(yyp_arr[j_ind])) {
         epsyy = abs(yyp_arr[j_ind]);
      }
   }
   nx_spr = -1;
   nx_a = 0;
   nx_b = 0;
   epsxx *= 16 * cxdbleps;
   epsyy *= 16 * cxdbleps;
   for (i_ind = 1; i_ind <= num_points - 1; i_ind += 1) {
      for (j_ind = 0; j_ind <= i_ind - 1; j_ind += 1) {
         dxx = xxp_arr[i_ind] - xxp_arr[j_ind];
         if (epsxx < abs(dxx)) {
            slope_t = (yyp_arr[i_ind] - yyp_arr[j_ind]) / dxx;
            intercept_t = yyp_arr[i_ind] - slope_t * xxp_arr[i_ind];
            pty = slope_t * xxp_arr[0] + intercept_t;
            dyy = yyp_arr[0] - pty;
            min_dyy = dyy;
            max_dyy = dyy;
            k_ind = 1;
            while (k_ind < num_points) {
               pty = slope_t * xxp_arr[k_ind] + intercept_t;
               dyy = yyp_arr[k_ind] - pty;
               if (dyy < min_dyy) {
                  min_dyy = dyy;
               }
               if (max_dyy < dyy) {
                  max_dyy = dyy;
               }
               this_spr = max_dyy - min_dyy;
               if ((0 < nx_spr && nx_spr + epsyy < this_spr) || (min_dyy\
                        < - epsyy && epsyy < max_dyy)) {
                  break;
               }
               k_ind += 1;
            }
            if (num_points <= k_ind) {
               if ((this_spr <= nx_spr + epsyy && abs(nx_a) <\
                        abs(slope_t)) || nx_spr < 0 || this_spr < nx_spr\
                        - epsyy) {
                  nx_spr = this_spr;
                  nx_a = slope_t;
                  nx_b = intercept_t + (min_dyy + max_dyy) / 2.0;
               }
            }
         }
      }
   }
   ret_coeff_arr_p[1] = nx_a;
   ret_coeff_arr_p[0] = nx_b;
   ret_coeff_arr_p[2] = nx_spr / 2.0;
   return (nx_spr / 2.0);
}
define lf_signcrossproduct(x_a,y_a,x_b,y_b,x_c,y_c) {
   auto cr,bbx_a,bby_a,ccx_a,ccy_a;
   bbx_a = x_b - x_a;
   bby_a = y_b - y_a;
   ccx_a = x_c - x_a;
   ccy_a = y_c - y_a;
   cr = bbx_a * ccy_a - ccx_a * bby_a;
   return (cr);
}
define fitx_minmax(num_points,*pt_arr_pc[],*ret_arr_p[]) {
   auto xxp_arr[],yyp_arr[],chi_arr[],chisize,hh,i_ind,j_ind,k_ind\
            ,this_spr,nx_spr,nx_a,nx_b,dxx,pty,dyy,epsxx,epsyy,\
            slope_t,intercept_t,max_dyy,min_dyy,e_ind,t_ind,poh_ind\
            ,crx,lmbm_ind;
   epsxx = 0.0;
   epsyy = 0.0;
   lmbm_ind = 0;
   for (j_ind = 0; j_ind <= num_points - 1; j_ind += 1) {
      xxp_arr[j_ind] = pt_arr_pc[2 * j_ind];
      yyp_arr[j_ind] = pt_arr_pc[2 * j_ind + 1];
      if (epsxx < abs(xxp_arr[j_ind])) {
         epsxx = abs(xxp_arr[j_ind]);
      }
      if (epsyy < abs(yyp_arr[j_ind])) {
         epsyy = abs(yyp_arr[j_ind]);
      }
      if (xxp_arr[j_ind] <= xxp_arr[lmbm_ind]) {
         if (xxp_arr[j_ind] < xxp_arr[lmbm_ind] || yyp_arr[j_ind] <=\
                  yyp_arr[lmbm_ind]) {
            lmbm_ind = j_ind;
         }
      }
   }
   nx_spr = -1;
   nx_a = 0;
   nx_b = 0;
   epsxx *= 16 * cxdbleps;
   epsyy *= 16 * cxdbleps;
   poh_ind = lmbm_ind;
   chisize = 0;
   for (;;) {
      chi_arr[chisize] = poh_ind;
      e_ind = 0;
      for (j_ind = 0; j_ind <= num_points - 1; j_ind += 1) {
         if (e_ind == poh_ind) {
            e_ind = j_ind;
         } else {
            t_ind = chi_arr[chisize];
            crx = lf_signcrossproduct(xxp_arr[j_ind],yyp_arr[j_ind],\
                     xxp_arr[t_ind],yyp_arr[t_ind],xxp_arr[e_ind],\
                     yyp_arr[e_ind]);
            if (crx < 0) {
               e_ind = j_ind;
            }
         }
      }
      chisize += 1;
      if (num_points < chisize) {
         halt;
      }
      poh_ind = e_ind;
      if (e_ind == chi_arr[0]) {
         break; # loop AWAIT
      }
   }
   chi_arr[chisize] = chi_arr[0];
   chisize += 1;
   for (hh = 0; hh <= chisize - 2; hh += 1) {
      i_ind = chi_arr[hh];
      j_ind = chi_arr[hh + 1];
      dxx = xxp_arr[i_ind] - xxp_arr[j_ind];
      if (epsxx < abs(dxx)) {
         slope_t = (yyp_arr[i_ind] - yyp_arr[j_ind]) / dxx;
         intercept_t = yyp_arr[i_ind] - slope_t * xxp_arr[i_ind];
         dyy = yyp_arr[0] - (slope_t * xxp_arr[0] + intercept_t);
         min_dyy = dyy;
         max_dyy = dyy;
         this_spr = 0;
         k_ind = 1;
         while (k_ind < num_points) {
            pty = (slope_t * xxp_arr[k_ind] + intercept_t);
            dyy = yyp_arr[k_ind] - pty;
            if (dyy < min_dyy) {
               min_dyy = dyy;
            }
            if (max_dyy < dyy) {
               max_dyy = dyy;
            }
            this_spr = max_dyy - min_dyy;
            if ((0 < nx_spr && nx_spr + epsyy < this_spr) || (min_dyy < -\
                     epsyy && epsyy < max_dyy)) {
               break;
            }
            k_ind += 1;
         }
         if (num_points <= k_ind) {
            if ((this_spr <= nx_spr + epsyy && abs(nx_a) < abs(slope_t))\
                     || nx_spr < 0 || this_spr < nx_spr - epsyy) {
               nx_a = slope_t;
               nx_b = intercept_t + (min_dyy + max_dyy) / 2.0;
               nx_spr = this_spr;
            }
         }
      }
   }
   ret_arr_p[0] = nx_b;
   ret_arr_p[1] = nx_a;
   ret_arr_p[2] = nx_spr / 2.0;
   return (ret_arr_p[2]);
}
define fit_minmax0(num_points,*pts_arr_pc[],*ret_arr_p[]) {
   auto xxp_arr[],yyp_arr[],i_ind,j_ind,k_ind,this_spr,mnmxz_spread\
            ,mnmxz_slope,mnmxz_intercept,dxx,dyy,pty,epsxx,epsyy,\
            slope_t,intercept_t,midxx,midyy,max_dyy,min_dyy;
   epsxx = 0.0;
   epsyy = 0.0;
   for (j_ind = 0; j_ind <= num_points - 1; j_ind += 1) {
      xxp_arr[j_ind] = pts_arr_pc[2 * j_ind];
      yyp_arr[j_ind] = pts_arr_pc[2 * j_ind + 1];
      if (epsxx < abs(xxp_arr[j_ind])) {
         epsxx = abs(xxp_arr[j_ind]);
      }
      if (epsyy < abs(yyp_arr[j_ind])) {
         epsyy = abs(yyp_arr[j_ind]);
      }
   }
   mnmxz_spread = -1;
   mnmxz_slope = 0;
   mnmxz_intercept = yyp_arr[0];
   epsxx *= 8 * cxdbleps;
   epsyy *= 8 * cxdbleps;
   for (i_ind = 2; i_ind <= num_points - 1; i_ind += 1) {
      for (j_ind = 2; j_ind <= i_ind - 1; j_ind += 1) {
         midxx = (xxp_arr[i_ind] + xxp_arr[j_ind]) / 2.0;
         midyy = (yyp_arr[i_ind] + yyp_arr[j_ind]) / 2.0;
         dxx = xxp_arr[0] - midxx;
         if (epsxx < abs(dxx)) {
            slope_t = (yyp_arr[0] - midyy) / dxx;
            intercept_t = yyp_arr[0] - slope_t * xxp_arr[0];
            min_dyy = 0;
            max_dyy = 0;
            for (k_ind = 0; k_ind <= num_points - 1; k_ind += 1) {
               pty = slope_t * xxp_arr[k_ind] + intercept_t;
               dyy = yyp_arr[k_ind] - pty;
               if (dyy < min_dyy) {
                  min_dyy = dyy;
               }
               if (max_dyy < dyy) {
                  max_dyy = dyy;
               }
               this_spr = max_dyy - min_dyy;
               if (0 < mnmxz_spread && mnmxz_spread + epsyy < this_spr) {
                  break;
               }
            }
            if (mnmxz_spread < 0 || this_spr < mnmxz_spread - epsyy) {
               mnmxz_slope = slope_t;
               mnmxz_intercept = intercept_t;
               mnmxz_spread = this_spr;
            }
         }
      }
   }
   if (0 <= mnmxz_spread) {
      ret_arr_p[1] = mnmxz_slope;
      ret_arr_p[0] = mnmxz_intercept;
      ret_arr_p[2] = mnmxz_spread / 2.0;
   }
   return (mnmxz_spread / 2.0);
}
define fit_ls(num_points,*pts_arr_pc[],*ret_arr_p[]) {
   auto i_ind,dxx,dyy,xx,yy,slope,mean_yy,ssq_yy,mean_xx,ssq_xx,\
            covariance_xy;
   mean_xx = 0.0;
   ssq_xx = 0.0;
   mean_yy = 0.0;
   ssq_yy = 0.0;
   covariance_xy = 0.0;
   for (i_ind = 0; i_ind <= num_points - 1; i_ind += 1) {
      xx = pts_arr_pc[2 * i_ind];
      dxx = xx - mean_xx;
      mean_xx += dxx / (i_ind + 1);
      ssq_xx += dxx * (xx - mean_xx);
      yy = pts_arr_pc[2 * i_ind + 1];
      dyy = yy - mean_yy;
      mean_yy += dyy / (i_ind + 1);
      ssq_yy += dyy * (yy - mean_yy);
      covariance_xy += dxx * dyy * i_ind / (i_ind + 1.0);
   }
   slope = covariance_xy / ssq_xx;
   ret_arr_p[1] = slope;
   ret_arr_p[0] = mean_yy - slope * mean_xx;
   ret_arr_p[2] = covariance_xy / sqrt(ssq_xx * ssq_yy);
   ret_arr_p[3] = sqrt((ssq_yy - slope * covariance_xy) / (num_points - 2));
   return (ret_arr_p[2]);
}
define fit_ls0(num_points,*pts_arr_pc[],*ret_lsz_arr_p[]) {
   auto xxsum,xysum,dxx,slope,j_ind,i_ind;
   xxsum = 0.0;
   xysum = 0.0;
   for (i_ind = 1; i_ind <= num_points - 1; i_ind += 1) {
      j_ind = 2 * i_ind;
      dxx = (pts_arr_pc[j_ind] - pts_arr_pc[0]);
      xxsum += dxx * dxx;
      xysum += dxx * (pts_arr_pc[j_ind + 1] - pts_arr_pc[1]);
   }
   slope = xysum / xxsum;
   ret_lsz_arr_p[1] = slope;
   ret_lsz_arr_p[0] = (pts_arr_pc[1] - slope * pts_arr_pc[0]);
   return (slope);
}
define sqrt__1(xx) {
   auto yy_curr,yy_prev,zz,power_of_two;
   if (xx <= 0.0) {
      yy_curr = 0.0;
   } else {
      power_of_two = 1.0;
      zz = xx;
      while (4.0 <= zz) {
         zz /= 4.0;
         power_of_two *= 2.0;
      }
      while (zz < 1.0) {
         zz *= 4.0;
         power_of_two /= 2.0;
      }
      yy_curr = (((-0.0353026277858345) * zz + 0.502513025246083) * zz +\
               0.546382637992462);
      for (;;) {
         yy_prev = yy_curr;
         yy_curr = (yy_curr + zz / yy_curr) / 2.0;
         if (iseq(yy_prev,yy_curr)) {
            break; # loop AWAIT
         }
      }
      yy_curr *= power_of_two;
   }
   return (yy_curr);
}
define sqrt__2(xx) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_ii,ini;
   if (xx <= 0.0) {
      scvx_xx = 0.0;
   } else {
      if (1.0 < xx) {
         ini = xx / 2.0;
      } else {
         ini = 2.0 * xx;
      }
      scvx_dx = ini / 10.0;
      scvx_xx = ini;
      scvx_yy = xx - scvx_xx * scvx_xx;
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = xx - scvx_xx * scvx_xx;
         if (iseq(scvx_yy,scvx_yp)) {
            break;
         }
         scvx_dx *= - scvx_yy / (scvx_yy - scvx_yp);
      }
   }
   return (scvx_xx);
}
define sqrt__3(yy) {
   auto nrvx_ii,nrvx_yy,nrvx_xx,nrvx_dy,nrvx_xp,ini;
   if (yy <= 0.0) {
      nrvx_xx = 0.0;
   } else {
      if (1.0 < yy) {
         ini = yy / 2.0;
      } else {
         ini = 2.0 * yy;
      }
      nrvx_xx = ini;
      for (nrvx_ii = 0; nrvx_ii <= 20; nrvx_ii += 1) {
         nrvx_xp = nrvx_xx;
         nrvx_dy = 2.0 * nrvx_xx;
         if (iszero(nrvx_dy)) {
            break;
         }
         nrvx_yy = nrvx_xx * nrvx_xx - yy;
         nrvx_xx -= nrvx_yy / nrvx_dy;
         if (iseq(nrvx_xp,nrvx_xx)) {
            break;
         }
      }
   }
   return (nrvx_xx);
}
define nthroot__1(xx,kk) {
   auto yy_curr,yy_prev,pp,ii;
   if (xx <= 0.0) {
      yy_curr = 0.0;
   } else {
      yy_curr = xx / 2.0;
      for (;;) {
         yy_prev = yy_curr;
         pp = yy_curr;
         for (ii = 2; ii <= kk - 1; ii += 1) {
            pp *= yy_curr;
         }
         yy_curr = (yy_curr * (kk - 1.0) + xx / pp) / kk;
         if (iseq(yy_prev,yy_curr)) {
            break; # loop AWAIT
         }
      }
   }
   return (yy_curr);
}
define cossin_ev(init_ii,xx_rad,addone_mult) {
   auto cval,ii,trig_sum,xr_rad,xr_sqr;
   if (iszero(xx_rad)) {
      trig_sum = 0.0;
   } else {
      xr_rad = fmods(xx_rad,cxtau);
      xr_sqr = -xr_rad * xr_rad;
      cval = 1.0;
      ii = init_ii;
      while (cxdbleps / 16.0 < abs(cval)) {
         ii += 2;
         cval *= xr_sqr / (ii * (ii - 1.0));
      }
      trig_sum = 1.0 / (ii * (ii + 1.0));
      while (1 < ii) {
         trig_sum += 1.0;
         trig_sum *= xr_sqr / (ii * (ii - 1.0));
         ii -= 2;
      }
      if (addone_mult) {
         trig_sum += 1.0;
         trig_sum *= xr_rad;
      }
   }
   return (trig_sum);
}
define cos__1(xx_rad) {
   return (cossin_ev(0,xx_rad,false) + 1.0);
}
define cosm1__1(xx_rad) {
   return (cossin_ev(0,xx_rad,false));
}
define sin__1(xx_rad) {
   return (cossin_ev(1,xx_rad,true));
}
define sinc__1(xx_rad) {
   auto retvalu;
   if (iszero(xx_rad)) {
      retvalu = 1.0;
   } else {
      if (cxtau / 2.0 < abs(xx_rad)) {
         retvalu = cossin_ev(1,xx_rad,true) / xx_rad;
      } else {
         retvalu = cossin_ev(1,xx_rad,false) + 1.0;
      }
   }
   return (retvalu);
}
define exp__1(xx) {
   auto ii,term_count,vale,axx,exp_sum,retvalu,squaring_count;
   if (xx < 0.0) {
      axx = -xx;
   } else {
      axx = xx;
   }
   squaring_count = 0;
   while (1.0 < axx) {
      axx /= 2.0;
      squaring_count += 1;
   }
   vale = 1.0;
   term_count = 1;
   while (cxdbleps / 10.0 < vale) {
      term_count += 1;
      vale *= axx / term_count;
   }
   exp_sum = 1.0 / (term_count + 1.0);
   for (ii = term_count; 1 <= ii; ii -= 1) {
      exp_sum = 1.0 + axx * (exp_sum / ii);
   }
   if (xx < 0.0) {
      retvalu = 1.0 / exp_sum;
   } else {
      retvalu = exp_sum;
   }
   for (ii = 1; ii <= squaring_count; ii += 1) {
      retvalu *= retvalu;
   }
   return (retvalu);
}
define exp__2(xx) {
   auto ii,term_count,axx,expmo_sum,retvalu,squaring_count,vale;
   if (xx < 0.0) {
      axx = -xx;
   } else {
      axx = xx;
   }
   squaring_count = 0;
   while (1.0 < axx) {
      axx /= 2.0;
      squaring_count += 1;
   }
   vale = 1.0;
   term_count = 1;
   while (cxdbleps / 4.0 < vale) {
      term_count += 1;
      vale *= axx / term_count;
   }
   expmo_sum = 0.0;
   for (ii = term_count; 1 <= ii; ii -= 1) {
      expmo_sum = axx * (expmo_sum + 1.0) / ii;
   }
   for (ii = 1; ii <= squaring_count; ii += 1) {
      expmo_sum *= (2.0 + expmo_sum);
   }
   if (xx < 0.0) {
      retvalu = 1.0 / (expmo_sum + 1.0);
   } else {
      retvalu = expmo_sum + 1.0;
   }
   return (retvalu);
}
define ln__1(xx) {
   auto yy_curr,logshift,retvalu,tmp;
   scale *= 2;
   logshift = 0.0;
   yy_curr = 8.0 / xx;
   tmp = (cxdbleps);
   while (tmp < yy_curr) {
      logshift -= 16.0 * cxtwoln;
      yy_curr /= 65536.0;
   }
   retvalu = (cxpi / agmean(2.0,yy_curr) + logshift);
   scale /= 2;
   return (retvalu);
}
define ln__2(xx) {
   auto yy_curr,ptwo,term,nn,sum_curr,sum_prev,mant;
   yy_curr = xx;
   ptwo = 0.0;
   while (cxtwosqrt < yy_curr) {
      ptwo += 1.0;
      yy_curr /= 2.0;
   }
   while (yy_curr < 1.0 / cxtwosqrt) {
      ptwo -= 1.0;
      yy_curr *= 2.0;
   }
   mant = (yy_curr - 1.0) / (yy_curr + 1.0);
   sum_curr = 2.0 * mant;
   term = sum_curr;
   mant *= mant;
   nn = 3;
   for (;;) {
      term *= mant;
      sum_prev = sum_curr;
      sum_curr += term / nn;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      nn += 2;
   }
   return (ptwo * cxtwoln + sum_curr);
}
define euler__1() {
   auto twon,exptwon,ii,jj,term,subsum,sum_curr,sum_prev;
   twon = 1.0;
   exptwon = e;
   ii = 0;
   for (;;) {
      twon *= 2.0;
      exptwon *= exptwon;
      if (0.1 < cxdbleps * exptwon) {
         break; # loop AWAIT
      }
      ii += 1;
   }
   term = 1.0 / twon;
   subsum = 0.0;
   sum_curr = 0.0;
   jj = 1;
   for (;;) {
      subsum += 1.0 / jj;
      term *= twon / jj;
      sum_prev = sum_curr;
      sum_curr += term * subsum;
      if (iseq(sum_prev,sum_curr)) {
         break; # loop AWAIT
      }
      jj += 1;
   }
   return (twon * sum_curr / exptwon - (ii + 1.0) * cxtwoln);
}
define sphere_d(lata_rad,lona_rad,latb_rad,lonb_rad) {
   auto xc,xd,xe,c_lond,s_lond,c_lata,c_latb,s_lata,s_latb,retvalu;
   c_lata = cos(lata_rad);
   c_latb = cos(latb_rad);
   s_lata = sin(lata_rad);
   s_latb = sin(latb_rad);
   s_lond = sin(lonb_rad - lona_rad);
   c_lond = cos(lonb_rad - lona_rad);
   xc = c_lata * s_latb - s_lata * c_latb * c_lond;
   xd = c_latb * s_lond;
   xe = s_lata * s_latb + c_lata * c_latb * c_lond;
   retvalu = atan2(hypot(xd,xc),xe);
   return (retvalu);
}
define great_circle_distance(lata_rad,lona_rad,latb_rad,lonb_rad) {
   return (sphere_d(lata_rad,lona_rad,latb_rad,lonb_rad));
}
define sphere_distance(lata_rad,lona_rad,latb_rad,lonb_rad,\
         *ret_dirs_arr_p[]) {
   auto xc,xd,xe,s_lond,c_lond,c_lata,c_latb,s_lata,s_latb,dist;
   c_lata = cos(lata_rad);
   c_latb = cos(latb_rad);
   s_lata = sin(lata_rad);
   s_latb = sin(latb_rad);
   s_lond = sin(lonb_rad - lona_rad);
   c_lond = cos(lonb_rad - lona_rad);
   xc = c_lata * s_latb - s_lata * c_latb * c_lond;
   xd = c_latb * s_lond;
   ret_dirs_arr_p[0] = atan2(xd,xc);
   xe = s_lata * s_latb + c_lata * c_latb * c_lond;
   dist = atan2(hypot(xd,xc),xe);
   xc = c_latb * s_lata - s_latb * c_lata * c_lond;
   xd = c_lata * s_lond;
   ret_dirs_arr_p[1] = -atan2(xd,xc);
   return (dist);
}
define lf_ka(usq) {
   auto hyp;
   hyp = sqrt(1.0 + usq);
   return ((hyp - 1.0) / (hyp + 1.0));
}
define lf_cap_a(usq) {
   auto ka;
   ka = lf_ka(usq);
   return ((1.0 + square(ka / 2.0)) / (1.0 - ka));
}
define lf_cap_b(usq) {
   auto ka;
   ka = lf_ka(usq);
   return (ka * (1.0 - 3.0 * square(ka) / 8.0));
}
define ellipsoid_distance(flat,lata_rad,lona_rad,latb_rad,lonb_rad,\
         *ret_dirs_arr_p[]) {
   auto iflat,cap_ua,cap_ub,lon_diff,c_cap_ua,s_cap_ua,c_cap_ub,\
            s_cap_ub,xx_curr,xx_prev,xc,xd,s_xx,c_xx,c_sig,s_sig,\
            sig,s_a,c_asq,cbsigm,cap_c,usq,cap_a,cap_b,deltasig,\
            ii,dist;
   iflat = 1.0 - flat;
   cap_ua = atan2(iflat * sin(lata_rad),cos(lata_rad));
   cap_ub = atan2(iflat * sin(latb_rad),cos(latb_rad));
   lon_diff = lonb_rad - lona_rad;
   xx_curr = lon_diff;
   c_cap_ua = cos(cap_ua);
   c_cap_ub = cos(cap_ub);
   s_cap_ua = sin(cap_ua);
   s_cap_ub = sin(cap_ub);
   ii = 0;
   for (;;) {
      s_xx = sin(xx_curr);
      c_xx = cos(xx_curr);
      s_sig = hypot(c_cap_ub * s_xx,c_cap_ua * s_cap_ub - s_cap_ua *\
               c_cap_ub * c_xx);
      c_sig = s_cap_ua * s_cap_ub + c_cap_ua * c_cap_ub * c_xx;
      sig = atan2(s_sig,c_sig);
      s_a = c_cap_ua * c_cap_ub * s_xx / s_sig;
      c_asq = 1.0 - square(s_a);
      cbsigm = c_sig - divi(2 * s_cap_ua * s_cap_ub,c_asq,0.0);
      cap_c = ((flat / 16) * c_asq * (4.0 + flat * (4.0 - 3.0 * c_asq)));
      xx_prev = xx_curr;
      xx_curr = (lon_diff + (1.0 - cap_c) * flat * s_a * (sig + cap_c *\
               s_sig * (cbsigm + cap_c * c_sig * (2.0 * square(cbsigm) -\
               1.0))));
      if (10 < ii && iseq(abs(xx_prev + xx_curr),cxtau)) {
         xx_curr = cxtau / 2.0;
         break;
      }
      if (abs(xx_curr - xx_prev) < (1.0 * 10^-12)) {
         break; # loop AWAIT
      }
      ii += 1;
   }
   usq = c_asq * (1.0 / square(iflat) - 1.0);
   cap_a = iflat * lf_cap_a(usq);
   cap_b = lf_cap_b(usq);
   deltasig = cap_b * s_sig * (cbsigm + 0.25 * cap_b * (c_sig * (-1.0 +\
            2.0 * square(cbsigm)) - (1.0 / 6.0) * cap_b * cbsigm * (3.0 +\
            4.0 * square(s_sig)) * (-3.0 + 4.0 * square(cbsigm))));
   dist = cap_a * (sig - deltasig);
   xc = c_cap_ua * s_cap_ub - s_cap_ua * c_cap_ub * c_xx;
   xd = c_cap_ub * s_xx;
   ret_dirs_arr_p[0] = atan2(xd,xc);
   xc = c_cap_ub * s_cap_ua - s_cap_ub * c_cap_ua * c_xx;
   xd = c_cap_ua * s_xx;
   ret_dirs_arr_p[1] = -atan2(xd,xc);
   return (dist);
}
define ellipsoid_destination(flat,lata_rad,lona_rad,heading_rad,\
         cxdistance,*ret_loc_arr_p[]) {
   auto iflat,cap_ua,c_cap_ua,s_cap_ua,sig_rad,sig_rad_prev,\
            sig_rad_delta,c_sig,s_sig,aa,bb,sig_b_rad,s_a,c_asq,\
            twosigm_rad,c_twosigm,c_twosigmsq,cap_c,usq,cap_a,cap_b\
            ,cap_l,alpha_rad,c_heading,s_heading,lamda,xd,xc;
   iflat = 1.0 - flat;
   aa = 1.0;
   bb = iflat * aa;
   cap_ua = atan2(iflat * sin(lata_rad),cos(lata_rad));
   c_cap_ua = cos(cap_ua);
   s_cap_ua = sin(cap_ua);
   c_heading = cos(heading_rad);
   s_heading = sin(heading_rad);
   sig_b_rad = atan2(s_cap_ua,c_cap_ua * c_heading);
   s_a = cos(cap_ua) * sin(heading_rad);
   c_asq = 1.0 - square(s_a);
   usq = c_asq * (square(aa / bb) - 1.0);
   cap_a = lf_cap_a(usq);
   cap_b = lf_cap_b(usq);
   sig_rad_delta = 0.0;
   sig_rad = -10.0;
   for (;;) {
      sig_rad_prev = sig_rad;
      sig_rad = cxdistance / (bb * cap_a) + sig_rad_delta;
      s_sig = sin(sig_rad);
      c_sig = cos(sig_rad);
      twosigm_rad = 2.0 * sig_b_rad + sig_rad;
      c_twosigm = cos(twosigm_rad);
      c_twosigmsq = square(c_twosigm);
      sig_rad_delta = cap_b * s_sig * (c_twosigm + 0.25 * cap_b * (c_sig\
               * (2.0 * c_twosigmsq - 1.0) - (cap_b / 6.0) * c_twosigm *\
               (4.0 * s_sig * s_sig - 3.0) * (4.0 * c_twosigmsq - 3.0)));
      if (iseq(sig_rad,sig_rad_prev)) {
         break; # loop AWAIT
      }
   }
   xd = s_cap_ua * c_sig + c_cap_ua * s_sig * c_heading;
   xc = iflat * hypot(s_a,s_cap_ua * s_sig - c_cap_ua * c_sig * c_heading);
   ret_loc_arr_p[0] = atan2(xd,xc);
   xd = s_sig * s_heading;
   xc = c_cap_ua * c_sig - s_cap_ua * s_sig * c_heading;
   lamda = atan2(xd,xc);
   cap_c = ((flat / 16.0) * c_asq * (4.0 + flat * (4.0 - 3.0 * c_asq)));
   cap_l = lamda - (1.0 - cap_c) * flat * s_a * (sig_rad + cap_c * s_sig\
            * (c_twosigm + cap_c * c_sig * (2 * c_twosigmsq - 1.0)));
   ret_loc_arr_p[1] = cap_l + lona_rad;
   alpha_rad = fmodu(cxpi + atan2(s_a,c_cap_ua * c_sig * c_heading -\
            s_cap_ua * s_sig),cxtau);
   return (alpha_rad);
}
define ellipsoid_surface(axis_a,axis_b,axis_c) {
   auto absaa,absbb,abscc,phi_rad,sinphi,cosphi,kk,retvalu;
   absaa = abs(axis_a);
   absbb = abs(axis_b);
   abscc = abs(axis_c);
   if (absaa < absbb) {
      kk = absaa;
      absaa = absbb;
      absbb = kk;
   }
   if (absbb < abscc) {
      kk = abscc;
      abscc = absbb;
      absbb = kk;
      if (absaa < absbb) {
         kk = absaa;
         absaa = absbb;
         absbb = kk;
      }
   }
   if (abscc < absaa) {
      cosphi = (abscc / absaa);
      phi_rad = cosinv(cosphi);
      sinphi = sin(phi_rad);
      kk = sqrt((1.0 - abscc * abscc / (absbb * absbb)) / (1.0 - abscc *\
               abscc / (absaa * absaa)));
      retvalu = cxtau * (abscc * abscc + absaa * absbb / sinphi * (sinphi\
               * sinphi * elliptic2ik(kk,phi_rad) + cosphi * cosphi *\
               elliptic1ik(kk,phi_rad)));
   } else {
      retvalu = 2.0 * cxtau * absaa * absaa;
   }
   return (retvalu);
}
define ellipsoid_volume(axis_a,axis_b,axis_c) {
   return (2.0 * cxtau * axis_a * axis_b * axis_c / 3.0);
}
define shc_shftpoles2steps(shft,poles) {
   auto step_arr[],retvalu;
   if (poles <= 0) {
      retvalu = 0.0;
   } else if (shft < 0) {
      retvalu = 0.0;
   } else if (16 < shft) {
      retvalu = (1.0 * 10^9);
   } else if (poles == 1) {
      step_arr[0] = 1.0;
      step_arr[1] = 8.75664018;
      step_arr[2] = (2.174418277 * 10^1);
      step_arr[3] = (4.709615109 * 10^1);
      step_arr[4] = (9.755325605 * 10^1);
      step_arr[5] = (1.983575685 * 10^2);
      step_arr[6] = (3.9991425188 * 10^2);
      step_arr[7] = (8.0300236937 * 10^2);
      step_arr[8] = (1.60916613901 * 10^3);
      step_arr[9] = (3.22148750069 * 10^3);
      step_arr[10] = (6.44612712926 * 10^3);
      step_arr[11] = (1.289540487229 * 10^4);
      step_arr[12] = (2.579395961911 * 10^4);
      step_arr[13] = (5.159106828928 * 10^4);
      step_arr[14] = (1.0318528839545 * 10^5);
      step_arr[15] = (2.0637372529029 * 10^5);
      step_arr[16] = (4.1275053067337 * 10^5);
      retvalu = step_arr[shft];
   } else if (poles == 2) {
      step_arr[0] = 1.0;
      step_arr[1] = (1.372295755 * 10^1);
      step_arr[2] = (3.383938971 * 10^1);
      step_arr[3] = (7.318281398 * 10^1);
      step_arr[4] = (1.5153838699 * 10^2);
      step_arr[5] = (3.0810336456 * 10^2);
      step_arr[6] = (6.2116437416 * 10^2);
      step_arr[7] = (1.24725288016 * 10^3);
      step_arr[8] = (2.49941335432 * 10^3);
      step_arr[9] = (5.00372613671 * 10^3);
      step_arr[10] = (1.001234749878 * 10^4);
      step_arr[11] = (2.002958840334 * 10^4);
      step_arr[12] = (4.006406905172 * 10^4);
      step_arr[13] = (8.013303000155 * 10^4);
      step_arr[14] = (1.6027095510986 * 10^5);
      step_arr[15] = (3.2054680443102 * 10^5);
      step_arr[16] = (6.4109851712798 * 10^5);
      retvalu = step_arr[shft];
   } else if (poles == 3) {
      step_arr[0] = 1.0;
      step_arr[1] = (1.737173781 * 10^1);
      step_arr[2] = (4.273609545 * 10^1);
      step_arr[3] = (9.238532150 * 10^1);
      step_arr[4] = (1.9128399554 * 10^2);
      step_arr[5] = (3.8890510497 * 10^2);
      step_arr[6] = (7.8406421045 * 10^2);
      step_arr[7] = (1.57434201644 * 10^3);
      step_arr[8] = (3.15487771808 * 10^3);
      step_arr[9] = (6.31593923478 * 10^3);
      step_arr[10] = (1.263805730898 * 10^4);
      step_arr[11] = (2.528229097067 * 10^4);
      step_arr[12] = (5.057075779500 * 10^4);
      step_arr[13] = (1.0114768912723 * 10^5);
      step_arr[14] = (2.0230154729287 * 10^5);
      step_arr[15] = (4.0460928016924 * 10^5);
      step_arr[16] = (8.0922476138170 * 10^5);
      retvalu = step_arr[shft];
   } else if (poles == 4) {
      step_arr[0] = 1.0;
      step_arr[1] = (2.03878236 * 10^1);
      step_arr[2] = (5.009900279 * 10^1);
      step_arr[3] = (1.0828162825 * 10^2);
      step_arr[4] = (2.2418834788 * 10^2);
      step_arr[5] = (4.5579968748 * 10^2);
      step_arr[6] = (9.189270663 * 10^2);
      step_arr[7] = (1.84513549236 * 10^3);
      step_arr[8] = (3.69752950942 * 10^3);
      step_arr[9] = (7.40230620593 * 10^3);
      step_arr[10] = (1.48118537839 * 10^4);
      step_arr[11] = (2.963094667636 * 10^4);
      step_arr[12] = (5.926913086318 * 10^4);
      step_arr[13] = (1.1854549900613 * 10^5);
      step_arr[14] = (2.3709822433702 * 10^5);
      step_arr[15] = (4.7420371217077 * 10^5);
      step_arr[16] = (9.4841452431326 * 10^5);
      retvalu = step_arr[shft];
   } else if (poles == 5) {
      step_arr[0] = 1.0;
      step_arr[1] = (2.301559338 * 10^1);
      step_arr[2] = (5.651862690 * 10^1);
      step_arr[3] = (1.2214337218 * 10^2);
      step_arr[4] = (2.5288215751 * 10^2);
      step_arr[5] = (5.1413464355 * 10^2);
      step_arr[6] = (1.03653347249 * 10^3);
      step_arr[7] = (2.08127953713 * 10^3);
      step_arr[8] = (4.17074621528 * 10^3);
      step_arr[9] = (8.34966697295 * 10^3);
      step_arr[10] = (1.670750214140 * 10^4);
      step_arr[11] = (3.342316957219 * 10^4);
      step_arr[12] = (6.685449836446 * 10^4);
      step_arr[13] = (1.3371716646729 * 10^5);
      step_arr[14] = (2.6744248565129 * 10^5);
      step_arr[15] = (5.3489319815476 * 10^5);
      step_arr[16] = (1.06979462735136 * 10^6);
      retvalu = step_arr[shft];
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
cxlx_shc_shiftshift = 3.85514;
cxlx_shc_stepshift = 8.5;
define shc_steps2shft(steps) {
   return (lg(steps + cxlx_shc_stepshift) - cxlx_shc_shiftshift);
}
define shc_steps2shftinv(shft) {
   return (pow(2.0,shft + cxlx_shc_shiftshift) - cxlx_shc_stepshift);
}
define shc_shft2steps(shft) {
   return (shc_shftpoles2steps(shft,4));
}
define m2k(emm) {
   return (sqrt(emm));
}
define k2m(ekk) {
   return (ekk * ekk);
}
define a2k(eaa) {
   return (sin(eaa));
}
define k2a(ekk) {
   return (sininv(ekk));
}
define a2m(eaa) {
   return (square(sin(eaa)));
}
define m2a(emm) {
   return (sininv(sqrt(emm)));
}
define m2b(emm) {
   return (1.0 / sqrt(1.0 - emm));
}
define b2m(ebb) {
   return (1.0 - 1.0 / (ebb * ebb));
}
define elliptic1m(emm) {
   auto retvalu,aa_arr[],bb_arr[],cc_arr[],dd;
   if (emm < 1.0) {
      retvalu = cxpi / (2.0 * agmean(1.0,sqrt(1.0 - emm)));
   } else if (1.0 < emm) {
      aa_arr[0] = 1.0;
      aa_arr[1] = 0.0;
      bb_arr[0] = 0.0;
      bb_arr[1] = sqrt(emm - 1.0);
      dd = agcmean(aa_arr[],bb_arr[],cc_arr[]);
      retvalu = cxpi / (2.0 * dd);
   } else {
      retvalu = 20.0;
   }
   return (retvalu);
}
define elliptick(ekk) {
   return (elliptic1m(k2m(ekk)));
}
define elliptic1m__1(emm) {
   return (carlsonrf(0.0,1.0 - emm,1.0));
}
define elliptic1m__2(emm) {
   auto term,sum_curr,sum_prev,ii;
   term = cxtau / 4.0;
   sum_curr = 0.0;
   ii = 1;
   for (;;) {
      term *= square(emm * ii / (ii + 1.0));
      sum_prev = sum_curr;
      sum_curr += term;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      ii += 2;
   }
   return (sum_curr);
}
define elliptic1im(emm,circ_rad) {
   auto aan,ggn,cc,skip_flag,temp,retvalu,tt,kresult,lcirc_rad,\
            emmc,ii,modd,signof,npihlfs,ee;
   emmc = 1.0 - emm;
   if (iszero(emm)) {
      retvalu = circ_rad;
   } else if (iszero(emmc)) {
      if (cxpi / 2.0 <= abs(circ_rad)) {
         retvalu = cxdblmax;
      } else {
         retvalu = log(tan((cxpi / 2.0 + circ_rad) / 2.0));
      }
   } else {
      npihlfs = floor(circ_rad / (cxpi / 2.0));
      if (isodd(npihlfs)) {
         npihlfs += 1;
      }
      lcirc_rad = circ_rad;
      if (npihlfs == 0) {
         kresult = 0.0;
      } else {
         kresult = elliptic1m(emm);
         lcirc_rad -= npihlfs * cxpi / 2.0;
      }
      if (lcirc_rad < 0.0) {
         lcirc_rad = -lcirc_rad;
         signof = -1;
      } else {
         signof = 1;
      }
      tt = tan(lcirc_rad);
      ggn = sqrt(emmc);
      skip_flag = false;
      if (10.0 < abs(tt)) {
         ee = 1.0 / (ggn * tt);
         if (abs(ee) < 10.0) {
            if (npihlfs == 0) {
               kresult = elliptic1m(emm);
            }
            temp = kresult - elliptic1im(emm,atan2(ee,1.0));
            skip_flag = true;
         }
      }
      if (! skip_flag) {
         aan = 1.0;
         ii = 1;
         modd = 0;
         for (;;) {
            temp = ggn / aan;
            lcirc_rad += atan2(tt * temp,1.0) + modd * cxpi;
            modd = floor(lcirc_rad / cxpi + 0.5);
            tt *= (1.0 + temp) / (1.0 - temp * tt * tt);
            cc = (aan - ggn) / 2.0;
            temp = sqrt(aan * ggn);
            aan = (aan + ggn) / 2.0;
            ggn = temp;
            ii += ii;
            if (abs(cc / aan) <= cxdbleps) {
               break; # loop AWAIT
            }
         }
         temp = (atan2(tt,1.0) + modd * cxpi) / (ii * aan);
      }
      if (signof < 0) {
         temp = -temp;
      }
      retvalu = temp + npihlfs * kresult;
   }
   return (retvalu);
}
define elliptic1k(kk) {
   return (elliptic1m(k2m(kk)));
}
define elliptic1ik(kk,circ_rad) {
   return (elliptic1im(k2m(kk),circ_rad));
}
define elliptic1a(aa) {
   return (elliptic1m(a2m(aa)));
}
define elliptic1ia(aa,circ_rad) {
   return (elliptic1im(a2m(aa),circ_rad));
}
define ellipticf(ekk,circ_rad) {
   return (elliptic1im(k2m(ekk),circ_rad));
}
define elliptic1im__1(emm,circ_rad) {
   auto sinphi,npihlfs,lcirc_rad,kresult;
   npihlfs = floor(circ_rad / (cxpi / 2.0));
   if (isodd(npihlfs)) {
      npihlfs += 1;
   }
   lcirc_rad = circ_rad;
   if (npihlfs == 0) {
      kresult = 0.0;
   } else {
      kresult = elliptic1m(emm) * npihlfs;
      lcirc_rad -= npihlfs * cxpi / 2.0;
   }
   sinphi = sin(lcirc_rad);
   return (sinphi * carlsonrf(square(cos(lcirc_rad)),1.0 - emm *\
            square(sinphi),1.0) + kresult);
}
define elliptic2m(emm) {
   auto aan,ggn,tn,twon,sum,sum_prev,ii,aemm,retvalu;
   aemm = abs(emm);
   if (aemm < 1.0) {
      twon = 0.5;
      aan = 1.0;
      ggn = sqrt(1.0 - emm);
      sum = 1.0 - emm / 2.0;
      ii = 0;
      for (;;) {
         twon *= 2.0;
         tn = aan;
         aan = (aan + ggn) / 2.0;
         ggn = sqrt(tn * ggn);
         sum_prev = sum;
         sum -= twon * (aan * aan - ggn * ggn);
         if (iseq(sum,sum_prev)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = cxpi * sum / (2.0 * aan);
   } else {
      retvalu = 1.0;
   }
   return (retvalu);
}
define elliptice(ekk) {
   return (elliptic2m(k2m(ekk)));
}
define elliptic2m__1(emm) {
   return (carlsonrf(0.0,1.0 - emm,1.0) - emm * carlsonrd(0.0,1.0 -\
            emm,1.0) / 3.0);
}
define elliptic2im(emm,circ_rad) {
   auto aan,ggn,cc,errsum,temp,tt,eliptwoemm,emmc,ii,modd,\
            npihalfs,signof,lcirc_rad,retvalu;
   if (iszero(emm)) {
      retvalu = circ_rad;
   } else {
      emmc = 1.0 - emm;
      eliptwoemm = elliptic2m(emm);
      npihalfs = floor(circ_rad / (cxpi / 2.0));
      if (isodd(npihalfs)) {
         npihalfs += 1;
      }
      lcirc_rad = circ_rad - npihalfs * cxpi / 2.0;
      if (iszero(emmc)) {
         retvalu = sin(lcirc_rad) + npihalfs * eliptwoemm;
      } else {
         if (lcirc_rad < 0.0) {
            lcirc_rad = -lcirc_rad;
            signof = -1;
         } else {
            signof = 1;
         }
         tt = tan(lcirc_rad);
         ggn = sqrt(emmc);
         if (abs(tt) < - 1) {
            errsum = 1.0 / (ggn * tt);
         } else {
            errsum = 0.0;
         }
         if (0.0 < abs(errsum) && abs(errsum) < 1000.0) {
            errsum = atan2(1.0,ggn * tt);
            temp = eliptwoemm - elliptic2im(emm,errsum) + emm *\
                     sin(circ_rad) * sin(errsum);
         } else {
            cc = sqrt(emm);
            aan = 1.0;
            ii = 1;
            modd = 0;
            while (cxdbleps < abs(cc / aan)) {
               temp = ggn / aan;
               lcirc_rad += atan2(tt * temp,1.0) + modd * cxpi;
               modd = floor(lcirc_rad / cxpi + 0.5);
               tt *= (1.0 + temp) / (1.0 - temp * tt * tt);
               cc = (aan - ggn) / 2.0;
               temp = sqrt(aan * ggn);
               aan = (aan + ggn) / 2.0;
               ggn = temp;
               ii += ii;
               errsum += cc * sin(lcirc_rad);
            }
            temp = errsum + eliptwoemm * (atan2(tt,1.0) + modd * cxpi) /\
                     (ii * aan * elliptic1m(emm));
         }
         if (signof < 0) {
            temp = -temp;
         }
         retvalu = temp + npihalfs * eliptwoemm;
      }
   }
   return (retvalu);
}
define ellipticei(ekk,circ_rad) {
   return (elliptic2im(k2m(ekk),circ_rad));
}
define elliptic2im__1(emm,circ_rad) {
   auto sinphi,sinphisq,sinphicu,cosphisq,argb,npihlfs,lcirc_rad,\
            kresult;
   npihlfs = floor(circ_rad / (cxpi / 2.0));
   if (isodd(npihlfs)) {
      npihlfs += 1;
   }
   lcirc_rad = circ_rad;
   if (npihlfs == 0) {
      kresult = 0.0;
   } else {
      kresult = elliptic2m(emm) * npihlfs;
      lcirc_rad -= npihlfs * cxpi / 2.0;
   }
   sinphi = sin(lcirc_rad);
   sinphisq = sinphi * sinphi;
   sinphicu = sinphi * sinphisq;
   cosphisq = square(cos(lcirc_rad));
   argb = 1.0 - emm * sinphisq;
   return (sinphi * carlsonrf(cosphisq,argb,1.0) - emm * sinphicu *\
            carlsonrd(cosphisq,argb,1.0) / 3.0 + kresult);
}
define elliptic2k(kk) {
   return (elliptic2m(k2m(kk)));
}
define elliptic2ik(kk,circ_rad) {
   return (elliptic2im(k2m(kk),circ_rad));
}
define elliptic2a(aa) {
   return (elliptic2m(a2m(aa)));
}
define elliptic2ia(aa,circ_rad) {
   return (elliptic2im(a2m(aa),circ_rad));
}
define elliptic3m(enn,emm) {
   auto aan,ggn,ppn,een,qqn,tpp,tag,tn,sum,sum_prev,ii,aemm,\
            retvalu;
   aemm = abs(emm);
   if (aemm < 1.0) {
      aan = 1.0;
      ggn = sqrt(1.0 - emm);
      if (1.0 <= abs(enn)) {
         ppn = sqrt(1.0 - emm / enn);
      } else {
         ppn = sqrt(1.0 - enn);
      }
      qqn = 1.0;
      sum = qqn;
      ii = 0;
      for (;;) {
         tpp = ppn * ppn;
         tag = aan * ggn;
         een = (tpp - tag) / (tpp + tag);
         ppn = (tpp + tag) / (2.0 * ppn);
         qqn = qqn * een / 2.0;
         aan = (aan + ggn) / 2.0;
         ggn = sqrt(tag);
         sum_prev = sum;
         sum += qqn;
         if (iseq(sum,sum_prev) && iseq(aan,ggn)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      if (1.0 <= abs(enn)) {
         tn = emm * sum / (emm - enn);
      } else {
         tn = 2.0 + sum * enn / (1.0 - enn);
      }
      retvalu = cxpi * tn / (4.0 * aan);
   } else {
      retvalu = 1.0;
   }
   return (retvalu);
}
define elliptic3k(enn,kk) {
   return (elliptic3m(enn,k2m(kk)));
}
define elliptic3ik(enn,kk,circ_rad) {
   return (elliptic3im(enn,k2m(kk),circ_rad));
}
define elliptic3a(enn,aa) {
   return (elliptic3m(enn,a2m(aa)));
}
define elliptic3ia(enn,aa,circ_rad) {
   return (elliptic3im(enn,a2m(aa),circ_rad));
}
define ellipticp(ekk,circ_rad) {
   return (elliptic3m(ekk,circ_rad));
}
define elliptic3im(enn,emm,circ_rad) {
   auto sp,cp,spq,cpq,spm,spn;
   sp = sin(circ_rad);
   cp = cos(circ_rad);
   spq = sp * sp;
   cpq = cp * cp;
   spm = 1.0 - emm * spq;
   spn = 1.0 - enn * spq;
   return (sp * (carlsonrf(cpq,spm,1.0) + spq * enn * carlsonrj(cpq,\
            spm,1.0,spn) / 3.0));
}
define ellipticpi(enn,ekk,circ_rad) {
   return (elliptic3im(enn,k2m(ekk),circ_rad));
}
define elliptic3m__1(enn,emm) {
   return (carlsonrf(0.0,1.0 - emm,1.0) + enn * carlsonrj(0.0,1.0 -\
            emm,1.0,1.0 - enn) / 3.0);
}
define elliptic3im__1(enn,emm,circ_rad) {
   auto sinphi,sinphisq,sinphicu,cosphisq,argb,npihlfs,lcirc_rad,\
            kresult;
   npihlfs = floor(circ_rad / (cxpi / 2.0));
   if (isodd(npihlfs)) {
      npihlfs += 1;
   }
   lcirc_rad = circ_rad;
   if (npihlfs == 0) {
      kresult = 0.0;
   } else {
      kresult = elliptic3m(enn,emm) * npihlfs;
      lcirc_rad -= npihlfs * cxpi / 2.0;
   }
   sinphi = sin(lcirc_rad);
   sinphisq = sinphi * sinphi;
   sinphicu = sinphi * sinphisq;
   cosphisq = square(cos(lcirc_rad));
   argb = 1.0 - emm * sinphisq;
   return (kresult + sinphi * carlsonrf(cosphisq,argb,1.0) + sinphicu *\
            carlsonrj(cosphisq,argb,1.0,1.0 - enn * sinphisq) * enn /\
            3.0);
}
cxlx_elliptic_eps = (1.0 * 10^-9);
lv_emm = -10.0;
lv_elli_rad = -10.0;
lv_arr_arr[0] = 0;
define lf_jacobiphi_0_1(emm,elli_rad) {
   auto ai,ebb,circ_rad,geo_mean,twon,aa_arr[],cc_arr[],ii;
   ebb = sqrt(1.0 - emm);
   aa_arr[0] = 1.0;
   cc_arr[0] = sqrt(emm);
   twon = 1.0;
   ii = 0;
   while (cxdbleps < abs(cc_arr[ii] / aa_arr[ii])) {
      if (19 - 1 < ii) {
         break;
      }
      ai = aa_arr[ii];
      ii += 1;
      cc_arr[ii] = (ai - ebb) / 2.0;
      geo_mean = sqrt(ai * ebb);
      aa_arr[ii] = (ai + ebb) / 2.0;
      ebb = geo_mean;
      twon *= 2.0;
   }
   circ_rad = twon * aa_arr[ii] * elli_rad;
   while (0 < ii) {
      ebb = cc_arr[ii] * sin(circ_rad) / aa_arr[ii];
      circ_rad = (sininv(ebb) + circ_rad) / 2.0;
      ii -= 1;
   }
   return (circ_rad);
}
define lf_cn_0_1(emm,elli_rad) {
   auto ai,csx,snx,retvalu;
   if (emm < cxlx_elliptic_eps) {
      snx = sin(elli_rad);
      csx = cos(elli_rad);
      ai = emm * (elli_rad - snx * csx) / 4.0;
      retvalu = csx + ai * snx;
   } else if (emm < 1.0 - cxlx_elliptic_eps) {
      retvalu = cos(lf_jacobiphi_0_1(emm,elli_rad));
   } else {
      csx = cosh(elli_rad);
      if (emm < 1.0) {
         snx = sinh(elli_rad);
         ai = (1.0 - emm) / 4.0;
         retvalu = 1.0 / csx - ai * (csx * snx + elli_rad);
      } else {
         retvalu = 1.0 / csx;
      }
   }
   return (retvalu);
}
define lf_sn_0_1(emm,elli_rad) {
   auto ai,csx,snx,retvalu;
   if (emm < cxlx_elliptic_eps) {
      snx = sin(elli_rad);
      csx = cos(elli_rad);
      ai = emm * (elli_rad - snx * csx) / 4.0;
      retvalu = snx - ai * csx;
   } else if (emm < 1.0 - cxlx_elliptic_eps) {
      retvalu = sin(lf_jacobiphi_0_1(emm,elli_rad));
   } else {
      csx = cosh(elli_rad);
      snx = sinh(elli_rad);
      if (emm < 1.0) {
         ai = (1.0 - emm) / 4.0;
         retvalu = (snx + snx * ai - ai * elli_rad / csx) / csx;
      } else {
         retvalu = snx / csx;
      }
   }
   return (retvalu);
}
define lf_dn_0_1(emm,elli_rad) {
   auto ai,csx,snx,retvalu;
   if (emm < cxlx_elliptic_eps) {
      snx = sin(elli_rad);
      retvalu = 1.0 - emm * snx * snx / 2.0;
   } else if (emm < 1.0 - cxlx_elliptic_eps) {
      snx = sin(lf_jacobiphi_0_1(emm,elli_rad));
      retvalu = sqrtx(1.0 - emm * snx * snx);
   } else {
      csx = cosh(elli_rad);
      if (emm < 1.0) {
         ai = (1.0 - emm) / 4.0;
         snx = sinh(elli_rad);
         retvalu = 1.0 / csx + ai * (csx * snx + elli_rad);
      } else {
         retvalu = 1.0 / csx;
      }
   }
   return (retvalu);
}
define lf_cn_gt1(emm,elli_rad) {
   auto ekk,retvalu;
   ekk = m2k(emm);
   retvalu = lf_dn_0_1(1.0 / emm,elli_rad * ekk);
   return (retvalu);
}
define lf_sn_gt1(emm,elli_rad) {
   auto ekk,retvalu;
   ekk = m2k(emm);
   retvalu = lf_sn_0_1(1.0 / emm,elli_rad * ekk) / ekk;
   return (retvalu);
}
define lf_dn_gt1(emm,elli_rad) {
   auto ekk,retvalu;
   ekk = m2k(emm);
   retvalu = lf_cn_0_1(1.0 / emm,elli_rad * ekk);
   return (retvalu);
}
define lf_ellpj_0_1(emm,elli_rad,*ret_arr_p[]) {
   # local-use Bc lv_emm;
   # local-use Bc lv_elli_rad;
   auto ai,csx,snx,circ_rad,twon;
   if (emm < cxlx_elliptic_eps) {
      snx = sin(elli_rad);
      csx = cos(elli_rad);
      ai = emm * (elli_rad - snx * csx) / 4.0;
      ret_arr_p[0] = snx - ai * csx;
      ret_arr_p[1] = csx + ai * snx;
      ret_arr_p[2] = 1.0 - emm * snx * snx / 2.0;
      ret_arr_p[3] = elli_rad - ai;
   } else if (emm < 1.0 - cxlx_elliptic_eps) {
      circ_rad = lf_jacobiphi_0_1(emm,elli_rad);
      snx = sin(circ_rad);
      ret_arr_p[0] = snx;
      ret_arr_p[1] = cos(circ_rad);
      ret_arr_p[2] = sqrtx(1.0 - emm * snx * snx);
      ret_arr_p[3] = circ_rad;
   } else {
      ai = (1.0 - emm) / 4.0;
      csx = cosh(elli_rad);
      snx = tanh(elli_rad);
      twon = csx * sinh(elli_rad);
      ret_arr_p[0] = snx + ai * (twon - elli_rad) / (csx * csx);
      ret_arr_p[3] = 2.0 * atan2(exp(elli_rad),1.0) - cxpi / 2.0 + ai *\
               (twon - elli_rad) / csx;
      ai *= snx / csx;
      ret_arr_p[1] = 1.0 / csx - ai * (twon - elli_rad);
      ret_arr_p[2] = 1.0 / csx + ai * (twon + elli_rad);
   }
   lv_emm = emm;
   lv_elli_rad = elli_rad;
   return 0;
}
define lf_ellpj(emm,elli_rad,*ret_arr_p[]) {
   # local-use Bc lv_emm;
   # local-use Bc lv_elli_rad;
   auto ai,csx,snx,junk_arr[];
   if (emm < 0.0) {
      if (emm < - 2.0) {
         snx = sin(elli_rad) + tanh(elli_rad) - lf_sn_gt1(1.0 - emm,\
                  elli_rad);
      } else {
         snx = sin(elli_rad) + tanh(elli_rad) - lf_sn_0_1(1.0 - emm,\
                  elli_rad);
      }
      if (emm < - 1.0) {
         csx = 2.0 * cos(elli_rad) - lf_cn_gt1(-emm,elli_rad);
      } else {
         csx = 2.0 * cos(elli_rad) - lf_cn_0_1(-emm,elli_rad);
      }
      ret_arr_p[0] = snx;
      ret_arr_p[1] = csx;
      ret_arr_p[2] = -dn(-emm,elli_rad) + 2.0;
      ret_arr_p[3] = atan2(snx,csx);
   } else if (emm <= 1.0) {
      bcdummy = lf_ellpj_0_1(emm,elli_rad,junk_arr[]);
      ret_arr_p[0] = junk_arr[0];
      ret_arr_p[1] = junk_arr[1];
      ret_arr_p[2] = junk_arr[2];
      ret_arr_p[3] = junk_arr[3];
   } else {
      ai = m2k(emm);
      bcdummy = lf_ellpj_0_1(1.0 / emm,elli_rad * ai,junk_arr[]);
      ret_arr_p[0] = junk_arr[0] / ai;
      ret_arr_p[1] = junk_arr[2];
      ret_arr_p[2] = junk_arr[1];
      ret_arr_p[3] = junk_arr[3];
   }
   lv_emm = emm;
   lv_elli_rad = elli_rad;
   return 0;
}
define jacobiphi(emm,elli_rad) {
   auto circ_rad;
   if (0.0 < emm && emm < 1.0) {
      circ_rad = lf_jacobiphi_0_1(emm,elli_rad);
   } else {
      circ_rad = taninv(sn(emm,elli_rad) / cn(emm,elli_rad));
   }
   return (circ_rad);
}
define sn__1(emm,elli_rad) {
   # local-use Bc lv_emm;
   # local-use Bc lv_elli_rad;
   # local-use Bc lv_arr_arr[];
   if (isneq(emm,lv_emm) || isneq(elli_rad,lv_elli_rad)) {
      bcdummy = lf_ellpj(emm,elli_rad,lv_arr_arr[]);
   }
   return (lv_arr_arr[0]);
}
define cn__1(emm,elli_rad) {
   # local-use Bc lv_emm;
   # local-use Bc lv_elli_rad;
   # local-use Bc lv_arr_arr[];
   if (isneq(emm,lv_emm) || isneq(elli_rad,lv_elli_rad)) {
      bcdummy = lf_ellpj(emm,elli_rad,lv_arr_arr[]);
   }
   return (lv_arr_arr[1]);
}
define dn__1(emm,elli_rad) {
   # local-use Bc lv_emm;
   # local-use Bc lv_elli_rad;
   # local-use Bc lv_arr_arr[];
   if (isneq(emm,lv_emm) || isneq(elli_rad,lv_elli_rad)) {
      bcdummy = lf_ellpj(emm,elli_rad,lv_arr_arr[]);
   }
   return (lv_arr_arr[2]);
}
define dn(emm,elli_rad) {
   auto ekk,retvalu;
   if (emm < - 1.0) {
      retvalu = -lf_dn_gt1(-emm,elli_rad) + 2.0;
   } else if (emm < 0.0) {
      retvalu = -lf_dn_0_1(-emm,elli_rad) + 2.0;
   } else if (emm <= 1.0) {
      retvalu = lf_dn_0_1(emm,elli_rad);
   } else {
      ekk = m2k(emm);
      retvalu = lf_cn_0_1(1.0 / emm,elli_rad * ekk);
   }
   return (retvalu);
}
define cn(emm,elli_rad) {
   auto ai,csx,snx,ekk,retvalu;
   if (emm < - 1.0) {
      retvalu = -lf_cn_gt1(-emm,elli_rad) + 2.0 * cos(elli_rad);
   } else if (emm < 0.0) {
      retvalu = -lf_cn_0_1(-emm,elli_rad) + 2.0 * cos(elli_rad);
   } else if (emm < cxlx_elliptic_eps) {
      snx = sin(elli_rad);
      csx = cos(elli_rad);
      ai = emm * (elli_rad - snx * csx) / 4.0;
      retvalu = csx + ai * snx;
   } else if (emm < 1.0 - cxlx_elliptic_eps) {
      retvalu = cos(lf_jacobiphi_0_1(emm,elli_rad));
   } else if (emm <= 1.0) {
      ai = (1.0 - emm) / 4.0;
      csx = cosh(elli_rad);
      snx = sinh(elli_rad);
      retvalu = 1.0 / csx - ai * (csx * snx + elli_rad);
   } else {
      ekk = m2k(emm);
      retvalu = lf_dn_0_1(1.0 / emm,elli_rad * ekk);
   }
   return (retvalu);
}
define sn(emm,elli_rad) {
   auto ai,csx,snx,ekk,retvalu;
   if (emm < - 1.0) {
      retvalu = sin(elli_rad) + tanh(elli_rad) - lf_sn_gt1(1.0 - emm,\
               elli_rad);
   } else if (emm < 0.0) {
      retvalu = sin(elli_rad) + tanh(elli_rad) - lf_sn_0_1(1.0 - emm,\
               elli_rad);
   } else if (emm < cxlx_elliptic_eps) {
      snx = sin(elli_rad);
      csx = cos(elli_rad);
      ai = emm * (elli_rad - snx * csx) / 4.0;
      retvalu = snx - ai * csx;
   } else if (emm < 1.0 - cxlx_elliptic_eps) {
      retvalu = sin(lf_jacobiphi_0_1(emm,elli_rad));
   } else if (emm <= 1.0) {
      ai = (1.0 - emm) / 4.0;
      csx = cosh(elli_rad);
      snx = sinh(elli_rad);
      retvalu = (snx + snx * ai - ai * elli_rad / csx) / csx;
   } else {
      ekk = m2k(emm);
      retvalu = lf_sn_0_1(1.0 / emm,elli_rad * ekk) / ekk;
   }
   return (retvalu);
}
define cd(emm,elli_rad) {
   return (cn(emm,elli_rad) / dn(emm,elli_rad));
}
define sd(emm,elli_rad) {
   return (sn(emm,elli_rad) / dn(emm,elli_rad));
}
define nd(emm,elli_rad) {
   return (1.0 / dn(emm,elli_rad));
}
define dc(emm,elli_rad) {
   return (dn(emm,elli_rad) / cn(emm,elli_rad));
}
define nc(emm,elli_rad) {
   return (1.0 / cn(emm,elli_rad));
}
define sc(emm,elli_rad) {
   return (sn(emm,elli_rad) / cn(emm,elli_rad));
}
define ds(emm,elli_rad) {
   return (dn(emm,elli_rad) / sn(emm,elli_rad));
}
define cs(emm,elli_rad) {
   return (cn(emm,elli_rad) / sn(emm,elli_rad));
}
define ns(emm,elli_rad) {
   return (1.0 / sn(emm,elli_rad));
}
define ell2cir(emm,elli_rad) {
   return (jacobiphi(emm,elli_rad));
}
define cir2ell(emm,circ_rad) {
   return (elliptic1im(emm,circ_rad));
}
define jacobicir(emm) {
   return (4.0 * elliptic2m(emm) / sqrt(1.0 - emm));
}
define nom(emm) {
   return (exp(-cxpi * elliptic1m(1.0 - emm) / elliptic1m(emm)));
}
define theta1(emm,zz) {
   auto sum_curr,sum_prev,enn,sig,ang,ang_inc,qq;
   sig = 1.0;
   qq = nom(emm);
   sum_curr = 0.0;
   ang = zz;
   ang_inc = 2.0 * zz;
   enn = 0;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += sig * pow(qq,square(enn + 0.5)) * sin(ang);
      ang += ang_inc;
      sig = -sig;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      enn += 1;
   }
   return (2.0 * sum_curr);
}
define theta2(emm,zz) {
   auto sum_curr,sum_prev,enn,ang,ang_inc,qq;
   qq = nom(emm);
   sum_curr = 0.0;
   ang = zz;
   ang_inc = 2.0 * zz;
   enn = 0;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += pow(qq,square(enn + 0.5)) * cos(ang);
      ang += ang_inc;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      enn += 1;
   }
   return (2.0 * sum_curr);
}
define theta3(emm,zz) {
   auto sum_curr,sum_prev,enn,ang,ang_inc,qq;
   qq = nom(emm);
   sum_curr = 0.0;
   ang = 2.0 * zz;
   ang_inc = ang;
   enn = 1;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += pow(qq,enn * enn) * cos(ang);
      ang += ang_inc;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      enn += 1;
   }
   return (1.0 + 2.0 * sum_curr);
}
define theta4(emm,zz) {
   auto sum_curr,sum_prev,enn,ang,ang_inc,qq,sig;
   sig = 1.0;
   qq = nom(emm);
   sum_curr = 0.0;
   ang = 2.0 * zz;
   ang_inc = ang;
   enn = 1;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += sig * pow(qq,enn * enn) * cos(ang);
      ang += ang_inc;
      sig = -sig;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      enn += 1;
   }
   return (1.0 + 2.0 * sum_curr);
}
define nevillethetac(emm,zz) {
   auto sum_curr,sum_prev,enn,qq,km,cos_of,cos_inc;
   km = elliptic1m(emm);
   qq = exp(-cxpi * elliptic1m(1.0 - emm) / km);
   sum_curr = 0.0;
   cos_inc = cxpi * zz / km;
   cos_of = cxpi * zz / (2.0 * km);
   enn = 0;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += pow(qq,enn * enn + enn) * cos(cos_of);
      cos_of += cos_inc;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      enn += 1;
   }
   return (sum_curr * sqrt(cxtau * sqrt(qq / emm) / km));
}
define nevillethetad(emm,zz) {
   auto sum_curr,sum_prev,enn,qq,km,cos_of,cos_inc;
   km = elliptic1m(emm);
   qq = exp(-cxpi * elliptic1m(1.0 - emm) / km);
   sum_curr = 0.0;
   cos_inc = cxpi * zz / km;
   cos_of = cxpi * zz / km;
   enn = 1;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += pow(qq,enn * enn) * cos(cos_of);
      cos_of += cos_inc;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      enn += 1;
   }
   return ((1.0 + 2.0 * sum_curr) * sqrt(cxtau / km) / 2.0);
}
define nevillethetan(emm,zz) {
   auto sum_curr,sum_prev,enn,qq,km,sig,cos_of,cos_inc;
   km = elliptic1m(emm);
   qq = exp(-cxpi * elliptic1m(1.0 - emm) / km);
   sum_curr = 0.5;
   sig = -1.0;
   cos_inc = cxpi * zz / km;
   cos_of = cxpi * zz / km;
   enn = 1;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += sig * pow(qq,enn * enn) * cos(cos_of);
      cos_of += cos_inc;
      sig = -sig;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      enn += 1;
   }
   return (2.0 * sum_curr * sqrt(cxtau / (km * sqrt(1.0 - emm))) / 2.0);
}
define nevillethetas(emm,zz) {
   auto sum_curr,sum_prev,enn,qq,km,sig,cos_of,cos_inc;
   km = elliptic1m(emm);
   qq = exp(-cxpi * elliptic1m(1.0 - emm) / km);
   sum_curr = 0.0;
   sig = 1.0;
   cos_inc = cxpi * zz / km;
   cos_of = cxpi * zz / (2.0 * km);
   enn = 0;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += sig * pow(qq,enn * enn + enn) * sin(cos_of);
      sig = -sig;
      cos_of += cos_inc;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      enn += 1;
   }
   return (sum_curr * sqrt(cxtau * sqrt(qq / (emm * (1.0 - emm))) / km));
}
define ellipsearea(semi_axis_a,semi_axis_b) {
   return (cxpi * semi_axis_a * semi_axis_b);
}
define ellipseecc(semi_axis_a,semi_axis_b) {
   return (topyh1(ratio(semi_axis_a,semi_axis_b)));
}
define ellipsem(semi_axis_a,semi_axis_b) {
   auto rati;
   rati = ratio(semi_axis_a,semi_axis_b);
   return (1.0 - rati * rati);
}
define ellipseflatness(semi_axis_a,semi_axis_b) {
   return (1.0 - ratio(semi_axis_a,semi_axis_b));
}
define ellipsen(semi_axis_a,semi_axis_b) {
   return (abs(semi_axis_a - semi_axis_b) / (semi_axis_a + semi_axis_b));
}
define flat2ecc(flt) {
   return (sqrt(flt * (2.0 - flt)));
}
define ecc2flat(ecc) {
   return (1.0 - sqrt(1.0 - ecc * ecc));
}
define ellipsecir(semi_axes_a,semi_axes_b) {
   auto aaa,bbb,pows_two,suma,temp,ii,retvalu,axes_sum;
   if (semi_axes_a < semi_axes_b) {
      aaa = semi_axes_b;
      bbb = semi_axes_a;
   } else {
      aaa = semi_axes_a;
      bbb = semi_axes_b;
   }
   if (bbb <= sqrt(cxdbleps) * aaa) {
      retvalu = 4.0 * aaa;
   } else {
      suma = 0.0;
      axes_sum = aaa + bbb;
      pows_two = 1.0;
      ii = 0;
      for (;;) {
         temp = (aaa + bbb) / 2.0;
         bbb = sqrt(aaa * bbb);
         aaa = temp;
         pows_two += pows_two;
         suma += pows_two * square(aaa - bbb);
         if (iseq(aaa,bbb)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (30 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = cxpi * (square(axes_sum) - suma) / (aaa + bbb);
   }
   return (retvalu);
}
define ellipsecir__1(semi_axis_a,semi_axis_b) {
   auto major_axis,minor_axis,rati;
   if (semi_axis_a < semi_axis_b) {
      major_axis = semi_axis_b;
      minor_axis = semi_axis_a;
   } else {
      major_axis = semi_axis_a;
      minor_axis = semi_axis_b;
   }
   rati = minor_axis / major_axis;
   return (4.0 * major_axis * elliptic2m(1.0 - rati * rati));
}
define epdf(minvalx,maxvalx,data_num,*data_arr_pc[],pdf_num,\
         *ret_pdf_arr_p[]) {
   auto ii,indi,gap_size,retvalu,inc;
   for (ii = 0; ii <= pdf_num - 1; ii += 1) {
      ret_pdf_arr_p[ii] = 0.0;
   }
   inc = 1.0 / data_num;
   gap_size = (maxvalx - minvalx) / (pdf_num - 1.0);
   retvalu = 0.0;
   for (ii = 0; ii <= data_num - 1; ii += 1) {
      if (data_arr_pc[ii] < minvalx) {
         ret_pdf_arr_p[0] += inc;
      } else if (data_arr_pc[ii] < maxvalx) {
         indi = ceil((data_arr_pc[ii] - minvalx) / gap_size);
         ret_pdf_arr_p[indi] += inc;
      } else {
         retvalu += inc;
      }
   }
   return (retvalu);
}
define ecdf(minvalx,maxvalx,data_num,*data_arr_pc[],pdf_num,\
         *ret_cdf_arr_p[]) {
   auto ii,sumcurr;
   bcdummy = epdf(minvalx,maxvalx,data_num,data_arr_pc[],pdf_num,\
            ret_cdf_arr_p[]);
   sumcurr = ret_cdf_arr_p[0];
   for (ii = 1; ii <= pdf_num - 1; ii += 1) {
      sumcurr += ret_cdf_arr_p[ii];
      ret_cdf_arr_p[ii] = sumcurr;
   }
   return (sumcurr);
}
define epdf2cdf(data_num,*pdf_arr_pc[],*ret_cdf_arr_p[]) {
   auto ii,sumcurr;
   sumcurr = 0.0;
   for (ii = 0; ii <= data_num - 1; ii += 1) {
      sumcurr += pdf_arr_pc[ii];
      ret_cdf_arr_p[ii] = sumcurr;
   }
   return (sumcurr);
}
lv_search_target = 0;
define search_check(gg) {
   # local-use Bc lv_search_target;
   auto retvalu;
   if (gg < lv_search_target) {
      retvalu = -1;
   } else if (lv_search_target < gg) {
      retvalu = 1;
   } else {
      retvalu = 0;
   }
   return (retvalu);
}
define search_search(gg) {
   # local-use Bc lv_search_target;
   auto curr,delta,result;
   lv_search_target = gg;
   curr = 1;
   for (delta = 0; delta <= cxintmax; delta += 1) {
      result = search_check(curr);
      if (0 <= result) {
         break;
      }
      curr += curr;
   }
   if (4 <= curr) {
      delta = curr / 4;
      while (1 <= delta) {
         if (0 < result) {
            curr -= delta;
         } else if (result < 0) {
            curr += delta;
         } else {
            break;
         }
         result = search_check(curr);
         if (delta < 2) {
            if (0 < result && 1 < curr) {
               curr -= 1;
            }
            break;
         }
         delta /= 2;
      }
   }
   return (curr);
}
define blackbodyl(wavelen,temp_k) {
   auto hc,hc_kt,retvalu;
   if (wavelen <= 0.0 || temp_k <= 0.0) {
      retvalu = 0.0;
   } else {
      hc = cxplanck * cxlight;
      hc_kt = hc / (cxboltzmann * temp_k);
      retvalu = 2.0 * hc * cxlight / (pow(wavelen,5) * (exp(hc_kt /\
               wavelen) - 1.0));
   }
   return (retvalu);
}
define blackbodyf(wavefreq,temp_k) {
   auto h_kt,retvalu;
   if (wavefreq <= 0.0 || temp_k <= 0.0) {
      retvalu = 0.0;
   } else {
      h_kt = cxplanck / (cxboltzmann * temp_k);
      retvalu = 2.0 * cxplanck * pow(wavefreq,3) / (pow(cxlight,2) *\
               (exp(h_kt * wavefreq) - 1.0));
   }
   return (retvalu);
}
define blackbodymode(temp_k) {
   auto hc_kt,retvalu;
   if (temp_k <= 0.0) {
      retvalu = 0.0;
   } else {
      hc_kt = cxplanck * cxlight / (cxboltzmann * temp_k);
      retvalu = hc_kt / (5.0 + wp(-5.0 * exp(-5.0)));
   }
   return (retvalu);
}
define blackbodypower(temp_k) {
   return (cxstefan * pow(temp_k,4.0));
}
define bhmass_to_tempk(bhmass_kg) {
   return (cxbhmasstemp / bhmass_kg);
}
define bhtempk_to_mass(bhtemp_k) {
   return (cxbhmasstemp / bhtemp_k);
}
define bhmass_to_radius(bhmass_kg) {
   return (bhmass_kg / cxbhmass_radius);
}
define bhradius_to_mass(bhradius_m) {
   return (cxbhmass_radius * bhradius_m);
}
define bhmass_to_entropy(bhmass_kg) {
   return (bhmass_kg * bhmass_kg / cxbhmass2_entropy);
}
define bhentropy_to_mass(bhentropy) {
   return (sqrt(bhentropy * cxbhmass2_entropy));
}
define bhmass_to_power(bhmass_kg) {
   return (cxbhmass2power / (bhmass_kg * bhmass_kg));
}
define bhpower_to_mass(bhpower_w) {
   return (sqrt(cxbhmass2power / bhpower_w));
}
define bhmass_to_area(bhmass_kg) {
   return (bhmass_kg * bhmass_kg / cxbhmass2_area);
}
define bharea_to_mass(bharea) {
   return (sqrt(cxbhmass2_area * bharea));
}
define bhlifetime_to_mass(bhlifetime_s) {
   return (cbrt(cxbhmass3_lifetime * bhlifetime_s));
}
define bhmass_to_lifetime(bhmass_kg) {
   return (bhmass_kg * bhmass_kg * bhmass_kg / cxbhmass3_lifetime);
}
define bhmass_to_density(bhmass_kg) {
   return (bhmass_kg * bhmass_kg / cxbhmass2_density);
}
define bhdensity_to_mass(bhdensity) {
   return (sqrt(bhdensity * cxbhmass2_density));
}
define pendulum(len_m,ang_offset_rad,grav) {
   return (cxtau * sqrt(len_m / grav) / agmean(1.0,cos(ang_offset_rad /\
            2.0)));
}
define sr_mass(velo_mps) {
   return (1.0 / sqrtxp1m1(-square(velo_mps / cxlight)));
}
define sr_time(velo_mps) {
   return (sqrtxp1m1(-square(velo_mps / cxlight)));
}
define gr_massgm(gm_gm,radius_m) {
   return (gm_gm / (radius_m * cxlight * cxlight));
}
define gr_mass(mass_kg,radius_m) {
   return (gr_massgm(cxgravitation * mass_kg,radius_m));
}
define gr_timegm(gm_gm,radius_m) {
   auto con;
   con = 2 * gm_gm / (cxlight * cxlight);
   return (sqrtxp1m1(-con / radius_m));
}
define gr_time(mass_kg,radius_m) {
   return (gr_timegm(cxgravitation * mass_kg,radius_m));
}
define gr_timegm_dr(gm_gm,radius_m) {
   auto con;
   con = 2 * gm_gm / (cxlight * cxlight);
   return (con / (2 * radius_m * radius_m * sqrt(1.0 - con / radius_m)));
}
define cent2ratio(cnt) {
   return (pow2(cnt / 1200.0));
}
define ratio2cent(rat) {
   return (lg(rat) * 1200.0);
}
#   DDDDDDDDDDescription ################################### kw_description #
define kw_description() {
   print "Usage: bcc [Expression]\n";
   print "   Kw 0-ary Functions: corr_new euler__1 gau_rand jd2ymdhmsinv ma";
   print "gicnot magicset normal_rand parabola_realroots parabola_xaxis par";
   print "abola_yextrema randd stts_new timee";
   print "\n";
   print "   Kw 1-ary Functions: a2k a2m abs agmean1 agmean1inv ahmean1 alm";
   print "ean1 amean1 aqmean1 b2m bankers bell bellx benford_rand bernoulli";
   print " bernoullid bernoullin bessI0 bessI1 bessJ0 bessJ1 bessK0 bessK1 ";
   print "bessY0 bessY1 bessY1__1 bharea_to_mass bhdensity_to_mass bhentrop";
   print "y_to_mass bhlifetime_to_mass bhmass_to_area bhmass_to_density bhm";
   print "ass_to_entropy bhmass_to_lifetime bhmass_to_power bhmass_to_radiu";
   print "s bhmass_to_tempk bhpower_to_mass bhradius_to_mass bhtempk_to_mas";
   print "s bits_count bits_ls1b bits_ls1bpos bits_ms1b bits_ms1bpos bitwis";
   print "enot blackbodyf_pdf blackbodyl_pdf blackbodymode blackbodypower\
            cxc";
   print "antor carmichael catalan cauchy_rand cbrt ceil cent2ratio chisqr_";
   print "rand circle_get clip clockhour clockmin clocksec clockstdev clock";
   print "sum cnv_dbl2si16 contfra_print contfrac_print contfracd_print cor";
   print "r_delete corr_handlex corr_handley corrcorr corrslope corrstderr ";
   print "corry0 cos cos__1 cosd cosdinv cosh coshinv cosintegral cosinv co";
   print "sm1 cosm1__1 cost costinv cot cotd cotdinv coth cothinv cotinv co";
   print "tt cottinv csc cscd cscdinv csch cschinv cscinv csct csctinv ctz ";
   print "cu cube cuberoot date_easter date_pesach date_rosh_hashanah day2d";
   print "hms day2dhmsinv day2hour deg2dms deg2rad deg2sec deg2tur digamma ";
   print "digamma__1 digammainv dms2deg dms2rad doomsday ecc2flat Ein ellip";
   print "tic1a elliptic1k elliptic1m elliptic1m__1 elliptic1m__2 elliptic2";
   print "a elliptic2k elliptic2m elliptic2m__1 ellipticE ellipticK erf erf";
   print "__1 erf__2 erf__3 erf__4 erfc erfcinv erfcx erfcxinv erfinv eta\
            cxe";
   print "ulerphi eulerx exp exp__1 exp__2 exp_rand expintegral1 expintegra";
   print "li expm1 fac facinv factor_print factorial factorialdouble factor";
   print "ialinv fibo fibox fiboxinv flat2ecc floor frac fubini fusc g2jewi";
   print "sh gamma_rand gau_cdf gau_pdf gau_quantile gd gdinv geo_rand ghme";
   print "an1 ghmean1inv glmean1 gmean1 gqmean1 has_primitiveroot haversin ";
   print "heaviside heronianmean1 hlmean1 hmean1 hn hn__1 hour2day hqmean1 ";
   print "hypot1 hypot1inv id int_rand iround iseven isint isjewish8short i";
   print "sjewish9short isjewishleap isleapyear ismagic isneg isnegint isod";
   print "d ispos isposint ispractical isprime issquarefree iszero j2k2dow ";
   print "j2k2jd j2k2kwt j2k2uet j2k2ymdhms jacobicir jd264_print jd2dow jd";
   print "2j2k jd2kwt jd2uet jd2ymdhms jewish2g jewish2jd jewish2jdx jewish";
   print "_months_in_year jewish_yearlength k2a k2m k2tempc k2tempf k2tempr";
   print " ks_a_cdf kwt2j2k kwt2jd kwt2uet l10 lg lgamma lgamma__1 lgamma__";
   print "2 lgammainv lix lixinv lmean1 ln ln1p ln__1 ln__2 lns log log10 l";
   print "og2 logintegral logistic_rand lqmean1 lucas lucasx m2a m2b m2k me";
   print "rtens minkowski mobius n2primish neg nom normal_cdf normal_cdf__1";
   print " normal_pdf normal_quantile normal_quantile__1 num2char_print par";
   print "abola_get parabola_roots partition partitionq pcf pfg pfl poi_ran";
   print "d pow10 pow2 prime0 prime1 primecount primecountx primenext prime";
   print "nth primenth__1 primeprev primitiveroot qmean1 rad2deg rad2dms ra";
   print "d2dms2 rad2sec rad2tur rand_init randl ratio2cent reci reimann ro";
   print "und rto125 rtoi rtoz sba search_check search_search sec sec2deg s";
   print "ec2dhms sec2rad sec2tur secd secdinv sech sechinv secinv sect sec";
   print "tinv shc_shft2steps shc_steps2shft shc_steps2shftinv sigma0 sigma";
   print "1 sigmoid sigmoidinv sign sin sin__1 sinc sinc__1 sincc sincinv s";
   print "ind sindinv sinh sinhinv sinintegral sininv sint sintinv smooth s";
   print "q sqinv sqrt sqrt__1 sqrt__2 sqrt__3 sqrtx sqrtxp1m1 square squar";
   print "eroot sr_mass sr_time stair stts_delete stts_reset sttscount stts";
   print "magic sttsmax sttsmean sttsmin sttsmsq sttsspread sttsstdev sttss";
   print "tdevmean sttssum sttsvar supercatalan tan tand tandinv tanh tanhi";
   print "nv taninv tant tantinv tempc2k tempc2tempf tempf2k tempf2tempc te";
   print "mpr2k tgamma tgamma__1 tgamma__2 tgamma__3 tgamma__stirling tgamm";
   print "adouble tgammainv topyh1 totient tri tri_rand triinv trip trunc t";
   print "ur2deg tur2rad tur2sec uet2j2k uet2jd uet2kwt uni_rand versin wm ";
   print "wminv wp wpinv ymdhms2j2k ymdhms2jd ymdhms_get zag zeta zig zigza";
   print "cxg";
   print "\n";
   print "   Kw 2-ary Functions: agmean agmean__1 agmeaninva agmeaninvg ahm";
   print "ean almean amean aqmean atan2 atan2d atan2h atan2t atan2u ballot ";
   print "ballots base_out_print base_outf_print benford_cdf benford_pdf be";
   print "ss_jn bess_yn bessIn bessIn_ps bessJn bessJn_ps bessJv bessKn bes";
   print "sYn bessYn_ps bessYv beta beta_rand binomial binomial_rand binomi";
   print "alx birthday birthdayinv birthdayx bits_get bits_set bitshiftl bi";
   print "tshiftr bitwiseand bitwiseor bitwisexor bkn blackbodyf blackbodyl";
   print " carlsonRC cauchy_cdf cauchy_pdf cauchy_quantile cd ceil2 chisqr_";
   print "cdf chisqr_pdf cir2ell cn cn__1 comb combination combx contraharm";
   print "onic cs d1diamond_d2 d1lt_d2 d1spiral_d2 d1ur_d2 d2diamond_d1 d2h";
   print "ypot_d1 d2lt_d1 d2spiral_d1 d2ur_d1 days_in_month dc ddist dist d";
   print "log1 dn dn__1 ds ell2cir ellipsearea ellipsecir ellipsecir__1 ell";
   print "ipseecc ellipseflatness ellipsem ellipsen elliptic1ia elliptic1ik";
   print " elliptic1im elliptic1im__1 elliptic2ia elliptic2ik elliptic2im\
            cxe";
   print "lliptic2im__1 elliptic3a elliptic3k elliptic3m elliptic3m__1 elli";
   print "pticEi ellipticF ellipticP entringer eulerian exp_cdf exp_pdf exp";
   print "_quantile expintegraln factor factorialt floor2 fmod fmod fmods f";
   print "modu fmody fmul gamma_cdf gamma_pdf gcd gcda geo_cdf geo_pdf geo_";
   print "quantile ghmean glmean gmean gompertz_rand gqmean gr_mass gr_mass";
   print "gm gr_time gr_timegm gr_timegm_dr has_primitiveroot_f heronianmea";
   print "n hlmean hmean hnm hqmean hypot int_cdf int_pdf int_quantile ints";
   print "_rand iseq isge isgt isle islt ismult ismultl isneq ispractical_f";
   print " isprimitiveroot issignsame issquarefree_f isss jacobiphi jewish_";
   print "monthbegin jewish_monthlength ks_b_cdf ks_cdf ks_quantile lbeta l";
   print "cam lcams lcantim lcm lcombx ligamma ligammainv lmean logistic_cd";
   print "f logistic_pdf logistic_quantile logx lpermx lqmean max2 maxabs m";
   print "axabs2 maxi mb_cdf mb_pdf mean min2 minabs minabs2 mini mobius_f ";
   print "modf mods modulo n2perm_print nbd_rand nc nd nevillethetac nevill";
   print "ethetad nevillethetan nevillethetas ns nthroot__1 pareto_rand per";
   print "m permutation permx pochhammer poi_cdf poi_pdf poi_quantile polya";
   print "_rand polycnum polynum pow powi prime0_f print_array qmean rand_i";
   print "nit_array ratio repetendlen rligamma rms round2 rtomsd ruigamma s";
   print "cxc sd shc_shftpoles2steps sigma sigma0_f sigma1_f sn sn__1\
            spread2";
   print "stdev stdev2spread stirling1 stirling2 stts_copy stts_downdate st";
   print "ts_newx stts_scale stts_shift stts_update stts_update2 t_cdf t_cd";
   print "f__1 t_pdf t_quantile t_quantile__1 tetracnum tetranum theta1 the";
   print "ta2 theta3 theta4 Tn topyh totient_f trap_rand tri_cdf tri_pdf tr";
   print "i_quantile uigamma uigamma__1 uigammainv Un uni_cdf uni_pdf uni_q";
   print "uantile variance zeta_cdf zeta_pdf zipf_rand znorder znorder__1";
   print "\n";
   print "   Kw 3-ary Functions: agcmean aghmean atothenmodp atothenmodx ba";
   print "se_out_fix_print beta_cdf beta_pdf beta_quantile betainc betainc_";
   print "_1 binomial_cdf binomial_pdf bits_assign bkbn cantorll cantorul\
            cxc";
   print "antorxx carlsonRD carlsonRF chebeval clip2 clip2x corr_update cos";
   print "sin_ev divi dlog dlogx ellipsoid_surface ellipsoid_volume ellipti";
   print "c3ia elliptic3ik elliptic3im elliptic3im__1 ellipticPi epdf2cdf f";
   print "11 f_cdf f_quantile f_quantile__1 fibo3 fit_ls fit_ls0 fit_minmax";
   print " fit_minmax0 fit_poly fitx_minmax fmod2 fvad fvoa gompertz_cdf go";
   print "mpertz_pdf gompertz_quantile hms2day horner hypot3 ifzero isalmos";
   print "tequal isbetween isbetweenx isfloorsame iswithin jewishymd2jd kev";
   print "y_print loanpayment loanrate loanvalue maxabsoffset maxmin maxwel";
   print "l_boltzmann_cdf maxwell_boltzmann_pdf maxwell_juttner_pdf minabso";
   print "ffset n2comb_print n2perm nbd_cdf nbd_pdf pareto_cdf pareto_pdf p";
   print "areto_quantile pendulum pmean polya_cdf polya_pdf pvad pvoa remqu";
   print "ou roundy sigma_f sigmoid3 sigmoid3d stts_updatex taninv3 trap_cd";
   print "f trap_pdf trap_quantile ymd2dow ymd2doy ymd2j2k ymd2j2k__1 ymd2j";
   print "d zipf_cdf zipf_pdf zipf_quantile";
   print "\n";
   print "   Kw 4-ary Functions: carlsonRJ f21 great_circle_distance n2comb";
   print " sphere_d";
   print "\n";
   print "   Kw 5-ary Functions: sphere_distance";
   print "\n";
   print "   Kw 6-ary Functions: circle_solve ecdf ellipsoid_destination el";
   print "lipsoid_distance epdf parabola_solve stts_init stts_initx";
   print "\n";
}
define kw_desc() {
   print "Usage: bcc [Expression]\n";
   print "   Kw 0-ary Functions: corr_new euler__1 gau_rand jd2ymdhmsinv ma";
   print "gic(not|set) normal_rand parabola_(realroots|xaxis|yextrema) rand";
   print "d stts_new timee";
   print "\n";
   print "   Kw 1-ary Functions: a2k a2m abs agmean1(inv)? ahmean1 almean1 ";
   print "amean1 aqmean1 b2m bankers bellx? benford_rand bernoulli[dn]? bes";
   print "s(I[01]|J[01]|K[01]|y(0|1(__1)?)) bharea_to_mass bhdensity_to_mas";
   print "s bhentropy_to_mass bhlifetime_to_mass\
            bhmass_to_(cxarea|density|en";
   print "tropy|lifetime|power|radius|tempk) bhpower_to_mass bhradius_to_ma";
   print "ss bhtempk_to_mass\
            cxbit(s_(count|ls1b(pos)?|ms1b(pos)?)|wisenot) b";
   print "lackbody(f_pdf|l_pdf|mode|power) cantor carmichael catalan cauchy";
   print "_rand cbrt ceil cent2ratio chisqr_rand circle_get clip\
            clock(cxhour";
   print "|min|s(ec|tdev|um)) cnv_dbl2si16 contfra(_print|c(_print|d_print)";
   print ") corr(_(delete|handle[xy])|corr|s(lope|tderr)|y0) cos(|__1|d(inv";
   print ")?|h(inv)?|in(tegral|v)|m1(__1)?|t(inv)?) cot([dht]?(inv)?)? csc(";
   print "[dht]?(inv)?)? ctz cu cube(root)? date_(easter|pesach|rosh_hashan";
   print "cxah) day2(dhms(inv)?|hour) deg2(dms|rad|sec|tur)\
            digamma(__1|inv)?";
   print " dms2(deg|rad) doomsday ecc2flat Ein elliptic(1([ak]|m(__[12])?)|";
   print "2([ak]|m(__1)?)|[EK]) erf(|__([12]|[34])|c(inv|x(inv)?)?|inv) eta";
   print " cxeuler(cxphi|x) exp(_(_[12]|rand)|integral[1i]|m1)?\
            fac(|inv|tor(_p";
   print "rint|ial(double|inv)?)) fibo(x(inv)?)? flat2ecc floor frac fubini";
   print " fusc g2jewish gamma_rand gau_(cdf|pdf|quantile) gd gdinv geo_ran";
   print "d ghmean1(inv)? glmean1 gmean1 gqmean1 has_primitiveroot haversin";
   print " heaviside heronianmean1 hlmean1 hmean1 hn hn__1 hour2day hqmean1";
   print " hypot1(inv)? id int_rand iround is(even|int|jewish8short|jewish9";
   print "short|jewishleap|leapyear|magic|neg|negint|odd|pos|posint|practic";
   print "al|prime|squarefree|zero) j2k2(dow|jd|kwt|uet|ymdhms) jacobicir j";
   print "d2(64_print|dow|j2k|kwt|uet|ymdhms)\
            jewish(2(cxg|jdx?)|_(months_in_";
   print "year|yearlength)) k2a k2m k2temp[cfr] ks_a_cdf kwt2(j(2k|d)|uet) ";
   print "l10 lg lgamma(__[12]|inv)? lix(inv)? lmean1 ln ln1p ln__[12] lns ";
   print "log(10|2|i(ntegral|stic_rand))? lqmean1 lucasx? m2a m2b m2k merte";
   print "ns minkowski mobius n2primish neg nom normal_(cdf(__1)?|pdf|quant";
   print "ile(__1)?) num2char_print par(abola_(get|roots)|titionq?) pcf pfg";
   print " pfl poi_rand pow(10|2)\
            prim(cxe([01]|countx?|n(ext|th(__1)?)|prev)";
   print "|itiveroot) qmean1 rad2(d(eg|ms2?)|sec|tur) rand(_init|l) ratio2c";
   print "ent reci reimann round rto(125|[iz]) sba search_(check|search) se";
   print "cxc(|2(d(eg|hms)|rad|tur)|[dht]?(inv)?)\
            shc_s(hft2steps|teps2shft(i";
   print "nv)?) sig(m(a[01]|oid(inv)?)|n) sin(|__1|c(__1|c|inv)?|d(inv)?|h(";
   print "inv)?|in(tegral|v)|t(inv)?) smooth sq sqinv sqrt(__[123]|x(p1m1)?";
   print ")? square(root)? sr_(cxmass|time) stair\
            stts(_(delete|reset)|count|";
   print "m(a(gic|x)|ean|in|sq)|s(pread|tdev(mean)?|um)|var) supercatalan t";
   print "an([dht]?(inv)?)? temp(c2(k|tempf)|f2(k|tempc)|r2k) tgamma(__([12";
   print "3]|stirling)|double|inv)? topyh1 totient tri(_rand|inv|p)? trunc ";
   print "tur2(deg|rad|sec) uet2(j(2k|d)|kwt) uni_rand versin wm(inv)? wp(i";
   print "nv)? ymdhms(2j(2k|d)|_get) zag zeta zig(zag)?";
   print "\n";
   print "   Kw 2-ary Functions: agmean(__1|inv[ag])? ahmean almean amean a";
   print "qmean atan2([dh]|[tu])? ballots? base_out(_print|f_print) benford";
   print "_(cdf|pdf) bess(_(jn|yn)|in(_ps)?|j(n(_ps)?|v)|Kn|y(n(_ps)?|v)) b";
   print "eta(_rand)? binomial(_rand|x)? birthday(inv|x)?\
            cxbit(s(_(get|set)|";
   print "hift[lr])|wise(and|or|xor)) bkn blackbody[fl] carlsonRC\
            cauchy_(cxc";
   print "df|pdf|quantile) cd ceil2 chisqr_(cdf|pdf) cir2ell cn cn__1 comb(";
   print "ination|x)? contraharmonic cs d1diamond_d2 d1lt_d2 d1spiral_d2 d1";
   print "ur_d2 d2diamond_d1 d2hypot_d1 d2lt_d1 d2spiral_d1 d2ur_d1 days_in";
   print "_month dc ddist dist dlog1 dn dn__1 ds\
            ell(2cir|ip(se(cxarea|cir(__";
   print "1)?|ecc|flatness|[mn])|tic(1i([ak]|m(__1)?)|2i([ak]|m(__1)?)|3([a";
   print "k]|m(__1)?)|Ei|[FP]))) entringer eulerian exp(_(cdf|pdf|quantile)";
   print "|integraln) factor(ialt)? floor2 fmod([suy]?)? fmul gamma_(cdf|pd";
   print "f) gcda? geo_(cdf|pdf|quantile) ghmean glmean gmean gompertz_rand";
   print " gqmean gr_(cxmass(gm)?|time(gm(_dr)?)?) has_primitiveroot_f\
            heroni";
   print "anmean hlmean hmean hnm hqmean hypot int(_(cdf|pdf|quantile)|s_ra";
   print "nd) is(eq|ge|gt|le|lt|mult|multl|neq|practical_f|primitiveroot|si";
   print "gnsame|squarefree_f|ss) jacobiphi jewish_month(begin|length) ks_(";
   print "b_cdf|cdf|quantile) lbeta lca(ms?|ntim) lcm lcombx ligamma(inv)? ";
   print "lmean log(istic_(cdf|pdf|quantile)|x) lpermx lqmean max(2|abs2?|i";
   print ") mb_(cdf|pdf) mean min(2|abs2?|i) mobius_f mod([fs]|ulo) n2perm_";
   print "print nbd_rand nc nd nevilletheta([cd]|[ns]) ns nthroot__1 pareto";
   print "_rand perm(utation|x)? pochhammer poi_(cdf|pdf|quantile) poly(a_r";
   print "and|cnum|num) powi? pri(me0_f|nt_array) qmean rand_init_array rat";
   print "io repetendlen rligamma rms round2 rtomsd ruigamma sc sd shc_shft";
   print "poles2steps sigma(0_f|1_f)? sn sn__1 spread2stdev stdev2spread st";
   print "irling[12] stts_(copy|downdate|newx|s(cale|hift)|update2?) t_cdf(";
   print "__1)? t_pdf t_quantile(__1)? tetra(cnum|num) theta([12]|[34]) Tn ";
   print "topyh totient_f trap_rand tri_(cdf|pdf|quantile) uigamma(__1|inv)";
   print "? Un uni_(cdf|pdf|quantile) variance zeta_(cdf|pdf) zipf_rand zno";
   print "rder(__1)?";
   print "\n";
   print "   Kw 3-ary Functions: agcmean aghmean atothenmod[px] base_out_fi";
   print "x_print beta(_(cdf|pdf|quantile)|inc(__1)?) binomial_(cdf|pdf) bi";
   print "ts_assign bkbn cantor(ll|ul|xx) carlsonR[DF] chebeval clip2x? cor";
   print "r_update cossin_ev divi dlogx? ellip(soid_(surface|volume)|tic(3i";
   print "([ak]|m(__1)?)|Pi)) epdf2cdf f11 f_cdf f_quantile(__1)? fibo3 fit";
   print "(_(ls0?|minmax0?|poly)|x_minmax) fmod2 fvad fvoa gompertz_(cdf|pd";
   print "f|quantile) hms2day horner hypot3 ifzero is(almostequal|between|b";
   print "etweenx|floorsame|within) jewishymd2jd kevy_print loan(payment|ra";
   print "te|value) max(absoffset|min|well_(boltzmann_(cdf|pdf)|juttner_pdf";
   print ")) minabsoffset n2comb_print n2perm nbd_(cdf|pdf) pareto_(cdf|pdf";
   print "|quantile) pendulum pmean polya_(cdf|pdf) pvad pvoa remquou round";
   print "y sigm(a_f|oid3d?) stts_updatex taninv3 trap_(cdf|pdf|quantile) y";
   print "md2(do[wy]|j(2k(__1)?|d)) zipf_(cdf|pdf|quantile)";
   print "\n";
   print "   Kw 4-ary Functions: carlsonRJ f21 great_circle_distance n2comb";
   print " sphere_d";
   print "\n";
   print "   Kw 5-ary Functions: sphere_distance";
   print "\n";
   print "   Kw 6-ary Functions: circle_solve ecdf ellipsoid_d(estination|i";
   print "stance) epdf parabola_solve stts_initx?";
   print "\n";
}
