#    Copyright (C) 2021 by Kevin D. Woerner
##-# =KDW= ########## DO NOT EDIT -- AUTOGENERATED CODE #########
##-# =KDW= ############ BUILDER $KWROOT/0lib/vkkcp.sh ###########
##-# =KDW= ######### SRC $KWROOT/codekdw/kw-lib/Kw.fwipp ########
# 2021-01-06 kdw  For Changelog,See File Kw.varylog
true = 1;
false = 0;
cxkilogram = 1.0;
cxmeter = 1.0;
cxsecond = 1.0;
cxkelvin = 1.0;
cxampere = 1.0;
cxcoulomb = cxampere * cxsecond;
cxmole = 1.0;
cxcandela = 1.0;
cxbit = 1.0;
cxradian = 1.0;
cxsteradian = (cxradian * cxradian);
cxmetre = cxmeter;
cxkg = cxkilogram;
cxrad = cxradian;
cxe = e(1.0);
cxtau = 8.0 * a((1.0) / (1.0)) / cxrad;
cxphi = 0.5 + sqrt(5.0) / 2.0;
cxlntwo = l(2.0);
cxlnten = l(10.0);
cxsqrttwo = sqrt(2.0);
cxeuler = 0.577215664901532860606512090082402431042159335939924;
cxfeigenbaum =\
      4.669201609102990671853203820466201617258185577475769;
cxapery = 1.202056903159594285399738161511449990764986292340499;
cxgammamin =\
      1.461632144968362341262659542325721328468196204006446;
cxpi = cxtau / 2.0;
cxyotta = (1.0 * 10^24);
cxzetta = (1.0 * 10^21);
cxexa = (1.0 * 10^18);
cxpeta = (1.0 * 10^15);
cxtera = (1.0 * 10^12);
cxgiga = (1.0 * 10^9);
cxmega = (1.0 * 10^6);
cxkilo = (1.0 * 10^3);
cxhecto = (1.0 * 10^2);
cxdeca = (1.0 * 10^1);
cxdeci = (1.0 * 10^-1);
cxcenti = (1.0 * 10^-2);
cxmilli = (1.0 * 10^-3);
cxmicro = (1.0 * 10^-6);
cxnano = (1.0 * 10^-9);
cxpico = (1.0 * 10^-12);
cxfemto = (1.0 * 10^-15);
cxatto = (1.0 * 10^-18);
cxzepto = (1.0 * 10^-21);
cxyocto = (1.0 * 10^-24);
cxkibi = 1024.0;
cxmebi = cxkibi * cxkibi;
cxgibi = cxmebi * cxkibi;
cxtebi = cxgibi * cxkibi;
cxpebi = cxtebi * cxkibi;
cxexbi = cxpebi * cxkibi;
cxzebi = cxexbi * cxkibi;
cxyobi = cxzebi * cxkibi;
cxmps = cxmeter / cxsecond;
cxmpss = cxmeter / (cxsecond * cxsecond);
cxunitgm = cxmeter * (cxmps * cxmps);
cxnewton = cxkilogram * cxmpss;
cxjoule = cxnewton * cxmeter;
cxpa = cxnewton / (cxmeter * cxmeter);
cxwatt = cxjoule / cxsecond;
cxhertz = 1.0 / cxsecond;
cxamp = cxampere;
cxvolt = cxwatt / cxampere;
cxohm = cxvolt / cxampere;
cxhenry = cxohm * cxsecond;
cxfarad = cxcoulomb / cxvolt;
cxsiemens = 1.0 / cxohm;
cxweber = cxvolt * cxsecond;
cxtesla = cxweber / (cxmeter * cxmeter);
cxlumen = cxcandela * cxsteradian;
cxlux = cxlumen / (cxmeter * cxmeter);
cxboltzmann = (1.380649 * 10^-23) * cxjoule / cxkelvin;
cxboltzmann_err = 0.0;
cxboltzmannconst = cxboltzmann;
cxboltzmannconst_err = 0.0;
cxelectroncharge = (1.602176634 * 10^-19) * cxcoulomb;
cxelectroncharge_err = 0.0;
cxlight = (2.99792458 * 10^8) * cxmeter / cxsecond;
cxlight_err = 0.0;
cxlightconst = cxlight;
cxlightconst_err = 0.0;
cxavogadro = (6.02214076 * 10^23) / cxmole;
cxavogadro_err = 0.0;
cxavogadroconst = cxavogadro;
cxavogadroconst_err = 0.0;
cxplanck = (6.62607015 * 10^-34) * cxjoule * cxsecond;
cxplanck_err = 0.0;
cxplanckconst = cxplanck;
cxplanckconst_err = 0.0;
cxkcd = (6.83 * 10^2) * cxlumen / cxwatt;
cxkcd_err = 0.0;
cxdvcshz = (9.19263177 * 10^9) / cxsecond;
cxdvcswavelength = cxlight / cxdvcshz;
cxdvcswavenumber = 1.0 / cxdvcswavelength;
cxdvcsenergy = cxplanck * cxdvcshz;
cxdvcs_err = 0.0;
cxkb = cxboltzmann;
cxkb_err = cxboltzmann_err;
cxelementarycharge = cxelectroncharge;
cxelementarycharge_err = cxelectroncharge_err;
cxplanckbar = cxplanck / cxtau;
cxplanckbar_err = cxplanck_err;
cxh = cxplanck;
cxh_err = cxplanck_err;
cxhbar = cxplanckbar;
cxhbar_err = cxplanckbar_err;
cxboltzmann_rec = 1.0 / cxboltzmann;
cxelectroncharge_rec = 1.0 / cxelectroncharge;
cxlight_rec = 1.0 / cxlight;
cxavogadro_rec = 1.0 / cxavogadro;
cxdvcshz_rec = 1.0 / cxdvcshz;
cxplanck_rec = 1.0 / cxplanck;
cxh_rec = cxplanck_rec;
cxkb_rec = cxboltzmann_rec;
cxkghz = cxkg * (cxlight * cxlight) / cxplanck;
cxkgwavelength = cxlight / cxkghz;
cxkgwavenumber = 1.0 / cxkgwavelength;
cxkgenergy = cxplanck * cxkghz;
cxgravity = 9.80665 * cxmpss;
cxgravity_err = 0.0;
cxatmosphere = (1.01325 * 10^5) * cxpa;
cxatmosphere_err = 0.0;
cxau = (1.495978707 * 10^11) * cxmeter;
cxau_err = 0.0;
cxjosephson = 2.0 * cxelectroncharge / cxplanck;
cxjosephson_err = 0.0;
cxvonklitzing = cxplanck / (cxelectroncharge * cxelectroncharge);
cxvonklitzing_err = 0.0;
cxfaraday = cxelectroncharge * cxavogadro;
cxfaraday_err = 0.0;
cxfaradayconst = cxfaraday;
cxfaradayconst_err = 0.0;
cxgas = cxboltzmann * cxavogadro;
cxgas_err = 0.0;
cxgasconst = cxgas;
cxgasconst_err = 0.0;
cxgravitation = (6.67430 * 10^-11) * cxunitgm / cxkilogram;
cxgravitation_err = (2.2 * 10^-5);
cxgravitationconst = cxgravitation;
cxgravitationconst_err = (2.2 * 10^-5);
cxrydberg = (1.0973731568160 * 10^7) * cxlight / cxmeter;
cxrydberg_err = (1.9 * 10^-12);
cxrydbergconst = cxrydberg;
cxrydbergconst_err = (1.9 * 10^-12);
cxg = cxgravitation;
cxg_err = cxgravitation_err;
cxalpha = (7.2973525664 * 10^-3);
cxalpha_err = (2.3 * 10^-10);
cxalpha_rec = 1.0 / cxalpha;
cxalpha_rec_err = cxalpha_err;
cxfltsig = 23;
cxfltman = 8;
cxflteps = (1.1920928955078125 * 10^-7);
cxfltmax = (3.402823466385288598 * 10^38);
cxdblmaxln = cxlntwo * 1024.0;
cxdblsig = scale * cxlnten / cxlntwo;
cxdbleps = e(cxlnten * (1.0 - scale));
cxdblmax = e(cxdblmaxln) * (1.0 - cxdbleps);
cxsi16max = 32767;
cxsi16min = -32768;
cxui16max = 65535;
cxsi32max = 2147483647;
cxsi32min = -2147483648;
cxui32max = 4294967295;
cxintmax = cxsi32max;
cxmonths_in_year = 12;
cxminute = 60.0 * cxsecond;
cxhour = 60.0 * cxminute;
cxday = 24.0 * cxhour;
cxearthsolarday = cxday;
cxweek = 7.0 * cxday;
cxflick = cxsecond / 705600000.0;
cxjulianday = cxday;
cxjulianyear = 365.25 * cxjulianday;
cxjuliancentury = 100.0 * cxjulianyear;
cxjulianmillennium = 1000.0 * cxjulianyear;
cxjday = cxjulianday;
cxjyear = cxjulianyear;
cxjcentury = cxjuliancentury;
cxjmillennium = cxjulianmillennium;
cxjd = cxjulianday;
cxjy = cxjulianyear;
cxjc = cxjuliancentury;
cxjm = cxjulianmillennium;
cxjewish_first_month = 7;
cxgyear = 365.2425 * cxday;
cxgregorianyear = cxgyear;
cxkwt = 0.1875 * cxsecond;
cxuet = cxsecond;
cxj2k = cxday;
cxj2kday = cxday;
cxjdsec_at_0gregorian = 1721058.5 * cxjday;
cxjdsec_at_0kwt = 2437240.66125 * cxjday;
cxjdsec_at_0j2k = 2451545.0 * cxjday;
cxjdsec_at_0uet = 2440587.5 * cxjday;
cxtt_at_0tai = 32.184 * cxsecond;
cxtt_at_0ut1 = 68.97 * cxsecond;
cxgram = 0.001 * cxkilogram;
cxpound = 0.45359237 * cxkilogram;
cxlb = cxpound;
cxounce = 0.0625 * cxpound;
cxoz = cxounce;
cxton = 2000.0 * cxpound;
cxtonne = 1000.0 * cxkilogram;
cxgrain = cxpound / 7000.0;
cxcarat = 0.2 * cxgram;
cxmm = cxmilli * cxmeter;
cxinch = 0.0254 * cxmeter;
cxhand = 4.0 * cxinch;
cxfoot = 12.0 * cxinch;
cxfeet = cxfoot;
cxft = cxfoot;
cxyard = 3.0 * cxfeet;
cxhorse = 8.0 * cxfeet;
cxmile = 5280.0 * cxfeet;
cxpoint = cxinch / 72.0;
cxstandardgravity = cxgravity;
cxearthgravitya = 9.7803253359 * cxmpss;
cxearthgravityb = 9.8321849378 * cxmpss;
cxgravitationnasa = (6.67259 * 10^-11) * cxunitgm / cxkilogram;
cxgravitationiers = (6.67428 * 10^-11) * cxunitgm / cxkilogram;
cxkgf = cxkilogram * cxgravity;
cxlbf = cxpound * cxgravity;
cxatm = cxatmosphere;
cxstandardatmosphere = cxatmosphere;
cxtorr = cxatmosphere / 760.0;
cxbar = (1.0 * 10^5) * cxpa;
cxmmhg = 13595.1 * cxkilogram * cxgravity * cxmm / (cxmeter *\
      cxmeter * cxmeter);
cxinhg = cxmmhg * cxinch / cxmm;
cxpsi = cxpound * cxgravity / (cxinch * cxinch);
cxdegc = cxkelvin;
cxdegf = cxkelvin / 1.8;
cxdegr = cxdegf;
cxk_at_0tempc = 273.15 * cxdegc;
cxk_at_0tempf = 459.67 * cxdegf;
cxk_at_0tempr = 0.0 * cxdegr;
cxmach = 331.46 * cxmps;
cxmph = cxmile / cxhour;
cxhectare = 10000.0 * (cxmeter * cxmeter);
cxare = 100.0 * (cxmeter * cxmeter);
cxacre = (cxmile * cxmile) / 640.0;
cxbarn = (1.0 * 10^-28) * (cxmeter * cxmeter);
cxliter = (cxmeter * cxmeter * cxmeter) / 1000.0;
cxlitre = cxliter;
cxgallon = 231.0 * (cxinch * cxinch * cxinch);
cxquart = cxgallon / 4.0;
cxpint = cxquart / 2.0;
cxcup = cxpint / 2.0;
cxfloz = cxcup / 8.0;
cxtblsp = cxfloz / 2.0;
cxtsp = cxtblsp / 3.0;
cxbarrel = 42.0 * cxgallon;
cxah = cxampere * cxhour;
cxcalorie = 4.184 * cxjoule;
cxcal_it = 4.1868 * cxjoule;
cxcal_th = cxcalorie;
cxcal = cxcalorie;
cxbtu_th = cxcal_th * cxpound * cxdegf / (cxgram * cxdegc);
cxbtu_it = cxcal_it * cxpound * cxdegf / (cxgram * cxdegc);
cxbtu = cxcalorie * cxpound * cxdegf / (cxgram * cxdegc);
cxhp = 550.0 * cxfoot * cxpound * cxgravity / cxsecond;
cxhorsepower = cxhp;
cxhpmetric = 75.0 * cxkilogram * cxgravity * cxmps;
cxelectronvolt = cxelectroncharge * cxvolt;
cxerg = (1.0 * 10^-7) * cxjoule;
cxfoe = (1.0 * 10^44) * cxjoule;
cxaaabatterycharge = 2.1 * cxah;
cxaaabatteryvoltage = 1.5 * cxvolt;
cxaaabattery = cxaaabatterycharge * cxaaabatteryvoltage;
cxaaabatteryenergy = cxaaabattery;
cxaabatterycharge = 2.7 * cxah;
cxaabatteryvoltage = 1.5 * cxvolt;
cxaabattery = cxaabatterycharge * cxaabatteryvoltage;
cxaabatteryenergy = cxaabattery;
cxcbatterycharge = 8.0 * cxah;
cxcbatteryvoltage = 1.5 * cxvolt;
cxcbattery = cxcbatterycharge * cxcbatteryvoltage;
cxcbatteryenergy = cxcbattery;
cxdbatterycharge = 12.0 * cxah;
cxdbatteryvoltage = 1.5 * cxvolt;
cxdbattery = cxdbatterycharge * cxdbatteryvoltage;
cxdbatteryenergy = cxdbattery;
cxninevoltcharge = 0.565 * cxah;
cxninevoltvoltage = 9.0 * cxvolt;
cxninevolt = cxninevoltcharge * cxninevoltvoltage;
cxninevoltenergy = cxninevolt;
cxninevoltbatterycharge = cxninevoltcharge;
cxninevoltbatteryvoltage = cxninevoltvoltage;
cxninevoltbattery = cxninevoltbatterycharge *\
      cxninevoltbatteryvoltage;
cxninevoltbatteryenergy = cxninevoltbattery;
cxphonebatterycharge = 3.0 * cxah;
cxphonebatteryvoltage = 3.8 * cxvolt;
cxphonebattery = cxphonebatterycharge * cxphonebatteryvoltage;
cxphonebatteryenergy = cxphonebattery;
cxcarbatterycharge = 45.0 * cxah;
cxcarbatteryvoltage = 12.0 * cxvolt;
cxcarbattery = cxcarbatterycharge * cxcarbatteryvoltage;
cxcarbatteryenergy = cxcarbattery;
cxmicrowavehz = (2.45 * 10^9) / cxsecond;
cxmicrowavewavelength = cxlight / cxmicrowavehz;
cxmicrowavewavenumber = 1.0 / cxmicrowavewavelength;
cxmicrowaveenergy = cxplanck * cxmicrowavehz;
cxlfhz = (1.0 * 10^5) / cxsecond;
cxlfwavelength = cxlight / cxlfhz;
cxlfwavenumber = 1.0 / cxlfwavelength;
cxlfenergy = cxplanck * cxlfhz;
cxmfhz = (1.0 * 10^6) / cxsecond;
cxmfwavelength = cxlight / cxmfhz;
cxmfwavenumber = 1.0 / cxmfwavelength;
cxmfenergy = cxplanck * cxmfhz;
cxhfhz = (1.0 * 10^7) / cxsecond;
cxhfwavelength = cxlight / cxhfhz;
cxhfwavenumber = 1.0 / cxhfwavelength;
cxhfenergy = cxplanck * cxhfhz;
cxvhfhz = (1.0 * 10^8) / cxsecond;
cxvhfwavelength = cxlight / cxvhfhz;
cxvhfwavenumber = 1.0 / cxvhfwavelength;
cxvhfenergy = cxplanck * cxvhfhz;
cxuhfhz = (1.0 * 10^9) / cxsecond;
cxuhfwavelength = cxlight / cxuhfhz;
cxuhfwavenumber = 1.0 / cxuhfwavelength;
cxuhfenergy = cxplanck * cxuhfhz;
cxshfhz = (1.0 * 10^10) / cxsecond;
cxshfwavelength = cxlight / cxshfhz;
cxshfwavenumber = 1.0 / cxshfwavelength;
cxshfenergy = cxplanck * cxshfhz;
cxehfhz = (1.0 * 10^11) / cxsecond;
cxehfwavelength = cxlight / cxehfhz;
cxehfwavenumber = 1.0 / cxehfwavelength;
cxehfenergy = cxplanck * cxehfhz;
cxthfhz = (1.0 * 10^12) / cxsecond;
cxthfwavelength = cxlight / cxthfhz;
cxthfwavenumber = 1.0 / cxthfwavelength;
cxthfenergy = cxplanck * cxthfhz;
cxfirhz = (1.0 * 10^12) / cxsecond;
cxfirwavelength = cxlight / cxfirhz;
cxfirwavenumber = 1.0 / cxfirwavelength;
cxfirenergy = cxplanck * cxfirhz;
cxmirhz = (1.0 * 10^13) / cxsecond;
cxmirwavelength = cxlight / cxmirhz;
cxmirwavenumber = 1.0 / cxmirwavelength;
cxmirenergy = cxplanck * cxmirhz;
cxnirhz = (1.0 * 10^14) / cxsecond;
cxnirwavelength = cxlight / cxnirhz;
cxnirwavenumber = 1.0 / cxnirwavelength;
cxnirenergy = cxplanck * cxnirhz;
cxredwavelength = (7.0 * 10^-7) * cxmeter;
cxredhz = cxlight / cxredwavelength;
cxredwavenumber = 1.0 / cxredwavelength;
cxredenergy = cxplanck * cxredhz;
cxorangewavelength = (6.2 * 10^-7) * cxmeter;
cxorangehz = cxlight / cxorangewavelength;
cxorangewavenumber = 1.0 / cxorangewavelength;
cxorangeenergy = cxplanck * cxorangehz;
cxyellowwavelength = (5.8 * 10^-7) * cxmeter;
cxyellowhz = cxlight / cxyellowwavelength;
cxyellowwavenumber = 1.0 / cxyellowwavelength;
cxyellowenergy = cxplanck * cxyellowhz;
cxyellowgreenhz = (5.4 * 10^14) / cxsecond;
cxyellowgreenwavelength = cxlight / cxyellowgreenhz;
cxyellowgreenwavenumber = 1.0 / cxyellowgreenwavelength;
cxyellowgreenenergy = cxplanck * cxyellowgreenhz;
cxgreenwavelength = (5.3 * 10^-7) * cxmeter;
cxgreenhz = cxlight / cxgreenwavelength;
cxgreenwavenumber = 1.0 / cxgreenwavelength;
cxgreenenergy = cxplanck * cxgreenhz;
cxbluewavelength = (5.0 * 10^-7) * cxmeter;
cxbluehz = cxlight / cxbluewavelength;
cxbluewavenumber = 1.0 / cxbluewavelength;
cxblueenergy = cxplanck * cxbluehz;
cxvioletwavelength = (4.2 * 10^-7) * cxmeter;
cxviolethz = cxlight / cxvioletwavelength;
cxvioletwavenumber = 1.0 / cxvioletwavelength;
cxvioletenergy = cxplanck * cxviolethz;
cxnuvhz = (1.0 * 10^15) / cxsecond;
cxnuvwavelength = cxlight / cxnuvhz;
cxnuvwavenumber = 1.0 / cxnuvwavelength;
cxnuvenergy = cxplanck * cxnuvhz;
cxeuvhz = (1.0 * 10^16) / cxsecond;
cxeuvwavelength = cxlight / cxeuvhz;
cxeuvwavenumber = 1.0 / cxeuvwavelength;
cxeuvenergy = cxplanck * cxeuvhz;
cxuvawavelength = (3.6 * 10^-7) * cxmeter;
cxuvahz = cxlight / cxuvawavelength;
cxuvawavenumber = 1.0 / cxuvawavelength;
cxuvaenergy = cxplanck * cxuvahz;
cxuvbwavelength = (3.0 * 10^-7) * cxmeter;
cxuvbhz = cxlight / cxuvbwavelength;
cxuvbwavenumber = 1.0 / cxuvbwavelength;
cxuvbenergy = cxplanck * cxuvbhz;
cxuvcwavelength = (1.9 * 10^-7) * cxmeter;
cxuvchz = cxlight / cxuvcwavelength;
cxuvcwavenumber = 1.0 / cxuvcwavelength;
cxuvcenergy = cxplanck * cxuvchz;
cxsxhz = (3.0 * 10^17) / cxsecond;
cxsxwavelength = cxlight / cxsxhz;
cxsxwavenumber = 1.0 / cxsxwavelength;
cxsxenergy = cxplanck * cxsxhz;
cxsxxwavelength = (1.0 * 10^-9) * cxmeter;
cxsxxhz = cxlight / cxsxxwavelength;
cxsxxwavenumber = 1.0 / cxsxxwavelength;
cxsxxenergy = cxplanck * cxsxxhz;
cxhxhz = (1.0 * 10^19) / cxsecond;
cxhxwavelength = cxlight / cxhxhz;
cxhxwavenumber = 1.0 / cxhxwavelength;
cxhxenergy = cxplanck * cxhxhz;
cxgammahz = (1.0 * 10^20) / cxsecond;
cxgammawavelength = cxlight / cxgammahz;
cxgammawavenumber = 1.0 / cxgammawavelength;
cxgammaenergy = cxplanck * cxgammahz;
cxturn = cxtau * cxradian;
cxarcdegree = cxturn / 360.0;
cxarcminute = cxarcdegree / 60.0;
cxarcsecond = cxarcminute / 60.0;
cxgrad = cxturn / 400.0;
cxarcdeg = cxarcdegree;
cxarcmin = cxarcminute;
cxarcsec = cxarcsecond;
cxsquaredegree = (cxarcdegree * cxarcdegree);
cxsqdeg = cxsquaredegree;
cxspheresurface = 2.0 * cxtau * cxsteradian;
cxshannon = cxbit;
cxnat = cxbit / cxlntwo;
cxhartley = cxlnten / cxlntwo * cxbit;
cxhart = cxhartley;
cxdit = cxhartley;
cxban = cxhartley;
cxrpm = cxturn / cxminute;
cxrps = cxturn / cxsecond;
cxrph = cxturn / cxhour;
cxlbfin = cxpound * cxgravity * cxinch;
cxnm_per_lbfin = cxlbfin / (cxnewton * cxmeter);
cxkgfm_per_lbfin = cxlbfin / (cxkg * cxgravity * cxmeter);
cxlbfinrpm_per_hp = cxhorsepower / (cxlbfin * cxrpm);
cxfinestructure = cxalpha;
cxfinestructure_err = cxalpha_err;
cxfinestructureconst = cxfinestructure;
cxfinestructureconst_err = cxalpha_err;
cxfinestructure_rec = cxalpha_rec;
cxfinestructure_rec_err = cxalpha_err;
cxmagnetic = 2.0 * cxvonklitzing * cxalpha / cxlight;
cxmagnetic_err = cxalpha_err;
cxmu0 = cxmagnetic;
cxmu0_err = cxalpha_err;
cxelectric = 1.0 / ((cxlight * cxlight) * cxmu0);
cxelectric_err = cxalpha_err;
cxelectricconst = cxelectric;
cxelectricconst_err = cxalpha_err;
cxepsilon0 = cxelectric;
cxepsilon0_err = cxalpha_err;
cxcoulombconst = 1.0 / (2.0 * cxtau * cxelectric);
cxcoulombconst_err = cxalpha_err;
cxprotonradius = (8.414 * 10^-16) * cxmeter;
cxprotonradius_err = (2.2 * 10^-3);
cxmolarmass = 0.99999999965 * cxgram / cxmole;
cxmolarmass_err = (2.0 * 10^-10);
cxmolarmassconst = cxmolarmass;
cxmolarmassconst_err = (2.0 * 10^-10);
cxmolarmassx = (1.0 - (3.5 * 10^-10)) * cxgram / cxmole;
cxmolarmassx_err = (2.0 * 10^-10);
cxdalton = cxmolarmass / cxavogadro;
cxdalton_err = cxmolarmass_err;
cxamu = cxdalton;
cxamu_err = cxdalton_err;
cxatomicmassunit = cxdalton;
cxatomicmassunit_err = cxdalton_err;
cxuamu = cxdalton;
cxuamu_err = cxdalton_err;
cxrydberghz = cxrydberg;
cxrydbergwavelength = cxlight / cxrydberghz;
cxrydbergwavenumber = 1.0 / cxrydbergwavelength;
cxrydbergenergy = cxplanck * cxrydberghz;
cxelectronmassa = 2.0 * cxrydberghz * cxplanck / ((cxlight *\
      cxalpha) * (cxlight * cxalpha));
cxelectronmassa_err = 2.0 * cxalpha_err;
cxelectronmass = (5.48579909065 * 10^-4) * cxamu;
cxelectronmass_err = (2.9 * 10^-11);
cxelectron_mass = cxelectronmass * cxavogadro;
cxelectronenergy = cxelectronmass * (cxlight * cxlight);
cxelectronhz = cxelectronenergy / cxplanck;
cxelectronwavelength = cxlight / cxelectronhz;
cxupquarkmass = 0.00216 * cxamu;
cxupquarkmass_err = 0.2;
cxupquark_mass = cxupquarkmass * cxavogadro;
cxupquarkenergy = cxupquarkmass * (cxlight * cxlight);
cxupquarkhz = cxupquarkenergy / cxplanck;
cxupquarkwavelength = cxlight / cxupquarkhz;
cxdownquarkmass = 0.00514 * cxamu;
cxdownquarkmass_err = 0.1;
cxdownquark_mass = cxdownquarkmass * cxavogadro;
cxdownquarkenergy = cxdownquarkmass * (cxlight * cxlight);
cxdownquarkhz = cxdownquarkenergy / cxplanck;
cxdownquarkwavelength = cxlight / cxdownquarkhz;
cxmuonmass = 0.1134289259 * cxamu;
cxmuonmass_err = (2.2 * 10^-8);
cxmuon_mass = cxmuonmass * cxavogadro;
cxmuonenergy = cxmuonmass * (cxlight * cxlight);
cxmuonhz = cxmuonenergy / cxplanck;
cxmuonwavelength = cxlight / cxmuonhz;
cxprotonmass = 1.007276466812 * cxamu;
cxprotonmass_err = (8.9 * 10^-11);
cxproton_mass = cxprotonmass * cxavogadro;
cxprotonenergy = cxprotonmass * (cxlight * cxlight);
cxprotonhz = cxprotonenergy / cxplanck;
cxprotonwavelength = cxlight / cxprotonhz;
cxneutronmass = 1.00866491595 * cxamu;
cxneutronmass_err = (4.8 * 10^-10);
cxneutron_mass = cxneutronmass * cxavogadro;
cxneutronenergy = cxneutronmass * (cxlight * cxlight);
cxneutronhz = cxneutronenergy / cxplanck;
cxneutronwavelength = cxlight / cxneutronhz;
cxtaumass = 1.90754 * cxamu;
cxtaumass_err = (6.8 * 10^-5);
cxtau_mass = cxtaumass * cxavogadro;
cxtauenergy = cxtaumass * (cxlight * cxlight);
cxtauhz = cxtauenergy / cxplanck;
cxtauwavelength = cxlight / cxtauhz;
cxdeuteronmass = 2.013553212745 * cxamu;
cxdeuteronmass_err = (2.0 * 10^-11);
cxdeuteron_mass = cxdeuteronmass * cxavogadro;
cxdeuteronenergy = cxdeuteronmass * (cxlight * cxlight);
cxdeuteronhz = cxdeuteronenergy / cxplanck;
cxdeuteronwavelength = cxlight / cxdeuteronhz;
cxhelionmass = 3.0149322467175 * cxamu;
cxhelionmass_err = (3.2 * 10^-11);
cxhelion_mass = cxhelionmass * cxavogadro;
cxhelionenergy = cxhelionmass * (cxlight * cxlight);
cxhelionhz = cxhelionenergy / cxplanck;
cxhelionwavelength = cxlight / cxhelionhz;
cxtritonmass = 3.01550071621 * cxamu;
cxtritonmass_err = (4.0 * 10^-11);
cxtriton_mass = cxtritonmass * cxavogadro;
cxtritonenergy = cxtritonmass * (cxlight * cxlight);
cxtritonhz = cxtritonenergy / cxplanck;
cxtritonwavelength = cxlight / cxtritonhz;
cxalphamass = 4.001506179127 * cxamu;
cxalphamass_err = (1.6 * 10^-11);
cxalpha_mass = cxalphamass * cxavogadro;
cxalphaenergy = cxalphamass * (cxlight * cxlight);
cxalphahz = cxalphaenergy / cxplanck;
cxalphawavelength = cxlight / cxalphahz;
cxhydrogenradius = (cxhbar / (cxelectronmass * cxlight *\
      cxalpha));
cxhydrogenradius_err = cxalpha_err;
cxbohrradius = cxhydrogenradius;
cxbohrradius_err = cxalpha_err;
cxhihz = 1420405751.7667 * cxhertz;
cxhiwavelength = cxlight / cxhihz;
cxhiwavenumber = 1.0 / cxhiwavelength;
cxhienergy = cxplanck * cxhihz;
cxhydrogenline = cxhiwavelength;
cxhydrogenline_err = (6.3 * 10^-13);
cxhi = cxlight / cxhihz;
cxhi_err = cxhydrogenline_err;
cxplanckmass = sqrt(cxhbar * cxlight / cxgravitation);
cxplanckcharge = cxelectroncharge / sqrt(cxalpha);
cxplanckenergy = cxplanckmass * (cxlight * cxlight);
cxplancktemp = cxplanckenergy / cxboltzmann;
cxplancklength = cxhbar / cxplanckmass / cxlight;
cxplancktime = cxplancklength / cxlight;
cxstefan = (cxtau * cxtau * cxtau * cxtau * cxtau) *\
      (cxboltzmann * cxboltzmann * cxboltzmann * cxboltzmann)\
      / (240.0 * (cxlight * cxlight) * (cxplanck * cxplanck *\
      cxplanck));
cxstefan_err = 0.0;
cxstefanconst = cxstefan;
cxstefanconst_err = 0.0;
cxpingpongballradius = 0.02 * cxmeter;
cxgolfballradius = 0.02135 * cxmeter;
cxtennisballradius = 0.03325 * cxmeter;
cxbaseballradius = 9.125 * cxinch / cxtau;
cxsoftballradius = 12.0 * cxinch / cxtau;
cxsoccerballradius = 0.69 * cxmeter / cxtau;
cxbasketballradius = 0.75 * cxmeter / cxtau;
cxpingpongballmass = 0.0027 * cxkg;
cxgolfballmass = 0.04593 * cxkg;
cxtennisballmass = 0.0577 * cxkg;
cxbaseballmass = 0.1465 * cxkg;
cxsoftballmass = 0.187 * cxkg;
cxbasketballmass = 0.620 * cxkg;
cxsoccerballmass = 0.430 * cxkg;
cxmarathon = 42195.0 * cxmeter;
cxpennythickness = (1.55 * 10^-3) * cxmeter;
cxnickelthickness = (1.95 * 10^-3) * cxmeter;
cxdimethickness = (1.35 * 10^-3) * cxmeter;
cxquarterthickness = (1.75 * 10^-3) * cxmeter;
cxpennyradius = (9.525 * 10^-3) * cxmeter;
cxnickelradius = (1.061 * 10^-2) * cxmeter;
cxdimeradius = (8.955 * 10^-3) * cxmeter;
cxquarterradius = (1.213 * 10^-2) * cxmeter;
cxpennymass = 2.5 * cxgram;
cxnickelmass = 5.0 * cxgram;
cxdimemass = 0.005 * cxpound;
cxquartermass = 0.0125 * cxpound;
cxmoonmonth = 29.530587981 * cxday;
cxmilkywayage = (8.3 * 10^9) * cxjyear;
cxastronomicalunit = cxau;
cxlightyear = cxlight * cxjyear;
cxparsec = 1296000.0 * cxastronomicalunit / cxtau;
cxproximacentauri = (39.9 * 10^15) * cxmeter;
cxmilkywayradius = (6.0 * 10^4) * cxlightyear;
cxgalacticcenter = (2.64 * 10^4) * cxlightyear;
cxmilkywaymass = (1.4 * 10^42) * cxkilogram;
cxsolarconstant = 1361.0 * cxwatt / (cxmeter * cxmeter);
cxuniverseage = (13.799 * 10^9) * cxjyear;
cxuniverseradius = (14.26 * 10^9) * cxparsec;
cxuniversemass = (1.46 * 10^53) * cxkilogram;
cxeinstein = 4.0 * cxtau * cxgravitation / (cxlight * cxlight\
      * cxlight * cxlight);
cxeinstein_err = cxgravitation_err;
cxhubble = (67.66 * 10^-3) * cxmeter / (cxsecond * cxparsec);
cxhubble_err = (6.0 * 10^-3);
cxhubbleconst = cxhubble;
cxhubbleconst_err = (6.0 * 10^-3);
cxhubbleradius = cxlight / cxhubble;
cxbhmasstemp = (cxhbar * (cxlight * cxlight * cxlight) / (4.0\
      * cxtau * cxgravitation * cxboltzmann));
cxbhmass_radius = 0.5 * (cxlight * cxlight) / cxgravitation;
cxbhmass3_lifetime = (cxplanck * (cxlight * cxlight * cxlight\
      * cxlight)) / (2560.0 * (cxtau * cxtau) *\
      (cxgravitation * cxgravitation));
cxbhradius2density = 1.5 * cxbhmass_radius / cxtau;
cxbhmass2_entropy = (cxplanck * cxlight) / (2.0 * cxtau *\
      cxtau * cxgravitation * cxboltzmann);
cxbhentropy_area = (cxtau * (cxlight * cxlight * cxlight) *\
      cxboltzmann) / (4.0 * cxplanck * cxgravitation);
cxbhmass2power = cxplanck * (cxlight * cxlight * cxlight *\
      cxlight * cxlight * cxlight) / (7680.0 * (cxtau *\
      cxtau) * (cxgravitation * cxgravitation));
cxbhmass2_area = cxbhmass2_entropy * cxbhentropy_area;
cxbhmass2_density = (cxbhmass_radius * cxbhmass_radius) *\
      cxbhradius2density;
cxbekensteininformation = ((cxtau * cxtau) * cxnat) /\
      (cxplanck * cxlight);
cxbekensteinentropy = ((cxtau * cxtau) * cxboltzmann) /\
      (cxplanck * cxlight);
cxelevationmax = 8848.0 * cxmeter;
cxelevationmin = -10994.0 * cxmeter;
cxkpgboundary = (65.5 * 10^6) * cxjyear;
cxtrjboundary = (199.6 * 10^6) * cxjyear;
cxmilkywayday = (250.0 * 10^6) * cxjyear;
cxptrboundary = (251.4 * 10^6) * cxjyear;
cxnpboundary = (542.0 * 10^6) * cxjyear;
cxlifeage = (3.85 * 10^9) * cxjyear;
cxgiantimpact = (4.533 * 10^9) * cxjyear;
cxearthage = (4.56717 * 10^9) * cxjyear;
cxppq = (1.0 * 10^-15);
cxppt = (1.0 * 10^-12);
cxppb = (1.0 * 10^-9);
cxppm = (1.0 * 10^-6);
cxmass = cxkilogram;
cxlength = cxmeter;
cxdistance = cxlength;
cxtemperature = cxkelvin;
cxtime = cxsecond;
cxangle = cxradian;
cxsolid_angle = cxsteradian;
cxspeed = cxlength / cxtime;
cxacceleration = cxspeed / cxtime;
cxforce = cxmass * cxacceleration;
cxenergy = cxforce * cxlength;
cxaction = cxenergy * cxtime;
cxpower = cxenergy / cxtime;
cxarea = (cxlength * cxlength);
cxvolume = (cxlength * cxlength * cxlength);
cxdensity = cxmass / cxvolume;
cxspecificheat = cxenergy / (cxmass * cxtemperature);
cxpressure = cxforce / cxarea;
cxviscosity = cxforce * cxtime / cxarea;
cxfrequency = 1 / cxtime;
cxcharge = cxampere * cxsecond;
cxcurrent = cxcharge / cxtime;
cxvoltage = cxpower / cxcurrent;
cxresistance = cxvoltage / cxcurrent;
cxinductance = cxresistance * cxtime;
cxcapacitance = cxcharge / cxvoltage;
cxconductance = 1.0 / cxresistance;
cxmagneticflux = cxvoltage * cxtime;
cxmagneticinduction = cxmagneticflux / cxarea;
#include <time.h>
#   IIIIIIIIIIMPORT_MASTER-Function --------------------- atan2 #
define atan2(yy,xx) {
   auto retvalu;
   if (0.0 < xx) {
      retvalu = a(yy / xx);
   } else if (xx < 0) {
      if (yy < 0.0) {
         retvalu = a(yy / xx) - cxtau / 2.0;
      } else if (0.0 < yy) {
         retvalu = a(yy / xx) + cxtau / 2.0;
      } else {
         retvalu = cxtau / 2.0;
      }
   } else {
      if (yy < 0.0) {
         retvalu = -cxtau / 4.0;
      } else if (0.0 < yy) {
         retvalu = cxtau / 4.0;
      } else {
         retvalu = 0.0;
      }
   }
   return(retvalu);
}
#   IIIIIIIIIIMPORT_MASTER-Function --------------------- floor #
define floor(xx) {
   auto local_prev_scale,retvalu;
   local_prev_scale = scale;
   scale = 0;
   retvalu = xx / 1;
   if (xx < retvalu) {
      retvalu -= 1;
   }
   scale = local_prev_scale;
   return(retvalu);
}
#   IIIIIIIIIIMPORT_MASTER-Function ----------------------- log #
define log(xx)     { return(l(xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function ----------------------- exp #
define exp(xx)     { return(e(xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function ----------------------- pow #
define pow(xx,yy) { return(e(yy * l(xx))); }
#   IIIIIIIIIIMPORT_MASTER-Function ----------------------- cos #
define cos(xx)     { return(c(xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function ----------------------- sin #
define sin(xx)     { return(s(xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function ----------------------- tan #
define tan(xx)     { return(sin(xx) / cos(xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function ---------------------- ceil #
define ceil(xx)    { return(-floor(-xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function --------------------- ceill #
define ceill(xx)   { return(ceil(xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function -------------------- floorl #
define floorl(xx)  { return(floor(xx)); }
#   IIIIIIIIIIMPORT_MASTER-Function ----------------- lf_shiftl #
define lf_shiftl(xx,nn) {
   return(xx * (2 ^ nn));
}
#   IIIIIIIIIIMPORT_MASTER-Function ----------------- lf_shiftr #
define lf_shiftr(xx,nn) {
   auto local_prev_scale,retvalu;
   local_prev_scale = scale;
   scale = 0;
   retvalu = xx / (2 ^ nn);
   scale = local_prev_scale;
   return(retvalu);
}
#   IIIIIIIIIIMPORT_MASTER-Function ----------------------- abs #
define abs(xx) {
   auto retvalu;
   if (xx < 0.0) {
      retvalu = -xx;
   } else {
      retvalu = xx;
   }
   return (retvalu);
}
#   IIIIIIIIIIMPORT_MASTER-Function ----------------- lf_mod_bc #
define lf_mod_bc(xx,yy) {
   auto axx,ayy,retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   axx = abs(xx) / 1;
   ayy = abs(yy) / 1;
   retvalu = axx % ayy;
   if (xx < 0) {
      retvalu = ayy - retvalu;
   }
   scale = local_prev_scale;
   return(retvalu);
}
define id(xx) {
   return (xx);
}
define reci(xx) {
   return (1.0 / xx);
}
define neg(xx) {
   return (- xx);
}
define square(xx) {
   return (xx * xx);
}
define sq(xx) {
   return (xx * xx);
}
define sqinv(xx) {
   return (sqrt(xx));
}
define cube(xx) {
   return (xx * xx * xx);
}
define cu(xx) {
   return (xx * xx * xx);
}
define sign(xx) {
   auto retvalu;
   if (xx < 0.0) {
      retvalu = -1.0;
   } else if (0.0 < xx) {
      retvalu = 1.0;
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define stair(xx) {
   auto retvalu;
   if (xx < 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = 1.0;
   }
   return (retvalu);
}
define heaviside(xx) {
   auto retvalu;
   if (xx < 0.0) {
      retvalu = 0.0;
   } else if (0.0 < xx) {
      retvalu = 1.0;
   } else {
      retvalu = 0.5;
   }
   return (retvalu);
}
define divi(numer,denom,def_val) {
   auto retvalu;
   if (denom < 0.0 || 0.0 < denom) {
      retvalu = numer / denom;
   } else {
      retvalu = def_val;
   }
   return (retvalu);
}
define clip(xx) {
   auto retvalu;
   if (xx < 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = xx;
   }
   return (retvalu);
}
define clip2(xx,xlow,xhigh) {
   auto retvalu;
   if (xx <= xlow) {
      retvalu = xlow;
   } else if (xx <= xhigh) {
      retvalu = xx;
   } else {
      retvalu = xhigh;
   }
   return (retvalu);
}
define clip2x(xx,xa,xb) {
   auto retvalu;
   if (xb < xa) {
      if (xx <= xb || xa <= xx) {
         retvalu = xx;
      } else if (2.0 * xx < xa + xb) {
         retvalu = xb;
      } else {
         retvalu = xa;
      }
   } else {
      if (xx <= xa) {
         retvalu = xa;
      } else if (xx <= xb) {
         retvalu = xx;
      } else {
         retvalu = xb;
      }
   }
   return (retvalu);
}
define sba(xx) {
   auto retvalu;
   if (- 1.0 < xx && xx < 1.0) {
      retvalu = xx;
   } else {
      retvalu = 1.0 / xx;
   }
   return (retvalu);
}
define ratio(aa,bb) {
   auto rati;
   if (abs(aa) < abs(bb)) {
      rati = aa / bb;
   } else {
      rati = bb / aa;
   }
   return (rati);
}
define horner(xx,deg,*coefh_arr_pc[]) {
   auto jj,sum_curr;
   sum_curr = coefh_arr_pc[deg];
   for (jj = deg - 1; 0 <= jj; jj -= 1) {
      sum_curr *= xx;
      sum_curr += coefh_arr_pc[jj];
   }
   return (sum_curr);
}
define chebeval(xx,deg,*cheb_arr_pc[]) {
   auto ba,bb,bc,ii;
   xx *= 2.0;
   ba = cheb_arr_pc[deg];
   bb = 0.0;
   bc = 0.0;
   for (ii = deg - 1; 0 <= ii; ii -= 1) {
      bc = bb;
      bb = ba;
      ba = xx * bb - bc + cheb_arr_pc[ii];
   }
   return ((ba - bc) / 2.0);
}
define ln(xx) {
   return (log(xx));
}
define lg(xx) {
   return (log(xx) / cxlntwo);
}
define log10(xx) {
   return (log(xx) / log(10.0));
}
define logx(xx,bb) {
   return (log(xx) / log(bb));
}
define l10(xx) {
   return (log(xx) / log(10.0));
}
define log2(xx) {
   return (log(xx) / cxlntwo);
}
define fmod(xx,yymodulus) {
   auto retvalu,qu;
   if (yymodulus < 0.0 || 0.0 < yymodulus) {
      qu = xx / yymodulus;
      if (qu < 0.0) {
         retvalu = xx - ceil(qu) * yymodulus;
      } else {
         retvalu = xx - floor(qu) * yymodulus;
      }
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define modf(xx,*ret_int_arr_p[]) {
   auto retvalu,int_part;
   if (xx < 0.0) {
      int_part = ceil(xx);
   } else if (0.0 < xx) {
      int_part = floor(xx);
   } else {
      int_part = 0;
   }
   ret_int_arr_p[0] = xx - int_part;
   return (retvalu);
}
define fmody(xx,yymodulus) {
   auto retvalu;
   if (yymodulus < 0.0 || 0.0 < yymodulus) {
      retvalu = xx - floor(xx / yymodulus) * yymodulus;
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define fmodu(xx,yymodulus) {
   auto retvalu;
   if (yymodulus < 0.0 || 0.0 < yymodulus) {
      retvalu = fmod(xx,yymodulus);
      if (retvalu < 0.0) {
         retvalu += abs(yymodulus);
      }
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define remquou(xx,yymodulus,*ret_int_arr_p[]) {
   auto retvalu,qu,fl;
   if (yymodulus < 0.0 || 0.0 < yymodulus) {
      qu = xx / yymodulus;
      fl = floor(qu);
      retvalu = qu - fl;
   } else {
      fl = 0.0;
      retvalu = xx;
   }
   ret_int_arr_p[0] = fl;
   return (retvalu);
}
define fmods(xx,yymodulus) {
   auto retvalu,ayy,lim;
   if (yymodulus < 0.0 || 0.0 < yymodulus) {
      retvalu = fmod(xx,yymodulus);
      ayy = abs(yymodulus);
      lim = ayy / 2.0;
      if (retvalu < - lim) {
         retvalu += ayy;
      } else if (lim <= retvalu) {
         retvalu -= ayy;
      }
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define pow2(expo) {
   return (pow(2.0,expo));
}
define pow10(expo) {
   return (pow(10.0,expo));
}
define sigmoid(xx) {
   return (1.0 / (1.0 + exp(-xx)));
}
define sigmoidinv(xx) {
   return (- log(((1.0 / xx - 0.5) - 0.5)));
}
define sigmoid3(aa,bb,xx) {
   auto retvalu,alfa,xzero,taa;
   if (aa <= 0.0 || 1.0 <= aa || bb <= 0.0 || 1.0 <= bb) {
      retvalu = 0.0;
   } else {
      taa = log((1.0 - aa) / aa);
      alfa = log((1.0 - bb) / bb) - taa;
      xzero = -taa / alfa;
      retvalu = 1.0 / (1.0 + exp(alfa * (xx - xzero)));
   }
   return (retvalu);
}
define taninv3(aa,bb,xx) {
   auto retvalu,alfa,taa;
   if (aa <= 0.0 || 1.0 <= aa || bb <= 0.0 || 1.0 <= bb) {
      retvalu = 0.0;
   } else {
      taa = tan((aa - 0.5) * cxpi);
      alfa = tan((bb - 0.5) * cxpi) - taa;
      retvalu = taninv(alfa * xx + taa) / cxpi + 0.5;
   }
   return (retvalu);
}
define sigmoid3d(aa,bb,xx) {
   auto retvalu,alfa,xzero,taa,expa;
   if (aa <= 0.0 || 1.0 <= aa || bb <= 0.0 || 1.0 <= bb) {
      retvalu = 0.0;
   } else {
      taa = log((1.0 - aa) / aa);
      alfa = log((1.0 - bb) / bb) - taa;
      xzero = -taa / alfa;
      expa = exp(alfa * (xx - xzero));
      retvalu = -alfa * expa / square(1.0 + expa);
   }
   return (retvalu);
}
define sqrtx(xx) {
   auto retvalu;
   if (xx < 0.0) {
      retvalu = -sqrt(-xx);
   } else {
      retvalu = sqrt(xx);
   }
   return (retvalu);
}
define smooth(xx) {
   auto retvalu;
   if (xx <= -1.0) {
      retvalu = 0.0;
   } else if (1.0 <= xx) {
      retvalu = 1.0;
   } else {
      retvalu = sigmoid(4.0 * xx / (1.0 - xx * xx));
   }
   return (retvalu);
}
define hypot(xx,yy) {
   auto retvalu,axx,ayy;
   axx = abs(xx);
   ayy = abs(yy);
   if (axx < ayy) {
      retvalu = ayy;
      ayy = axx;
      axx = retvalu;
   }
   if (0.0 < axx) {
      if (ayy < cxdbleps * axx) {
         retvalu = axx;
      } else {
         ayy /= axx;
         retvalu = axx * sqrt(1.0 + ayy * ayy);
      }
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define hypot1(xx) {
   return (hypot(1.0,xx));
}
define hypot1inv(xx) {
   return (sqrt(xx * xx - 1.0));
}
define hypot3(xx,yy,zz) {
   return (sqrt(xx * xx + yy * yy + zz * zz));
}
define topyh(xx,yy) {
   auto retvalu,xsq,ysq;
   xsq = xx * xx;
   ysq = yy * yy;
   if (ysq <= 0.0) {
      retvalu = xx;
   } else if (xsq <= 0.0) {
      retvalu = yy;
   } else if (xsq < ysq) {
      xsq /= ysq;
      retvalu = -sign(xx) * sqrt(1.0 - xsq) * abs(yy);
   } else {
      ysq /= xsq;
      retvalu = sqrt(1.0 - ysq) * xx;
   }
   return (retvalu);
}
define topyh1(xx) {
   auto retvalu;
   if (xx < - 1.0 || 1.0 < xx) {
      retvalu = -sqrt(xx * xx - 1.0);
   } else {
      retvalu = sqrt(1.0 - xx * xx);
   }
   return (retvalu);
}
define cnv_dbl2si16(xx) {
   auto retvalu;
   if (xx <= cxsi16min) {
      retvalu = cxsi16min;
   } else if (xx <= cxsi16max) {
      retvalu = floorl(xx + 0.5);
   } else {
      retvalu = cxsi16max;
   }
   return (retvalu);
}
define k2tempc(temp_k) {
   return ((temp_k - cxk_at_0tempc) * cxkelvin / cxdegc);
}
define tempc2k(temp_c) {
   return (temp_c * cxdegc / cxkelvin + cxk_at_0tempc);
}
define tempc(temp_c) {
   return (tempc2k(temp_c));
}
define k2tempf(temp_k) {
   return ((temp_k - cxk_at_0tempf) * cxkelvin / cxdegf);
}
define tempf2k(temp_f) {
   return (temp_f * cxdegf / cxkelvin + cxk_at_0tempf);
}
define tempf(temp_f) {
   return (tempf2k(temp_f));
}
define k2tempr(temp_k) {
   return ((temp_k - cxk_at_0tempr) * cxkelvin / cxdegr);
}
define tempr2k(temp_r) {
   return (temp_r * cxdegr / cxkelvin + cxk_at_0tempr);
}
define tempr(temp_r) {
   return (tempr2k(temp_r));
}
define tempf2tempc(temp_f) {
   return (k2tempc(tempf2k(temp_f)));
}
define tempc2tempf(temp_c) {
   return (k2tempf(tempc2k(temp_c)));
}
define iszero(xx) {
   return (0.0 <= xx && xx <= 0.0);
}
define iseven(xx) {
   return (fmodu(xx,2.0) < 1.0);
}
define isodd(xx) {
   return (1.0 <= fmodu(xx,2.0));
}
define ismult(xx,mult) {
   return (fmodu(xx,mult) < 1.0);
}
define ismultl(xx,mult) {
   auto retvalu_bol,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (xx % mult == 0) {
      retvalu_bol = true;
   } else {
      retvalu_bol = false;
   }
   scale = local_prev_scale;
   return (retvalu_bol);
}
define isgt(xx,yy) {
   return (yy < xx);
}
define islt(xx,yy) {
   return (xx < yy);
}
define isge(xx,yy) {
   return (yy <= xx);
}
define isle(xx,yy) {
   return (xx <= yy);
}
define ispos(xx) {
   return (0.0 < xx);
}
define isneg(xx) {
   return (xx < 0.0);
}
define iseq(xx,yy) {
   auto retvalu_bol,epsx,diffxy;
   retvalu_bol = false;
   if (iszero(xx)) {
      if (abs(yy) <= cxdbleps) {
         retvalu_bol = true;
      }
   } else {
      epsx = 2.0 * xx * cxdbleps;
      diffxy = xx - yy;
      if (epsx < 0.0) {
         epsx = -epsx;
      }
      if (- epsx <= diffxy && diffxy <= epsx) {
         retvalu_bol = true;
      }
   }
   return (retvalu_bol);
}
define isneq(xx,yy) {
   return (xx < yy || yy < xx);
}
define isint(xx) {
   return (iseq(xx,floor(xx)));
}
define isnegint(xx) {
   return (xx < 0.0 && iseq(xx,floor(xx)));
}
define isposint(xx) {
   return (0.0 < xx && iseq(xx,floor(xx)));
}
define ifzero(cond,tru_val,fal_val) {
   auto retvalu;
   if (cond < 0.0 || 0.0 < cond) {
      retvalu = fal_val;
   } else {
      retvalu = tru_val;
   }
   return (retvalu);
}
define isalmostequal(xx,yy,epsratio) {
   return (abs(xx - yy) <= abs(epsratio * xx));
}
define iswithin(xx,yy,delta) {
   return (xx - delta <= yy && yy <= xx + delta);
}
define isbetweenx(xx,min_xx,max_xx) {
   return (min_xx < xx && xx < max_xx);
}
define isbetween(xx,min_xx,max_xx) {
   return (min_xx <= xx && xx <= max_xx);
}
define isleapyear(gregyear) {
   auto retvalu_bol,rema;
   retvalu_bol = false;
   if ((gregyear % 4) == 0) {
      rema = (gregyear % 400);
      if (rema != 100 && rema != 200 && rema != 300) {
         retvalu_bol = true;
      }
   }
   return (retvalu_bol);
}
define isss(xx,yy) {
   auto retvalu_bol;
   if (0.0 < xx) {
      if (0.0 < yy) {
         retvalu_bol = true;
      } else {
         retvalu_bol = false;
      }
   } else if (xx < 0.0) {
      if (yy < 0.0) {
         retvalu_bol = true;
      } else {
         retvalu_bol = false;
      }
   } else {
      if (0.0 < yy || yy < 0.0) {
         retvalu_bol = false;
      } else {
         retvalu_bol = true;
      }
   }
   return (retvalu_bol);
}
define issignsame(xx,yy) {
   return (isss(xx,yy));
}
define isfloorsame(xx,yy,multy) {
   return (iseq(floor(xx * multy),floor(yy * multy)));
}
cxlc_magic_int = 2070108020;
cxlc_magic_int_not = 301040105;
define magicset() {
   return (cxlc_magic_int);
}
define magicnot() {
   return (cxlc_magic_int_not);
}
define ismagic(xx) {
   return (iseq(xx,magicset()));
}
define rtoz(xx) {
   auto retvalu;
   if (xx < 0.0) {
      retvalu = ceil(xx);
   } else {
      retvalu = floor(xx);
   }
   return (retvalu);
}
define rtoi(xx) {
   auto retvalu;
   if (0.0 <= xx) {
      retvalu = ceil(xx);
   } else {
      retvalu = floor(xx);
   }
   return (retvalu);
}
define bankers(xx) {
   auto retvalu;
   retvalu = floor(xx + 0.5);
   if (isint(xx + 0.5) && isodd(retvalu)) {
      retvalu -= 1.0;
   }
   return (retvalu);
}
define round(xx) {
   auto retvalu;
   retvalu = floor(xx + 0.5);
   return (retvalu);
}
define iround(xx) {
   auto retvalu;
   retvalu = floor(xx + 0.5);
   return (retvalu);
}
define round2(xx,yy) {
   auto retvalu;
   if (iszero(yy)) {
      retvalu = xx;
   } else {
      retvalu = round(xx / yy) * yy;
   }
   return (retvalu);
}
define roundy(xx,yy,shf) {
   auto retvalu;
   if (yy < 0.0 || 0.0 < yy) {
      retvalu = (round((xx - shf) / yy) * yy + shf);
   } else {
      retvalu = xx;
   }
   return (retvalu);
}
define rtomsd(fs,msds) {
   auto retvalu,signs,logi;
   if (iszero(fs)) {
      retvalu = 0.0;
   } else {
      if (fs < 0.0) {
         signs = -1.0;
         fs = -fs;
      } else {
         signs = 1.0;
      }
      logi = floor(log10(fs) - msds + 1.0);
      retvalu = signs * round2(fs,pow(10.0,logi));
   }
   return (retvalu);
}
define rto125(fs) {
   auto signs,tmpf,valu,pow_ten,retvalu;
   if (iszero(fs)) {
      retvalu = 0.0;
   } else {
      if (fs < 0.0) {
         signs = -1.0;
         fs = -fs;
      } else {
         signs = 1.0;
      }
      pow_ten = pow(10.0,floor(log10(fs)));
      tmpf = fs / pow_ten;
      if (tmpf < sqrt(2.0)) {
         valu = 1.0;
      } else if (tmpf < sqrt(10.0)) {
         valu = 2.0;
      } else if (tmpf < sqrt(50.0)) {
         valu = 5.0;
      } else {
         valu = 10.0;
      }
      retvalu = signs * pow_ten * valu;
   }
   return (retvalu);
}
define floor2(xx,yy) {
   auto retvalu;
   if (iszero(yy)) {
      retvalu = 0.0;
   } else {
      retvalu = floor(xx / abs(yy)) * abs(yy);
   }
   return (retvalu);
}
define ceil2(xx,yy) {
   auto retvalu;
   if (iszero(yy)) {
      retvalu = 0.0;
   } else {
      retvalu = ceil(xx / abs(yy)) * abs(yy);
   }
   return (retvalu);
}
define fmod2(xx,minn,maxx) {
   auto retvalu;
   if (iseq(maxx,minn)) {
      retvalu = 0.0;
   } else {
      retvalu = fmodu(xx - minn,maxx - minn) + minn;
   }
   return (retvalu);
}
define frac(xx) {
   return (xx - floor(xx));
}
define trunc(xx) {
   auto retvalu;
   if (0.0 <= xx) {
      retvalu = xx - floor(xx);
   } else {
      retvalu = xx - ceil(xx);
   }
   return (retvalu);
}
define fmul(xx,pp) {
   auto lpp;
   lpp = log(pp);
   return (exp(lpp * frac(log(xx) / lpp)));
}
define dist(xx,mm) {
   auto retvalu,axx,amm;
   axx = abs(xx);
   amm = abs(mm);
   retvalu = fmod(axx,amm);
   if (amm < 2.0 * retvalu) {
      retvalu = amm - retvalu;
   }
   return (retvalu);
}
define ddist(xx,mm) {
   auto retvalu,rema,amm;
   if (iszero(mm)) {
      retvalu = 0.0;
   } else {
      amm = abs(mm);
      rema = xx - floor(xx / amm) * amm;
      if (amm < 2.0 * rema) {
         rema -= amm;
      }
      retvalu = rema;
   }
   return (retvalu);
}
define sinc(xx_rad) {
   auto retvalu;
   if (xx_rad < 0.0 || 0.0 < xx_rad) {
      retvalu = sin(xx_rad) / xx_rad;
   } else {
      retvalu = 1.0;
   }
   return (retvalu);
}
define sincinv(yy) {
   auto min_yy,min_xx,start_xx,aa,bb,nrvx_ii,nrvx_yy,\
         nrvx_xx,nrvx_dy,nrvx_xp;
   min_xx = 4.4934094579090641753079882808139693729311345;
   min_yy = sinc(min_xx);
   if (yy <= min_yy) {
      nrvx_xx = min_xx;
   } else if (yy < 1.0) {
      aa = yy - min_yy;
      bb = 1.0 - yy;
      start_xx = (aa * sqrt(5.0 * bb) + bb * (min_xx -\
            sqrt(6.0 * aa))) / (1.0 - min_yy);
      nrvx_xx = start_xx;
      for (nrvx_ii = 0; nrvx_ii <= 20; nrvx_ii += 1) {
         nrvx_xp = nrvx_xx;
         nrvx_dy = cos(nrvx_xx) - yy;
         if (iszero(nrvx_dy)) {
            break;
         }
         nrvx_yy = sin(nrvx_xx) - yy * nrvx_xx;
         nrvx_xx -= nrvx_yy / nrvx_dy;
         if (iseq(nrvx_xp,nrvx_xx)) {
            break;
         }
      }
   } else {
      nrvx_xx = 0.0;
   }
   return (nrvx_xx);
}
define sincc(xx_rad) {
   auto trigsign,xr_rad,sum_curr,sum_prev,nxr_sqr,ii,\
         term,retvalu;
   if (iszero(xx_rad)) {
      retvalu = 1.0;
   } else {
      xr_rad = fmod(xx_rad,cxtau);
      if (cxtau / 2.0 < xr_rad) {
         xr_rad = cxtau - xr_rad;
         trigsign = -1.0;
      } else {
         trigsign = 1.0;
      }
      if (cxtau / 4.0 < xr_rad) {
         xr_rad = cxtau / 2.0 - xr_rad;
      }
      nxr_sqr = -xr_rad * xr_rad;
      sum_curr = xr_rad;
      term = xr_rad;
      ii = 2;
      for (;;) {
         term *= nxr_sqr / (ii * (ii - 1.0));
         sum_prev = sum_curr;
         sum_curr += term;
         if (iseq(sum_curr,sum_prev)) {
            break; # loop AWAIT
         }
         ii += 2;
      }
      retvalu = trigsign * sum_curr * xr_rad / xx_rad;
   }
   return (retvalu);
}
define versin(circ_rad) {
   auto trigsign,xr_rad,xr_sqr,ii,sum_curr,term,sum_prev;
   xr_rad = fmod(circ_rad,cxtau);
   if (cxtau / 2.0 < xr_rad) {
      xr_rad = cxtau - xr_rad;
   }
   if (cxtau / 4.0 < xr_rad) {
      xr_rad = cxtau / 2.0 - xr_rad;
      trigsign = -1.0;
   } else {
      trigsign = 1.0;
   }
   xr_sqr = -xr_rad * xr_rad;
   sum_curr = 1.0 / 2.0;
   term = 1.0 / 2.0;
   ii = 4;
   for (;;) {
      term *= xr_sqr / (ii * (ii - 1.0));
      sum_prev = sum_curr;
      sum_curr += term;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      ii += 2;
   }
   sum_curr *= - xr_sqr;
   if (trigsign < 0.0) {
      sum_curr = 2.0 - sum_curr;
   }
   return (sum_curr);
}
define haversin(circ_rad) {
   return (versin(circ_rad) / 2.0);
}
define tur2deg(circ_tur) {
   return (circ_tur * cxturn / cxarcdeg);
}
define deg2tur(circ_deg) {
   return (circ_deg * cxarcdeg / cxturn);
}
define tur2rad(circ_tur) {
   return (circ_tur * cxturn / cxradian);
}
define rad2tur(circ_rad) {
   return (circ_rad * cxradian / cxturn);
}
define tur2sec(circ_tur) {
   return (circ_tur * cxturn / cxarcsec);
}
define sec2tur(circ_sec) {
   return (circ_sec * cxarcsec / cxturn);
}
define rad2deg(circ_rad) {
   return (circ_rad * cxradian / cxarcdeg);
}
define deg2rad(circ_deg) {
   return (circ_deg * cxarcdeg / cxradian);
}
define rad2sec(circ_rad) {
   return (circ_rad * cxradian / cxarcsec);
}
define sec2rad(circ_sec) {
   return (circ_sec * cxarcsec / cxradian);
}
define deg2sec(circ_deg) {
   return (circ_deg * cxarcdeg / cxarcsec);
}
define sec2deg(circ_sec) {
   return (circ_sec * cxarcsec / cxarcdeg);
}
define rad2dms(xx_rads) {
   auto dd_deg,mm_min,dg;
   dg = rad2deg(xx_rads);
   dd_deg = floor(dg);
   dg = (dg - dd_deg) * cxarcdeg / cxarcmin;
   mm_min = floor(dg);
   dg = (dg - mm_min) * cxarcmin / cxarcsec;
   return (dd_deg + (mm_min + dg / 100.0) / 100.0);
}
define rad2dms2(circ_rads) {
   auto dg,dd_deg_arr[],mm_min_arr[];
   dg = rad2deg(circ_rads);
   dg = modf(dg,dd_deg_arr[]) * cxarcdeg / cxarcmin;
   dg = modf(dg,mm_min_arr[]) * cxarcmin / cxarcsec;
   return (dd_deg_arr[0] + (mm_min_arr[0] + dg / 100.0) / 100.0);
}
define dms2rad(circ_dms) {
   auto dd_deg,mm_min,dg;
   dd_deg = floor(circ_dms);
   dg = (circ_dms - dd_deg) * 100.0;
   mm_min = floor(dg);
   dg = (dg - mm_min) * 100.0;
   return ((dg * cxarcsec + mm_min * cxarcmin + dd_deg *\
         cxarcdeg) / cxradian);
}
define deg2dms(circ_deg) {
   return (rad2dms(deg2rad(circ_deg)));
}
define dms2deg(circ_dms) {
   return (rad2deg(dms2rad(circ_dms)));
}
define cot(circ_rad) {
   return (cos(circ_rad) / sin(circ_rad));
}
define sec(circ_rad) {
   return (1.0 / cos(circ_rad));
}
define csc(circ_rad) {
   return (1.0 / sin(circ_rad));
}
define sininv(xx) {
   return (atan2(xx,topyh1(xx)));
}
define cosinv(xx) {
   return (atan2(topyh1(xx),xx));
}
define taninv(xx) {
   return (atan2(xx,1.0));
}
define cotinv(xx) {
   return (atan2(1.0,xx));
}
define secinv(xx) {
   return (atan2(sqrt(xx * xx - 1.0),sign(xx)));
}
define cscinv(xx) {
   return (atan2(sign(xx),sqrt(xx * xx - 1.0)));
}
define sinh(hyp_rad) {
   return ((exp(hyp_rad) - exp(-hyp_rad)) / 2.0);
}
define cosh(hyp_rad) {
   return ((exp(hyp_rad) + exp(-hyp_rad)) / 2.0);
}
define tanh(hyp_rad) {
   return (sinh(hyp_rad) / cosh(hyp_rad));
}
define coth(hyp_rad) {
   return (cosh(hyp_rad) / sinh(hyp_rad));
}
define sech(hyp_rad) {
   return (1.0 / cosh(hyp_rad));
}
define csch(hyp_rad) {
   return (1.0 / sinh(hyp_rad));
}
define gd(hyp_rad) {
   return (2.0 * atan2(exp(hyp_rad),1.0) - cxpi / 2.0);
}
define gdinv(xx) {
   auto xxn;
   xxn = fmods(xx,cxpi);
   return (log(abs((1.0 + sin(xxn)) / cos(xxn))));
}
define sinhinv(xx) {
   return (log(xx + sqrt(xx * xx + 1.0)));
}
define coshinv(xx) {
   return (log(xx + sqrt(xx * xx - 1.0)));
}
define tanhinv(xx) {
   return (log((1.0 + xx) / (1.0 - xx)) / 2.0);
}
define cothinv(xx) {
   return (log((xx + 1.0) / (xx - 1.0)) / 2.0);
}
define sechinv(xx) {
   return (log((1.0 + topyh1(xx)) / xx));
}
define cschinv(xx) {
   return (log((1.0 + sqrt(1.0 + xx * xx)) / xx));
}
define atan2h(xx,yy) {
   auto retvalu;
   if (abs(yy) <= abs(xx)) {
      retvalu = 0.0;
   } else {
      retvalu = log((yy + xx) / (yy - xx)) / 2.0;
   }
   return (retvalu);
}
define atan2u(xx,yy) {
   return (fmodu(atan2(xx,yy),tur2rad(1.0)));
}
define sind(circ_deg) {
   return (sin(deg2rad(circ_deg)));
}
define sindinv(xx) {
   return (rad2deg(sininv(xx)));
}
define cosd(circ_deg) {
   return (cos(deg2rad(circ_deg)));
}
define cosdinv(xx) {
   return (rad2deg(cosinv(xx)));
}
define tand(circ_deg) {
   return (tan(deg2rad(circ_deg)));
}
define tandinv(xx) {
   return (rad2deg(taninv(xx)));
}
define cotd(circ_deg) {
   return (cot(deg2rad(circ_deg)));
}
define cotdinv(xx) {
   return (rad2deg(cotinv(xx)));
}
define secd(circ_deg) {
   return (sec(deg2rad(circ_deg)));
}
define secdinv(xx) {
   return (rad2deg(secinv(xx)));
}
define cscd(circ_deg) {
   return (csc(deg2rad(circ_deg)));
}
define cscdinv(xx) {
   return (rad2deg(cscinv(xx)));
}
define atan2d(xx,yy) {
   return (rad2deg(atan2(xx,yy)));
}
define sint(circ_tur) {
   return (sin(tur2rad(circ_tur)));
}
define sintinv(xx) {
   return (rad2tur(sininv(xx)));
}
define cost(circ_tur) {
   return (cos(tur2rad(circ_tur)));
}
define costinv(xx) {
   return (rad2tur(cosinv(xx)));
}
define tant(circ_tur) {
   return (tan(tur2rad(circ_tur)));
}
define tantinv(xx) {
   return (rad2tur(taninv(xx)));
}
define cott(circ_tur) {
   return (cot(tur2rad(circ_tur)));
}
define cottinv(xx) {
   return (rad2tur(cotinv(xx)));
}
define sect(circ_tur) {
   return (sec(tur2rad(circ_tur)));
}
define sectinv(xx) {
   return (rad2tur(secinv(xx)));
}
define csct(circ_tur) {
   return (csc(tur2rad(circ_tur)));
}
define csctinv(xx) {
   return (rad2tur(cscinv(xx)));
}
define atan2t(xx,yy) {
   return (rad2tur(atan2(xx,yy)));
}
define ln1p(xx) {
   auto retvalu,sum_curr,jj,start;
   if (0.1 < abs(xx)) {
      retvalu = log(1.0 + xx);
   } else if (iszero(xx)) {
      retvalu = 0.0;
   } else {
      start = ceil(abs(log(cxdbleps) / log(abs(xx))));
      if (start < 2) {
         start = 2;
      }
      sum_curr = 0.0;
      for (jj = start; 1 <= jj; jj -= 1) {
         sum_curr = 1.0 / jj - sum_curr * xx;
      }
      retvalu = sum_curr * xx;
   }
   return (retvalu);
}
define expm1(xx) {
   auto retvalu,sum_curr,jj,start;
   if (0.1 < abs(xx)) {
      retvalu = exp(xx) - 1.0;
   } else if (iszero(xx)) {
      retvalu = 0.0;
   } else {
      start = ceil(abs(log(cxdbleps) / log(abs(xx))));
      if (start < 2) {
         start = 2;
      }
      sum_curr = 0.0;
      for (jj = start; 1 <= jj; jj -= 1) {
         sum_curr = xx * (1.0 + sum_curr) / jj;
      }
      retvalu = sum_curr;
   }
   return (retvalu);
}
define cosm1(xx) {
   auto retvalu,sum_curr,jj,start,xr_sqr;
   if (0.1 < abs(xx)) {
      retvalu = cos(xx) - 1.0;
   } else if (iszero(xx)) {
      retvalu = 0.0;
   } else {
      start = ceil(abs(log(cxdbleps) / log(abs(xx))));
      if (start < 6) {
         start = 6;
      } else if (isodd(start)) {
         start += 1;
      }
      xr_sqr = -xx * xx;
      sum_curr = 1.0 / (start * (start + 1.0));
      for (jj = start; 2 <= jj; jj -= 2) {
         sum_curr += 1.0;
         sum_curr *= xr_sqr / (jj * (jj - 1.0));
      }
      retvalu = sum_curr;
   }
   return (retvalu);
}
define lns(xx) {
   auto aa,retvalu;
   aa = abs(xx);
   if (aa < 1.0 / cxdblmax) {
      retvalu = -cxdblmaxln - 1.0;
   } else {
      retvalu = log(aa);
   }
   return (retvalu);
}
define trip(xx) {
   auto retvalu,fx;
   fx = 4.0 * frac(xx);
   if (fx < 2.0) {
      retvalu = 1.0 - fx;
   } else {
      retvalu = fx - 3.0;
   }
   return (retvalu);
}
define lf_cbrtx_gt_zero(xx) {
   auto yy,zz;
   zz = 64.0 * xx / 27.0;
   yy = 1.0;
   while (zz <= 1.0) {
      zz *= 8.0;
      yy /= 2.0;
   }
   while (8.0 < zz) {
      zz /= 8.0;
      yy *= 2.0;
   }
   return (yy);
}
define cbrt(yy) {
   auto ayy,init_xx,nrvx_ii,nrvx_yy,nrvx_xx,nrvx_dy,\
         nrvx_xp;
   ayy = abs(yy);
   if (0.0 < ayy) {
      init_xx = lf_cbrtx_gt_zero(ayy);
      if (yy < 0.0) {
         init_xx = -init_xx;
      }
      nrvx_xx = init_xx;
      for (nrvx_ii = 0; nrvx_ii <= 20; nrvx_ii += 1) {
         nrvx_xp = nrvx_xx;
         nrvx_dy = 3.0 * nrvx_xx * nrvx_xx;
         if (iszero(nrvx_dy)) {
            break;
         }
         nrvx_yy = nrvx_xx * nrvx_xx * nrvx_xx - yy;
         nrvx_xx -= nrvx_yy / nrvx_dy;
         if (iseq(nrvx_xp,nrvx_xx)) {
            break;
         }
      }
   } else {
      nrvx_xx = 0.0;
   }
   return (nrvx_xx);
}
define cuberoot(xx) {
   return (cbrt(xx));
}
define squareroot(xx) {
   return (sqrt(xx));
}
define lf_continued_fraction(orig,show_diff) {
   auto whole,xx,epsilon,den_a,den_b,den_c,num_a,num_b\
         ,num_c,diff,steps,appr;
   steps = 0;
   xx = orig;
   den_b = 0;
   num_b = 1;
   den_a = 1;
   num_a = 0;
   epsilon = cxdbleps / 2.0;
   for (;;) {
      whole = floorl(xx);
      den_c = den_b * whole + den_a;
      num_c = num_b * whole + num_a;
      den_a = den_b;
      num_a = num_b;
      den_b = den_c;
      num_b = num_c;
      steps += 1;
      appr = (1.0 * num_b / den_b);
      diff = orig - appr;
      print "";
      print whole;
      if (0 <= show_diff) {
         print "\t";
         print num_b;
         print " / ";
         print den_b;
         print "\t";
         print appr;
         if (0 < show_diff) {
            print "\t";
            print diff;
         }
         print "\n";
      } else {
         print " ";
      }
      if (iseq(xx,whole)) {
         break;
      }
      xx = 1.0 / (xx - whole);
      epsilon *= 2.0;
      if (abs(diff) < epsilon) {
         break; # loop AWAIT
      }
   }
   return (steps);
}
define contfra_print(orig) {
   return (lf_continued_fraction(orig,-1));
}
define contfrac_print(orig) {
   return (lf_continued_fraction(orig,0));
}
define contfracd_print(orig) {
   return (lf_continued_fraction(orig,1));
}
define num2char_print(num) {
   if (num < 32) {
      if (num < 16) {
         if (num < 8) {
            if (num < 4) {
               if (num < 2) {
                  if (num < 1) {
                     print "0";
                  } else {
                     print "1";
                  }
               } else if (num < 3) {
                  print "2";
               } else {
                  print "3";
               }
            } else if (num < 6) {
               if (num < 5) {
                  print "4";
               } else {
                  print "5";
               }
            } else if (num < 7) {
               print "6";
            } else {
               print "7";
            }
         } else if (num < 12) {
            if (num < 10) {
               if (num < 9) {
                  print "8";
               } else {
                  print "9";
               }
            } else if (num < 11) {
               print "a";
            } else {
               print "b";
            }
         } else if (num < 14) {
            if (num < 13) {
               print "c";
            } else {
               print "d";
            }
         } else if (num < 15) {
            print "e";
         } else {
            print "f";
         }
      } else if (num < 24) {
         if (num < 20) {
            if (num < 18) {
               if (num < 17) {
                  print "g";
               } else {
                  print "cxh";
               }
            } else if (num < 19) {
               print "i";
            } else {
               print "j";
            }
         } else if (num < 22) {
            if (num < 21) {
               print "k";
            } else {
               print "l";
            }
         } else if (num < 23) {
            print "m";
         } else {
            print "n";
         }
      } else if (num < 28) {
         if (num < 26) {
            if (num < 25) {
               print "o";
            } else {
               print "p";
            }
         } else if (num < 27) {
            print "q";
         } else {
            print "r";
         }
      } else if (num < 30) {
         if (num < 29) {
            print "s";
         } else {
            print "t";
         }
      } else if (num < 31) {
         print "u";
      } else {
         print "v";
      }
   } else if (num < 48) {
      if (num < 40) {
         if (num < 36) {
            if (num < 34) {
               if (num < 33) {
                  print "w";
               } else {
                  print "x";
               }
            } else if (num < 35) {
               print "y";
            } else {
               print "z";
            }
         } else if (num < 38) {
            if (num < 37) {
               print "A";
            } else {
               print "B";
            }
         } else if (num < 39) {
            print "C";
         } else {
            print "D";
         }
      } else if (num < 44) {
         if (num < 42) {
            if (num < 41) {
               print "cxe";
            } else {
               print "F";
            }
         } else if (num < 43) {
            print "cxg";
         } else {
            print "H";
         }
      } else if (num < 46) {
         if (num < 45) {
            print "I";
         } else {
            print "J";
         }
      } else if (num < 47) {
         print "K";
      } else {
         print "L";
      }
   } else if (num < 56) {
      if (num < 52) {
         if (num < 50) {
            if (num < 49) {
               print "M";
            } else {
               print "N";
            }
         } else if (num < 51) {
            print "O";
         } else {
            print "P";
         }
      } else if (num < 54) {
         if (num < 53) {
            print "Q";
         } else {
            print "R";
         }
      } else if (num < 55) {
         print "S";
      } else {
         print "T";
      }
   } else if (num < 60) {
      if (num < 58) {
         if (num < 57) {
            print "U";
         } else {
            print "V";
         }
      } else if (num < 59) {
         print "W";
      } else {
         print "X";
      }
   } else if (num < 62) {
      if (num < 61) {
         print "Y";
      } else {
         print "Z";
      }
   } else if (num < 63) {
      print "_";
   } else if (num < 64) {
      print "?";
   } else {
      print "(";
      print num;
      print ")";
   }
   return (num);
}
define base_out_print(num,baset) {
   auto digits_arr[],dig_count,ii,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (num < 0) {
      print "-";
      num = -num;
   }
   dig_count = 0;
   for (;;) {
      digits_arr[dig_count] = num % baset;
      dig_count += 1;
      num = floorl(num / baset);
      if (num == 0) {
         break; # loop AWAIT
      }
   }
   for (ii = dig_count - 1; 0 <= ii; ii -= 1) {
      bcdummy = num2char_print(digits_arr[ii]);
   }
   scale = local_prev_scale;
   return (dig_count);
}
define base_out_fix_print(num,baset,min_sz) {
   auto digits_arr[],dig_count,ii,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (num < 0) {
      num = -num;
   }
   dig_count = 0;
   for (;;) {
      digits_arr[dig_count] = num % baset;
      dig_count += 1;
      num = floorl(num / baset);
      if (num == 0) {
         break; # loop AWAIT
      }
   }
   for (ii = dig_count; ii <= min_sz - 1; ii += 1) {
      bcdummy = num2char_print(0);
   }
   for (ii = dig_count - 1; 0 <= ii; ii -= 1) {
      bcdummy = num2char_print(digits_arr[ii]);
   }
   scale = local_prev_scale;
   return (min_sz);
}
define base_outf_print(num,baset) {
   auto dig_count,ii,frc,dig,lim;
   dig_count = 0;
   if (num < 0.0) {
      print "-";
      num = -num;
      dig_count += 1;
   }
   dig_count += base_out_print(floorl(num),baset) + 1;
   print ".";
   lim = ceill(-lg(cxdbleps) / lg(baset));
   frc = frac(num) * baset;
   ii = 1;
   while (ii <= lim && ! iszero(frc)) {
      dig = floorl(frc);
      bcdummy = num2char_print(dig);
      frc -= dig;
      frc *= baset;
      ii += 1;
   }
   return (dig_count + lim);
}
define f21(aa,bb,cc,zz) {
   auto sum_curr,sum_prev,term,nn;
   if (1 < abs(zz)) {
      sum_curr = 0.0;
   } else {
      sum_curr = 1.0;
      term = 1.0;
      nn = 0;
      for (;;) {
         term *= ((aa + nn) * (bb + nn) * zz / ((cc + nn) *\
               (1 + nn)));
         sum_prev = sum_curr;
         sum_curr += term;
         if (iseq(sum_curr,sum_prev)) {
            break; # loop AWAIT
         }
         nn += 1;
      }
   }
   return (sum_curr);
}
define f11(aa,bb,zz) {
   auto sum_curr,sum_prev,term,nn;
   if (1 < abs(zz)) {
      sum_curr = 0.0;
   } else {
      sum_curr = 1.0;
      term = 1.0;
      nn = 0;
      for (;;) {
         term *= ((aa + nn) * zz / ((bb + nn) * (1 + nn)));
         sum_prev = sum_curr;
         sum_curr += term;
         if (iseq(sum_curr,sum_prev)) {
            break; # loop AWAIT
         }
         nn += 1;
      }
   }
   return (sum_curr);
}
define lf_lambert_iter(xx,nearw_zero) {
   auto ii,eww,tnn,snn,unn,delta,wjj,wjj_prev;
   wjj = nearw_zero;
   ii = 0;
   for (;;) {
      eww = exp(wjj);
      tnn = wjj * eww - xx;
      snn = (wjj + 2.0) / (2.0 * (wjj + 1.0));
      unn = (wjj + 1.0) * eww;
      delta = tnn / (tnn * snn - unn);
      wjj_prev = wjj;
      wjj += delta;
      if (iseq(wjj,wjj_prev)) {
         break; # loop AWAIT
      }
      ii += 1;
      if (20 <= ii) {
         break; # loop AWAIT
      }
   }
   return (wjj);
}
define wp(xx) {
   auto tnn,snn,near_w,retvalu;
   if (xx <= - exp(-1.0)) {
      retvalu = -1.0;
   } else {
      if (xx < 3.0) {
         snn = cxe * xx + 1.0;
         near_w = cbrt(snn) - 1.0 + 0.025 * (snn / cxe);
      } else {
         snn = log(xx);
         tnn = log(log(xx));
         near_w = snn - tnn + tnn / snn;
      }
      retvalu = lf_lambert_iter(xx,near_w);
   }
   return (retvalu);
}
define wm(xx) {
   auto ii,near_w,retvalu,tnn,numer,denom;
   if (xx <= - exp(-1.0)) {
      retvalu = -1.0;
   } else {
      if (xx < - 0.303) {
         tnn = -sqrt(2.0 * (1.0 + cxe * xx));
         near_w = ((((((((((226287557.0 / 37623398400.0) *\
               tnn - 1963.0 / 204120.0) * tnn + 680863.0 /\
               43545600.0) * tnn - 221.0 / 8505.0) * tnn +\
               769.0 / 17280.0) * tnn - 43.0 / 540.0) * tnn +\
               11.0 / 72.0) * tnn - 1.0 / 3.0) * tnn + 1.0) *\
               tnn - 1.0);
      } else if (xx < - 0.0510129) {
         numer = (((6.5794931769023040 * 10^2) * xx +\
               (2.5388810188892484 * 10^2)) * xx -\
               (7.8141767239074400 * 10^0));
         denom = ((((((1.4779341280760887 * 10^3) * xx +\
               (9.6217849696986600 * 10^2)) * xx +\
               (6.8260739999094280 * 10^2)) * xx +\
               (9.9985670831076100 * 10^1)) * xx -\
               (6.0439587136908080 * 10^1)) * xx + 1.0);
         near_w = numer / denom;
      } else if (xx < 0.0) {
         near_w = log(-xx);
         for (ii = 0; ii <= 8; ii += 1) {
            near_w = log(xx / near_w);
         }
      } else {
         near_w = cxdblmax;
      }
      retvalu = lf_lambert_iter(xx,near_w);
   }
   return (retvalu);
}
define wpinv(zz) {
   return (zz * exp(zz));
}
define wminv(zz) {
   return (zz * exp(zz));
}
define sinintegral(xx) {
   auto sum_curr,sum_prev,term,kk,xsq;
   if (iszero(xx)) {
      sum_curr = 0.0;
   } else {
      sum_curr = xx;
      term = xx;
      xsq = xx * xx;
      kk = 3;
      for (;;) {
         term *= - xsq / (kk * (kk - 1.0));
         sum_prev = sum_curr;
         sum_curr += term / kk;
         if (iseq(sum_curr,sum_prev)) {
            break; # loop AWAIT
         }
         kk += 2;
      }
   }
   return (sum_curr);
}
define cosintegral(xx) {
   auto sum_curr,sum_prev,term,kk,xsq;
   if (iszero(xx)) {
      sum_curr = -cxdblmax;
   } else {
      sum_curr = cxeuler + log(abs(xx));
      term = 1.0;
      xsq = xx * xx;
      kk = 2;
      for (;;) {
         term *= - xsq / (kk * (kk - 1.0));
         sum_prev = sum_curr;
         sum_curr += term / kk;
         if (iseq(sum_curr,sum_prev)) {
            break; # loop AWAIT
         }
         kk += 2;
      }
   }
   return (sum_curr);
}
define ein(xx) {
   auto sum_curr,sum_prev,term,kk;
   sum_curr = 0;
   term = -1;
   kk = 1;
   for (;;) {
      term *= - xx / kk;
      sum_prev = sum_curr;
      sum_curr += term / kk;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      kk += 1;
   }
   return (sum_curr);
}
define expintegrali(xx) {
   auto retvalu;
   retvalu = cxeuler + log(abs(xx)) - ein(-xx);
   return (retvalu);
}
define expintegral1(xx) {
   auto retvalu;
   retvalu = ein(xx) - cxeuler - log(abs(xx));
   return (retvalu);
}
define expintegraln(nn,xx) {
   return (pow(xx,nn - 1) * uigamma(1 - nn,xx));
}
define logintegral(xx) {
   auto sum,lnx,yy,nn,sum_prev,limit,retvalu;
   if (xx <= 1.0) {
      retvalu = 0.0;
   } else {
      lnx = log(xx);
      sum = 0.0;
      yy = 1.0;
      limit = 1.6 * log(xx) + 40;
      nn = 1;
      for (;;) {
         yy *= lnx / nn;
         sum_prev = sum;
         sum += yy / nn;
         if (iseq(sum,sum_prev)) {
            break; # loop AWAIT
         }
         nn += 1;
         if (limit <= nn) {
            break; # loop AWAIT
         }
      }
      retvalu = cxeuler + log(lnx) + sum;
   }
   return (retvalu);
}
define carlsonrf(xx,yy,zz) {
   auto sqx,sqy,sqz,lmbd;
   for (;;) {
      sqx = sqrt(xx);
      sqy = sqrt(yy);
      sqz = sqrt(zz);
      lmbd = sqx * sqy + sqx * sqz + sqy * sqz;
      xx = (xx + lmbd) / 4.0;
      yy = (yy + lmbd) / 4.0;
      zz = (zz + lmbd) / 4.0;
      if (iseq(xx,yy) && iseq(yy,zz)) {
         break; # loop AWAIT
      }
   }
   return (1.0 / sqrt(xx));
}
define carlsonrc(xx,yy) {
   auto lmbd;
   for (;;) {
      lmbd = 2 * sqrt(xx * yy) + yy;
      xx = (xx + lmbd) / 4.0;
      yy = (yy + lmbd) / 4.0;
      if (iseq(xx,yy)) {
         break; # loop AWAIT
      }
   }
   return (1.0 / sqrt(xx));
}
define carlsonrj(xx,yy,zz,pp) {
   auto sqx,sqy,sqz,lmbd,pfour,alfa,beta,sigm;
   pfour = 1.0;
   sigm = 0.0;
   for (;;) {
      sqx = sqrt(xx);
      sqy = sqrt(yy);
      sqz = sqrt(zz);
      lmbd = sqx * sqy + sqx * sqz + sqy * sqz;
      alfa = pp * (sqx + sqy + sqz) + sqx * sqy * sqz;
      alfa *= alfa;
      beta = pp * (pp + lmbd) * (pp + lmbd);
      sigm += pfour * carlsonrc(alfa,beta);
      pfour /= 4.0;
      xx = (xx + lmbd) / 4.0;
      yy = (yy + lmbd) / 4.0;
      zz = (zz + lmbd) / 4.0;
      pp = (pp + lmbd) / 4.0;
      if (iseq(xx,yy) && iseq(yy,zz) && iseq(zz,pp)) {
         break; # loop AWAIT
      }
   }
   return (3.0 * sigm);
}
define carlsonrd(xx,yy,zz) {
   auto sqx,sqy,sqz,lmbd,pfour,alfa,beta,sigm;
   pfour = 1.0;
   sigm = 0.0;
   for (;;) {
      sqx = sqrt(xx);
      sqy = sqrt(yy);
      sqz = sqrt(zz);
      lmbd = sqx * sqy + sqx * sqz + sqy * sqz;
      alfa = zz * (sqx + sqy + sqz) + sqx * sqy * sqz;
      alfa *= alfa;
      beta = zz * (zz + lmbd) * (zz + lmbd);
      sigm += pfour * carlsonrc(alfa,beta);
      pfour /= 4.0;
      xx = (xx + lmbd) / 4.0;
      yy = (yy + lmbd) / 4.0;
      zz = (zz + lmbd) / 4.0;
      if (iseq(xx,yy) && iseq(yy,zz)) {
         break; # loop AWAIT
      }
   }
   return (3.0 * sigm);
}
define powi(xx,nn) {
   auto pp,sqx;
   pp = 1;
   sqx = xx;
   while (0 < nn) {
      if (isodd(nn)) {
         pp *= sqx;
      }
      sqx *= sqx;
      nn = lf_shiftr(nn,1);
   }
   return (pp);
}
define atothenmodp(aa,nn,pp) {
   auto retvalu,cc,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (pp == 0) {
      retvalu = 0;
   } else {
      if (pp < 0) {
         pp = -pp;
      }
      if (nn < 0) {
         nn = nn % pp;
         if (nn < 0) {
            nn += pp;
         }
      }
      retvalu = 1;
      cc = aa % pp;
      while (0 < nn) {
         if (isodd(nn)) {
            retvalu = (retvalu * cc) % pp;
            nn = (nn - 1) / 2;
         } else {
            nn /= 2;
         }
         cc = (cc * cc) % pp;
      }
   }
   scale = local_prev_scale;
   return (retvalu);
}
define atothenmodx(aa,nn,pp) {
   return (frac(exp(nn * log(aa) - log(pp))) * pp);
}
define ctz(nn) {
   auto ii;
   ii = 0;
   while (0 == bitwiseand(nn,1)) {
      ii += 1;
      nn = lf_shiftr(nn,1);
   }
   return (ii);
}
define gcd(aa,bb) {
   auto cc,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   aa = abs(aa);
   bb = abs(bb);
   if (bb <= 0) {
      bb = aa;
   } else {
      while (0 < aa) {
         cc = aa;
         aa = bb % aa;
         bb = cc;
      }
   }
   scale = local_prev_scale;
   return (bb);
}
define gcda(nn,*num_arr_pc[]) {
   auto ind,gc;
   gc = num_arr_pc[0];
   for (ind = 1; ind <= nn - 1; ind += 1) {
      gc = gcd(gc,num_arr_pc[ind]);
   }
   return (gc);
}
define lcm(aa,bb) {
   return (aa * bb / gcd(aa,bb));
}
define lcam(aa,bb) {
   auto ii,mm;
   if (bb < aa) {
      ii = aa;
      aa = bb;
      bb = ii;
   }
   ii = bb;
   for (;;) {
      mm = mods(ii,aa);
      if (- 2 <= mm && mm <= 2) {
         break; # loop AWAIT
      }
      ii += bb;
   }
   if (mm == -2) {
      ii += 1;
   } else if (0 <= mm) {
      ii -= 1;
   }
   return (ii);
}
define lcams(aa,bb) {
   auto ii,mm;
   if (bb < aa) {
      ii = aa;
      aa = bb;
      bb = ii;
   }
   ii = 2 * bb;
   for (;;) {
      mm = mods(ii,aa);
      if (- 2 <= mm && mm <= 2) {
         break; # loop AWAIT
      }
      ii += bb;
   }
   if (mm == -2) {
      ii += 1;
   } else if (0 <= mm) {
      ii -= 1;
   }
   return (ii);
}
define lcantim(aa,bb) {
   auto haa,hbb,ii,rema,odd_mask;
   if (isposint(aa) && isposint(bb)) {
      odd_mask = 0;
      if (isodd(aa)) {
         odd_mask = 1;
      }
      if (isodd(bb)) {
         odd_mask += 2;
      }
      if (2 == odd_mask || (bb < aa && odd_mask != 1)) {
         ii = bb;
         bb = aa;
         aa = ii;
      }
      haa = floorl(aa / 2);
      hbb = floorl(bb / 2);
      ii = hbb;
      for (;;) {
         rema = dist(ii,aa);
         if (rema == haa) {
            break;
         } else if (odd_mask == 3 && rema == haa + 1) {
            break;
         }
         ii += bb;
         if (aa * bb <= ii) {
            break; # loop AWAIT
         }
      }
      if (aa * bb <= ii) {
         ii = 0;
      }
   } else {
      ii = 0;
   }
   return (ii);
}
define factor(nn,*ret_fctr_arr_p[]) {
   auto pp,fctr_ind,inc,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   fctr_ind = 0;
   nn = abs(nn);
   if (nn <= 3) {
      ret_fctr_arr_p[fctr_ind] = nn;
      fctr_ind = 1;
   } else {
      for (pp = 2; pp <= 3; pp += 1) {
         while (0 == nn % pp) {
            ret_fctr_arr_p[fctr_ind] = pp;
            fctr_ind += 1;
            nn /= pp;
         }
      }
      pp = 1;
      inc = 4;
      for (;;) {
         pp += inc;
         inc = 6 - inc;
         while (0 == nn % pp) {
            ret_fctr_arr_p[fctr_ind] = pp;
            fctr_ind += 1;
            nn /= pp;
         }
         if (nn < pp * pp) {
            break; # loop AWAIT
         }
      }
      if (1 < nn) {
         ret_fctr_arr_p[fctr_ind] = nn;
         fctr_ind += 1;
      }
   }
   scale = local_prev_scale;
   ret_fctr_arr_p[fctr_ind] = 0;
   return (fctr_ind);
}
define modulo(xxn,yymod) {
   auto retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   retvalu = xxn % yymod;
   if (retvalu < 0) {
      retvalu += abs(yymod);
   }
   scale = local_prev_scale;
   return (retvalu);
}
define mods(xxn,yymod) {
   auto retvalu,ayy,axx,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   ayy = floorl(abs(yymod));
   axx = abs(xxn);
   retvalu = axx % ayy;
   if (0 < retvalu) {
      while (ayy < 2 * retvalu) {
         retvalu -= ayy;
      }
   } else if (retvalu < 0) {
      while (2 * retvalu < - ayy) {
         retvalu += ayy;
      }
   }
   scale = local_prev_scale;
   return (retvalu);
}
define pfl(nn) {
   auto small_factor,lim,divid,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (nn < 2) {
      small_factor = 1;
   } else if (nn % 2 == 0) {
      small_factor = 2;
   } else if (nn % 3 == 0) {
      small_factor = 3;
   } else if (nn % 5 == 0) {
      small_factor = 5;
   } else if (nn % 7 == 0) {
      small_factor = 7;
   } else {
      lim = floorl(sqrt(nn));
      divid = 11;
      small_factor = nn;
      while (divid <= lim) {
         if (nn % divid == 0) {
            small_factor = divid;
            break;
         }
         divid += 2;
         if (nn % divid == 0) {
            small_factor = divid;
            break;
         }
         divid += 4;
      }
   }
   scale = local_prev_scale;
   return (small_factor);
}
define pfg(nn) {
   auto mm,ff;
   mm = nn;
   for (;;) {
      ff = pfl(mm);
      mm /= ff;
      if (mm == 1) {
         break; # loop AWAIT
      }
   }
   return (ff);
}
define isprime(nn) {
   auto retvalu_bol,ann;
   ann = abs(nn);
   if (ann == 2 || ann == 3 || ann == 5 || ann == 7) {
      retvalu_bol = true;
   } else if (ann < 11) {
      retvalu_bol = false;
   } else if (pfl(ann) == ann) {
      retvalu_bol = true;
   } else {
      retvalu_bol = false;
   }
   return (retvalu_bol);
}
define primeprev(pp) {
   auto retvalu,rema,inc,qq,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (pp <= 7) {
      if (pp < 0) {
         retvalu = -primenext(-pp);
      } else if (5 < pp) {
         retvalu = 5;
      } else if (3 < pp) {
         retvalu = 3;
      } else if (2 < pp) {
         retvalu = 2;
      } else {
         retvalu = -2;
      }
   } else {
      rema = pp % 6;
      qq = pp - rema;
      if (rema <= 1) {
         qq -= 1;
         inc = 4;
      } else {
         qq += 1;
         inc = 2;
      }
      while (! isprime(qq)) {
         qq -= inc;
         inc = 6 - inc;
      }
      retvalu = qq;
   }
   scale = local_prev_scale;
   return (retvalu);
}
define primenext(pp) {
   auto retvalu,rema,inc,qq,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (pp < 7) {
      if (pp < 0) {
         retvalu = -primeprev(-pp);
      } else if (pp < 2) {
         retvalu = 2;
      } else if (pp < 3) {
         retvalu = 3;
      } else if (pp < 5) {
         retvalu = 5;
      } else {
         retvalu = 7;
      }
   } else {
      rema = (pp + 1) % 6;
      qq = (pp + 1) - rema;
      if (rema <= 1) {
         qq += 1;
         inc = 4;
      } else {
         qq += 5;
         inc = 2;
      }
      while (! isprime(qq)) {
         qq += inc;
         inc = 6 - inc;
      }
      retvalu = qq;
   }
   scale = local_prev_scale;
   return (retvalu);
}
lv_pcf_end = 0;
lv_pcf_arr[0] = 0;
define primecount(xx) {
   # local-use Bc lv_pcf_arr[];
   # local-use Bc lv_pcf_end;
   auto retvalu,poss_prime,s_ind,ps_ind,pcf_val,\
         local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (xx < 7) {
      if (xx < 3) {
         if (xx < 2) {
            retvalu = 0;
         } else {
            retvalu = 1;
         }
      } else {
         if (xx < 5) {
            retvalu = 2;
         } else {
            retvalu = 3;
         }
      }
   } else {
      s_ind = floorl((xx - 5) / 2) - floorl((xx - 3) / 6);
      if (lv_pcf_end <= s_ind) {
         ps_ind = lv_pcf_end;
         if (lv_pcf_end <= 0) {
            pcf_val = 2;
         } else {
            pcf_val = lv_pcf_arr[lv_pcf_end - 1];
         }
         lv_pcf_end = ceil2(s_ind + 1,2);
         poss_prime = 3 * ps_ind - (ps_ind % 2) + 5;
         while (ps_ind <= s_ind) {
            if (isprime(poss_prime)) {
               pcf_val += 1;
            }
            lv_pcf_arr[ps_ind] = pcf_val;
            poss_prime += 2;
            ps_ind += 1;
            if (isprime(poss_prime)) {
               pcf_val += 1;
            }
            lv_pcf_arr[ps_ind] = pcf_val;
            poss_prime += 4;
            ps_ind += 1;
         }
      }
      retvalu = lv_pcf_arr[s_ind];
   }
   scale = local_prev_scale;
   return (retvalu);
}
define pcf(xx) {
   return (primecount(xx));
}
define primecountx(xx) {
   auto retvalu,poss_prime,inc,pcf_val;
   if (xx < 7) {
      if (xx < 3) {
         if (xx < 2) {
            retvalu = 0;
         } else {
            retvalu = 1;
         }
      } else {
         if (xx < 5) {
            retvalu = 2;
         } else {
            retvalu = 3;
         }
      }
   } else {
      pcf_val = 4;
      poss_prime = 11;
      inc = 2;
      while (poss_prime <= xx) {
         if (isprime(poss_prime)) {
            pcf_val += 1;
         }
         poss_prime += inc;
         inc = 6 - inc;
      }
      retvalu = pcf_val;
   }
   return (retvalu);
}
define eta(xx) {
   auto sum,sump,tt,nn,kk,s_ind,retvalu,pm_one,\
         ps_arr[],temp_arr[],term;
   if (0 < xx) {
      tt = 0;
      term = -log(cxdbleps) / xx;
      if (term < log(4000)) {
         kk = ceill(exp(term));
         sum = 0;
         pm_one = -1.0;
         nn = 1;
         for (;;) {
            pm_one = -pm_one;
            term = pm_one * pow(nn,- xx);
            tt += 1;
            sump = sum;
            sum += term;
            if (iseq(sump,sum)) {
               break; # loop AWAIT
            }
            nn += 1;
            if (kk <= nn) {
               break; # loop AWAIT
            }
         }
         retvalu = sum - 0.5 * term;
      } else {
         sum = 0;
         pm_one = -1.0;
         ps_arr[0] = -pow(2,- xx);
         tt += 1;
         temp_arr[0] = ps_arr[0];
         nn = 1;
         for (;;) {
            pm_one = -pm_one;
            ps_arr[nn] = ps_arr[nn - 1] + pm_one * pow(nn + 2\
                  ,- xx);
            tt += 1;
            temp_arr[nn] = ps_arr[nn];
            for (kk = nn - 1; 0 <= kk; kk -= 1) {
               temp_arr[kk] = (temp_arr[kk] + temp_arr[kk +\
                     1]) / 2.0;
            }
            sump = sum;
            sum = temp_arr[0];
            if (iseq(sump,sum)) {
               break; # loop AWAIT
            }
            nn += 1;
            if (400 <= nn) {
               break; # loop AWAIT
            }
         }
         s_ind = floorl(nn / 3);
         sum = (4 * temp_arr[s_ind] + 3 * temp_arr[s_ind +\
               1]) / 7;
         retvalu = sum + 1.0;
      }
   } else if (xx < 0) {
      retvalu = 0.0;
   } else {
      retvalu = 0.5;
   }
   return (retvalu);
}
define zeta(xx) {
   auto retvalu;
   if (1 < xx) {
      retvalu = eta(xx) / (1.0 - pow(2.0,1.0 - xx));
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define fibo3(nn,fib_a,fib_b) {
   auto ii,tt,retvalu;
   if (nn == 0) {
      retvalu = fib_a;
   } else {
      for (ii = 2; ii <= nn; ii += 1) {
         tt = fib_b;
         fib_b += fib_a;
         fib_a = tt;
      }
      retvalu = fib_b;
   }
   return (retvalu);
}
define fibo(nn) {
   return (fibo3(nn,0,1));
}
define fibox(xx) {
   auto zz,retvalu;
   if (log(cxdblmax) / log(cxphi) < abs(xx)) {
      retvalu = 0.0;
   } else {
      zz = pow(cxphi,xx);
      retvalu = (zz - cos(cxpi * xx) / zz) / sqrt(5.0);
   }
   return (retvalu);
}
define fiboxinv(yy) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_dy,\
         scvx_ii,x_init;
   if (yy <= 0) {
      scvx_xx = 0.0;
   } else {
      if (yy <= 0.2) {
         x_init = 0.075;
      } else if (yy <= 0.896946387424606) {
         x_init = 0.8 * yy - 0.15;
      } else if (yy <= 1.009824331847821) {
         x_init = 0.92;
      } else {
         x_init = log(yy * sqrt(5.0)) / log(cxphi);
      }
      scvx_dx = 0.05;
      scvx_xx = x_init;
      scvx_yy = yy - fibox(scvx_xx);
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = yy - fibox(scvx_xx);
         scvx_dy = (scvx_yy - scvx_yp);
         if (iszero(scvx_dy)) {
            break;
         }
         scvx_dx *= - scvx_yy / scvx_dy;
      }
   }
   return (scvx_xx);
}
define lucas(nn) {
   return (fibo3(nn,2,1));
}
define lucasx(xx) {
   auto zz,retvalu;
   if (log(cxdblmax) / log(cxphi) < abs(xx)) {
      retvalu = 0.0;
   } else {
      zz = pow(cxphi,xx);
      retvalu = (zz + cos(cxpi * xx) / zz);
   }
   return (retvalu);
}
define fusc(nn) {
   auto aa,bb;
   aa = 1;
   bb = 0;
   while (0 < nn) {
      if (isodd(nn)) {
         bb += aa;
      } else {
         aa += bb;
      }
      nn = lf_shiftr(nn,1);
   }
   return (bb);
}
define tn(nn,xx) {
   auto retvalu,tnm_a,tnm_b,tnn,kk;
   if (nn == 0) {
      retvalu = 1.0;
   } else if (nn == 1) {
      retvalu = xx;
   } else if (nn == 2) {
      retvalu = 2.0 * xx * xx - 1.0;
   } else {
      tnm_a = 2.0 * xx * xx - 1.0;
      tnm_b = xx;
      tnn = tnm_a;
      for (kk = 3; kk <= nn; kk += 1) {
         tnn = (2.0 * xx * tnm_a) - tnm_b;
         tnm_b = tnm_a;
         tnm_a = tnn;
      }
      retvalu = tnn;
   }
   return (retvalu);
}
define un(nn,xx) {
   auto retvalu,tnm_a,tnm_b,tnn,kk;
   if (nn == 0) {
      retvalu = 1.0;
   } else if (nn == 1) {
      retvalu = 2.0 * xx;
   } else {
      tnm_a = 2.0 * xx;
      tnm_b = 1.0;
      tnn = tnm_a;
      for (kk = 2; kk <= nn; kk += 1) {
         tnn = (2.0 * xx * tnm_a) - tnm_b;
         tnm_b = tnm_a;
         tnm_a = tnn;
      }
      retvalu = tnn;
   }
   return (retvalu);
}
define tri(nn) {
   return (nn * (nn + 1) / 2);
}
define triinv(nn) {
   auto retvalu;
   if (- 0.125 < nn) {
      retvalu = (sqrt(8.0 * nn + 1.0) - 1.0) / 2.0;
   } else {
      retvalu = -0.5;
   }
   return (retvalu);
}
define polynum(ss,nn) {
   return ((ss - 2) * nn * (nn - 1) / 2 + nn);
}
define polycnum(ss,nn) {
   return (ss * nn * (nn - 1) / 2 + 1);
}
define tetranum(ss,nn) {
   return (nn * (nn + 1) * ((ss - 2) * nn + 5 - ss) / 6);
}
define tetracnum(ss,nn) {
   return (nn * (ss * nn * nn + 6 - ss) / 6);
}
define minkowski(xx) {
   auto pp,qq,rr,ss,mm,nn,dd,yy;
   pp = floor(xx);
   qq = 1;
   rr = pp + 1;
   ss = 1;
   dd = 1.0;
   yy = pp;
   for (;;) {
      dd /= 2.0;
      mm = pp + rr;
      nn = qq + ss;
      if (xx < mm / nn) {
         rr = mm;
         ss = nn;
      } else {
         yy += dd;
         pp = mm;
         qq = nn;
      }
      if (iseq(yy + dd,yy)) {
         break; # loop AWAIT
      }
   }
   return (yy);
}
define cantorxx(bb,ee,xx) {
   auto yy,rest,dd,ulmt;
   if (ee < 0.0 || bb < 0.0 || 1.0 < ee + bb) {
      yy = xx;
   } else {
      ulmt = 1.0 - ee;
      yy = floor(xx);
      rest = (xx - yy);
      dd = 0.5;
      for (;;) {
         if (ulmt <= rest) {
            yy += dd;
            rest = frac((rest - ulmt) / ee);
         } else if (bb <= rest) {
            yy += dd;
            break;
         } else {
            rest = frac(rest / bb);
         }
         dd /= 2.0;
         if (iseq(yy + dd,yy) || iszero(rest)) {
            break; # loop AWAIT
         }
      }
   }
   return (yy);
}
define cantor(xx) {
   return (cantorxx(1.0 / 3.0,1.0 / 3.0,xx));
}
define cantorul(bb,ee,xx) {
   return (pow(0.5,log(xx) / log(bb) + 0.0 * ee));
}
define cantorll(bb,ee,xx) {
   return (pow(0.5,log(xx / (1.0 - ee)) / log(bb) + 1.0));
}
define dlogx(aa,bb,nn) {
   auto ii,pp,retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   pp = aa;
   retvalu = -1;
   for (ii = 1; ii <= nn; ii += 1) {
      if (pp == bb) {
         retvalu = ii;
         break;
      }
      pp = (pp * aa) % nn;
   }
   scale = local_prev_scale;
   return (retvalu);
}
define dlog(aa,bb,nn) {
   auto sqnn,cur,atothesqnn,atothens,ii,log_arr[],\
         retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (aa == bb) {
      retvalu = 1;
   } else if (aa <= 0 || bb <= 0 || nn <= 0) {
      retvalu = -1;
   } else if (1 < gcd(aa,nn) || (! isprimitiveroot(aa,nn))) {
      retvalu = dlogx(aa,bb,nn);
   } else {
      sqnn = ceill(sqrt(nn));
      for (ii = 0; ii <= nn - 1; ii += 1) {
         log_arr[ii] = 0;
      }
      atothesqnn = atothenmodp(aa,sqnn,nn);
      cur = atothesqnn;
      for (ii = 1; ii <= sqnn; ii += 1) {
         if (log_arr[cur] == 0) {
            log_arr[cur] = ii;
         }
         cur = (cur * atothesqnn) % nn;
      }
      cur = bb % nn;
      retvalu = -1;
      for (ii = 0; ii <= sqnn; ii += 1) {
         if (0 < log_arr[cur]) {
            atothens = log_arr[cur] * sqnn - ii;
            if (atothens < nn) {
               retvalu = atothens;
               break;
            }
         }
         cur = (cur * aa) % nn;
      }
   }
   scale = local_prev_scale;
   return (retvalu);
}
define dlog1(aa,nn) {
   return (dlog(aa,1,nn));
}
lv_mertens_end = 0;
lv_mertens_arr[0] = 0;
define mertens(nn) {
   # local-use Bc lv_mertens_arr[];
   # local-use Bc lv_mertens_end;
   auto retvalu,kk;
   if (nn < 0) {
      retvalu = 0;
   } else {
      if (lv_mertens_end <= 0) {
         lv_mertens_end = 4;
         lv_mertens_arr[0] = 0;
         lv_mertens_arr[1] = 1;
         lv_mertens_arr[2] = 0;
         lv_mertens_arr[3] = -1;
      }
      if (lv_mertens_end <= nn) {
         kk = lv_mertens_end;
         lv_mertens_end = nn + 1;
         while (kk < lv_mertens_end) {
            lv_mertens_arr[kk] = lv_mertens_arr[kk - 1] +\
                  mobius(kk);
            kk += 1;
         }
      }
      retvalu = lv_mertens_arr[nn];
   }
   return (retvalu);
}
define has_primitiveroot_f(nf,*fac_arr_pc[]) {
   auto ind;
   ind = 0;
   if (1 < nf) {
      if (fac_arr_pc[0] == 2) {
         ind += 1;
      }
      if (2 < fac_arr_pc[ind]) {
         while (ind < nf - 1) {
            if (fac_arr_pc[ind] < fac_arr_pc[ind + 1]) {
               break;
            }
            ind += 1;
         }
      }
   }
   return (ind == (nf - 1));
}
define sigma0_f(nf,*fac_arr_pc[]) {
   auto ind,retvalu,exp_i;
   retvalu = 1;
   exp_i = 2;
   for (ind = 0; ind <= nf - 2; ind += 1) {
      if (fac_arr_pc[ind] == fac_arr_pc[ind + 1]) {
         exp_i += 1;
      } else {
         retvalu *= exp_i;
         exp_i = 2;
      }
   }
   return (retvalu * exp_i);
}
define sigma1_f(nf,*fac_arr_pc[]) {
   auto ind,retvalu,exp_i,prm_prev,prm_curr;
   retvalu = 1;
   exp_i = 2;
   prm_prev = fac_arr_pc[0];
   for (ind = 1; ind <= nf - 1; ind += 1) {
      prm_curr = fac_arr_pc[ind];
      if (prm_prev == prm_curr) {
         exp_i += 1;
      } else {
         retvalu *= (powi(prm_prev,exp_i) - 1) / (prm_prev - 1);
         exp_i = 2;
         prm_prev = prm_curr;
      }
   }
   return (retvalu * (powi(prm_prev,exp_i) - 1) / (prm_prev\
         - 1));
}
define sigma_f(powy,nf,*fac_arr_pc[]) {
   auto ind,retvalu,exp_i,prm_curr,prm_prev,pw;
   if (powy == 0) {
      retvalu = sigma0_f(nf,fac_arr_pc[]);
   } else if (powy == 1) {
      retvalu = sigma1_f(nf,fac_arr_pc[]);
   } else {
      retvalu = 1;
      exp_i = 2;
      prm_prev = fac_arr_pc[0];
      for (ind = 1; ind <= nf - 1; ind += 1) {
         prm_curr = fac_arr_pc[ind];
         if (prm_prev == prm_curr) {
            exp_i += 1;
         } else {
            pw = powi(prm_prev,powy);
            retvalu *= ((powi(pw,exp_i) - 1) / (pw - 1));
            exp_i = 2;
            prm_prev = prm_curr;
         }
      }
      pw = powi(prm_prev,powy);
      retvalu *= ((powi(pw,exp_i) - 1) / (pw - 1));
   }
   return (retvalu);
}
define ispractical_f(nf,*fac_arr_pc[]) {
   auto ind,sgma,exp_i,prm_curr,prm_prev,retvalu_bol;
   if (2 < fac_arr_pc[0]) {
      retvalu_bol = false;
   } else {
      retvalu_bol = true;
      sgma = 1;
      exp_i = 2;
      prm_prev = fac_arr_pc[0];
      for (ind = 1; ind <= nf - 1; ind += 1) {
         prm_curr = fac_arr_pc[ind];
         if (prm_prev == prm_curr) {
            exp_i += 1;
         } else {
            sgma *= (powi(prm_prev,exp_i) - 1) / (prm_prev - 1);
            if (1 + sgma < prm_curr) {
               retvalu_bol = false;
               break;
            }
            exp_i = 2;
            prm_prev = prm_curr;
         }
      }
   }
   return (retvalu_bol);
}
define issquarefree_f(nf,*fac_arr_pc[]) {
   auto ind,retvalu_bol;
   retvalu_bol = true;
   for (ind = 1; ind <= nf - 1; ind += 1) {
      if (fac_arr_pc[ind - 1] == fac_arr_pc[ind]) {
         retvalu_bol = false;
         break;
      }
   }
   return (retvalu_bol);
}
define totient_f(nf,*fac_arr_pc[]) {
   auto ind,retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   retvalu = 1;
   for (ind = 0; ind <= nf - 2; ind += 1) {
      if (fac_arr_pc[ind] == fac_arr_pc[ind + 1]) {
         retvalu *= fac_arr_pc[ind];
      } else {
         retvalu *= (fac_arr_pc[ind] - 1);
      }
   }
   retvalu *= (fac_arr_pc[nf - 1] - 1);
   scale = local_prev_scale;
   return (retvalu);
}
define mobius_f(nf,*fac_arr_pc[]) {
   auto retvalu,ind;
   if (iseven(nf)) {
      retvalu = 1;
   } else {
      retvalu = -1;
   }
   for (ind = 1; ind <= nf - 1; ind += 1) {
      if (fac_arr_pc[ind - 1] == fac_arr_pc[ind]) {
         retvalu = 0;
         break;
      }
   }
   return (retvalu);
}
define prime0_f(nf,*fac_arr_pc[]) {
   auto ind,prm_curr,prm_prev,retvalu;
   retvalu = 1;
   prm_prev = fac_arr_pc[0];
   for (ind = 1; ind <= nf - 1; ind += 1) {
      prm_curr = fac_arr_pc[ind];
      if (prm_prev < prm_curr) {
         retvalu += 1;
      }
      prm_prev = prm_curr;
   }
   return (retvalu);
}
cxlc_max_factors = 65;
define factor_print(nn) {
   auto ind,fac_arr[],nf;
   nf = factor(nn,fac_arr[]);
   print nn;
   print ":";
   for (ind = 0; ind <= nf - 1; ind += 1) {
      print " ";
      print fac_arr[ind];
   }
   print "\n";
   return (nf);
}
define mobius(nn) {
   auto nf,fac_arr[];
   nf = factor(nn,fac_arr[]);
   return (mobius_f(nf,fac_arr[]));
}
define isprimitiveroot(aa,nn) {
   auto toti,nf_toti,ind,prm,retvalu_bol,fac_arr[];
   if (aa <= 1 || 1 < gcd(aa,nn)) {
      retvalu_bol = false;
   } else if (aa == 2) {
      retvalu_bol = isodd(nn);
   } else {
      toti = totient(nn);
      nf_toti = factor(toti,fac_arr[]);
      if (atothenmodp(aa,toti / fac_arr[0],nn) == 1) {
         retvalu_bol = false;
      } else {
         retvalu_bol = true;
         for (ind = 1; ind <= nf_toti - 1; ind += 1) {
            if (fac_arr[ind - 1] != fac_arr[ind]) {
               prm = fac_arr[ind];
               if (atothenmodp(aa,toti / prm,nn) == 1) {
                  retvalu_bol = false;
                  break;
               }
            }
         }
      }
   }
   return (retvalu_bol);
}
define prime0(nn) {
   auto nf,fac_arr[];
   nf = factor(nn,fac_arr[]);
   return (prime0_f(nf,fac_arr[]));
}
define prime1(nn) {
   auto fac_arr[];
   return (factor(nn,fac_arr[]));
}
define sigma0(nn) {
   auto nf,fac_arr[];
   nf = factor(nn,fac_arr[]);
   return (sigma0_f(nf,fac_arr[]));
}
define sigma1(nn) {
   auto nf,fac_arr[];
   nf = factor(nn,fac_arr[]);
   return (sigma1_f(nf,fac_arr[]));
}
define sigma(powy,nn) {
   auto nf,fac_arr[],retvalu;
   if (nn <= 1) {
      retvalu = nn;
   } else if (powy == 0) {
      retvalu = sigma0(nn);
   } else if (powy == 1) {
      retvalu = sigma1(nn);
   } else {
      nf = factor(nn,fac_arr[]);
      retvalu = sigma_f(powy,nf,fac_arr[]);
   }
   return (retvalu);
}
define totient(nn) {
   auto fac_arr[],nf;
   nf = factor(nn,fac_arr[]);
   return (totient_f(nf,fac_arr[]));
}
define has_primitiveroot(nn) {
   auto nf,fac_arr[],retvalu_bol;
   if (nn < 2) {
      retvalu_bol = false;
   } else {
      nf = factor(nn,fac_arr[]);
      retvalu_bol = has_primitiveroot_f(nf,fac_arr[]);
   }
   return (retvalu_bol);
}
define issquarefree(nn) {
   auto nf,fac_arr[],retvalu_bol;
   if (nn < 1) {
      retvalu_bol = false;
   } else if (nn < 3) {
      retvalu_bol = true;
   } else {
      nf = factor(nn,fac_arr[]);
      retvalu_bol = issquarefree_f(nf,fac_arr[]);
   }
   return (retvalu_bol);
}
define ispractical(nn) {
   auto nf,fac_arr[],retvalu_bol;
   if (nn < 1) {
      retvalu_bol = false;
   } else if (nn < 3) {
      retvalu_bol = true;
   } else {
      nf = factor(nn,fac_arr[]);
      retvalu_bol = ispractical_f(nf,fac_arr[]);
   }
   return (retvalu_bol);
}
define primitiveroot(nn) {
   auto ind,nf_toti,toti,mm,fac_arr[],prm,retvalu,\
         local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (nn < 2) {
      retvalu = 0;
   } else if (nn < 5) {
      retvalu = nn - 1;
   } else if (! has_primitiveroot(nn)) {
      retvalu = 0;
   } else {
      toti = totient(nn);
      nf_toti = factor(toti,fac_arr[]);
      mm = 2;
      retvalu = 0;
      while (mm < nn && retvalu <= 0) {
         if (gcd(mm,nn) == 1) {
            retvalu = mm;
            prm = 0;
            for (ind = 0; ind <= nf_toti - 1; ind += 1) {
               if (prm != fac_arr[ind]) {
                  prm = fac_arr[ind];
                  if (atothenmodp(mm,toti / prm,nn) == 1) {
                     retvalu = 0;
                     break;
                  }
               }
            }
         }
         mm += 1;
      }
   }
   scale = local_prev_scale;
   return (retvalu);
}
define carmichael(nn) {
   auto ind,nf,lmbd,prm,pk,fac_arr[],local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (nn < 8) {
      lmbd = totient(nn);
   } else {
      nf = factor(nn,fac_arr[]);
      ind = 0;
      while (ind < nf && fac_arr[ind] == 2) {
         ind += 1;
      }
      if (2 < ind) {
         lmbd = lf_shiftl(1,ind - 2);
      } else {
         lmbd = 1;
      }
      while (ind < nf) {
         prm = fac_arr[ind];
         pk = prm - 1;
         while (ind < nf - 1 && prm == fac_arr[ind + 1]) {
            ind += 1;
            pk *= prm;
         }
         lmbd = lcm(lmbd,pk);
         ind += 1;
      }
   }
   scale = local_prev_scale;
   return (lmbd);
}
define znorder(aa,nn) {
   auto ind,fac_arr[],nfkk,kk,ab,ek,prm_i,exp_i,\
         local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (nn == 0 || aa == 0) {
      kk = 0;
   } else {
      if (nn < 0) {
         nn = -nn;
      }
      while (aa < 0) {
         aa += nn;
      }
      if (nn <= 1) {
         kk = nn;
      } else if (aa <= 1) {
         kk = aa;
      } else if (1 < gcd(aa,nn)) {
         kk = 0;
      } else {
         kk = carmichael(nn);
         nfkk = factor(kk,fac_arr[]);
         exp_i = 1;
         for (ind = 0; ind <= nfkk - 1; ind += 1) {
            prm_i = fac_arr[ind];
            kk /= prm_i;
            if (ind + 1 < nfkk && prm_i == fac_arr[ind + 1]) {
               exp_i += 1;
            } else {
               ab = atothenmodp(aa,kk,nn);
               for (ek = 0; ek <= exp_i; ek += 1) {
                  if (ab == 1) {
                     break;
                  }
                  kk *= prm_i;
                  ab = atothenmodp(ab,prm_i,nn);
               }
               if (exp_i < ek) {
                  kk = 0;
                  break;
               }
               exp_i = 1;
            }
         }
      }
   }
   scale = local_prev_scale;
   return (kk);
}
define repetendlen(denm,basee) {
   auto gdn,retvalu;
   for (;;) {
      gdn = gcd(denm,basee);
      denm /= gdn;
      if (1 == gdn) {
         break; # loop AWAIT
      }
   }
   if (denm == 1) {
      retvalu = 0;
   } else {
      retvalu = znorder(basee,denm);
   }
   return (retvalu);
}
define kevy_print(den,start,basee) {
   auto numer,valu,leny,rema,overall_len,baseek,\
         digits_in_start;
   digits_in_start = floorl(log(start) / log(basee) + 1);
   baseek = pow(basee,digits_in_start);
   overall_len = (dlog(basee,den,den * baseek - 1) + 3) *\
         digits_in_start;
   auto local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   leny = 0;
   numer = start;
   valu = start;
   for (;;) {
      bcdummy = base_out_fix_print(valu,basee,digits_in_start);
      leny += digits_in_start;
      valu = floorl(numer / den);
      rema = numer % den;
      numer = rema * baseek + valu;
      if (numer == start) {
         break;
      }
      if (2 * overall_len < leny) {
         break; # loop AWAIT
      }
   }
   scale = local_prev_scale;
   return (leny);
}
define eulerphi(nn) {
   return (totient(nn));
}
define znorder__1(bb,mdls) {
   auto nn,pp,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (1 < gcd(bb,mdls)) {
      nn = 0;
   } else {
      pp = 1;
      nn = 1;
      for (;;) {
         pp = (pp * bb) % mdls;
         if (pp == 1) {
            break; # loop AWAIT
         }
         nn += 1;
         if (mdls <= nn) {
            break; # loop AWAIT
         }
      }
   }
   scale = local_prev_scale;
   return (nn);
}
define bkn(bb,kk) {
   return (znorder(bb,kk * bb - 1));
}
define bkbn(bb,kk,cc) {
   auto mdls,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   mdls = kk * bb - 1;
   if (mdls % cc == 0) {
      mdls /= cc;
   }
   scale = local_prev_scale;
   return (znorder(bb,mdls));
}
lv_li_two = 0;
define lix(xx) {
   # local-use Bc lv_li_two;
   if (lv_li_two <= 0) {
      lv_li_two = logintegral(2.0);
   }
   return (logintegral(xx) - lv_li_two);
}
define lixinv(yy) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_dy,\
         scvx_ii,x_init;
   x_init = yy / log(yy);
   scvx_dx = 0.05;
   scvx_xx = x_init;
   scvx_yy = yy - lix(scvx_xx);
   for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
      scvx_xp = scvx_xx;
      scvx_yp = scvx_yy;
      scvx_xx += scvx_dx;
      if (iseq(scvx_xp,scvx_xx)) {
         break;
      }
      scvx_yy = yy - lix(scvx_xx);
      scvx_dy = (scvx_yy - scvx_yp);
      if (iszero(scvx_dy)) {
         break;
      }
      scvx_dx *= - scvx_yy / scvx_dy;
   }
   return (scvx_xx);
}
define n2primish(nn) {
   auto retvalu;
   if (nn < 0) {
      retvalu = -n2primish(-nn);
   } else if (nn == 0) {
      retvalu = 0;
   } else if (nn < 3) {
      retvalu = nn + 1;
   } else if (isodd(nn)) {
      retvalu = 3 * nn - 4;
   } else {
      retvalu = 3 * nn - 5;
   }
   return (retvalu);
}
define primenth__1(nn) {
   auto logn,loglogn,retvalu;
   if (nn < 0) {
      retvalu = 0;
   } else if (nn < 4.25) {
      retvalu = 1.6 * nn + 0.1;
   } else {
      logn = log(nn);
      loglogn = log(logn);
      retvalu = nn * (logn + loglogn - 1.0 + (loglogn - 2.0)\
            / logn - ((loglogn - 6.0) * loglogn + 11.0) /\
            (2.0 * logn * logn)) + 3.5 * sqrt(nn) + 10;
   }
   return (retvalu);
}
define reimann(nn) {
   auto retvalu,sum,sum_prev,ii,lim;
   if (nn < 2) {
      retvalu = 0;
   } else {
      sum = lix(nn);
      lim = 10 * lg(nn);
      ii = 2;
      for (;;) {
         sum_prev = sum;
         sum += mobius(ii) * lix(pow(nn,1.0 / ii)) / ii;
         if (iseq(sum,sum_prev)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (lim <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = sum;
   }
   return (retvalu);
}
define primenth(nn) {
   auto ii,pp,rmndr,inc,prime_arr[];
   if (nn < 5) {
      if (nn < 1) {
         pp = 0;
      } else if (nn < 2) {
         pp = 2;
      } else if (nn < 3) {
         pp = 3;
      } else if (nn < 4) {
         pp = 5;
      } else {
         pp = 7;
      }
   } else {
      if (1024 <= nn) {
         prime_arr[0] = 8161;
         prime_arr[1] = 17863;
         prime_arr[2] = 38873;
         prime_arr[3] = 84017;
         prime_arr[4] = 180503;
         prime_arr[5] = 386093;
         prime_arr[6] = 821641;
         prime_arr[7] = 1742537;
         prime_arr[8] = 3681131;
         prime_arr[9] = 7754077;
         prime_arr[10] = 16290047;
         prime_arr[11] = 34136029;
         prime_arr[12] = 71378569;
         prime_arr[13] = 148948139;
         prime_arr[14] = 310248241;
         prime_arr[15] = 645155197;
         prime_arr[16] = 1339484197;
         prime_arr[17] = 2777105129;
         prime_arr[18] = 5750079047;
         prime_arr[19] = 11891268401;
         prime_arr[20] = 24563311309;
         prime_arr[21] = 50685770167;
         prime_arr[22] = 104484802057;
         ii = floorl(lg(nn + 1) - 10);
         if (22 <= ii) {
            ii = 22;
         }
         pp = prime_arr[ii];
         ii = round(pow(2,ii + 10));
         rmndr = fmodu(pp,6);
         if (iseq(rmndr,5)) {
            inc = 2;
         } else if (iseq(rmndr,1)) {
            inc = 4;
         } else {
            halt;
         }
      } else {
         pp = 11;
         ii = 5;
         inc = 2;
      }
      while (ii < nn) {
         for (;;) {
            pp += inc;
            inc = 6 - inc;
            if (isprime(pp)) {
               break; # loop AWAIT
            }
         }
         ii += 1;
      }
   }
   return (pp);
}
define bessjv(vv,xx) {
   auto sum,sum_prev,term,mm,xxsqr_div_four,avv;
   if (xx < 0.0) {
      sum = 0.0;
   } else {
      avv = vv;
      if (isposint(-vv)) {
         avv = abs(vv);
      }
      xxsqr_div_four = (xx * xx / 4.0);
      term = pow(xx / 2.0,avv) / tgamma(avv + 1.0);
      sum = term;
      mm = 1;
      for (;;) {
         term *= - xxsqr_div_four / (mm * (avv + mm));
         sum_prev = sum;
         sum += term;
         if (iseq(sum,sum_prev)) {
            break; # loop AWAIT
         }
         mm += 1;
      }
      if (isposint(-vv) && isodd(vv)) {
         sum = -sum;
      }
   }
   return (sum);
}
define bessyv(vv,xx) {
   auto retvalu,vvpi;
   if (isint(vv)) {
      retvalu = bessyn(vv,xx);
   } else {
      vvpi = cxpi * vv;
      retvalu = ((cos(vvpi) * bessjv(vv,xx) - bessjv(-vv,\
            xx)) / sin(vvpi));
   }
   return (retvalu);
}
define bessi0(xx) {
   auto yy,retvalu;
   if (xx < 7.75) {
      yy = xx * xx / 4.0;
      retvalu = (((((((((((((((((1.1497640034400735733456400\
            * 10^-29) * yy + (2.0732014503197852176921968 *\
            10^-27)) * yy + (5.9203280572170548134753422 *\
            10^-25)) * yy + (1.3141332422663039834197910 *\
            10^-22)) * yy + (2.5791926805873898803749321 *\
            10^-20)) * yy + (4.3583591008893599099577755 *\
            10^-18)) * yy + (6.2760839879536225394314453 *\
            10^-16)) * yy + (7.5940582595094190098755663 *\
            10^-14)) * yy + (7.5940584360755226536109511 *\
            10^-12)) * yy + (6.1511873265092916275099070 *\
            10^-10)) * yy + (3.9367598891475388547279760 *\
            10^-08)) * yy + (1.9290123456788994104574754 *\
            10^-06)) * yy + (6.9444444444444568581891535 *\
            10^-05)) * yy + (1.7361111111111110294015271 *\
            10^-03)) * yy + (2.7777777777777777805664954 *\
            10^-02)) * yy + (2.4999999999999999999629693 *\
            10^-01)) * yy + (1.0000000000000000000000801 *\
            10^00)) * yy + 1.0;
   } else {
      yy = 1.0 / xx;
      retvalu =\
            (((((((((((((((((((((((\
            1.6069467093441596329340754 * 10^16) * yy -\
            (2.1363029690365351606041265 * 10^16)) * yy +\
            (1.3012646806421079076251950 * 10^16)) * yy -\
            (4.8049082153027457378879746 * 10^15)) * yy +\
            (1.1989242681178569338129044 * 10^15)) * yy -\
            (2.1323049786724612220362154 * 10^14)) * yy +\
            (2.7752144774934763122129261 * 10^13)) * yy -\
            (2.6632742974569782078420204 * 10^12)) * yy +\
            (1.8592340458074104721496236 * 10^11)) * yy -\
            (8.9270060370015930749184222 * 10^09)) * yy +\
            (2.3518420447411254516178388 * 10^08)) * yy +\
            (2.6092888649549172879282592 * 10^06)) * yy -\
            (5.9355022509673600842060002 * 10^05)) * yy +\
            (3.1275740782277570164423916 * 10^04)) * yy -\
            (1.0026890180180668595066918 * 10^03)) * yy +\
            (2.2725199603010833194037016 * 10^01)) * yy -\
            (1.0699095472110916094973951 * 10^-01)) * yy +\
            (9.4085204199017869159183831 * 10^-02)) * yy +\
            (4.4718622769244715693031735 * 10^-02)) * yy +\
            (2.9219501690198775910219311 * 10^-02)) * yy +\
            (2.8050628884163787533196746 * 10^-02)) * yy +\
            (4.9867785050353992900698488 * 10^-02)) * yy +\
            (3.9894228040143265335649948 * 10^-01));
      retvalu *= exp(xx) / sqrt(xx);
   }
   return (retvalu);
}
define bessi1(xx) {
   auto yy,aa,retvalu;
   if (xx < 7.75) {
      yy = xx * xx / 4.0;
      aa = (((((((((((((1.332898928162290861 * 10^-23) * yy +\
            (1.625212890947171108 * 10^-21)) * yy +\
            (3.410720494727771276 * 10^-19)) * yy +\
            (5.220157095351373194 * 10^-17)) * yy +\
            (6.904822652741917551 * 10^-15)) * yy +\
            (7.593969849687574339 * 10^-13)) * yy +\
            (6.834657311305621830 * 10^-11)) * yy +\
            (4.920949692800671435 * 10^-09)) * yy +\
            (2.755731926254790268 * 10^-07)) * yy +\
            (1.157407407354987232 * 10^-05)) * yy +\
            (3.472222222225921045 * 10^-04)) * yy +\
            (6.944444444444341983 * 10^-03)) * yy +\
            (8.333333333333333803 * 10^-02));
      retvalu = ((aa * yy + 0.5) * yy + 1.0) * xx / 2.0;
   } else if (xx < 500.0) {
      yy = 1.0 / xx;
      retvalu = ((((((((((((((((((((((-(2.213318202179221945\
            * 10^15)) * yy + (3.146401654361325073 * 10^15))\
            * yy - (2.067285045778906105 * 10^15)) * yy +\
            (8.325554073334618015 * 10^14)) * yy -\
            (2.298849639457172489 * 10^14)) * yy +\
            (4.614040809616582764 * 10^13)) * yy -\
            (6.967602516005787001 * 10^12)) * yy +\
            (8.087824484994859552 * 10^11)) * yy -\
            (7.313784438967834057 * 10^10)) * yy +\
            (5.192386898222206474 * 10^09)) * yy -\
            (2.903390398236656519 * 10^08)) * yy +\
            (1.277677779341446497 * 10^07)) * yy -\
            (4.404655582443487334 * 10^05)) * yy +\
            (1.178785865993440669 * 10^04)) * yy -\
            (2.426181371595021021 * 10^02)) * yy +\
            (3.458284470977172076 * 10^00)) * yy -\
            (1.528189554374492735 * 10^-01)) * yy -\
            (5.719036414430205390 * 10^-02)) * yy -\
            (4.090895951581637791 * 10^-02)) * yy -\
            (4.675104253598537322 * 10^-02)) * yy -\
            (1.496033551613111533 * 10^-01)) * yy +\
            (3.989422804014406054 * 10^-01)) * exp(xx) /\
            sqrt(xx);
   } else {
      yy = 1.0 / xx;
      aa = exp(xx / 2.0);
      retvalu = (((((-(5.843630344778927582 * 10^-02)) * yy -\
            (4.090421597376992892 * 10^-02)) * yy -\
            (4.675105322571775911 * 10^-02)) * yy -\
            (1.496033551467584157 * 10^-01)) * yy +\
            (3.989422804014314820 * 10^-01)) * aa / sqrt(xx);
      retvalu *= aa;
   }
   return (retvalu);
}
define bessk0(arg) {
   auto retvalu,sumf,sumg,sump,sumq,xx,xz;
   xx = arg;
   if (xx <= 0.0) {
      retvalu = cxdblmax;
   } else if (xx < cxdbleps) {
      retvalu = 0.11593151565841244858684731328185 - log(xx);
   } else if (xx <= 1.0) {
      xz = xx * xx;
      sump = (((((5.8599221412826100000 * 10^-04) * xz +\
            (1.3166052564989571850 * 10^-01)) * xz +\
            (1.1999463724910714109 * 10^01)) * xz +\
            (4.6850901201934832188 * 10^02)) * xz +\
            (5.9169059852270512312 * 10^03)) * xz +\
            (2.4708152720399552679 * 10^03);
      sumq = ((1.0) * xz - (2.4994418972832303646 * 10^02)) *\
            xz + (2.1312714303849120380 * 10^04);
      sumf = (((-(1.6414452837299064100 * 10^00)) * xz -\
            (2.9601657892958843866 * 10^02)) * xz -\
            (1.7733784684952985886 * 10^04)) * xz -\
            (4.0320340761145482298 * 10^05);
      sumg = ((1.0 * xz - (2.5064972445877992730 * 10^02)) *\
            xz + (2.9865713163054025489 * 10^04)) * xz -\
            (1.6128136304458193998 * 10^06);
      retvalu = sump / sumq - log(xx) * (xz * sumf / sumg + 1.0);
   } else if (xx < cxdblmaxln) {
      xz = 1.0 / xx;
      sump = (((((((((1.1394980557384778174 * 10^02) * xz +\
            (3.6832589957340267940 * 10^03)) * xz +\
            (3.1075408980684392399 * 10^04)) * xz +\
            (1.0577068948034021957 * 10^05)) * xz +\
            (1.7398867902565686251 * 10^05)) * xz +\
            (1.5097646353289914539 * 10^05)) * xz +\
            (7.1557062783764037541 * 10^04)) * xz +\
            (1.8321525870183537725 * 10^04)) * xz +\
            (2.3444738764199315021 * 10^03)) * xz +\
            (1.1600249425076035558 * 10^02);
      sumq = ((((((((((1.0) * xz + (2.0013443064949242491 *\
            10^02)) * xz + (4.4329628889746408858 * 10^03)) *\
            xz + (3.1474655750295278825 * 10^04)) * xz +\
            (9.7418829762268075784 * 10^04)) * xz +\
            (1.5144644673520157801 * 10^05)) * xz +\
            (1.2689839587977598727 * 10^05)) * xz +\
            (5.8824616785857027752 * 10^04)) * xz +\
            (1.4847228371802360957 * 10^04)) * xz +\
            (1.8821890840982713696 * 10^03)) * xz +\
            (9.2556599177304839811 * 10^01);
      retvalu = sump / sumq / sqrt(xx) * exp(-xx);
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define bessk1(arg) {
   auto retvalu,sumf,sumg,sump,sumq,xx,xz;
   xx = arg;
   if (xx < cxdbleps) {
      retvalu = cxdblmax;
   } else if (xx < cxdbleps) {
      retvalu = 1.0 / xx;
   } else if (xx <= 1.0) {
      xz = xx * xx;
      sump = (((((4.8127070456878442310 * 10^-1) * xz +\
            (9.9991373567429309922 * 10^1)) * xz +\
            (7.1885382604084798576 * 10^3)) * xz +\
            (1.7733324035147015630 * 10^5)) * xz +\
            (7.1938920065420586101 * 10^5)) * xz -\
            (2.2149374878243304548 * 10^6);
      sumq = (((1.0) * xz - (2.8143915754538725829 * 10^2)) *\
            xz + (3.7264298672067697862 * 10^4)) * xz -\
            (2.2149374878243304548 * 10^6);
      sumf = ((((-(2.2795590826955002390 * 10^-1)) * xz -\
            (5.3103913335180275253 * 10^1)) * xz -\
            (4.5051623763436087023 * 10^3)) * xz -\
            (1.4758069205414222471 * 10^5)) * xz -\
            (1.3531161492785421328 * 10^6);
      sumg = (((1.0) * xz - (3.0507151578787595807 * 10^2)) *\
            xz + (4.3117653211351080007 * 10^4)) * xz -\
            (2.7062322985570842656 * 10^6);
      retvalu = (xz * log(xx) * sumf / sumg + sump / sumq) / xx;
   } else if (xx < cxdblmaxln) {
      xz = 1.0 / xx;
      sump = ((((((((((6.4257745859173138767 * 10^-2) * xz +\
            (7.5584584631176030810 * 10^0)) * xz +\
            (1.3182609918569941308 * 10^2)) * xz +\
            (8.1094256146537402173 * 10^2)) * xz +\
            (2.3123742209168871550 * 10^3)) * xz +\
            (3.4540675585544584407 * 10^3)) * xz +\
            (2.8590657697910288226 * 10^3)) * xz +\
            (1.3319486433183221990 * 10^3)) * xz +\
            (3.4122953486801312910 * 10^2)) * xz +\
            (4.4137176114230414036 * 10^1)) * xz +\
            (2.2196792496874548962 * 10^0);
      sumq = (((((((((1.0) * xz + (3.6001069306861518855 *\
            10^1)) * xz + (3.3031020088765390854 * 10^2)) *\
            xz + (1.2082692316002348638 * 10^3)) * xz +\
            (2.1181000487171943810 * 10^3)) * xz +\
            (1.9448440788918006154 * 10^3)) * xz +\
            (9.6929165726802648634 * 10^2)) * xz +\
            (2.5951223655579051357 * 10^2)) * xz +\
            (3.4552228452758912848 * 10^1)) * xz +\
            (1.7710478032601086579 * 10^0);
      retvalu = sump / sumq / sqrt(xx);
      retvalu = retvalu * exp(-xx);
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define bessjn_ps(nn,xx) {
   auto sum,sum_prev,term,mm,xxsqr_div_four,ann;
   if (nn < 0) {
      ann = -nn;
   } else {
      ann = nn;
   }
   term = pow(xx / 2.0,ann) / factorial(ann);
   xxsqr_div_four = -(xx * xx / 4.0);
   sum = term;
   mm = 1;
   for (;;) {
      term *= xxsqr_div_four / (mm * (ann + mm));
      sum_prev = sum;
      sum += term;
      if (iseq(sum,sum_prev)) {
         break; # loop AWAIT
      }
      mm += 1;
   }
   if (nn < 0 && isodd(nn)) {
      sum = -sum;
   }
   return (sum);
}
define bessin_ps(nn,xx) {
   auto sum,sum_prev,term,mm,xxsqr_div_four,ann;
   if (nn < 0) {
      ann = -nn;
   } else {
      ann = nn;
   }
   term = pow(xx / 2.0,ann) / factorial(ann);
   xxsqr_div_four = xx * xx / 4.0;
   sum = term;
   mm = 1;
   for (;;) {
      term *= xxsqr_div_four / (mm * (ann + mm));
      sum_prev = sum;
      sum += term;
      if (iseq(sum,sum_prev)) {
         break; # loop AWAIT
      }
      mm += 1;
   }
   return (sum);
}
define lf_besucjy0_xge5(xx,jfunc) {
   auto ww,pp,qq,zz,xn,denom,numer;
   ww = 5.0 / xx;
   zz = 25.0 / (xx * xx);
   numer = (((((((7.96936729297347051624 * 10^-4) * zz +\
         (8.28352392107440799803 * 10^-2)) * zz +\
         (1.23953371646414299388 * 10^0)) * zz +\
         (5.44725003058768775090 * 10^0)) * zz +\
         (8.74716500199817011941 * 10^0)) * zz +\
         (5.30324038235394892183 * 10^0)) * zz +\
         (9.99999999999999997821 * 10^-1));
   denom = (((((((9.24408810558863637013 * 10^-4) * zz +\
         (8.56288474354474431428 * 10^-2)) * zz +\
         (1.25352743901058953537 * 10^0)) * zz +\
         (5.47097740330417105182 * 10^0)) * zz +\
         (8.76190883237069594232 * 10^0)) * zz +\
         (5.30605288235394617618 * 10^0)) * zz +\
         (1.00000000000000000218 * 10^0));
   pp = numer / denom;
   numer = ((((((((-(1.13663838898469149931 * 10^-2)) * zz -\
         (1.28252718670509318512 * 10^0)) * zz -\
         (1.95539544257735972385 * 10^1)) * zz -\
         (9.32060152123768231369 * 10^1)) * zz -\
         (1.77681167980488050595 * 10^2)) * zz -\
         (1.47077505154951170175 * 10^2)) * zz -\
         (5.14105326766599330220 * 10^1)) * zz -\
         (6.05014350600728481186 * 10^0));
   denom = ((((((((1.0) * zz + (6.43178256118178023184 *\
         10^1)) * zz + (8.56430025976980587198 * 10^2)) * zz\
         + (3.88240183605401609683 * 10^3)) * zz +\
         (7.24046774195652478189 * 10^3)) * zz +\
         (5.93072701187316984827 * 10^3)) * zz +\
         (2.06209331660327847417 * 10^3)) * zz +\
         (2.42005740240291393179 * 10^2));
   qq = numer / denom;
   xn = xx - cxpi / 4.0;
   if (jfunc < 1) {
      pp = pp * cos(xn) - ww * qq * sin(xn);
   } else {
      pp = pp * sin(xn) + ww * qq * cos(xn);
   }
   return (pp * cxsqrttwo / sqrt(cxpi * xx));
}
define lf_besucjy1_xge5(xx,jfunc) {
   auto ww,pp,qq,zz,xn,denom,numer;
   ww = 5.0 / xx;
   zz = 25.0 / (xx * xx);
   numer = (((((((7.62125616208173112003 * 10^-4) * zz +\
         (7.31397056940917570436 * 10^-2)) * zz +\
         (1.12719608129684925192 * 10^0)) * zz +\
         (5.11207951146807644818 * 10^0)) * zz +\
         (8.42404590141772420927 * 10^0)) * zz +\
         (5.21451598682361504063 * 10^0)) * zz +\
         (1.00000000000000000254 * 10^0));
   denom = (((((((5.71323128072548699714 * 10^-4) * zz +\
         (6.88455908754495404082 * 10^-2)) * zz +\
         (1.10514232634061696926 * 10^0)) * zz +\
         (5.07386386128601488557 * 10^0)) * zz +\
         (8.39985554327604159757 * 10^0)) * zz +\
         (5.20982848682361821619 * 10^0)) * zz +\
         (9.99999999999999997461 * 10^-1));
   pp = numer / denom;
   numer = ((((((((5.10862594750176621635 * 10^-2) * zz +\
         (4.98213872951233449420 * 10^0)) * zz +\
         (7.58238284132545283818 * 10^1)) * zz +\
         (3.66779609360150777800 * 10^2)) * zz +\
         (7.10856304998926107277 * 10^2)) * zz +\
         (5.97489612400613639965 * 10^2)) * zz +\
         (2.11688757100572135698 * 10^2)) * zz +\
         (2.52070205858023719784 * 10^1));
   denom = ((((((((1.0) * zz + (7.42373277035675149943 *\
         10^1)) * zz + (1.05644886038262816351 * 10^3)) * zz\
         + (4.98641058337653607651 * 10^3)) * zz +\
         (9.56231892404756170795 * 10^3)) * zz +\
         (7.99704160447350683650 * 10^3)) * zz +\
         (2.82619278517639096600 * 10^3)) * zz +\
         (3.36093607810698293419 * 10^2));
   qq = numer / denom;
   xn = xx - 3.0 * cxpi / 4.0;
   if (jfunc < 1) {
      pp = pp * cos(xn) - ww * qq * sin(xn);
   } else {
      pp = pp * sin(xn) + ww * qq * cos(xn);
   }
   return (pp * cxsqrttwo / sqrt(cxpi * xx));
}
define bessj0(xx) {
   auto zz,denom,numer,retvalu;
   if (xx < 0.0) {
      xx = -xx;
   }
   zz = xx * xx;
   if (xx < (1.0 * 10^-5)) {
      retvalu = 1.0 - zz / 4.0;
   } else if (xx < 5.0) {
      numer = ((((-(4.79443220978201773821 * 10^9)) * zz +\
            (1.95617491946556577543 * 10^12)) * zz -\
            (2.49248344360967716204 * 10^14)) * zz +\
            (9.70862251047306323952 * 10^15));
      denom = (((((((((1.0) * zz + (4.99563147152651017219 *\
            10^2)) * zz + (1.73785401676374683123 * 10^5)) *\
            zz + (4.84409658339962045305 * 10^7)) * zz +\
            (1.11855537045356834862 * 10^10)) * zz +\
            (2.11277520115489217587 * 10^12)) * zz +\
            (3.10518229857422583814 * 10^14)) * zz +\
            (3.18121955943204943306 * 10^16)) * zz +\
            (1.71086294081043136091 * 10^18));
      retvalu = (zz - 5.783185962946784521175) * (zz -\
            30.4712623436620863991) * numer / denom;
   } else {
      retvalu = lf_besucjy0_xge5(xx,0);
   }
   return (retvalu);
}
define bessj1(xx) {
   auto ww,zz,denom,numer,retvalu;
   ww = xx;
   if (ww < 0.0) {
      ww = -ww;
   }
   if (ww < 5.0) {
      zz = ww * ww;
      numer = ((((-(8.99971225705559398224 * 10^8)) * zz +\
            (4.52228297998194034323 * 10^11)) * zz -\
            (7.27494245221818276015 * 10^13)) * zz +\
            (3.68295732863852883286 * 10^15));
      denom = (((((((((1.0) * zz + (6.20836478118054335476 *\
            10^2)) * zz + (2.56987256757748830383 * 10^5)) *\
            zz + (8.35146791431949253037 * 10^7)) * zz +\
            (2.21511595479792499675 * 10^10)) * zz +\
            (4.74914122079991414898 * 10^12)) * zz +\
            (7.84369607876235854894 * 10^14)) * zz +\
            (8.95222336184627338078 * 10^16)) * zz +\
            (5.32278620332680085395 * 10^18));
      retvalu = numer / denom * xx * (zz -\
            14.6819706421238932572) * (zz -\
            49.2184563216946036703);
   } else {
      retvalu = lf_besucjy1_xge5(xx,0);
   }
   return (retvalu);
}
define bessy0(xx) {
   auto zz,denom,numer,retvalu;
   if (xx <= 0.0) {
      retvalu = cxdblmax;
   } else {
      zz = xx * xx;
      if (xx < (1.0 * 10^-5)) {
         retvalu = 1.0 - zz / 4.0;
      } else if (xx < 5.0) {
         numer = ((((((((1.55924367855235737965 * 10^4) * zz\
               - (1.46639295903971606143 * 10^7)) * zz +\
               (5.43526477051876500413 * 10^9)) * zz -\
               (9.82136065717911466409 * 10^11)) * zz +\
               (8.75906394395366999549 * 10^13)) * zz -\
               (3.46628303384729719441 * 10^15)) * zz +\
               (4.42733268572569800351 * 10^16)) * zz -\
               (1.84950800436986690637 * 10^16));
         denom = ((((((((1.0) * zz + (1.04128353664259848412\
               * 10^3)) * zz + (6.26107330137134956842 *\
               10^5)) * zz + (2.68919633393814121987 * 10^8))\
               * zz + (8.64002487103935000337 * 10^10)) * zz\
               + (2.02979612750105546709 * 10^13)) * zz +\
               (3.17157752842975028269 * 10^15)) * zz +\
               (2.50596256172653059228 * 10^17));
         retvalu = numer / denom + 2.0 * log(xx) * bessj0(xx)\
               / cxpi;
      } else {
         retvalu = lf_besucjy0_xge5(xx,1);
      }
   }
   return (retvalu);
}
define bessy1(xx) {
   auto ww,zz,denom,numer,retvalu;
   ww = xx;
   if (xx <= 0.0) {
      retvalu = -cxdblmax;
   } else if (ww <= 5.0) {
      zz = ww * ww;
      numer = ((((((1.2632047479017802640 * 10^9) * zz -\
            (6.47355876379160291031 * 10^11)) * zz +\
            (1.14509511541823727583 * 10^14)) * zz -\
            (8.12770255501325109621 * 10^15)) * zz +\
            (2.02439475713594898196 * 10^17)) * zz -\
            (7.78877196265950026825 * 10^17));
      denom = (((((((((1.0) * zz + (5.94301592346128195359 *\
            10^2)) * zz + (2.35564092943068577943 * 10^5)) *\
            zz + (7.34811944459721705660 * 10^7)) * zz +\
            (1.87601316108706159478 * 10^10)) * zz +\
            (3.88231277496238566008 * 10^12)) * zz +\
            (6.20557727146953693363 * 10^14)) * zz +\
            (6.87141087355300489866 * 10^16)) * zz +\
            (3.97270608116560655612 * 10^18));
      retvalu = xx * numer / denom + 2.0 * (bessj1(xx) *\
            log(xx) - 1.0 / xx) / cxpi;
   } else {
      retvalu = lf_besucjy1_xge5(xx,1);
   }
   return (retvalu);
}
define lf_bess_ucrecur(nn,xx,fzero,fone) {
   auto av,bv,cv,tox,ii;
   if (nn <= 0) {
      cv = fzero;
   } else if (nn == 1) {
      cv = fone;
   } else {
      tox = 2.0 / xx;
      av = fzero;
      bv = fone;
      for (ii = 1; ii <= nn - 1; ii += 1) {
         cv = tox * ii * bv - av;
         av = bv;
         bv = cv;
      }
   }
   return (cv);
}
define lf_limi(nn) {
   return (nn + floor(sqrt(40.0 * nn)));
}
define lf_bess_ucrecur2(nn,xx) {
   auto tox,bzp,bzc,bzm,sjm,jj,flipflop,limi,retvalu;
   flipflop = 0;
   sjm = 0.0;
   tox = 2.0 / abs(xx);
   retvalu = 0.0;
   bzp = 0.0;
   bzc = 1.0;
   limi = lf_limi(nn);
   if (isodd(limi)) {
      limi -= 1;
   }
   for (jj = limi; 1 <= jj; jj -= 1) {
      bzm = jj * tox * bzc - bzp;
      bzp = bzc;
      bzc = bzm;
      if (flipflop == 0) {
         flipflop = 1;
      } else {
         sjm += bzc;
         flipflop = 0;
      }
      if (jj == nn) {
         retvalu = bzp;
      }
   }
   sjm = 2.0 * sjm - bzc;
   retvalu /= sjm;
   return (retvalu);
}
define bessin(nn,xx) {
   auto jj,limi,bzc,bzm,bzp,tox,retvalu,axx;
   if (nn < 0 || iszero(xx)) {
      retvalu = 0.0;
   } else if (nn == 0) {
      axx = abs(xx);
      retvalu = bessi0(axx);
   } else if (nn == 1) {
      axx = abs(xx);
      retvalu = bessi1(axx);
   } else {
      tox = 2.0 / abs(xx);
      retvalu = 0.0;
      bzp = 0.0;
      bzc = 1.0;
      limi = 2 * lf_limi(nn);
      for (jj = limi; 1 <= jj; jj -= 1) {
         bzm = bzp + jj * tox * bzc;
         bzp = bzc;
         bzc = bzm;
         if (jj == nn) {
            retvalu = bzp;
         }
      }
      retvalu *= bessi0(xx) / bzc;
   }
   if (xx < 0.0 && isodd(nn)) {
      retvalu = -retvalu;
   }
   return (retvalu);
}
define bessjn(nn,xx) {
   auto retvalu;
   if (nn == 0) {
      retvalu = bessj0(xx);
   } else if (nn == 1) {
      retvalu = bessj1(xx);
   } else if (nn < abs(xx)) {
      retvalu = lf_bess_ucrecur(nn,xx,bessj0(xx),bessj1(xx));
   } else {
      retvalu = lf_bess_ucrecur2(nn,xx);
   }
   return (retvalu);
}
define bessyn(nn,xx) {
   auto retvalu;
   if (nn == 0) {
      retvalu = bessy0(xx);
   } else if (nn == 1) {
      retvalu = bessy1(xx);
   } else {
      retvalu = lf_bess_ucrecur(nn,xx,bessy0(xx),bessy1(xx));
   }
   return (retvalu);
}
define besskn(nn,xx) {
   auto retvalu;
   if (nn < 0 || iszero(xx)) {
      retvalu = 0.0;
   } else if (nn == 0) {
      retvalu = bessk0(xx);
   } else if (nn == 1) {
      retvalu = bessk1(xx);
   } else {
      retvalu = lf_bess_ucrecur(nn,xx,bessk0(xx),bessk1(xx));
   }
   return (retvalu);
}
define bessyn_ps(nn,xx) {
   auto retvalu,sum,sum_prev,term,hn,kk,xxsqr_div_four;
   if (nn < 0 || iszero(xx)) {
      retvalu = 0.0;
   } else if (nn == 0) {
      xxsqr_div_four = xx * xx / 4.0;
      sum = (log(xx / 2.0) + cxeuler) * bessjn(0,xx);
      term = -1;
      hn = 0.0;
      kk = 1;
      for (;;) {
         hn += 1.0 / kk;
         term *= - xxsqr_div_four / (kk * kk);
         sum_prev = sum;
         sum += term * hn;
         if (iseq(sum,sum_prev)) {
            break; # loop AWAIT
         }
         kk += 1;
      }
      retvalu = 2.0 * sum / cxpi;
   } else if (nn == 1) {
      retvalu = bessy1(xx);
   } else {
      retvalu = lf_bess_ucrecur(nn,xx,bessy0(xx),bessy1(xx));
   }
   return (retvalu);
}
define bessy1__1(xx) {
   auto numer,denom,zz,ww,yy,retvalu;
   if (iszero(xx)) {
      retvalu = -cxdblmax;
   } else if (xx < 8.0) {
      yy = xx * xx;
      numer = ((((((8.511937935 * 10^3) * yy - (4.237922726 *\
            10^6)) * yy + (7.349264551 * 10^8)) * yy -\
            (5.153438139 * 10^10)) * yy + (1.275274390 *\
            10^12)) * yy - (4.900604943 * 10^12));
      denom = (((((((1.0) * yy + (3.549632885 * 10^2)) * yy +\
            (1.020426050 * 10^5)) * yy + (2.245904002 *\
            10^7)) * yy + (3.733650367 * 10^9)) * yy +\
            (4.244419664 * 10^11)) * yy + (2.499580570 * 10^13));
      retvalu = (xx * (numer / denom) + 2.0 * (bessjn(1,xx)\
            * log(xx) - 1.0 / xx) / cxpi);
   } else {
      zz = 8.0 / xx;
      yy = zz * zz;
      numer = (((((-(2.403370190 * 10^-7)) * yy +\
            (2.457520174 * 10^-6)) * yy - (3.516396496 *\
            10^-5)) * yy + (1.831050000 * 10^-3)) * yy + 1.0);
      denom = (((((1.057874120 * 10^-7) * yy - (8.822898700 *\
            10^-7)) * yy + (8.449199096 * 10^-6)) * yy -\
            (2.002690873 * 10^-4)) * yy + (4.687499995 * 10^-2));
      ww = xx - 0.75 * cxpi;
      retvalu = cxsqrttwo / sqrt(cxpi * xx) * (sin(ww) *\
            numer + zz * cos(ww) * denom);
   }
   return (retvalu);
}
define lf_bess_lcrecur(nn,xx,fzero,fone) {
   auto av,bv,cv,ii;
   if (nn <= 0) {
      cv = fzero;
   } else if (nn == 1) {
      cv = fone;
   } else {
      av = fzero;
      bv = fone;
      for (ii = 1; ii <= nn - 1; ii += 1) {
         cv = (2.0 * ii + 1.0) * bv / xx - av;
         av = bv;
         bv = cv;
      }
   }
   return (cv);
}
define bess_jn(nn,xx) {
   auto retvalu,jk_a,jk_b;
   if (iszero(xx)) {
      if (nn == 0) {
         retvalu = 1.0;
      } else {
         retvalu = 0.0;
      }
   } else {
      jk_a = sin(xx) / xx;
      jk_b = (sin(xx) - xx * cos(xx)) / (xx * xx);
      if (nn <= 0) {
         retvalu = jk_a;
      } else if (nn <= 1) {
         retvalu = jk_b;
      } else {
         retvalu = lf_bess_lcrecur(nn,xx,jk_a,jk_b);
      }
   }
   return (retvalu);
}
define bess_yn(nn,xx) {
   auto retvalu,yk_a,yk_b;
   if (iszero(xx)) {
      if (nn == 0) {
         retvalu = 1.0;
      } else {
         retvalu = 0.0;
      }
   } else {
      yk_a = -cos(xx) / xx;
      yk_b = (-cos(xx) - xx * sin(xx)) / (xx * xx);
      if (nn <= 0) {
         retvalu = yk_a;
      } else if (nn <= 1) {
         retvalu = yk_b;
      } else {
         retvalu = lf_bess_lcrecur(nn,xx,yk_a,yk_b);
      }
   }
   return (retvalu);
}
lv_partitionr_arr[0] = 0;
lv_partitionr_end = 0;
define partition(nn) {
   # local-use Bc lv_partitionr_arr[];
   # local-use Bc lv_partitionr_end;
   auto retvalu,jj,mm,kk,sum,ssign;
   if (nn < 0) {
      retvalu = 0.0;
   } else {
      if (lv_partitionr_end <= 0) {
         lv_partitionr_end = 6;
         lv_partitionr_arr[0] = 1.0;
         lv_partitionr_arr[1] = 1.0;
         lv_partitionr_arr[2] = 2.0;
         lv_partitionr_arr[3] = 3.0;
         lv_partitionr_arr[4] = 5.0;
         lv_partitionr_arr[5] = 7.0;
      }
      if (lv_partitionr_end <= nn) {
         mm = lv_partitionr_end;
         lv_partitionr_end = nn + 1;
         while (mm < lv_partitionr_end) {
            sum = 0.0;
            ssign = 1.0;
            kk = 1;
            jj = mm - 1;
            while (0 <= jj) {
               sum += ssign * lv_partitionr_arr[jj];
               jj -= kk;
               if (jj < 0) {
                  break;
               }
               sum += ssign * lv_partitionr_arr[jj];
               ssign = -ssign;
               kk += 1;
               jj -= (2 * kk - 1);
            }
            lv_partitionr_arr[mm] = sum;
            mm += 1;
         }
      }
      retvalu = lv_partitionr_arr[nn];
   }
   return (retvalu);
}
lv_partitionq_arr[0] = 0;
lv_partitionq_end = 0;
define partitionq(nn) {
   # local-use Bc lv_partitionq_arr[];
   # local-use Bc lv_partitionq_end;
   auto retvalu,jj,mm,kk,sum,ssign,ee;
   if (nn < 0) {
      retvalu = 0.0;
   } else {
      if (lv_partitionq_end <= 0) {
         lv_partitionq_end = 6;
         lv_partitionq_arr[0] = 1.0;
         lv_partitionq_arr[1] = 1.0;
         lv_partitionq_arr[2] = 1.0;
         lv_partitionq_arr[3] = 2.0;
         lv_partitionq_arr[4] = 2.0;
         lv_partitionq_arr[5] = 3.0;
      }
      if (lv_partitionq_end <= nn) {
         mm = lv_partitionq_end;
         lv_partitionq_end = nn + 1;
         while (mm < lv_partitionq_end) {
            sum = 0.0;
            ssign = 1.0;
            kk = 1;
            jj = mm - 1;
            while (0 <= jj) {
               sum += ssign * lv_partitionq_arr[jj];
               jj -= kk;
               if (jj < 0) {
                  break;
               }
               sum += ssign * lv_partitionq_arr[jj];
               ssign = -ssign;
               kk += 1;
               jj -= (2 * kk - 1);
            }
            ee = round(sqrt(1.0 + 12.0 * mm) / 6.0);
            if (mm == (3 * ee * ee - ee) || mm == (3 * ee *\
                  ee + ee)) {
               if (isodd(ee)) {
                  sum -= 1.0;
               } else {
                  sum += 1.0;
               }
            }
            lv_partitionq_arr[mm] = sum;
            mm += 1;
         }
      }
      retvalu = lv_partitionq_arr[nn];
   }
   return (retvalu);
}
define bitwisenot(xx) {
   auto retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   retvalu = -1 - xx;
   scale = local_prev_scale;
   return (retvalu);
}
define bitwiseand(xx,yy) {
   auto retvalu,nn,tt,aa,bb,qxx,qyy,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (xx < 0 && yy < 0) {
      retvalu = (-1 - bitwiseor(-1 - xx,-1 - yy));
   } else {
      nn = 0;
      xx /= 1;
      yy /= 1;
      if (xx < 0) {
         xx = -1 - xx;
         nn = 1;
      }
      if (yy < 0) {
         tt = -1 - yy;
         yy = xx;
         xx = tt;
         nn = 1;
      }
      retvalu = 0;
      tt = 1;
      while (0 < xx || 0 < yy) {
         qxx = xx / 4;
         qyy = yy / 4;
         aa = xx - 4 * qxx;
         if (0 < nn) {
            aa = 3 - aa;
         }
         bb = yy - 4 * qyy;
         if (aa != bb) {
            aa += bb - 3;
            if (aa < 0) {
               aa = 0;
            }
         }
         retvalu += tt * aa;
         tt *= 4;
         xx = qxx;
         yy = qyy;
      }
   }
   scale = local_prev_scale;
   return (retvalu);
}
define bitwiseor(xx,yy) {
   auto retvalu,tt,aa,bb,cc,qxx,qyy,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (xx < 0 || yy < 0) {
      retvalu = (-1 - bitwiseand(-1 - xx,-1 - yy));
   } else {
      xx /= 1;
      yy /= 1;
      retvalu = 0;
      tt = 1;
      while (0 < xx || 0 < yy) {
         qxx = xx / 4;
         qyy = yy / 4;
         aa = xx - 4 * qxx;
         bb = yy - 4 * qyy;
         if (aa != bb) {
            aa += bb;
            if (3 < aa) {
               aa = 3;
            }
         }
         retvalu += tt * aa;
         tt *= 4;
         xx = qxx;
         yy = qyy;
      }
   }
   scale = local_prev_scale;
   return (retvalu);
}
define bitwisexor(xx,yy) {
   auto retvalu,nn,tt,aa,bb,cc,qxx,qyy,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   nn = 0;
   xx /= 1;
   yy /= 1;
   if (xx < 0) {
      xx = -1 - xx;
      nn = 1 - nn;
   }
   if (yy < 0) {
      yy = -1 - yy;
      nn = 1 - nn;
   }
   retvalu = 0;
   tt = 1;
   while (0 < xx || 0 < yy) {
      qxx = xx / 4;
      qyy = yy / 4;
      aa = xx - 4 * qxx;
      bb = yy - 4 * qyy;
      cc = aa + bb;
      if (iseven(cc)) {
         cc = aa + 4 - bb;
      }
      retvalu += tt * (cc % 4);
      tt *= 4;
      xx = qxx;
      yy = qyy;
   }
   if (0 < nn) {
      retvalu = -1 - retvalu;
   }
   scale = local_prev_scale;
   return (retvalu);
}
define bitshiftl(hexnumber,shift_count) {
   auto retvalu;
   if (shift_count < 0) {
      retvalu = lf_shiftr(hexnumber,- shift_count);
   } else if (0 < shift_count) {
      retvalu = lf_shiftl(hexnumber,shift_count);
   } else {
      retvalu = hexnumber;
   }
   return (retvalu);
}
define bitshiftr(hexnumber,shift_count) {
   auto retvalu;
   if (shift_count < 0) {
      retvalu = lf_shiftl(hexnumber,- shift_count);
   } else if (0 < shift_count) {
      retvalu = lf_shiftr(hexnumber,shift_count);
   } else {
      retvalu = hexnumber;
   }
   return (retvalu);
}
define bits_count(hexnumber) {
   auto bit_counter,bitmask;
   bitmask = 1;
   bit_counter = 0;
   while (bitmask <= hexnumber) {
      if (bitwiseand(bitmask,hexnumber) != 0) {
         bit_counter += 1;
      }
      bitmask = lf_shiftl(bitmask,1);
   }
   return (bit_counter);
}
define bits_ls1b(orig) {
   auto divisor,retvalu;
   if (orig == 0) {
      retvalu = 0;
   } else {
      divisor = 1;
      while (0 == bitwiseand(divisor,orig)) {
         divisor *= 2;
      }
      retvalu = divisor;
   }
   return (retvalu);
}
define bits_ms1b(orig) {
   auto divisor,retvalu;
   if (orig == 0) {
      retvalu = 0;
   } else {
      divisor = -2;
      while (bitwiseand(divisor,orig) != 0) {
         divisor *= 2;
      }
      retvalu = -divisor / 2;
   }
   return (retvalu);
}
define bits_ls1bpos(orig) {
   auto divisor,retvalu,bit_count;
   if (orig == 0) {
      retvalu = -1;
   } else {
      divisor = 1;
      bit_count = 0;
      while (0 == bitwiseand(divisor,orig)) {
         divisor *= 2;
         bit_count += 1;
      }
      retvalu = bit_count;
   }
   return (retvalu);
}
define bits_ms1bpos(orig) {
   auto divisor,retvalu,bit_count;
   if (orig == 0) {
      retvalu = 0;
   } else {
      divisor = -2;
      bit_count = 0;
      while (bitwiseand(divisor,orig) != 0) {
         divisor *= 2;
         bit_count += 1;
      }
      retvalu = bit_count;
   }
   return (retvalu);
}
define bits_assign(orig,value_to_set,which_mask) {
   auto divisor,retvalu,tempo,tempv;
   if (which_mask == 0) {
      retvalu = orig;
   } else {
      divisor = bits_ls1bpos(which_mask);
      tempo = bitwiseand(orig,bitwisenot(which_mask));
      tempv = lf_shiftl(value_to_set,divisor);
      retvalu = bitwiseor(tempo,bitwiseand(tempv,which_mask));
   }
   return (retvalu);
}
define bits_get(vall,mask) {
   return (bitwiseand(vall,mask) / bits_ls1b(mask));
}
define bits_set(vall,mask) {
   return (bitwiseand(vall * bits_ls1b(mask),mask));
}
define lf_calerf(xx,jint) {
   auto result,retvalu,absx,numer,denom,rsqrpi,rxsq,\
         xsq,flag;
   absx = abs(xx);
   xsq = xx * xx;
   flag = 0;
   if (absx <= 0.46875) {
      numer = (((((1.85777706184603153 * 10^-1) * xsq +\
            (3.16112374387056560 * 10^0)) * xsq +\
            (1.13864154151050156 * 10^2)) * xsq +\
            (3.77485237685302021 * 10^2)) * xsq +\
            (3.20937758913846947 * 10^3));
      denom = (((((1.0) * xsq + (2.36012909523441209 * 10^1))\
            * xsq + (2.44024637934444173 * 10^2)) * xsq +\
            (1.28261652607737228 * 10^3)) * xsq +\
            (2.84423683343917062 * 10^3));
      retvalu = xx * numer / denom;
      if (jint == 1) {
         retvalu = 1.0 - retvalu;
      } else if (jint == 2) {
         retvalu = exp(xsq) * (1.0 - retvalu);
      }
      flag = 1;
   } else if (absx <= 4.0) {
      numer = (((((((((2.15311535474403846 * 10^-8) * absx +\
            (5.64188496988670089 * 10^-1)) * absx +\
            (8.88314979438837594 * 10^0)) * absx +\
            (6.61191906371416295 * 10^1)) * absx +\
            (2.98635138197400131 * 10^2)) * absx +\
            (8.81952221241769090 * 10^2)) * absx +\
            (1.71204761263407058 * 10^3)) * absx +\
            (2.05107837782607147 * 10^3)) * absx +\
            (1.23033935479799725 * 10^3));
      denom = (((((((((1.0) * absx + (1.57449261107098347 *\
            10^1)) * absx + (1.17693950891312499 * 10^2)) *\
            absx + (5.37181101862009858 * 10^2)) * absx +\
            (1.62138957456669019 * 10^3)) * absx +\
            (3.29079923573345963 * 10^3)) * absx +\
            (4.36261909014324716 * 10^3)) * absx +\
            (3.43936767414372164 * 10^3)) * absx +\
            (1.23033935480374942 * 10^3));
      result = numer / denom;
   } else {
      rsqrpi = sqrt(1.0 / cxpi);
      if (jint != 2 && sqrt(log(cxdblmax)) <= absx) {
         result = 0.0;
      } else if (jint == 2 && (6.71 * 10^7) <= absx) {
         if (cxdblmax / 8.0 <= absx) {
            result = 0.0;
         } else {
            result = rsqrpi / absx;
         }
      } else {
         rxsq = 1.0 / (absx * absx);
         numer = ((((((-(1.63153871373020978 * 10^2)) * rxsq\
               - (3.05326634961232344 * 10^3)) * rxsq -\
               (3.60344899949804439 * 10^3)) * rxsq -\
               (1.25781726111229246 * 10^3)) * rxsq -\
               (1.60837851487422766 * 10^2)) * rxsq -\
               (6.58749161529837803 * 10^0));
         denom = ((((((1.0 * 10^4) * rxsq +\
               (2.56852019228982242 * 10^4)) * rxsq +\
               (1.87295284992346047 * 10^4)) * rxsq +\
               (5.27905102951428412 * 10^3)) * rxsq +\
               (6.05183413124413191 * 10^2)) * rxsq +\
               (2.33520497626869185 * 10^1));
         result = (rsqrpi + rxsq * numer / denom) / absx;
      }
   }
   if (flag == 0) {
      if (jint == 2) {
         if (xx < - sqrt(log(cxdblmax))) {
            retvalu = cxdblmax;
         } else if (xx < 0.0) {
            retvalu = 2.0 * exp(xsq) - result;
         } else {
            retvalu = result;
         }
      } else {
         result *= exp(-xsq);
         if (jint == 0) {
            if (0.0 <= xx) {
               retvalu = (0.5 - result) + 0.5;
            } else {
               retvalu = -((0.5 - result) + 0.5);
            }
         } else if (jint == 1) {
            if (xx < 0.0) {
               retvalu = 2.0 - result;
            } else {
               retvalu = result;
            }
         } else {
            retvalu = 0.0;
         }
      }
   }
   return (retvalu);
}
define erf(xx) {
   return (lf_calerf(xx,0));
}
define erfc(xx) {
   return (lf_calerf(xx,1));
}
define erfcx(xx) {
   return (lf_calerf(xx,2));
}
define erfcinv(yy_orig) {
   auto retvalu,xx,yy,xx_pr,dx,cc,uu,ii;
   if (yy_orig <= 0.0) {
      retvalu = cxdblmax / 2.0;
   } else if (2.0 <= yy_orig) {
      retvalu = -(cxdblmax / 2.0);
   } else if (iszero(yy_orig - 1.0)) {
      retvalu = 0.0;
   } else {
      if (1.0 < yy_orig) {
         yy = 2.0 - yy_orig;
      } else {
         yy = yy_orig;
      }
      dx = 1.0;
      xx = 0.0;
      cc = -sqrt(cxtau / 8.0);
      ii = 0;
      for (;;) {
         uu = cc * (erfcx(xx) - yy * exp(xx * xx));
         dx = -uu / (1.0 + uu * xx);
         xx_pr = xx;
         xx += dx;
         if (iseq(xx_pr,xx)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      if (1.0 < yy_orig) {
         retvalu = -xx;
      } else {
         retvalu = xx;
      }
   }
   return (retvalu);
}
define erfcxinv(yy) {
   auto xx,xx_pr,dx,cc,ex,df,uu,ii;
   xx = 0.0;
   if (! iszero(yy - 1.0)) {
      dx = 1.0;
      cc = sqrt(8.0 / cxtau);
      ii = 0;
      for (;;) {
         ex = erfcx(xx);
         df = 2.0 * xx * ex - cc;
         uu = (ex - yy) / df;
         dx = -uu / (1.0 - uu * (xx + ex / df));
         xx_pr = xx;
         xx += dx;
         if (iseq(xx_pr,xx)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
   }
   return (xx);
}
define erfinv(yy) {
   auto retvalu,xx,xx_pr,dx,cc,uu,ii;
   if (iszero(yy)) {
      retvalu = 0.0;
   } else if (0.5 < yy) {
      retvalu = erfcinv(1.0 - yy);
   } else if (yy < - 0.5) {
      retvalu = -erfcinv(1.0 + yy);
   } else {
      dx = 1.0;
      xx = 0.0;
      cc = sqrt(cxtau / 8.0);
      ii = 0;
      for (;;) {
         uu = cc * (erf(xx) - yy) * exp(xx * xx);
         dx = -uu / (1.0 + uu * xx);
         xx_pr = xx;
         xx += dx;
         if (iseq(xx_pr,xx)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xx;
   }
   return (retvalu);
}
define erf__1(xx) {
   auto tt,ans,ply;
   tt = (1.0 / (1.0 + (0.5 * abs(xx))));
   ply = ((((((((((1.70872770 * 10^-1) * tt - (8.22152230 *\
         10^-1)) * tt + (1.48851587 * 10^0)) * tt -\
         (1.13520398 * 10^0)) * tt + (2.78868070 * 10^-1)) *\
         tt - (1.86288060 * 10^-1)) * tt + (9.67841800 *\
         10^-2)) * tt + (3.74091960 * 10^-1)) * tt +\
         (1.00002368 * 10^0)) * tt - (1.26551223 * 10^0));
   ans = 1.0 - tt * exp((-xx * xx) + ply);
   if (xx < 0.0) {
      ans = -ans;
   }
   return (ans);
}
define erf__2(xx) {
   auto tt,ans,ply;
   tt = 1.0 / (1.0 + 0.3275911 * abs(xx));
   ply = ((((((1.061405429 * 10^0) * tt - (1.453152027 *\
         10^0)) * tt + (1.421413741 * 10^0)) * tt -\
         (2.844967360 * 10^-1)) * tt + (2.548295920 * 10^-1))\
         * tt + (0.000000000 * 10^0));
   ans = 1.0 - exp(-xx * xx) * ply;
   if (xx < 0.0) {
      ans = -ans;
   }
   return (ans);
}
define erf__3(xx) {
   auto axx,xxsq,sum_curr,factx,nn,add_arr[],kk;
   axx = abs(xx);
   xxsq = xx * xx;
   if (axx < 4.4) {
      factx = 1.0;
      add_arr[0] = 1;
      nn = 1;
      for (;;) {
         factx *= - xxsq / nn;
         add_arr[nn] = factx / (2.0 * nn + 1.0);
         if (abs(add_arr[nn]) < cxdbleps) {
            break; # loop AWAIT
         }
         nn += 1;
         if (79 <= nn) {
            break; # loop AWAIT
         }
      }
      sum_curr = 0.0;
      for (kk = nn; 0 <= kk; kk -= 1) {
         sum_curr += add_arr[kk];
      }
      sum_curr *= (2.0 * xx / sqrt(cxpi));
   } else {
      factx = -exp(-xxsq) / sqrt(cxpi);
      sum_curr = 0.0;
      kk = round(xxsq);
      for (nn = 1; nn <= kk - 1; nn += 1) {
         factx *= -(2.0 * nn - 1.0) / (2.0 * xxsq);
         sum_curr += factx;
      }
      sum_curr += 1.0 - exp(-xxsq) / sqrt(cxpi) / axx;
      if (xx < 0.0) {
         sum_curr = -sum_curr;
      }
   }
   return (sum_curr);
}
define erf__4(xx) {
   auto xxsq,axx,sum_prev,sum_curr,nn,kk,twonnpone,\
         factx,factz,twoxxsq,term;
   axx = abs(xx);
   xxsq = xx * xx;
   twoxxsq = 2.0 * xxsq;
   sum_curr = 0.0;
   if (axx < 4.4) {
      factz = (2.0 * xx / sqrt(cxpi));
      factx = factz;
      nn = 3;
      for (;;) {
         twonnpone = 2 * nn + 1;
         factx *= xxsq * xxsq / ((nn - 1.0) * nn);
         term = (factx * (twonnpone * (nn - xxsq) + twoxxsq)\
               / (4.0 * nn * nn - 1.0));
         sum_prev = sum_curr;
         sum_curr += term;
         if (iseq(sum_prev,sum_curr)) {
            break; # loop AWAIT
         }
         nn += 2;
      }
      sum_curr += (1.0 - xxsq / 3.0) * factz;
   } else {
      factx = -exp(-xxsq) / (xx * sqrt(cxpi));
      kk = round(xxsq);
      for (nn = 1; nn <= kk - 5; nn += 2) {
         factx *= nn * (nn + 1.0) / (twoxxsq * twoxxsq);
         term = factx * (1.0 - (2.0 * nn + 1.0) / twoxxsq);
         sum_prev = sum_curr;
         sum_curr += term;
         if (iseq(sum_prev,sum_curr)) {
            break;
         }
      }
      sum_curr += 1.0 - exp(-xxsq) / sqrt(cxpi) / axx;
      if (xx < 0.0) {
         sum_curr = -sum_curr;
      }
   }
   return (sum_curr);
}
define lgamma__1(xx) {
   auto aa_arr[],sum,ii,tt,retvalu,qq;
   if (xx <= 0.0 && isint(xx)) {
      retvalu = log(cxdblmax);
   } else {
      if (xx < 0.0) {
         qq = 1.0 - xx;
      } else {
         qq = xx;
      }
      aa_arr[0] = (5.7156235665862923517 * 10^1);
      aa_arr[1] = -(5.9597960355475491248 * 10^1);
      aa_arr[2] = (1.4136097974741747174 * 10^1);
      aa_arr[3] = -(4.9191381609762019978 * 10^-1);
      aa_arr[4] = (3.3994649984811888699 * 10^-5);
      aa_arr[5] = (4.6523628927048575665 * 10^-5);
      aa_arr[6] = -(9.8374475304879564677 * 10^-5);
      aa_arr[7] = (1.5808870322491248884 * 10^-4);
      aa_arr[8] = -(2.1026444172410488319 * 10^-4);
      aa_arr[9] = (2.1743961811521264320 * 10^-4);
      aa_arr[10] = -(1.6431810653676389022 * 10^-4);
      aa_arr[11] = (8.4418223983852743293 * 10^-5);
      aa_arr[12] = -(2.6190838401581408670 * 10^-5);
      aa_arr[13] = (3.6899182659531622704 * 10^-6);
      sum = 0.99999999999999709182;
      for (ii = 0; ii <= 13; ii += 1) {
         sum += aa_arr[ii] / (qq + ii);
      }
      tt = qq + 607.0 / 128.0 - 0.5;
      qq = log(cxtau) / 2.0 + (qq - 0.5) * log(tt) + log(sum)\
            - tt;
      if (xx < 0.0) {
         retvalu = log(cxpi / abs(sin(2.0 * cxtau * xx))) - qq;
      } else {
         retvalu = qq;
      }
   }
   return (retvalu);
}
define lgammainv(yy) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_dy,\
         scvx_ii,yy_fixed,xx_init;
   yy_fixed = yy / cxpi + log(yy + 0.5);
   xx_init = yy_fixed + cxpi - 0.5;
   scvx_dx = 0.01;
   scvx_xx = xx_init;
   scvx_yy = yy - lgamma(scvx_xx);
   for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
      scvx_xp = scvx_xx;
      scvx_yp = scvx_yy;
      scvx_xx += scvx_dx;
      if (iseq(scvx_xp,scvx_xx)) {
         break;
      }
      scvx_yy = yy - lgamma(scvx_xx);
      scvx_dy = (scvx_yy - scvx_yp);
      if (iszero(scvx_dy)) {
         break;
      }
      scvx_dx *= - scvx_yy / scvx_dy;
   }
   return (scvx_xx);
}
define lf_lgamma_gt_zero(xx) {
   auto retvalu,zz,pp,uu,denom,numer;
   if (xx < 13.0) {
      zz = 1.0;
      pp = 0.0;
      uu = xx;
      while (3.0 <= uu) {
         pp -= 1.0;
         uu = xx + pp;
         zz *= uu;
      }
      while (uu < 2.0) {
         zz /= uu;
         pp += 1.0;
         uu = xx + pp;
      }
      if (zz < 0.0) {
         zz = -zz;
      }
      if (iseq(uu,2.0)) {
         retvalu = log(zz);
      } else {
         pp -= 2.0;
         xx += pp;
         numer = ((((((-(1.37825152569120859100 * 10^3)) * xx\
               - (3.88016315134637840924 * 10^4)) * xx -\
               (3.31612992738871184744 * 10^5)) * xx -\
               (1.16237097492762307383 * 10^6)) * xx -\
               (1.72173700820839662146 * 10^6)) * xx -\
               (8.53555664245765465627 * 10^5));
         denom = (((((((1.0) * xx - (3.51815701436523470549 *\
               10^2)) * xx - (1.70642106651881159223 * 10^4))\
               * xx - (2.20528590553854454839 * 10^5)) * xx -\
               (1.13933444367982507207 * 10^6)) * xx -\
               (2.53252307177582951285 * 10^6)) * xx -\
               (2.01889141433532773231 * 10^6));
         retvalu = log(zz) + xx * numer / denom;
      }
   } else {
      uu = (xx - 0.5) * log(xx) - xx + log(sqrt(cxtau));
      if ((1.0 * 10^8) < xx) {
         retvalu = uu;
      } else {
         pp = 1.0 / (xx * xx);
         if (1000.0 < xx) {
            zz = (((7.9365079365079365079365 * 10^-4) * pp -\
                  (2.7777777777777777777778 * 10^-3)) * pp +\
                  (8.3333333333333333333333 * 10^-2));
         } else {
            zz = (((((8.11614167470508450300 * 10^-4) * pp -\
                  (5.95061904284301438324 * 10^-4)) * pp +\
                  (7.93650340457716943945 * 10^-4)) * pp -\
                  (2.77777777300996872050 * 10^-3)) * pp +\
                  (8.33333333333331927722 * 10^-2));
         }
         retvalu = uu + zz / xx;
      }
   }
   return (retvalu);
}
define lgamma(zz) {
   auto retvalu;
   if (zz <= 0.0) {
      if (isint(zz)) {
         retvalu = log(cxdblmax);
      } else {
         retvalu = (log(cxpi / abs(sin(2.0 * cxtau * zz))) -\
               lf_lgamma_gt_zero(1.0 - zz));
      }
   } else {
      retvalu = lf_lgamma_gt_zero(zz);
   }
   return (retvalu);
}
define lf_eval_cont(xx,deg,*coeff_arr_pc[]) {
   auto sum,ii;
   sum = xx;
   for (ii = deg; 0 <= ii; ii -= 1) {
      sum = xx + coeff_arr_pc[ii] / sum;
   }
   return (sum);
}
define lgamma__2(zz) {
   auto retvalu,aa_arr[],sum;
   if (zz <= 0.0) {
      if (isint(zz)) {
         retvalu = log(cxdblmax);
      } else {
         retvalu = (log(cxpi / abs(sin(2.0 * cxtau * zz))) -\
               lgamma(1.0 - zz));
      }
   } else {
      aa_arr[0] = 1.0 / 12.0;
      aa_arr[1] = 1.0 / 30.0;
      aa_arr[2] = 53.0 / 210.0;
      aa_arr[3] = 195.0 / 371.0;
      aa_arr[4] = 229999.0 / 22737.0;
      aa_arr[5] = 29944523.0 / 19733142.0;
      aa_arr[6] = 109535241009.0 / 48264275462.0;
      aa_arr[7] = 29404527905795295658.0 /\
            9769214287853155785.0;
      aa_arr[8] = 455377030420113432210116914702.0 /\
            113084128923675014537885725485.0;
      sum = 0.0;
      while (zz <= 6.0) {
         sum += log(zz);
         zz += 1.0;
      }
      sum -= lf_eval_cont(zz,8,aa_arr[]);
      retvalu = (log(cxtau) / 2.0 + (zz - 0.5) * log(zz) -\
            2.0 * zz - sum);
   }
   return (retvalu);
}
define lpermx(nn,rr) {
   return (lgamma(nn + 1.0) - lgamma(nn - rr + 1.0));
}
define permx(nn,rr) {
   return (exp(lpermx(nn,rr)));
}
define lcombx(nn,rr) {
   return (lpermx(nn,rr) - lgamma(rr + 1.0));
}
define combx(nn,rr) {
   return (exp(lcombx(nn,rr)));
}
define birthdayx(nn,rr) {
   return (exp(lpermx(nn,rr) - log(nn) * rr));
}
define tgamma__1(xx) {
   auto zz,rslt,denom,numer;
   if (isposint(1.0 - xx)) {
      rslt = cxdblmax;
   } else {
      zz = 1.0;
      while (3.0 <= xx) {
         xx -= 1.0;
         zz *= xx;
      }
      while (xx < 2.0) {
         if (abs(xx) < (1.0 * 10^-9)) {
            break;
         }
         zz /= xx;
         xx += 1.0;
      }
      if (iseq(xx,0.0)) {
         rslt = cxdblmax;
      } else if (xx < 2.0) {
         rslt = zz / ((1.0 + cxeuler * xx) * xx);
      } else if (iseq(xx,2.0)) {
         rslt = zz;
      } else {
         xx -= 2.0;
         numer = (((((((1.60119522476751861407 * 10^-04) * xx\
               + (1.19135147006586384913 * 10^-03)) * xx +\
               (1.04213797561761569935 * 10^-02)) * xx +\
               (4.76367800457137231464 * 10^-02)) * xx +\
               (2.07448227648435975150 * 10^-01)) * xx +\
               (4.94214826801497100753 * 10^-01)) * xx +\
               (9.99999999999999996796 * 10^-01));
         denom = ((((((((-(2.31581873324120129819 * 10^-05))\
               * xx + (5.39605580493303397842 * 10^-04)) * xx\
               - (4.45641913851797240494 * 10^-03)) * xx +\
               (1.18139785222060435552 * 10^-02)) * xx +\
               (3.58236398605498653373 * 10^-02)) * xx -\
               (2.34591795718243348568 * 10^-01)) * xx +\
               (7.14304917030273074085 * 10^-02)) * xx +\
               (1.00000000000000000320 * 10^00));
         rslt = zz * numer / denom;
      }
   }
   return (rslt);
}
define tgamma(xx) {
   auto retvalu,tmp;
   if (xx < 0.0) {
      if (isint(xx)) {
         retvalu = cxdblmax;
      } else {
         tmp = exp(lgamma(1.0 - xx));
         retvalu = cxpi / (sin(cxpi * xx) * tmp);
      }
   } else {
      retvalu = exp(lgamma(xx));
   }
   return (retvalu);
}
define tgammainv(yy) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_dy,\
         scvx_ii,kk,cc,pp,xx_init;
   kk = cxgammamin;
   cc = sqrt(cxtau) / cxe - tgamma(kk);
   pp = log((yy + cc) / sqrt(cxtau));
   xx_init = pp / wp(pp / cxe) + 0.5;
   scvx_dx = 0.01;
   scvx_xx = xx_init;
   scvx_yy = yy - tgamma(scvx_xx);
   for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
      scvx_xp = scvx_xx;
      scvx_yp = scvx_yy;
      scvx_xx += scvx_dx;
      if (iseq(scvx_xp,scvx_xx)) {
         break;
      }
      scvx_yy = yy - tgamma(scvx_xx);
      scvx_dy = (scvx_yy - scvx_yp);
      if (iszero(scvx_dy)) {
         break;
      }
      scvx_dx *= - scvx_yy / scvx_dy;
   }
   return (scvx_xx);
}
define lf_gamma_shift(xx,yy) {
   auto prod;
   if (isposint(1.0 - yy)) {
      prod = cxdblmax;
   } else {
      prod = 1.0;
      while (yy < xx - 0.0001) {
         prod *= yy;
         yy += 1.0;
      }
      while (xx + 0.0001 < yy) {
         yy -= 1.0;
         prod /= yy;
      }
   }
   return (prod);
}
define lf_tgamma_gt_half(xx) {
   auto ii,sum,yy,pp_arr[];
   yy = xx - floor(xx) + 1.0;
   pp_arr[0] = (5.716400188274341379136 * 10^3);
   pp_arr[1] = -(1.481530426768413909044 * 10^4);
   pp_arr[2] = (1.429149277657478554025 * 10^4);
   pp_arr[3] = -(6.348160217641458813289 * 10^3);
   pp_arr[4] = (1.301608286058321874105 * 10^3);
   pp_arr[5] = -(1.081767053514369634679 * 10^2);
   pp_arr[6] = (2.605696505611755827729 * 10^0);
   pp_arr[7] = -(7.423452510201416151527 * 10^-3);
   pp_arr[8] = (5.384136432509564062961 * 10^-8);
   pp_arr[9] = -(4.023533141268236372067 * 10^-9);
   sum = 1.000000000000000174663;
   for (ii = 0; ii <= 9; ii += 1) {
      sum += pp_arr[ii] / (yy + ii);
   }
   return ((sqrt(cxtau) * sum * exp(log(yy + 8.5) * (yy -\
         0.5) - yy - 8.5) * lf_gamma_shift(xx,yy)));
}
define tgamma__2(xx) {
   auto ii,sum,pp_arr[],yy,rslt;
   if (isposint(1.0 - xx)) {
      rslt = cxdblmax;
   } else {
      yy = xx - floor(xx) + 2.0;
      pp_arr[0] = (7.61800917294715 * 10^1);
      pp_arr[1] = -(8.65053203294168 * 10^1);
      pp_arr[2] = (2.40140982408309 * 10^1);
      pp_arr[3] = -(1.23173957245015 * 10^0);
      pp_arr[4] = (1.20865097386618 * 10^-3);
      pp_arr[5] = -(5.395239384953 * 10^-6);
      sum = (1.00000000019001 * 10^0);
      for (ii = 0; ii <= 5; ii += 1) {
         sum += pp_arr[ii] / (yy + ii);
      }
      rslt = (sqrt(cxtau) * sum * exp(log(yy + 4.5) * (yy -\
            0.5) - yy - 4.5) * lf_gamma_shift(xx,yy));
   }
   return (rslt);
}
define tgamma__3(xx) {
   auto retvalu;
   if (isposint(1.0 - xx)) {
      retvalu = cxdblmax;
   } else if (xx < 0.5) {
      retvalu = (cxpi / sin(cxpi * xx) /\
            lf_tgamma_gt_half(1.0 - xx));
   } else {
      retvalu = lf_tgamma_gt_half(xx);
   }
   return (retvalu);
}
define tgamma__stirling(xx) {
   auto yy,ryy,sc,ply;
   sc = 1.0;
   while (xx < 10.0) {
      sc /= xx;
      xx += 1.0;
   }
   yy = xx - 1.0;
   ryy = 1.0 / yy;
   ply = (((((((-5246819.0 / 75246796800.0) * ryy + 163879.0\
         / 209018880.0) * ryy - 571.0 / 2488320.0) * ryy -\
         139.0 / 51840) * ryy + 1.0 / 288.0) * ryy + 1.0 /\
         12.0) * ryy + 1.0);
   return (sc * pow(yy / cxe,yy) * sqrt(cxtau * yy) * ply);
}
define tgammadouble(xx) {
   auto xxh;
   xxh = (xx - 1.0) / 2.0;
   return (pow(2.0,xxh) * pow(2.0 / cxpi,(1.0 - cos(cxtau *\
         xxh)) / 4.0) * tgamma(xxh + 1.0));
}
define lf_ligamma_xxleaa(aa,xx) {
   auto kk,rr,sum_curr,sum_prev;
   sum_curr = exp(aa * log(xx) - xx) / aa;
   rr = sum_curr;
   for (kk = 1; kk <= 100; kk += 1) {
      rr *= xx / (aa + kk);
      sum_prev = sum_curr;
      sum_curr += rr;
      if (iseq(sum_prev,sum_curr)) {
         break;
      }
   }
   return (sum_curr);
}
define lf_uigamma_aalexx(aa,xx) {
   auto jj,pp,ipp,sum_curr,tt;
   sum_curr = 0.0;
   pp = 47.0 / sqrt(xx - 0.75);
   ipp = floor(pp);
   for (jj = ipp; 1 <= jj; jj -= 1) {
      tt = xx + sum_curr;
      sum_curr = (jj - aa) * tt / (tt + jj);
   }
   return (exp(aa * log(xx) - xx) / (xx + sum_curr));
}
define ligamma(aa,xx) {
   auto retvalu;
   if (xx <= 0.0) {
      retvalu = 0.0;
   } else if (aa <= 0.0) {
      retvalu = cxdblmax;
   } else if (xx <= 1.1 || xx <= aa) {
      retvalu = lf_ligamma_xxleaa(aa,xx);
   } else {
      retvalu = tgamma(aa) - lf_uigamma_aalexx(aa,xx);
   }
   return (retvalu);
}
define uigamma(aa,xx) {
   auto retvalu;
   if (aa <= 0.0) {
      retvalu = cxdblmax;
   } else if (xx <= 0.0) {
      retvalu = tgamma(aa);
   } else if (xx <= 1.1 || xx <= aa) {
      retvalu = tgamma(aa) - lf_ligamma_xxleaa(aa,xx);
   } else {
      retvalu = lf_uigamma_aalexx(aa,xx);
   }
   return (retvalu);
}
define rligamma(aa,xx) {
   auto retvalu;
   if (xx <= 0.0) {
      retvalu = 0.0;
   } else if (aa <= 0.0) {
      retvalu = cxdblmax;
   } else {
      retvalu = ligamma(aa,xx) / tgamma(aa);
   }
   return (retvalu);
}
define ruigamma(aa,xx) {
   auto retvalu;
   if (aa <= 0.0) {
      retvalu = cxdblmax;
   } else if (xx <= 0.0) {
      retvalu = 1.0;
   } else {
      retvalu = uigamma(aa,xx) / tgamma(aa);
   }
   return (retvalu);
}
define uigamma__1(aa,xx) {
   auto ans,ax,cc,yc,rr,tt,yy,zz,pk,pkma,pkmb,qk,\
         qkma,qkmb,retvalu;
   if (xx <= 0.0 || aa <= 0.0) {
      retvalu = 1.0;
   } else {
      ax = aa * log(xx) - xx - lgamma(aa);
      if (ax < - cxdblmaxln) {
         retvalu = 0.0;
      } else {
         ax = exp(ax);
         if (xx < 1.0 || xx < aa) {
            rr = aa;
            cc = 1.0;
            ans = 1.0;
            for (;;) {
               rr += 1.0;
               cc *= xx / rr;
               ans += cc;
               if (cc / ans < cxdbleps) {
                  break; # loop AWAIT
               }
            }
            retvalu = 1.0 - ans * ax / aa;
         } else {
            yy = 1.0 - aa;
            zz = xx + yy + 1.0;
            cc = 0.0;
            pkmb = 1.0;
            qkmb = xx;
            pkma = xx + 1.0;
            qkma = zz * xx;
            ans = pkma / qkma;
            for (;;) {
               cc += 1.0;
               yy += 1.0;
               zz += 2.0;
               yc = yy * cc;
               pk = pkma * zz - pkmb * yc;
               qk = qkma * zz - qkmb * yc;
               if (! iszero(qk)) {
                  rr = pk / qk;
                  tt = abs((ans - rr) / rr);
                  ans = rr;
               } else {
                  tt = 1.0;
               }
               pkmb = pkma;
               pkma = pk;
               qkmb = qkma;
               qkma = qk;
               if (1.0 / cxdbleps < abs(pk)) {
                  pkmb *= cxdbleps;
                  pkma *= cxdbleps;
                  qkmb *= cxdbleps;
                  qkma *= cxdbleps;
               }
               if (tt <= cxdbleps) {
                  break; # loop AWAIT
               }
            }
            retvalu = ans * ax;
         }
      }
   }
   return (retvalu);
}
define uigammainv(aa,yy) {
   auto dd,tt,xx,scvx_xp,scvx_xx,scvx_yp,scvx_yy,\
         scvx_dx,scvx_dy,scvx_ii;
   dd = 1.0 / (9.0 * aa);
   tt = 1.0 - dd - gau_quantile(yy) * sqrt(dd);
   xx = aa * pow(tt,3);
   scvx_dx = 0.1;
   scvx_xx = xx;
   scvx_yy = yy - uigamma(aa,scvx_xx);
   for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
      scvx_xp = scvx_xx;
      scvx_yp = scvx_yy;
      scvx_xx += scvx_dx;
      if (iseq(scvx_xp,scvx_xx)) {
         break;
      }
      scvx_yy = yy - uigamma(aa,scvx_xx);
      scvx_dy = (scvx_yy - scvx_yp);
      if (iszero(scvx_dy)) {
         break;
      }
      scvx_dx *= - scvx_yy / scvx_dy;
   }
   return (scvx_xx);
}
define ligammainv(aa,yy) {
   return (uigammainv(aa,1.0 - yy));
}
define lbeta(aa,bb) {
   return (lgamma(aa) + lgamma(bb) - lgamma(aa + bb));
}
define beta(aa,bb) {
   auto retvalu,lbe;
   lbe = lbeta(aa,bb);
   if (cxdblmaxln < lbe) {
      retvalu = cxdblmax;
   } else if (- cxdblmaxln < lbe) {
      retvalu = exp(lbe);
   } else {
      retvalu = -cxdblmax;
   }
   return (retvalu);
}
define betainc(aa,bb,xx) {
   auto sum_curr,sum_prev,psq,compx,new_xx,pp,qq,term,\
         ai,rx,temp,log_beta,retvalu,indx,ns;
   if (aa <= 0.0 || bb <= 0.0 || 1.0 <= xx) {
      retvalu = 1.0;
   } else if (xx <= 0.0) {
      retvalu = 0.0;
   } else {
      psq = aa + bb;
      if (aa < psq * xx) {
         new_xx = 1.0 - xx;
         compx = xx;
         pp = bb;
         qq = aa;
         indx = 0;
      } else {
         new_xx = xx;
         compx = 1.0 - xx;
         pp = aa;
         qq = bb;
         indx = 1;
      }
      term = 1.0;
      sum_curr = 1.0;
      ai = 1.0;
      ns = floor(qq + compx * psq);
      rx = new_xx / compx;
      temp = qq - ai;
      if (ns == 0) {
         rx = new_xx;
      }
      for (;;) {
         term *= temp * rx / (pp + ai);
         ai += 1.0;
         ns -= 1;
         if (0 <= ns) {
            temp = qq - ai;
            if (ns == 0) {
               rx = new_xx;
            }
         } else {
            temp = psq;
            psq += 1.0;
         }
         sum_prev = sum_curr;
         sum_curr += term;
         if (iseq(sum_curr,sum_prev)) {
            break; # loop AWAIT
         }
      }
      log_beta = lgamma(aa) + lgamma(bb) - lgamma(aa + bb);
      retvalu = sum_curr * exp(pp * log(new_xx) + (qq - 1.0)\
            * log(compx) - log_beta) / pp;
      if (indx == 0) {
         retvalu = 1.0 - retvalu;
      }
   }
   return (retvalu);
}
define betainc__1(aa,bb,xx) {
   auto retvalu,lbeta_ab,front,ff,cc,dd,ii,jj,mm,\
         numerator,cd;
   if (xx <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= xx) {
      retvalu = 1.0;
   } else if ((aa + 1.0) / (aa + bb + 2.0) < xx) {
      retvalu = (1.0 - betainc__1(bb,aa,1.0 - xx));
   } else {
      lbeta_ab = lbeta(aa,bb);
      front = exp(log(xx) * aa + log(1.0 - xx) * bb -\
            lbeta_ab) / aa;
      ff = 1.0;
      cc = 1.0;
      dd = 0.0;
      jj = 0;
      ii = 0;
      for (;;) {
         if (ii == 0) {
            numerator = 1.0;
         } else if (jj == 0) {
            mm = ii / 2;
            numerator = (mm * (bb - mm) * xx) / ((aa + 2.0 *\
                  mm - 1.0) * (aa + 2.0 * mm));
         } else {
            mm = (ii - 1) / 2;
            numerator = -((aa + mm) * (aa + bb + mm) * xx) /\
                  ((aa + 2.0 * mm) * (aa + 2.0 * mm + 1.0));
         }
         dd = 1.0 + numerator * dd;
         if (abs(dd) < cxdbleps * cxdbleps) {
            dd = cxdbleps * cxdbleps;
         }
         dd = 1.0 / dd;
         cc = 1.0 + numerator / cc;
         if (abs(cc) < cxdbleps * cxdbleps) {
            cc = cxdbleps * cxdbleps;
         }
         cd = cc * dd;
         ff *= cd;
         jj = 1 - ii;
         if (abs(1.0 - cd) < cxdbleps) {
            break; # loop AWAIT
         }
         ii += 1;
         if (200 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = front * (ff - 1.0);
   }
   return (retvalu);
}
define lf_digamma_gt_zero(xx) {
   auto rec_xx_sqr,shift,sxx,ii,sumy;
   shift = 0.0;
   sxx = xx;
   while (sxx < 8.0) {
      shift -= 1.0 / sxx;
      sxx += 1.0;
   }
   rec_xx_sqr = 1.0 / (sxx * sxx);
   sumy = 0.0;
   for (ii = 14; 2 <= ii; ii -= 2) {
      sumy *= rec_xx_sqr;
      sumy += - bernoulli(ii) / ii;
   }
   return ((shift + log(sxx) - 1.0 / (2.0 * sxx) + rec_xx_sqr\
         * sumy));
}
define digamma(xx) {
   auto sxx,retvalu;
   if (xx <= 0.0) {
      if (isint(xx)) {
         retvalu = cxdblmax;
      } else {
         sxx = 2.0 * xx;
         retvalu = (lf_digamma_gt_zero(1.0 - xx) - cxpi *\
               cos(sxx) / sin(sxx));
      }
   } else {
      retvalu = lf_digamma_gt_zero(xx);
   }
   return (retvalu);
}
define digammainv(yy) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_dy,\
         scvx_ii;
   scvx_dx = 0.1;
   scvx_xx = exp(yy);
   scvx_yy = yy - digamma(scvx_xx);
   for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
      scvx_xp = scvx_xx;
      scvx_yp = scvx_yy;
      scvx_xx += scvx_dx;
      if (iseq(scvx_xp,scvx_xx)) {
         break;
      }
      scvx_yy = yy - digamma(scvx_xx);
      scvx_dy = (scvx_yy - scvx_yp);
      if (iszero(scvx_dy)) {
         break;
      }
      scvx_dx *= - scvx_yy / scvx_dy;
   }
   return (scvx_xx);
}
define lf_digamma_gt_zero__1(xx) {
   auto gg,aa_arr[],sxx,term,lnarg,numer,denom,ii;
   gg = 9.6565781537733158945718737389;
   aa_arr[0] = (1.144005294538510956673085217 * 10^4);
   aa_arr[1] = -(3.239880201523183350535979104 * 10^4);
   aa_arr[2] = (3.505145235055716665660834611 * 10^4);
   aa_arr[3] = -(1.816413095412607026106469185 * 10^4);
   aa_arr[4] = (4.632329905366668184091382704 * 10^3);
   aa_arr[5] = -(5.369767777033567805557478696 * 10^2);
   aa_arr[6] = (2.287544733951810076451548089 * 10^1);
   aa_arr[7] = -(2.179257487388651155600822204 * 10^-1);
   aa_arr[8] = (1.083148362725893688606893534 * 10^-4);
   numer = 0.0;
   denom = 1.0;
   for (ii = 8; 0 <= ii; ii -= 1) {
      sxx = xx + ii;
      term = aa_arr[ii] / sxx;
      denom += term;
      numer += term / sxx;
   }
   lnarg = (gg + xx - 0.5);
   return (log(lnarg) - (gg / lnarg) - numer / denom);
}
define digamma__1(xx) {
   auto sxx,retvalu;
   if (xx <= 0.0) {
      if (isint(xx)) {
         retvalu = cxdblmax;
      } else {
         sxx = 2.0 * xx;
         retvalu = (lf_digamma_gt_zero__1(1.0 - xx) - cxpi *\
               cos(sxx) / sin(sxx));
      }
   } else {
      retvalu = lf_digamma_gt_zero__1(xx);
   }
   return (retvalu);
}
define factorialinv(yy) {
   return (tgammainv(yy) - 1.0);
}
define facinv(yy) {
   return (tgammainv(yy) - 1.0);
}
define hn(xx) {
   auto sum,kk,fxx;
   if (0.0 < xx) {
      fxx = floor(xx);
      sum = 0.0;
      for (kk = fxx; 1 <= kk; kk -= 1) {
         sum += 1.0 / kk;
      }
   } else {
      sum = 0.0;
   }
   return (sum);
}
define hn__1(xx) {
   auto yy,retvalu;
   if (0.0 < xx) {
      yy = 1.0 / (xx * xx);
      retvalu = ((((((-5.0 / (66.0 * 10.0)) * yy + 1.0 /\
            (30.0 * 8.0)) * yy - 1.0 / (42.0 * 6.0)) * yy +\
            1.0 / (30.0 * 4.0)) * yy - 1.0 / (6.0 * 2.0)) *\
            yy + cxeuler) + log(xx) + 0.5 / xx;
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define hnm(xx,mm) {
   auto sum,kk,fxx;
   fxx = floor(xx);
   sum = 0.0;
   for (kk = fxx; 1 <= kk; kk -= 1) {
      sum += 1.0 / pow(kk,mm);
   }
   return (sum);
}
lv_factorial_arr[0] = 0;
lv_factorial_end = 0;
define factorial(nn) {
   # local-use Bc lv_factorial_end;
   # local-use Bc lv_factorial_arr[];
   auto mm,retvalu;
   if (nn < 0) {
      retvalu = 0;
   } else {
      if (lv_factorial_end <= 0) {
         lv_factorial_end = 6;
         lv_factorial_arr[0] = 1;
         lv_factorial_arr[1] = 1;
         lv_factorial_arr[2] = 2;
         lv_factorial_arr[3] = 6;
         lv_factorial_arr[4] = 24;
         lv_factorial_arr[5] = 120;
      }
      if (lv_factorial_end <= nn) {
         mm = lv_factorial_end;
         lv_factorial_end = nn + 1;
         while (mm < lv_factorial_end) {
            lv_factorial_arr[mm] = (mm * lv_factorial_arr[mm\
                  - 1]);
            mm += 1;
         }
      }
      retvalu = lv_factorial_arr[nn];
   }
   return (retvalu);
}
lv_factorial_b_arr[0] = 0;
lv_factorial_b_end = 0;
define factorialdouble(nn) {
   # local-use Bc lv_factorial_b_end;
   # local-use Bc lv_factorial_b_arr[];
   auto retvalu,mm;
   if (nn < 0) {
      retvalu = 0;
   } else {
      if (lv_factorial_b_end <= 0) {
         lv_factorial_b_end = 6;
         lv_factorial_b_arr[0] = 1;
         lv_factorial_b_arr[1] = 1;
         lv_factorial_b_arr[2] = 2;
         lv_factorial_b_arr[3] = 3;
         lv_factorial_b_arr[4] = 8;
         lv_factorial_b_arr[5] = 15;
      }
      if (lv_factorial_b_end <= nn) {
         mm = lv_factorial_b_end;
         lv_factorial_b_end = nn + 1;
         while (mm < lv_factorial_b_end) {
            lv_factorial_b_arr[mm] = mm *\
                  lv_factorial_b_arr[mm - 2];
            mm += 1;
         }
      }
      retvalu = lv_factorial_b_arr[nn];
   }
   return (retvalu);
}
define fac(nn) {
   return (factorial(nn));
}
define factorialt(n_things,r_each) {
   auto ii,retvalu;
   retvalu = 1.0;
   for (ii = r_each + 1; ii <= n_things; ii += 1) {
      retvalu *= ii;
   }
   return (retvalu);
}
define comb(n_things,r_each) {
   auto ii,retvalu;
   if (r_each < 0 || n_things < r_each) {
      retvalu = 0.0;
   } else {
      if (2 * r_each < n_things) {
         r_each = n_things - r_each;
      }
      retvalu = 1.0;
      for (ii = r_each + 1; ii <= n_things; ii += 1) {
         retvalu *= ii;
         retvalu /= (ii - r_each);
      }
   }
   return (retvalu);
}
define perm(n_things,r_each) {
   return (factorialt(n_things,n_things - r_each));
}
define combination(n_things,r_each) {
   return (comb(n_things,r_each));
}
define permutation(n_things,r_each) {
   return (perm(n_things,r_each));
}
lv_catalan_arr[0] = 0;
lv_catalan_end = 0;
define catalan(nn) {
   # local-use Bc lv_catalan_end;
   # local-use Bc lv_catalan_arr[];
   auto kk,retvalu;
   if (nn < 0) {
      retvalu = 0;
   } else {
      if (lv_catalan_end <= 0) {
         lv_catalan_end = 1;
         lv_catalan_arr[0] = 1;
      }
      if (lv_catalan_end <= nn) {
         kk = lv_catalan_end;
         lv_catalan_end = nn + 1;
         while (kk < lv_catalan_end) {
            lv_catalan_arr[kk] = (2 * (2.0 * kk - 1) *\
                  lv_catalan_arr[kk - 1] / (kk + 1.0));
            kk += 1;
         }
      }
      retvalu = lv_catalan_arr[nn];
   }
   return (retvalu);
}
lv_supercatalan_arr[0] = 0;
lv_supercatalan_end = 0;
define supercatalan(nn) {
   # local-use Bc lv_supercatalan_end;
   # local-use Bc lv_supercatalan_arr[];
   auto kk,retvalu;
   if (nn < 0) {
      retvalu = 0;
   } else {
      if (lv_supercatalan_end <= 0) {
         lv_supercatalan_end = 3;
         lv_supercatalan_arr[0] = 1;
         lv_supercatalan_arr[1] = 1;
         lv_supercatalan_arr[2] = 1;
      }
      if (lv_supercatalan_end <= nn) {
         kk = lv_supercatalan_end;
         lv_supercatalan_end = nn + 1;
         while (kk < lv_supercatalan_end) {
            lv_supercatalan_arr[kk] = (((6 * kk - 9) *\
                  lv_supercatalan_arr[kk - 1] - (kk - 3) *\
                  lv_supercatalan_arr[kk - 2]) / kk);
            kk += 1;
         }
      }
      retvalu = lv_supercatalan_arr[nn];
   }
   return (retvalu);
}
lv_bell_arr[0] = 0;
lv_bell_x_arr[0] = 0;
lv_bell_end = 0;
define bell(nn) {
   # local-use Bc lv_bell_end;
   # local-use Bc lv_bell_arr[];
   # local-use Bc lv_bell_x_arr[];
   auto jj,kk,retvalu;
   if (nn < 0) {
      retvalu = 0;
   } else {
      if (lv_bell_end <= 0) {
         lv_bell_end = 3;
         lv_bell_arr[0] = 1;
         lv_bell_arr[1] = 1;
         lv_bell_arr[2] = 2;
         lv_bell_x_arr[0] = 2;
         lv_bell_x_arr[1] = 1;
      }
      if (lv_bell_end <= nn) {
         kk = lv_bell_end;
         lv_bell_end = nn + 1;
         while (kk < lv_bell_end) {
            lv_bell_x_arr[kk - 1] = lv_bell_x_arr[0];
            for (jj = kk - 2; 0 <= jj; jj -= 1) {
               lv_bell_x_arr[jj] += lv_bell_x_arr[jj + 1];
            }
            lv_bell_arr[kk] = lv_bell_x_arr[0];
            kk += 1;
         }
      }
      retvalu = lv_bell_arr[nn];
   }
   return (retvalu);
}
define bellx(xxn) {
   auto sum,kk,sum_prev,den;
   kk = 0;
   sum = 0.0;
   den = 1.0;
   for (;;) {
      kk += 1;
      den *= kk;
      sum_prev = sum;
      sum += pow(kk,xxn) / den;
      if (iseq(sum_prev,sum)) {
         break; # loop AWAIT
      }
   }
   return (sum / cxe);
}
define fubini(nn) {
   auto mm,sum,retvalu;
   if (nn < 0) {
      retvalu = 0;
   } else if (nn == 0) {
      retvalu = 1;
   } else {
      sum = 1.0 / (2.0 * cxlntwo * cxlntwo);
      for (mm = 2; mm <= nn; mm += 1) {
         sum *= mm / cxlntwo;
      }
      retvalu = round(sum);
   }
   return (retvalu);
}
define d2lt_d1(xx,yy) {
   auto retvalu;
   if (0 <= yy && yy <= xx) {
      retvalu = yy + (xx * (xx + 1)) / 2;
   } else {
      retvalu = -1;
   }
   return (retvalu);
}
define d1lt_d2(nn,*ret_arr_p[]) {
   auto basee;
   if (nn <= 0) {
      ret_arr_p[0] = 0;
      ret_arr_p[1] = 0;
   } else {
      basee = floorl((sqrt(1 + 8.0 * nn) - 1) / 2);
      ret_arr_p[1] = nn - basee * (basee + 1) / 2;
      ret_arr_p[0] = basee;
   }
   return (ret_arr_p[0]);
}
define d2ur_d1(xx,yy) {
   auto retvalu,suma;
   if (0 <= xx && 0 <= yy) {
      suma = (yy + xx);
      retvalu = suma * (suma + 1) / 2 + yy;
   } else {
      retvalu = -1;
   }
   return (retvalu);
}
define d1ur_d2(nn,*ret_arr_p[]) {
   auto basee,y_coord;
   if (nn <= 0) {
      ret_arr_p[0] = 0;
      ret_arr_p[1] = 0;
   } else {
      basee = floorl((sqrt(1 + 8.0 * nn) - 1) / 2);
      y_coord = nn - basee * (basee + 1) / 2;
      ret_arr_p[1] = y_coord;
      ret_arr_p[0] = basee - y_coord;
   }
   return (ret_arr_p[0]);
}
define d2diamond_d1(xx,yy) {
   auto ss,tt,retvalu;
   if (0 == yy && xx == 0) {
      retvalu = 0;
   } else {
      ss = abs(xx) + abs(yy);
      tt = 2 * ss * (ss - 1) + 1;
      if (0 < xx) {
         retvalu = tt + ss + yy - 1;
      } else {
         retvalu = tt + 3 * ss - yy - 1;
      }
   }
   return (retvalu);
}
define d1diamond_d2(nn,*ret_arr_p[]) {
   auto ss,ssq,x_coord;
   if (nn <= 0) {
      x_coord = 0;
      ret_arr_p[1] = 0;
   } else {
      ss = floorl(sqrt(nn) / cxsqrttwo);
      ssq = 2 * ss * ss;
      if (nn <= ssq + 2 * ss) {
         ret_arr_p[1] = ssq - nn + ss;
         x_coord = ssq - nn;
         if (ss < - x_coord) {
            x_coord = -x_coord - 2 * ss;
         }
      } else {
         ret_arr_p[1] = nn - ssq - 3 * ss - 1;
         x_coord = nn - ssq - 2 * ss;
         if (ss < x_coord) {
            x_coord = -x_coord + 2 * ss + 2;
         }
      }
   }
   ret_arr_p[0] = x_coord;
   return (x_coord);
}
define d2spiral_d1(xx,yy) {
   auto retvalu;
   if (xx == 0 && yy == 0) {
      retvalu = 0;
   } else if (abs(xx) <= abs(yy)) {
      retvalu = (4 * yy - 1) * yy - xx;
      if (yy < 0) {
         retvalu -= 2 * (yy - xx);
      }
   } else {
      retvalu = (4 * xx - 1) * xx - yy;
      if (0 < xx) {
         retvalu -= 2 * (xx - yy);
      }
   }
   return (retvalu);
}
define d1spiral_d2(nn,*ret_arr_p[]) {
   auto sqrtnn,newdd,fxd;
   if (nn <= 0) {
      ret_arr_p[0] = 0;
      ret_arr_p[1] = 0;
   } else {
      sqrtnn = floorl(sqrt(nn));
      if (iseven(sqrtnn)) {
         fxd = -sqrtnn / 2;
      } else {
         fxd = (sqrtnn + 1) / 2;
      }
      newdd = nn - sqrtnn * sqrtnn;
      if (newdd <= sqrtnn) {
         ret_arr_p[0] = fxd;
         if (fxd < 0) {
            ret_arr_p[1] = -fxd - newdd;
         } else {
            ret_arr_p[1] = -fxd + newdd + 1;
         }
      } else {
         ret_arr_p[1] = fxd;
         newdd -= sqrtnn;
         if (fxd < 0) {
            ret_arr_p[0] = fxd + newdd;
         } else {
            ret_arr_p[0] = fxd - newdd;
         }
      }
   }
   return (ret_arr_p[0]);
}
define d2hypot_d1(xx,yy) {
   auto retvalu,xlim,dist,distsq,count,ixx,nyy,nyysq,\
         xmax;
   if (0 <= yy && yy <= xx) {
      distsq = xx * xx + yy * yy;
      dist = sqrt(distsq);
      xlim = floorl(dist / cxsqrttwo);
      xmax = floorl(dist);
      count = 0;
      for (ixx = xlim; ixx <= xmax; ixx += 1) {
         nyysq = distsq - ixx * ixx;
         nyy = ceill(sqrt(nyysq));
         if (ixx < nyy) {
            count += ixx + 1;
         } else {
            count += nyy;
            if (ixx < xx && nyy * nyy == nyysq) {
               count += 1;
            }
         }
      }
      retvalu = count + xlim * (xlim + 1) / 2;
   } else {
      retvalu = -1;
   }
   return (retvalu);
}
define binomialx(xnn,xkk) {
   return (tgamma(xnn + 1) / (tgamma(xkk + 1) * tgamma(xnn +\
         1 - xkk)));
}
lv_binom_arr[0] = 0;
lv_binom_end = 0;
lv_binom_max = 0;
define binomial(nn,kk) {
   # local-use Bc lv_binom_arr[];
   # local-use Bc lv_binom_end;
   # local-use Bc lv_binom_max;
   auto rz_ind,lz_ind,rr,ul_ind,retvalu;
   if (nn < kk || nn < 0 || kk < 0) {
      retvalu = 0;
   } else {
      if (lv_binom_end <= 0) {
         lv_binom_max = 2;
         lv_binom_end = d2lt_d1(lv_binom_max,0);
         lv_binom_arr[0] = 1;
         lv_binom_arr[1] = 1;
         lv_binom_arr[2] = 1;
      }
      rr = lv_binom_max;
      if (rr < nn + 1) {
         lv_binom_end = d2lt_d1(nn + 1,0);
         while (rr <= nn) {
            ul_ind = d2lt_d1(rr - 1,0);
            lz_ind = ul_ind + rr;
            lv_binom_arr[lz_ind] = 1;
            rz_ind = lz_ind + rr;
            while (lz_ind < rz_ind) {
               lv_binom_arr[rz_ind] = lv_binom_arr[lz_ind];
               rz_ind -= 1;
               lz_ind += 1;
               lv_binom_arr[lz_ind] = (lv_binom_arr[ul_ind] +\
                     lv_binom_arr[ul_ind + 1]);
               ul_ind += 1;
            }
            rr += 1;
         }
         lv_binom_max = rr;
      }
      retvalu = lv_binom_arr[d2lt_d1(nn,kk)];
   }
   return (retvalu);
}
lv_euler_arr[0] = 0;
lv_euler_end = 0;
lv_euler_max = 0;
define eulerian(nn,mm) {
   # local-use Bc lv_euler_arr[];
   # local-use Bc lv_euler_end;
   # local-use Bc lv_euler_max;
   auto cr,rr,lz_ind,rz_ind,ul_ind,retvalu;
   if (nn < mm || nn < 0 || mm < 0) {
      retvalu = 0;
   } else {
      if (lv_euler_end <= 0) {
         lv_euler_max = 3;
         lv_euler_end = d2lt_d1(lv_euler_max,0);
         lv_euler_arr[0] = 0;
         lv_euler_arr[1] = 1;
         lv_euler_arr[2] = 0;
         lv_euler_arr[3] = 1;
         lv_euler_arr[4] = 1;
         lv_euler_arr[5] = 0;
      }
      rr = lv_euler_max;
      if (rr < nn + 1) {
         lv_euler_end = d2lt_d1(nn + 1,0);
         while (rr <= nn) {
            lz_ind = d2lt_d1(rr,0);
            lv_euler_arr[lz_ind] = 1;
            lv_euler_arr[lz_ind + rr] = 0;
            rz_ind = lz_ind + rr - 1;
            ul_ind = d2lt_d1(rr - 1,0);
            cr = 1;
            while (lz_ind < rz_ind) {
               lv_euler_arr[rz_ind] = lv_euler_arr[lz_ind];
               lz_ind += 1;
               lv_euler_arr[lz_ind] = ((rr - cr) *\
                     lv_euler_arr[ul_ind] + (cr + 1) *\
                     lv_euler_arr[ul_ind + 1]);
               ul_ind += 1;
               rz_ind -= 1;
               cr += 1;
            }
            rr += 1;
            lv_euler_max = rr;
         }
      }
      retvalu = lv_euler_arr[d2lt_d1(nn,mm)];
   }
   return (retvalu);
}
lv_entringer_arr[0] = 0;
lv_entringer_end = 0;
lv_entringer_max = 0;
define entringer(nn,kk) {
   # local-use Bc lv_entringer_arr[];
   # local-use Bc lv_entringer_max;
   # local-use Bc lv_entringer_end;
   auto cz,inda,rr,retvalu;
   if (nn <= 0 || kk < 0 || nn < kk) {
      retvalu = 0;
   } else {
      if (lv_entringer_end <= 0) {
         lv_entringer_max = 1;
         lv_entringer_end = d2lt_d1(lv_entringer_max,0);
         lv_entringer_arr[0] = 1;
      }
      rr = lv_entringer_max;
      if (rr < nn + 1) {
         lv_entringer_end = d2lt_d1(nn + 1,0);
         while (rr <= nn) {
            inda = d2lt_d1(rr,0);
            lv_entringer_arr[inda] = 0;
            for (cz = 1; cz <= rr; cz += 1) {
               lv_entringer_arr[inda + cz] =\
                     lv_entringer_arr[inda + cz - 1] +\
                     lv_entringer_arr[inda - cz];
            }
            rr += 1;
            lv_entringer_max = rr;
         }
      }
      retvalu = lv_entringer_arr[d2lt_d1(nn,kk)];
   }
   return (retvalu);
}
define zigzag(nn) {
   return (entringer(nn,nn));
}
define zig(nn) {
   return (zigzag(2 * nn));
}
define zag(nn) {
   return (zigzag(2 * nn - 1));
}
define eulerx(nn) {
   auto retvalu;
   if (nn <= 0 || isodd(nn)) {
      retvalu = 0;
   } else {
      retvalu = entringer(nn,nn);
   }
   return (retvalu);
}
define ballot(xmm,xnn) {
   return (abs(xnn - xmm) / (xmm + xnn));
}
define ballots(xmm,xnn) {
   auto retvalu;
   if (xmm < xnn) {
      retvalu = (xnn - xmm + 1.0) / (xnn + 1.0);
   } else {
      retvalu = (xmm - xnn + 1.0) / (xmm + 1.0);
   }
   return (retvalu);
}
lv_stir_a_arr[0] = 0;
lv_stir_a_end = 0;
lv_stir_a_max = 0;
define stirling1(nn,kk) {
   # local-use Bc lv_stir_a_arr[];
   # local-use Bc lv_stir_a_end;
   # local-use Bc lv_stir_a_max;
   auto col_k,ul_ind,cz_ind,rr,retvalu;
   if (nn < 0 || kk < 0 || nn < kk) {
      retvalu = 0;
   } else {
      if (lv_stir_a_max <= 0) {
         lv_stir_a_max = 2;
         lv_stir_a_end = d2lt_d1(lv_stir_a_max,0);
         lv_stir_a_arr[0] = 1;
         lv_stir_a_arr[1] = 0;
         lv_stir_a_arr[2] = 1;
      }
      rr = lv_stir_a_max;
      if (rr < nn + 1) {
         lv_stir_a_end = d2lt_d1(nn + 1,0);
         while (rr <= nn) {
            cz_ind = d2lt_d1(rr,0);
            lv_stir_a_arr[cz_ind] = 0;
            cz_ind += 1;
            ul_ind = d2lt_d1(rr - 1,0);
            for (col_k = 1; col_k <= rr - 1; col_k += 1) {
               lv_stir_a_arr[cz_ind] = (lv_stir_a_arr[ul_ind]\
                     - (rr - 1) * lv_stir_a_arr[ul_ind + 1]);
               ul_ind += 1;
               cz_ind += 1;
            }
            lv_stir_a_arr[cz_ind] = 1;
            rr += 1;
            lv_stir_a_max = rr;
         }
      }
      retvalu = lv_stir_a_arr[d2lt_d1(nn,kk)];
   }
   return (retvalu);
}
lv_stir_b_arr[0] = 0;
lv_stir_b_end = 0;
lv_stir_b_max = 0;
define stirling2(nn,kk) {
   # local-use Bc lv_stir_b_arr[];
   # local-use Bc lv_stir_b_end;
   # local-use Bc lv_stir_b_max;
   auto col_k,ul_ind,cz_ind,rr,retvalu;
   if (nn < kk || nn < 0 || kk < 0) {
      retvalu = 0;
   } else {
      if (lv_stir_b_end <= 0) {
         lv_stir_b_max = 2;
         lv_stir_b_end = d2lt_d1(lv_stir_b_max,0);
         lv_stir_b_arr[0] = 1;
         lv_stir_b_arr[1] = 0;
         lv_stir_b_arr[2] = 1;
      }
      rr = lv_stir_b_max;
      if (rr < nn + 1) {
         lv_stir_b_end = d2lt_d1(nn + 1,0);
         while (rr <= nn) {
            cz_ind = d2lt_d1(rr,0);
            lv_stir_b_arr[cz_ind] = 0;
            cz_ind += 1;
            ul_ind = d2lt_d1(rr - 1,0);
            for (col_k = 1; col_k <= rr - 1; col_k += 1) {
               lv_stir_b_arr[cz_ind] = (lv_stir_b_arr[ul_ind]\
                     + col_k * lv_stir_b_arr[ul_ind + 1]);
               ul_ind += 1;
               cz_ind += 1;
            }
            lv_stir_b_arr[cz_ind] = 1;
            rr += 1;
            lv_stir_b_max = rr;
         }
      }
      retvalu = lv_stir_b_arr[d2lt_d1(nn,kk)];
   }
   return (retvalu);
}
lv_bern_n_arr[0] = 0;
lv_bern_d_arr[0] = 0;
lv_bern_end = 0;
define bernoulli(nn) {
   # local-use Bc lv_bern_n_arr[];
   # local-use Bc lv_bern_d_arr[];
   # local-use Bc lv_bern_end;
   auto retvalu,sz_ind,coeff,sumn,sumd,jj,mm,gdn,\
         nsumn,nsumd,xkk,nnhalf;
   if (nn == 1) {
      retvalu = -0.5;
   } else if (nn < 0 || isodd(nn)) {
      retvalu = 0.0;
   } else {
      if (lv_bern_end <= 0) {
         lv_bern_end = 3;
         lv_bern_n_arr[0] = 1;
         lv_bern_n_arr[1] = 1;
         lv_bern_n_arr[2] = -1;
         lv_bern_d_arr[0] = 1;
         lv_bern_d_arr[1] = 6;
         lv_bern_d_arr[2] = 30;
      }
      nnhalf = floorl(nn / 2);
      if (lv_bern_end <= nnhalf) {
         mm = lv_bern_end;
         lv_bern_end = nnhalf + 1;
         while (mm < lv_bern_end) {
            sz_ind = 2 * mm;
            coeff = ((sz_ind + 1) * sz_ind) / 2;
            sumn = 1.0 - sz_ind;
            sumd = 2.0;
            for (jj = 1; jj <= mm - 1; jj += 1) {
               nsumn = round(sumn * lv_bern_d_arr[jj] + sumd\
                     * coeff * lv_bern_n_arr[jj]);
               nsumd = round(sumd * lv_bern_d_arr[jj]);
               gdn = gcd(nsumn,nsumd);
               sumn = nsumn / gdn;
               sumd = nsumd / gdn;
               xkk = 2 * jj;
               coeff *= (sz_ind - xkk + 1.0) / (xkk + 1.0);
               coeff *= (sz_ind - xkk) / (xkk + 2.0);
               coeff = round(coeff);
            }
            sumd *= (sz_ind + 1);
            gdn = gcd(sumn,sumd);
            lv_bern_n_arr[mm] = -sumn / gdn;
            lv_bern_d_arr[mm] = sumd / gdn;
            mm += 1;
         }
      }
      retvalu = lv_bern_n_arr[nnhalf] / lv_bern_d_arr[nnhalf];
   }
   return (retvalu);
}
define bernoullin(nn) {
   # local-use Bc lv_bern_n_arr[];
   # local-use Bc lv_bern_d_arr[];
   auto retvalu;
   if (nn == 1) {
      retvalu = -1;
   } else if (isodd(nn) || nn < 0) {
      retvalu = 0;
   } else {
      retvalu = bernoulli(nn);
      retvalu = lv_bern_n_arr[nn / 2];
   }
   return (retvalu);
}
define bernoullid(nn) {
   # local-use Bc lv_bern_n_arr[];
   # local-use Bc lv_bern_d_arr[];
   auto retvalu;
   if (nn == 1) {
      retvalu = 2;
   } else if (isodd(nn) || nn < 0) {
      retvalu = 1;
   } else {
      retvalu = bernoulli(nn);
      retvalu = lv_bern_d_arr[nn / 2];
   }
   return (retvalu);
}
define birthday(xnn,xrr) {
   auto prob,ii;
   prob = 1.0;
   for (ii = 1; ii <= xrr - 1; ii += 1) {
      prob *= (xnn - ii) / xnn;
   }
   return (prob);
}
define birthdayinv(xnn,xprob) {
   auto xrr,cprob;
   cprob = 1.0;
   xrr = 1.0;
   while (xprob < cprob) {
      cprob *= (xnn - xrr) / xnn;
      xrr += 1;
   }
   return (xrr);
}
define n2perm(mm,nn,*ret_perm_arr_p[]) {
   auto ii,pat_arr[],source_arr[],jj,kk,mmm,sz_ind,\
         local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   mmm = modulo(mm,factorial(nn));
   kk = mmm;
   for (ii = 1; ii <= nn; ii += 1) {
      pat_arr[nn - ii] = kk % ii;
      kk = floor(kk / ii);
      source_arr[ii - 1] = ii - 1;
   }
   for (ii = 0; ii <= nn - 1; ii += 1) {
      sz_ind = pat_arr[ii];
      ret_perm_arr_p[ii] = source_arr[sz_ind];
      for (jj = sz_ind; jj <= nn - ii - 2; jj += 1) {
         source_arr[jj] = source_arr[jj + 1];
      }
   }
   scale = local_prev_scale;
   return (mmm);
}
define n2perm_print(mm,nn) {
   auto perm_arr[],ii,jj;
   jj = n2perm(mm,nn,perm_arr[]);
   for (ii = 0; ii <= nn - 1; ii += 1) {
      print perm_arr[ii];
      print " ";
   }
   return (jj);
}
define n2comb(mm,nn,rr,*ret_comb_arr_p[]) {
   auto kk,cc,qq,ss,pp,mmm,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   mmm = modulo(mm,comb(nn,rr));
   kk = comb(nn,rr) - mmm;
   for (ss = 0; ss <= rr - 1; ss += 1) {
      pp = rr - ss;
      cc = 1;
      qq = 1;
      while (cc < kk) {
         kk -= cc;
         cc = (cc * pp) / qq;
         qq += 1;
         pp += 1;
      }
      ret_comb_arr_p[ss] = nn - pp;
   }
   scale = local_prev_scale;
   return (mmm);
}
define n2comb_print(mm,nn,rr) {
   auto comb_arr[],ii,jj;
   jj = n2comb(mm,nn,rr,comb_arr[]);
   for (ii = 0; ii <= rr - 1; ii += 1) {
      print comb_arr[ii];
      print " ";
   }
   return (jj);
}
define pochhammer(nn,xx) {
   auto retvalu,ii;
   if (0 < nn) {
      retvalu = xx;
      for (ii = 1; ii <= nn; ii += 1) {
         retvalu *= (xx + ii);
      }
   } else if (nn < 0) {
      retvalu = xx;
      for (ii = -1; nn <= ii; ii -= 1) {
         retvalu *= (xx + ii);
      }
   } else {
      retvalu = 1.0;
   }
   return (retvalu);
}
define days_in_month(g_year,g_month) {
   auto retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   if (g_month == 2) {
      if (isleapyear(g_year)) {
         retvalu = 29;
      } else {
         retvalu = 28;
      }
   } else if ((6 * g_month + 1) % 11 < 5) {
      retvalu = 30;
   } else {
      retvalu = 31;
   }
   scale = local_prev_scale;
   return (retvalu);
}
define sec2dhms(seconds) {
   auto dy,hr,mn,tm,sg;
   if (seconds < 0.0) {
      sg = -1.0;
   } else {
      sg = 1.0;
   }
   dy = floor(seconds * cxsecond / cxday);
   tm = (seconds * cxsecond / cxday - dy) * cxday / cxhour;
   hr = floor(tm);
   tm = (tm - hr) * cxhour / cxminute;
   mn = floor(tm);
   tm = (tm - mn) * cxminute / cxsecond;
   return (dy + sg * (hr + (mn + tm / 100.0) / 100.0) / 100.0);
}
define day2dhms(dayfrac) {
   auto dy,hr,mn,tm,sg;
   if (dayfrac < 0.0) {
      sg = -1.0;
   } else {
      sg = 1.0;
   }
   dy = floor(dayfrac);
   tm = (dayfrac - dy) * cxday / cxhour;
   hr = floor(tm);
   tm = (tm - hr) * cxhour / cxminute;
   mn = floor(tm);
   tm = (tm - mn) * cxminute / cxsecond;
   return (dy + sg * (hr + (mn + tm / 100.0) / 100.0) / 100.0);
}
define day2dhmsinv(xx_hms) {
   auto dy,hr,mn,tm;
   dy = floor(xx_hms);
   tm = (xx_hms - dy) * 100.0;
   hr = floor(tm);
   tm = (tm - hr) * 100.0;
   mn = floor(tm);
   tm = (tm - mn) * 100.0;
   return (dy + (hr * cxhour + mn * cxminute + tm * cxsecond)\
         / cxday);
}
define hms2day(hourx,minutex,secondx) {
   return ((secondx * cxsecond + minutex * cxminute + hourx *\
         cxhour) / cxday);
}
define hour2day(hourx) {
   return (hourx * cxhour / cxday);
}
define day2hour(dayx) {
   return (dayx * cxday / cxhour);
}
define jd2kwt(jjdtime) {
   return ((jjdtime * cxjday - cxjdsec_at_0kwt) / cxkwt);
}
define jd2j2k(jjdtime) {
   return ((jjdtime * cxjday - cxjdsec_at_0j2k) / cxj2kday);
}
define jd2uet(jjdtime) {
   return ((jjdtime * cxjday - cxjdsec_at_0uet) / cxuet);
}
define kwt2jd(kwttime) {
   return ((kwttime * cxkwt + cxjdsec_at_0kwt) / cxjday);
}
define uet2jd(uettime) {
   return ((uettime * cxuet + cxjdsec_at_0uet) / cxjday);
}
define j2k2jd(jtwoktm) {
   return ((jtwoktm * cxj2kday + cxjdsec_at_0j2k) / cxjday);
}
define j2k2kwt(jtwoktm) {
   return (jd2kwt(j2k2jd(jtwoktm)));
}
define j2k2uet(jtwoktm) {
   return (jd2uet(j2k2jd(jtwoktm)));
}
define kwt2j2k(kwttime) {
   return (jd2j2k(kwt2jd(kwttime)));
}
define kwt2uet(kwttime) {
   return (jd2uet(kwt2jd(kwttime)));
}
define uet2kwt(uettime) {
   return (jd2kwt(uet2jd(uettime)));
}
define uet2j2k(uettime) {
   return (jd2j2k(uet2jd(uettime)));
}
define jd2dow(jjd) {
   auto jjtemp;
   jjtemp = floor(jjd + 1.5);
   return (jjtemp % 7);
}
define j2k2dow(jtwok) {
   auto jjtemp;
   jjtemp = floor(jtwok + 6.5);
   return (jjtemp % 7);
}
define ymd2doy(g_year,g_month,g_daymon) {
   auto delta;
   if (2 < g_month) {
      delta = floor(30.6001 * g_month - 32.3);
      if (isleapyear(g_year)) {
         delta += 1;
      }
   } else if (g_month == 2) {
      delta = 31;
   } else {
      delta = 0;
   }
   return (delta + g_daymon);
}
define ymd2j2k__1(g_year,g_month,g_day) {
   auto yr,mn,jtwok,jcen,dayoffset;
   yr = g_year - 2000;
   mn = g_month;
   if (mn < 3) {
      mn += cxmonths_in_year;
      yr -= 1;
   }
   jcen = floor(yr / 100);
   dayoffset = jcen - floor(jcen / 4.0) + 31.3;
   jtwok = (floor(yr * cxjyear / cxjday) + floor(30.6001 * mn\
         - dayoffset) + g_day - 1.5);
   return (jtwok);
}
define ymd2j2k(g_year,g_month,g_day) {
   auto yr,mn,jtwok,jcen;
   yr = g_year - 2000;
   mn = g_month;
   jcen = floor((yr - 1) / 100);
   jtwok = (floor(yr * cxjyear / cxjday - 0.0001) +\
         floor(jcen / 4.0) - jcen + ymd2doy(yr,mn,g_day) -\
         0.5);
   return (jtwok);
}
define ymd2jd(g_year,g_month,g_day) {
   return (j2k2jd(ymd2j2k(g_year,g_month,g_day)));
}
define ymd2dow(g_year,g_month,g_daymon) {
   return (jd2dow(ymd2jd(g_year,g_month,g_daymon)));
}
define doomsday(g_year) {
   auto cc,yy,lps,anchor,retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   cc = floor(g_year / 100);
   anchor = (cc % 4) * 5 + 2;
   yy = g_year % 100;
   lps = floor(yy / 4);
   retvalu = (anchor + yy + lps) % 7;
   scale = local_prev_scale;
   return (retvalu);
}
cxlc_gd_year = 0;
cxlc_gd_month = 1;
cxlc_gd_day = 2;
cxlc_gd_hour = 3;
cxlc_gd_min = 4;
cxlc_gd_sec = 5;
cxlc_gd_dow = 6;
cxlc_gd_num = 7;
cxlc_gd_jd = 8;
cxlc_gd_count = 9;
lv_ymdhms_arr[0] = 0;
define jd2ymdhms(jjulid) {
   # local-use Bc lv_ymdhms_arr[];
   auto jcent,bbdays,bdiff,g_years,month_next,ftime_frac\
         ,dtime_rem,ijulian;
   lv_ymdhms_arr[cxlc_gd_jd] = jjulid;
   ftime_frac = frac(jjulid + 0.5);
   ijulian = floor(jjulid + 0.5);
   jcent = floor(((ijulian - 60.5) * cxjday -\
         cxjdsec_at_0gregorian) / (100.0 * cxgyear));
   bbdays = ijulian + jcent - floor(jcent / 4.0);
   g_years = floor((bbdays + 1399.9) * cxjday / cxjyear);
   bdiff = bbdays - floor(g_years * cxjyear / cxjday) + 1522;
   month_next = floor(bdiff / 30.6001);
   dtime_rem = bdiff - floor(30.6001 * month_next) + ftime_frac;
   lv_ymdhms_arr[cxlc_gd_year] = g_years - 4716.0;
   if (13 < month_next) {
      lv_ymdhms_arr[cxlc_gd_month] = month_next - 13;
   } else {
      lv_ymdhms_arr[cxlc_gd_month] = month_next - 1;
   }
   if (lv_ymdhms_arr[cxlc_gd_month] < 3) {
      lv_ymdhms_arr[cxlc_gd_year] += 1;
   }
   lv_ymdhms_arr[cxlc_gd_day] = floor(dtime_rem);
   dtime_rem = cxday / cxhour * frac(dtime_rem);
   lv_ymdhms_arr[cxlc_gd_hour] = floor(dtime_rem);
   dtime_rem = cxhour / cxminute * frac(dtime_rem);
   lv_ymdhms_arr[cxlc_gd_min] = floor(dtime_rem);
   dtime_rem = cxminute / cxsecond * frac(dtime_rem);
   lv_ymdhms_arr[cxlc_gd_sec] = dtime_rem;
   lv_ymdhms_arr[cxlc_gd_dow] = floor(fmod(ijulian + 1.0,7.0));
   dtime_rem = (lv_ymdhms_arr[cxlc_gd_month] * 100.0 +\
         lv_ymdhms_arr[cxlc_gd_day] +\
         lv_ymdhms_arr[cxlc_gd_hour] / 100.0 +\
         lv_ymdhms_arr[cxlc_gd_min] / 10000.0 +\
         lv_ymdhms_arr[cxlc_gd_sec] / 1000000.0);
   ftime_frac = lv_ymdhms_arr[cxlc_gd_year] * 10000.0;
   if (ftime_frac < 0.0) {
      lv_ymdhms_arr[cxlc_gd_num] = ftime_frac - dtime_rem;
   } else {
      lv_ymdhms_arr[cxlc_gd_num] = ftime_frac + dtime_rem;
   }
   return (lv_ymdhms_arr[cxlc_gd_num]);
}
define j2k2ymdhms(jtwokd) {
   return (jd2ymdhms(j2k2jd(jtwokd)));
}
define ymdhms_get(indexp) {
   # local-use Bc lv_ymdhms_arr[];
   auto retvalu;
   if (cxlc_gd_year <= indexp && indexp < cxlc_gd_count) {
      retvalu = lv_ymdhms_arr[indexp];
   } else {
      retvalu = -1;
   }
   return (retvalu);
}
define jd2ymdhmsinv() {
   # local-use Bc lv_ymdhms_arr[];
   return (ymd2jd(lv_ymdhms_arr[cxlc_gd_year],\
         lv_ymdhms_arr[cxlc_gd_month],\
         lv_ymdhms_arr[cxlc_gd_day]) +\
         hms2day(lv_ymdhms_arr[cxlc_gd_hour],\
         lv_ymdhms_arr[cxlc_gd_min],\
         lv_ymdhms_arr[cxlc_gd_sec]) * cxday / cxjday);
}
define jd264_print(jjulid) {
   bcdummy = jd2ymdhms(jjulid);
   bcdummy = base_out_print(ymdhms_get(cxlc_gd_year),64);
   bcdummy = base_out_print(ymdhms_get(cxlc_gd_month),64);
   bcdummy = base_out_print(ymdhms_get(cxlc_gd_day),64);
   bcdummy = base_out_print(ymdhms_get(cxlc_gd_hour),64);
   bcdummy = base_out_print(ymdhms_get(cxlc_gd_min),64);
   bcdummy = base_outf_print(ymdhms_get(cxlc_gd_sec),64);
   return (jjulid);
}
define ymdhms2jd(ymdhmsx) {
   auto xx_arr[],ys;
   ys = ymdhmsx * (1.0 + cxdbleps);
   xx_arr[cxlc_gd_year] = floor(ys / 10000.0);
   if (ys < 0) {
      ys = -ys;
   }
   xx_arr[cxlc_gd_month] = fmodu(floor(ys / 100.0),100.0);
   xx_arr[cxlc_gd_day] = fmodu(floor(ys),100.0);
   xx_arr[cxlc_gd_hour] = fmodu(floor(ys * 100.0),100.0);
   xx_arr[cxlc_gd_min] = fmodu(floor(ys * 10000.0),100.0);
   xx_arr[cxlc_gd_sec] = frac(ys * 10000.0) * 100.0;
   return (ymd2jd(xx_arr[cxlc_gd_year],xx_arr[cxlc_gd_month]\
         ,xx_arr[cxlc_gd_day]) +\
         hms2day(xx_arr[cxlc_gd_hour],xx_arr[cxlc_gd_min],\
         xx_arr[cxlc_gd_sec]) * cxday / cxjday);
}
define ymdhms2j2k(ymdhmsx) {
   return (jd2j2k(ymdhms2jd(ymdhmsx)));
}
define clocksec(secnds) {
   return (frac(secnds / cxminute) * cxtau);
}
define clockmin(secnds) {
   return (frac(secnds / cxhour) * cxtau);
}
define clockhour(secnds) {
   return (frac(secnds / (cxday / 2)) * cxtau);
}
define clocksum(secnds) {
   auto sc,mn,hr;
   sc = clocksec(secnds);
   mn = clockmin(secnds);
   hr = clockhour(secnds);
   return (dist(sc - mn,cxtau) + dist(hr - mn,cxtau) +\
         dist(sc - hr,cxtau));
}
define clockstdev(secnds) {
   auto sc,mn,hr,da,db,dc;
   sc = clocksec(secnds);
   mn = clockmin(secnds);
   hr = clockhour(secnds);
   da = dist(sc - mn,cxtau);
   db = dist(hr - mn,cxtau);
   dc = dist(sc - hr,cxtau);
   return (sqrt((da * da + db * db + dc * dc - square(da + db\
         + dc) / 3) / 2));
}
cxlc_halaqim_per_hour = 1080;
cxlc_halaqim = cxhour / cxlc_halaqim_per_hour;
cxlc_year_per_metonic = 19;
define date_easter(g_year) {
   auto cc,nn,kk,ff,ii,jj,mm,lps,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   cc = floor(g_year / 100);
   nn = g_year % cxlc_year_per_metonic;
   lps = floor(g_year / 4);
   kk = floor((cc + 8) / 25 - 1);
   ff = floor((cc - kk) / 3);
   mm = cc - floor(cc / 4);
   ii = (mm - ff + cxlc_year_per_metonic * nn + 15) % 30;
   if (28 < ii || (ii == 28 && 10 < nn)) {
      ii -= 1;
   }
   jj = (g_year + lps + ii + 2 - mm) % 7;
   scale = local_prev_scale;
   return (ii - jj + 28);
}
define date_rosh_hashanah(g_year) {
   auto aa,dos,day_of_september,parts,doww,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   aa = (12 * g_year + 12) % cxlc_year_per_metonic;
   dos = (floor(g_year / 100) - floor(g_year / 400) - 2 +\
         (g_year % 4) / 4.0 + (round(cxmoonmonth /\
         cxlc_halaqim) * aa - 1565.0 * g_year - 445405) /\
         (cxlc_year_per_metonic * cxday / cxlc_halaqim));
   day_of_september = floor(dos);
   parts = frac(dos) * cxday / cxlc_halaqim;
   doww = ymd2dow(g_year,9,day_of_september);
   if (doww == 0 || doww == 3 || doww == 5) {
      day_of_september += 1;
   } else if (doww == 1 && 11 < aa && 23269 <= parts) {
      day_of_september += 1;
   } else if (doww == 2 && 6 < aa && 16404 <= parts) {
      day_of_september += 2;
   }
   scale = local_prev_scale;
   return (day_of_september - 0.25);
}
define jewish2jdx(hebyear) {
   auto months_el,halaqims_el,hour_el,hq_left,days_left,\
         alt_days,alt_dow,hymod,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   hymod = (hebyear - 1) % cxlc_year_per_metonic;
   months_el = (235 * floor((hebyear - 1) /\
         cxlc_year_per_metonic) + 12 * hymod + floor((7 *\
         hymod + 1) / cxlc_year_per_metonic));
   halaqims_el = 204 + (793 * (months_el %\
         cxlc_halaqim_per_hour));
   hour_el = (5 + (12 * months_el) + 793 * floor(months_el /\
         cxlc_halaqim_per_hour) + floor(halaqims_el /\
         cxlc_halaqim_per_hour));
   days_left = 1 + 29 * months_el + floor(hour_el / (cxday /\
         cxhour));
   alt_days = days_left + 347996;
   alt_dow = (alt_days % iround(cxweek / cxday));
   hq_left = (halaqims_el % cxlc_halaqim_per_hour);
   scale = local_prev_scale;
   hq_left += cxday * frac(hour_el * cxhour / cxday) /\
         cxlc_halaqim;
   if (19440 <= hq_left) {
      if (0 == alt_dow || 2 == alt_dow || 4 == alt_dow) {
         alt_days += 2;
      } else {
         alt_days += 1;
      }
   } else if (0 == alt_dow) {
      if (9924 <= hq_left && (! isjewishleap(hebyear))) {
         alt_days += 2;
      }
   } else if (6 == alt_dow) {
      if (16789 <= hq_left && isjewishleap(hebyear - 1)) {
         alt_days += 1;
      }
   } else if (1 == alt_dow || 3 == alt_dow || 5 == alt_dow) {
      alt_days += 1;
   }
   return (alt_days + 0.25);
}
define isjewishleap(hebyear) {
   return ((7 * hebyear + 1) % cxlc_year_per_metonic < 7);
}
define date_pesach(g_year) {
   auto rh;
   rh = date_rosh_hashanah(g_year);
   return (rh + 21);
}
define g2jewish(g_year) {
   return (g_year + 3761);
}
define jewish2g(hebyear) {
   return (hebyear - 3760);
}
define jewish_months_in_year(hebyear) {
   auto miy;
   if (isjewishleap(hebyear)) {
      miy = 13;
   } else {
      miy = 12;
   }
   return (miy);
}
define jewish_yearlength(hebyear) {
   auto g_year,retvalu;
   g_year = jewish2g(hebyear - 1);
   retvalu = (floor(cxjyear / cxjday) +\
         (date_rosh_hashanah(g_year + 1) -\
         date_rosh_hashanah(g_year)));
   if (isleapyear(g_year + 1)) {
      retvalu += 1;
   }
   return (retvalu);
}
define jewish2jd(hebyear) {
   auto gyear;
   gyear = jewish2g(hebyear - 1);
   return (ymd2jd(gyear,9,date_rosh_hashanah(gyear)));
}
define isjewish8short(hebyear) {
   auto remten,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   remten = jewish_yearlength(hebyear) % 10;
   scale = local_prev_scale;
   return (remten != 5);
}
define isjewish9short(hebyear) {
   auto remten,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   remten = jewish_yearlength(hebyear) % 10;
   scale = local_prev_scale;
   return (remten == 3);
}
define jewish_monthlength(hebyear,hebmonth) {
   auto retvalu;
   retvalu = 30;
   if (hebmonth < 1 || 13 < hebmonth) {
      retvalu = 0;
   } else if (hebmonth < 8) {
      if (iseven(hebmonth)) {
         retvalu = 29;
      }
   } else if (hebmonth == 8) {
      if (isjewish8short(hebyear)) {
         retvalu = 29;
      }
   } else if (hebmonth == 9) {
      if (isjewish9short(hebyear)) {
         retvalu = 29;
      }
   } else if (hebmonth == 10) {
      retvalu = 29;
   } else if (hebmonth == 11) {
      retvalu = 30;
   } else if (hebmonth == 12) {
      if (! isjewishleap(hebyear)) {
         retvalu = 29;
      }
   } else if (hebmonth == 13 && isjewishleap(hebyear)) {
      retvalu = 29;
   } else {
      retvalu = 0;
   }
   return (retvalu);
}
define jewish_monthbegin(hebyear,hmonth) {
   auto g_year,g_month,hm,gdate;
   g_year = jewish2g(hebyear - 1);
   g_month = 9;
   if (hmonth < cxjewish_first_month) {
      g_year += 1;
      gdate = date_rosh_hashanah(g_year);
      for (hm = cxjewish_first_month - 1; hmonth <= hm; hm -=\
            1) {
         g_month -= 1;
         gdate += (days_in_month(g_year,g_month) -\
               jewish_monthlength(hebyear,hm));
      }
   } else if (cxjewish_first_month <= hmonth) {
      gdate = date_rosh_hashanah(g_year);
      for (hm = cxjewish_first_month; hm <= hmonth - 1; hm +=\
            1) {
         gdate -= (days_in_month(g_year,g_month) -\
               jewish_monthlength(hebyear,hm));
         g_month += 1;
         if (cxmonths_in_year < g_month) {
            g_month = 1;
            g_year += 1;
         }
      }
   }
   return (gdate);
}
define jewishymd2jd(hebyear,hebmonth,hebday) {
   auto jds,hmon,moninyear;
   moninyear = jewish_months_in_year(hebyear);
   if (1 <= hebmonth && hebmonth <= moninyear) {
      jds = jewish2jd(hebyear);
      hmon = cxjewish_first_month;
      while (hmon != hebmonth) {
         jds += jewish_monthlength(hebyear,hmon);
         hmon += 1;
         if (moninyear < hmon) {
            hmon = 1;
         } else if (hmon == cxjewish_first_month) {
            hebyear += 1;
            moninyear = jewish_months_in_year(hebyear);
         }
      }
   } else {
      jds = 0;
   }
   return (jds + hebday - 1.0);
}
define amean(xa,xb) {
   return ((xa + xb) / 2.0);
}
define amean1(xa) {
   return ((xa + 1.0) / 2.0);
}
define lmean(xa,xb) {
   auto retvalu,diffy;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      diffy = xa - xb;
      if (0.0001 < abs(diffy)) {
         retvalu = diffy / log(xa / xb);
      } else {
         retvalu = diffy / ln1p(diffy / xb);
      }
   }
   return (retvalu);
}
define lmean1(xa) {
   return (lmean(1.0,xa));
}
define pmean(pp,xa,xb) {
   auto retvalu;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else if (iszero(pp)) {
      retvalu = sqrt(xa * xb);
   } else {
      retvalu = pow((pow(xa,pp) + pow(xb,pp)) / 2.0,1.0 / pp);
   }
   return (retvalu);
}
define gmean(xa,xb) {
   auto retvalu;
   if (xa < 0.0 || xb < 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      retvalu = sqrt(xa * xb);
   }
   return (retvalu);
}
define gmean1(xa) {
   return (gmean(1.0,xa));
}
define hmean(xa,xb) {
   auto retvalu;
   if (xa < 0.0 || xb < 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      retvalu = 2.0 * xa * xb / (xa + xb);
   }
   return (retvalu);
}
define hmean1(xa) {
   return (hmean(1.0,xa));
}
define qmean(xa,xb) {
   auto retvalu;
   if (xa < 0.0 || xb < 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      retvalu = sqrt((xa * xa + xb * xb) / 2.0);
   }
   return (retvalu);
}
define qmean1(xa) {
   return (qmean(1.0,xa));
}
define heronianmean(xa,xb) {
   auto retvalu;
   if (xa < 0.0 || xb < 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      retvalu = (xa + xb + sqrt(xa * xb)) / 3.0;
   }
   return (retvalu);
}
define heronianmean1(xa) {
   return (heronianmean(1.0,xa));
}
define agmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = sqrt(xa * xb);
         xa = (xa + xb) / 2.0;
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff <\
               cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define agmean1(xa) {
   return (agmean(1.0,xa));
}
define ahmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = 2.0 * xa * xb / (xa + xb);
         xa = (xa + xb) / 2.0;
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff <\
               cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define ahmean1(xa) {
   return (ahmean(1.0,xa));
}
define almean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = lmean(xa,xb);
         xa = (xa + xb) / 2.0;
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff <\
               cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define almean1(xa) {
   return (almean(1.0,xa));
}
define aqmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = (xa + xb) / 2.0;
         xa = qmean(xa,xb);
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff <\
               cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define aqmean1(xa) {
   return (aqmean(1.0,xa));
}
define ghmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = 2.0 * xa * xb / (xa + xb);
         xa = sqrt(xa * xb);
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff <\
               cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define ghmean1(xa) {
   return (ghmean(1.0,xa));
}
define glmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = sqrt(xa * xb);
         xa = lmean(xa,xb);
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff <\
               cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define glmean1(xa) {
   return (glmean(1.0,xa));
}
define gqmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = sqrt(xa * xb);
         xa = qmean(xa,xb);
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff <\
               cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define gqmean1(xa) {
   return (gqmean(1.0,xa));
}
define hlmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = 2.0 * xa * xb / (xa + xb);
         xa = lmean(xa,xb);
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff <\
               cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define hlmean1(xa) {
   return (hlmean(1.0,xa));
}
define hqmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = 2.0 * xa * xb / (xa + xb);
         xa = qmean(xa,xb);
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff <\
               cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define hqmean1(xa) {
   return (hqmean(1.0,xa));
}
define lqmean(xa,xb) {
   auto ii,retvalu,xtmp,pdifff,cdifff;
   if (xa <= 0.0 || xb <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb)) {
      retvalu = xa;
   } else {
      cdifff = abs(xa - xb);
      ii = 0;
      for (;;) {
         pdifff = cdifff;
         xtmp = lmean(xa,xb);
         xa = qmean(xa,xb);
         xb = xtmp;
         cdifff = xa - xb;
         if (iswithin(xa,xb,10.0 * cxdbleps) || pdifff <\
               cdifff) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xtmp;
   }
   return (retvalu);
}
define lqmean1(xa) {
   return (lqmean(1.0,xa));
}
define agmean__1(xa,xb) {
   auto ii,retvalu,xtmp,xsgn;
   xsgn = 1.0;
   ii = 0;
   for (;;) {
      xtmp = xa;
      xa = (xa + xb) / 2.0;
      xb = sqrt(abs(xtmp * xb)) * sign(xa);
      if (iswithin(xa,xb,10.0 * cxdbleps)) {
         break; # loop AWAIT
      }
      ii += 1;
      if (20 <= ii) {
         break; # loop AWAIT
      }
   }
   retvalu = xsgn * xtmp;
   return (retvalu);
}
define agcmean(*xa_arr_pc[],*xb_arr_pc[],*ret_arr_p[]) {
   auto gg_arr[],aa_arr[],tt_arr[],pr_arr[],pr_len,pr_theta;
   gg_arr[0] = xa_arr_pc[0];
   gg_arr[1] = xa_arr_pc[1];
   aa_arr[0] = xb_arr_pc[0];
   aa_arr[1] = xb_arr_pc[1];
   for (;;) {
      tt_arr[0] = (aa_arr[0] + gg_arr[0]) / 2;
      tt_arr[1] = (aa_arr[1] + gg_arr[1]) / 2;
      pr_arr[0] = aa_arr[0] * gg_arr[0] - aa_arr[1] * gg_arr[1];
      pr_arr[1] = aa_arr[1] * gg_arr[0] + aa_arr[0] * gg_arr[1];
      pr_len = sqrt(hypot(pr_arr[0],pr_arr[1]));
      pr_theta = atan2(pr_arr[1],pr_arr[0]) / 2.0;
      gg_arr[0] = pr_len * cos(pr_theta);
      gg_arr[1] = pr_len * sin(pr_theta);
      aa_arr[0] = tt_arr[0];
      aa_arr[1] = tt_arr[1];
      if (aa_arr[0] * gg_arr[0] + aa_arr[1] * gg_arr[1] < 0.0) {
         gg_arr[0] = -gg_arr[0];
         gg_arr[1] = -gg_arr[1];
      }
      if (iseq(gg_arr[0],aa_arr[0]) && iseq(gg_arr[1],\
            aa_arr[1])) {
         break; # loop AWAIT
      }
   }
   ret_arr_p[0] = gg_arr[0];
   ret_arr_p[1] = gg_arr[1];
   return (hypot(gg_arr[0],gg_arr[1]));
}
define aghmean(xa,xb,xc) {
   auto ii,ta,tb,tc,retvalu;
   if (xa <= 0.0 || xb <= 0.0 || xc <= 0.0) {
      retvalu = 0.0;
   } else if (iseq(xa,xb) && iseq(xa,xc)) {
      retvalu = xa;
   } else {
      ii = 0;
      for (;;) {
         ta = xa;
         tb = xb;
         tc = xc;
         xa = (ta + tb + tc) / 3.0;
         xb = cuberoot(ta * tb * tc);
         xc = 3.0 / (1.0 / ta + 1.0 / tb + 1.0 / tc);
         if (iswithin(xa,xc,10.0 * cxdbleps)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = xb;
   }
   return (retvalu);
}
define rms(xa,xb) {
   return (sqrt((xa * xa + xb * xb) / 2.0));
}
define agmeaninva(aa,gg) {
   auto new_aa;
   if (gg < aa) {
      new_aa = aa + sqrt(aa * aa - gg * gg);
   } else {
      new_aa = gg + sqrt(gg * gg - aa * aa);
   }
   return (new_aa);
}
define agmeaninvg(aa,gg) {
   auto new_gg;
   if (gg < aa) {
      new_gg = gg * gg / aa;
   } else {
      new_gg = aa * aa / gg;
   }
   return (new_gg);
}
define agmean1inv(yy) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_dy,\
         scvx_ii,x_init,dx,cc;
   if (yy <= 0.0) {
      scvx_xx = 0.0;
   } else if (yy < 0.0022) {
      scvx_xx = 1.0 / cxdblmax;
   } else {
      if (yy <= 0.5) {
         x_init = 4.0 * exp(cxpi / (-2.0 * yy));
      } else if (yy < 2.1) {
         cc = yy - 1.0;
         x_init = ((((((((-0.09765625) * cc + 0.12890625) *\
               cc + 0.1875) * cc + 0.1875) * cc - 0.25) * cc\
               + 0.5) * cc + 2.0) * cc + 1.0);
      } else {
         cc = -(cxpi / 2.0);
         x_init = yy * wm(cc / (4.0 * yy)) / cc;
      }
      if (yy < 0.06) {
         dx = x_init * 0.1;
      } else {
         dx = x_init * 0.5;
      }
      scvx_dx = dx;
      scvx_xx = x_init;
      scvx_yy = yy - agmean1(scvx_xx);
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = yy - agmean1(scvx_xx);
         scvx_dy = (scvx_yy - scvx_yp);
         if (iszero(scvx_dy)) {
            break;
         }
         scvx_dx *= - scvx_yy / scvx_dy;
      }
   }
   return (scvx_xx);
}
define ghmean1inv(yy) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_dy,\
         scvx_ii,x_init;
   if (yy <= 0.0) {
      scvx_xx = 0.0;
   } else {
      x_init = exp(cxpi * yy / 2.0 - 1.385) - 0.22;
      scvx_dx = 0.2;
      scvx_xx = x_init;
      scvx_yy = yy - ghmean1(scvx_xx);
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = yy - ghmean1(scvx_xx);
         scvx_dy = (scvx_yy - scvx_yp);
         if (iszero(scvx_dy)) {
            break;
         }
         scvx_dx *= - scvx_yy / scvx_dy;
      }
   }
   return (scvx_xx);
}
define contraharmonic(nn,*val_arr_pc[]) {
   auto denom,numer,ii;
   numer = 0.0;
   denom = 0.0;
   for (ii = 0; ii <= nn - 1; ii += 1) {
      denom += val_arr_pc[ii] * val_arr_pc[ii];
      numer += val_arr_pc[ii];
   }
   return (denom / numer);
}
cxlc_knuth_max = 1073741823;
cxlc_knuth_quality_count = 1009;
cxlc_knuth_kk_count = 100;
cxlc_knuth_ll = 37;
cxlc_knuth_tt = 70;
cxlc_knuth_array_count = 1100;
lv_ranz_ind = -3;
lv_ranz_magic = 0.0;
lv_ranz_arr[0] = 0;
lv_ran_a_arr[0] = 0;
lv_ran_x_arr[0] = 0;
define lf_ran_cycle(nn) {
   # local-use Bc lv_ran_x_arr[];
   # local-use Bc lv_ran_a_arr[];
   auto aa,bb,cc,mody,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   aa = 0;
   while (aa < cxlc_knuth_kk_count) {
      lv_ran_a_arr[aa] = lv_ran_x_arr[aa];
      aa += 1;
   }
   bb = 0;
   cc = (cxlc_knuth_kk_count - cxlc_knuth_ll);
   while (aa < nn) {
      mody = lv_ran_a_arr[bb] - lv_ran_a_arr[cc];
      lv_ran_a_arr[aa] = bitwiseand(cxlc_knuth_max,mody);
      aa += 1;
      bb += 1;
      cc += 1;
   }
   aa = 0;
   while (aa < cxlc_knuth_ll) {
      mody = lv_ran_a_arr[bb] - lv_ran_a_arr[cc];
      lv_ran_x_arr[aa] = bitwiseand(cxlc_knuth_max,mody);
      aa += 1;
      bb += 1;
      cc += 1;
   }
   cc = 0;
   while (aa < cxlc_knuth_kk_count) {
      mody = lv_ran_a_arr[bb] - lv_ran_x_arr[cc];
      lv_ran_x_arr[aa] = bitwiseand(cxlc_knuth_max,mody);
      aa += 1;
      bb += 1;
      cc += 1;
   }
   scale = local_prev_scale;
   return (bb);
}
define lf_fill_ranz() {
   # local-use Bc lv_ranz_magic;
   # local-use Bc lv_ranz_ind;
   # local-use Bc lv_ranz_arr[];
   # local-use Bc lv_ran_a_arr[];
   auto jj;
   bcdummy = lf_ran_cycle(cxlc_knuth_quality_count);
   for (jj = 0; jj <= cxlc_knuth_quality_count - 1; jj += 1) {
      lv_ranz_arr[jj] = lv_ran_a_arr[jj];
   }
   lv_ranz_arr[cxlc_knuth_kk_count] = -1;
   lv_ranz_ind = 0;
   lv_ranz_magic = magicset();
   return (lv_ranz_arr[0]);
}
define lf_next_ranz() {
   # local-use Bc lv_ranz_magic;
   # local-use Bc lv_ranz_ind;
   # local-use Bc lv_ranz_arr[];
   if (! ismagic(lv_ranz_magic)) {
      bcdummy = rand_init(timee());
   } else if (lv_ranz_arr[lv_ranz_ind] < 0) {
      bcdummy = lf_fill_ranz();
   }
   lv_ranz_ind += 1;
   return (lv_ranz_arr[lv_ranz_ind - 1]);
}
define rand_init_array(seed_size,*seed_arr_pc[]) {
   # local-use Bc lv_ran_x_arr[];
   auto tt,jj,kk,dd,rnd_arr[],rndss,rndx,rndff,\
         seed_ind,bitmask,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   rndss = bitwiseand((seed_arr_pc[0] + 2),(cxlc_knuth_max -\
         1));
   for (jj = 0; jj <= cxlc_knuth_kk_count - 1; jj += 1) {
      rnd_arr[jj] = rndss;
      rndss = lf_shiftl(rndss,1);
      if (cxlc_knuth_max < rndss) {
         rndss -= (cxlc_knuth_max - 1);
      }
   }
   rndff = 0;
   seed_ind = 0;
   bitmask = 0;
   for (jj = 0; jj <= cxlc_knuth_kk_count - 1; jj += 1) {
      if (bitmask <= 1) {
         seed_ind += 1;
         if (seed_size <= seed_ind) {
            break;
         }
         rndff = seed_arr_pc[seed_ind];
         bitmask = lf_shiftl(1,30);
      }
      if (bitwiseand(rndff,bitmask) != 0) {
         rnd_arr[jj] = bitwisexor(bitmask,rnd_arr[jj]);
      }
      bitmask = lf_shiftr(bitmask,1);
   }
   rnd_arr[1] += 1;
   rndss = bitwiseand(seed_arr_pc[0],cxlc_knuth_max);
   tt = cxlc_knuth_tt - 1;
   while (0 < tt) {
      for (jj = cxlc_knuth_kk_count - 1; 1 <= jj; jj -= 1) {
         rnd_arr[jj + jj] = rnd_arr[jj];
         rnd_arr[jj + jj - 1] = 0;
      }
      jj = cxlc_knuth_kk_count + cxlc_knuth_kk_count - 2;
      dd = cxlc_knuth_kk_count + cxlc_knuth_ll - 2;
      kk = cxlc_knuth_kk_count - 2;
      while (0 <= kk) {
         rndx = rnd_arr[dd] - rnd_arr[jj];
         rnd_arr[dd] = bitwiseand(rndx,cxlc_knuth_max);
         rndx = rnd_arr[kk] - rnd_arr[jj];
         rnd_arr[kk] = bitwiseand(rndx,cxlc_knuth_max);
         dd -= 1;
         kk -= 1;
         jj -= 1;
      }
      if (isodd(rndss)) {
         for (jj = cxlc_knuth_kk_count; 1 <= jj; jj -= 1) {
            rnd_arr[jj] = rnd_arr[jj - 1];
         }
         rnd_arr[0] = rnd_arr[cxlc_knuth_kk_count];
         jj = rnd_arr[cxlc_knuth_ll] - rnd_arr[0];
         rnd_arr[cxlc_knuth_ll] = bitwiseand(cxlc_knuth_max,jj);
         rndss = lf_shiftr(rndss,1);
      } else if (rndss == 0) {
         tt -= 1;
      } else {
         rndss = lf_shiftr(rndss,1);
      }
   }
   kk = (cxlc_knuth_kk_count - cxlc_knuth_ll);
   jj = 0;
   while (jj < cxlc_knuth_ll) {
      lv_ran_x_arr[kk] = rnd_arr[jj];
      kk += 1;
      jj += 1;
   }
   kk = 0;
   while (jj < cxlc_knuth_kk_count) {
      lv_ran_x_arr[kk] = rnd_arr[jj];
      kk += 1;
      jj += 1;
   }
   for (jj = 0; jj <= 9; jj += 1) {
      bcdummy = lf_ran_cycle(2 * cxlc_knuth_kk_count - 1);
   }
   scale = local_prev_scale;
   bcdummy = lf_fill_ranz();
   return 0;
}
define rand_init(seed) {
   auto sd_arr[];
   sd_arr[0] = floor(seed);
   sd_arr[1] = floor(frac(seed) * cxintmax);
   bcdummy = rand_init_array(2,sd_arr[]);
   return (seed);
}
define randl(nn) {
   auto max_allowed,rndm,retvalu,local_prev_scale;
   local_prev_scale = scale;
   scale = 0;
   max_allowed = cxlc_knuth_max - (cxlc_knuth_max % nn);
   for (;;) {
      rndm = lf_next_ranz();
      if (rndm < max_allowed) {
         break; # loop AWAIT
      }
   }
   retvalu = rndm % nn;
   scale = local_prev_scale;
   return (retvalu);
}
define randd() {
   return ((lf_next_ranz() + lf_next_ranz() / (cxlc_knuth_max\
         + 1.0)) / (cxlc_knuth_max + 1.0));
}
define int_pdf(nn,xx) {
   auto retvalu,mm;
   if (xx < 0.0 || nn < xx || (! isint(xx))) {
      retvalu = 0.0;
   } else {
      mm = floor(nn);
      if (isint(nn)) {
         if (xx < nn) {
            retvalu = 1.0 / nn;
         } else {
            retvalu = 0.0;
         }
      } else {
         if (xx < mm) {
            retvalu = 1.0 / nn;
         } else {
            retvalu = 1.0 - mm / nn;
         }
      }
   }
   return (retvalu);
}
define int_cdf(nn,xx) {
   auto retvalu,mm;
   if (xx <= 0.0) {
      retvalu = 0.0;
   } else if (nn <= xx) {
      retvalu = 1.0;
   } else {
      mm = floor(nn);
      if (xx < mm) {
         retvalu = (floor(xx) + 1) / nn;
      } else {
         retvalu = 1;
      }
   }
   return (retvalu);
}
define int_quantile(nn,prbx) {
   auto retvalu;
   if (prbx <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 - frac(nn) / nn <= prbx) {
      retvalu = ceil(nn - 1);
   } else {
      retvalu = floor(nn * prbx + 1);
   }
   return (retvalu);
}
define int_rand(nn) {
   auto retvalu;
   if (nn <= 1) {
      retvalu = 0;
   } else {
      retvalu = floorl(randd() * nn);
   }
   return (retvalu);
}
define normal_pdf(xx) {
   return (exp(-xx * xx / 2.0) / (sqrt(cxtau)));
}
define normal_cdf(xx) {
   return (erf(xx / cxsqrttwo) / 2.0 + 0.5);
}
define normal_cdf__1(xx) {
   auto retvalu,sum_curr,sum_prev,bb,xx_sqr,ii;
   if (xx <= -10.0) {
      retvalu = 0.0;
   } else if (10.0 <= xx) {
      retvalu = 1.0;
   } else if (iszero(xx)) {
      retvalu = 0.5;
   } else {
      sum_curr = 0.0;
      bb = 1.0 / xx;
      xx_sqr = xx * xx;
      ii = 0;
      for (;;) {
         bb *= xx_sqr / (2.0 * ii + 1.0);
         sum_prev = sum_curr;
         sum_curr += bb;
         if (iseq(sum_prev,sum_curr)) {
            break; # loop AWAIT
         }
         ii += 1;
      }
      retvalu = (sum_curr * exp(-0.5 * (xx_sqr + log(cxtau)))\
            + 0.5);
   }
   return (retvalu);
}
define normal_quantile(prbx) {
   return (cxsqrttwo * erfinv(2.0 * prbx - 1.0));
}
lv_rand_gau_magic = 0.0;
lv_rand_gau_prev = 0.0;
define normal_rand() {
   # local-use Bc lv_rand_gau_magic;
   # local-use Bc lv_rand_gau_prev;
   auto retvalu,uua,uub,ww;
   if (ismagic(lv_rand_gau_magic)) {
      lv_rand_gau_magic = magicnot();
      retvalu = lv_rand_gau_prev;
   } else {
      for (;;) {
         uua = randd() - 0.5;
         uub = randd() - 0.5;
         ww = uua * uua + uub * uub;
         if (isbetweenx(ww,0.0,0.25)) {
            break; # loop AWAIT
         }
      }
      ww = sqrt(-2.0 * log(4.0 * ww) / ww);
      lv_rand_gau_prev = uub * ww;
      lv_rand_gau_magic = magicset();
      retvalu = uua * ww;
   }
   return (retvalu);
}
define gau_pdf(xx) {
   return (normal_pdf(xx));
}
define gau_cdf(xx) {
   return (normal_cdf(xx));
}
define gau_quantile(prbx) {
   return (normal_quantile(prbx));
}
define gau_rand() {
   return (normal_rand());
}
define normal_quantile__1(prbx) {
   auto retvalu,p_low,qq,rr,denom,numer;
   p_low = 0.02425;
   if (prbx <= 0.0) {
      retvalu = -(cxdblmax);
   } else if (1.0 <= prbx) {
      retvalu = cxdblmax;
   } else if (p_low <= prbx && prbx <= 1.0 - p_low) {
      qq = prbx - 0.5;
      rr = qq * qq;
      numer = ((((((-(3.96968302866538 * 10^1)) * rr +\
            (2.20946098424521 * 10^2)) * rr -\
            (2.75928510446969 * 10^2)) * rr +\
            (1.38357751867269 * 10^2)) * rr -\
            (3.06647980661472 * 10^1)) * rr +\
            (2.50662827745924 * 10^0));
      denom = ((((((-(5.44760987982241 * 10^1)) * rr +\
            (1.61585836858041 * 10^2)) * rr -\
            (1.55698979859887 * 10^2)) * rr +\
            (6.68013118877197 * 10^1)) * rr -\
            (1.32806815528857 * 10^1)) * rr + 1.0);
      retvalu = (qq * numer / denom);
   } else {
      if (prbx < p_low) {
         rr = sqrt(-2.0 * log(prbx));
         qq = 1.0;
      } else {
         rr = sqrt(-2.0 * log(1 - prbx));
         qq = -1.0;
      }
      numer = ((((((-(7.78489400243029 * 10^-3)) * rr -\
            (3.22396458041136 * 10^-1)) * rr -\
            (2.40075827716184 * 10^0)) * rr -\
            (2.54973253934373 * 10^0)) * rr +\
            (4.37466414146497 * 10^0)) * rr +\
            (2.93816398269878 * 10^0));
      denom = (((((7.78469570904146 * 10^-3) * rr +\
            (3.22467129070040 * 10^-1)) * rr +\
            (2.44513413714300 * 10^0)) * rr +\
            (3.75440866190742 * 10^0)) * rr + 1.0);
      retvalu = qq * numer / denom;
   }
   return (retvalu);
}
define uni_pdf(max_x,xx) {
   auto retvalu;
   if (max_x <= 0.0 || xx <= 0.0 || max_x <= xx) {
      retvalu = 0.0;
   } else {
      retvalu = 1.0 / max_x;
   }
   return (retvalu);
}
define uni_cdf(max_x,xx) {
   auto retvalu;
   if (max_x <= 0.0 || xx < 0.0) {
      retvalu = 0.0;
   } else if (max_x < xx) {
      retvalu = 1.0;
   } else {
      retvalu = xx / max_x;
   }
   return (retvalu);
}
define uni_quantile(max_x,prbx) {
   auto retvalu;
   if (prbx < 0.0 || max_x <= 0.0) {
      retvalu = 0.0;
   } else if (max_x < prbx) {
      retvalu = 1.0;
   } else {
      retvalu = prbx * max_x;
   }
   return (retvalu);
}
define uni_rand(max_x) {
   return (uni_quantile(max_x,randd()));
}
define exp_pdf(scal,xx) {
   auto retvalu;
   if (xx < 0.0 || scal <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = scal * exp(-scal * xx);
   }
   return (retvalu);
}
define exp_cdf(scal,xx) {
   auto retvalu;
   if (xx < 0.0 || scal <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = 1.0 - exp(-scal * xx);
   }
   return (retvalu);
}
define exp_quantile(scal,prbx) {
   auto retvalu;
   if (prbx <= 0.0 || scal <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= prbx) {
      retvalu = cxdblmax;
   } else {
      retvalu = -log(1.0 - prbx) / scal;
   }
   return (retvalu);
}
define exp_rand(scal) {
   return (- log(randd()) / scal);
}
define poi_pdf(meanx,xx) {
   auto kk,retvalu;
   if (xx < 0.0 || meanx <= 0.0) {
      retvalu = 0.0;
   } else {
      kk = floor(xx);
      retvalu = pow(meanx,kk) * exp(-meanx) / factorial(kk);
   }
   return (retvalu);
}
define poi_cdf(meanx,xx) {
   auto ii,kk,sum,term,retvalu;
   if (xx <= 0.0 || meanx <= 0.0) {
      retvalu = 0.0;
   } else if (1000.0 < xx / meanx) {
      retvalu = 1;
   } else {
      term = exp(-meanx);
      sum = term;
      kk = floorl(xx);
      for (ii = 1; ii <= kk; ii += 1) {
         term *= meanx / ii;
         sum += term;
      }
      retvalu = sum;
   }
   return (retvalu);
}
define poi_quantile(meanx,prbx) {
   auto ii,sum,prevsum,term,retvalu;
   if (prbx <= 0.0 || meanx <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= prbx) {
      retvalu = cxdblmax;
   } else {
      prevsum = 0.0;
      term = exp(-meanx);
      sum = term;
      ii = 0;
      while (sum <= prbx) {
         ii += 1;
         term *= meanx / ii;
         prevsum = sum;
         sum += term;
      }
      if (sum - prbx < prbx - prevsum) {
         retvalu = ii;
      } else {
         retvalu = ii - 1;
      }
   }
   return (retvalu);
}
define poi_rand(meanx) {
   auto prob,poi,sum,nn;
   prob = randd();
   poi = exp(-meanx);
   sum = poi;
   nn = 0;
   while (sum < prob) {
      nn += 1;
      poi *= 1.0 * meanx / nn;
      sum += poi;
   }
   return (nn);
}
define geo_pdf(prob,kk) {
   auto retvalu;
   if (kk < 0 || prob < 0.0 || 1.0 <= prob) {
      retvalu = 0.0;
   } else {
      retvalu = pow(1.0 - prob,kk) * prob;
   }
   return (retvalu);
}
define geo_cdf(prob,kk) {
   auto retvalu;
   if (kk <= -1 || prob < 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= prob) {
      retvalu = 1.0;
   } else {
      retvalu = 1.0 - pow(1.0 - prob,kk + 1);
   }
   return (retvalu);
}
define geo_quantile(prob,prbx) {
   auto retvalu;
   if (prbx <= 0.0 || 1.0 <= prbx || prob <= 0.0 || 1.0 <=\
         prob) {
      retvalu = 0.0;
   } else {
      retvalu = log(1.0 - prbx) / log(1.0 - prob) - 1.0;
   }
   return (retvalu);
}
define geo_rand(prob) {
   return (floorl(log(randd()) / log(1.0 - prob)));
}
define cauchy_pdf(scal,xx) {
   return (1.0 / (cxpi * scal * (1 + (square(xx / scal)))));
}
define cauchy_cdf(scal,xx) {
   return (taninv(xx / scal) / cxpi + 0.5);
}
define cauchy_quantile(scal,prbx) {
   return (scal * tan((prbx - 0.5) * cxpi));
}
define cauchy_rand(scal) {
   return (cauchy_quantile(scal,randd()));
}
define logistic_pdf(ss,xx) {
   auto exs,retvalu;
   if (ss <= 0.0) {
      retvalu = 0.0;
   } else {
      exs = exp(-xx / ss);
      retvalu = exs / (ss * pow(1.0 + exs,2.0));
   }
   return (retvalu);
}
define logistic_cdf(ss,xx) {
   auto retvalu;
   if (ss <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = 1.0 / (1.0 + exp(-xx / ss));
   }
   return (retvalu);
}
define logistic_quantile(ss,prbx) {
   auto retvalu;
   if (prbx <= 0.0 || ss <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= prbx) {
      retvalu = 1.0;
   } else {
      retvalu = -ss * log(1.0 / prbx - 1.0);
   }
   return (retvalu);
}
define logistic_rand(ss) {
   return (- ss * log(1.0 / randd() - 1.0));
}
define tri_pdf(pp,xx) {
   auto retvalu;
   if (pp < 0.0 || 1.0 < pp) {
      retvalu = 0.0;
   } else {
      if (xx < 0.0 || 1.0 < xx) {
         retvalu = 0.0;
      } else if (xx < pp) {
         retvalu = divi(2.0 * xx,pp,2.0);
      } else {
         retvalu = divi(2.0 * (1.0 - xx),1.0 - pp,2.0);
      }
   }
   return (retvalu);
}
define tri_cdf(pp,xx) {
   auto retvalu;
   if (pp < 0.0 || 1.0 < pp) {
      retvalu = 0.0;
   } else {
      if (xx <= 0.0) {
         retvalu = 0.0;
      } else if (xx < pp) {
         retvalu = xx * xx / pp;
      } else if (xx < 1.0) {
         retvalu = 1.0 - square(1.0 - xx) / (1.0 - pp);
      } else {
         retvalu = 1.0;
      }
   }
   return (retvalu);
}
define tri_quantile(pp,prbx) {
   auto retvalu;
   if (pp < 0.0 || 1.0 < pp) {
      retvalu = 0.0;
   } else {
      if (prbx <= 0.0) {
         retvalu = 0.0;
      } else if (prbx < pp) {
         retvalu = sqrt(prbx * pp);
      } else if (prbx < 1.0) {
         retvalu = 1.0 - sqrt((1.0 - prbx) * (1.0 - pp));
      } else {
         retvalu = 1.0;
      }
   }
   return (retvalu);
}
define tri_rand(pp) {
   auto xx,yy;
   xx = randd();
   yy = randd();
   if (xx < pp) {
      if (2.0 * xx < pp * yy) {
         xx = pp - xx;
      }
   } else {
      if ((pp - 1.0) * yy < 2.0 * (xx - 1.0)) {
         xx = (pp + 1.0) - xx;
      }
   }
   return (xx);
}
define trap_pdf(para,parb,xx) {
   auto retvalu;
   if (xx < 0.0 || 1.0 < xx || para < 0.0 || parb < para ||\
         1.0 < parb) {
      retvalu = 0.0;
   } else {
      if (xx < para) {
         retvalu = xx / para;
      } else if (xx <= parb) {
         retvalu = 1.0;
      } else {
         retvalu = (1.0 - xx) / (1.0 - parb);
      }
   }
   return (retvalu * 2.0 / (1.0 + parb - para));
}
define trap_cdf(para,parb,xx) {
   auto mm,retvalu;
   if (para < 0.0 || parb < para || 1.0 < parb) {
      retvalu = 0.0;
   } else if (xx <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= xx) {
      retvalu = 1.0;
   } else {
      mm = 2.0 / (1.0 + parb - para);
      if (xx < para) {
         retvalu = mm * xx * xx / (2.0 * para);
      } else if (xx < parb) {
         retvalu = mm * (xx - para / 2.0);
      } else {
         retvalu = 1.0 - mm * square(1.0 - xx) / (2.0 * (1.0\
               - parb));
      }
   }
   return (retvalu);
}
define trap_quantile(para,parb,prbx) {
   auto mm,retvalu;
   if (para < 0.0 || parb < para || 1.0 < parb) {
      retvalu = 0.0;
   } else if (prbx <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= prbx) {
      retvalu = 1.0;
   } else {
      mm = 2.0 / (1.0 + parb - para);
      if (prbx < para * mm / 2.0) {
         retvalu = sqrt((2.0 * para * prbx) / mm);
      } else if (prbx < 1.0 - mm * (1.0 - parb) / 2.0) {
         retvalu = prbx / mm + para / 2.0;
      } else {
         retvalu = 1.0 - cxsqrttwo * sqrt((1.0 - parb) * (1.0\
               - prbx) / mm);
      }
   }
   return (retvalu);
}
define trap_rand(para,parb) {
   auto xx,retvalu;
   retvalu = -1;
   for (;;) {
      xx = randd();
      if (xx < para) {
         if (randd() * para < xx) {
            retvalu = xx;
         }
      } else if (xx <= parb) {
         retvalu = xx;
      } else {
         if (randd() * (1.0 - parb) < (1.0 - xx)) {
            retvalu = xx;
         }
      }
      if (0.0 <= retvalu) {
         break; # loop AWAIT
      }
   }
   return (retvalu);
}
define pareto_pdf(shap,scal,xx) {
   return (shap * pow(scal / xx,shap) / xx);
}
define pareto_cdf(shap,scal,xx) {
   return (1.0 - pow(scal / xx,shap));
}
define pareto_quantile(shap,scal,prbx) {
   return (scal / pow(1.0 - prbx,1.0 / shap));
}
define pareto_rand(shap,scal) {
   return (scal / pow(randd(),1.0 / shap));
}
define gompertz_pdf(shap,scal,xx) {
   return (scal * shap * exp(shap + scal * xx - shap *\
         exp(scal * xx)));
}
define gompertz_cdf(shap,scal,xx) {
   return (1.0 - exp(-shap * (exp(scal * xx) - 1)));
}
define gompertz_quantile(shap,scal,prbx) {
   return (log(1 - log(1.0 - prbx) / shap) / scal);
}
define gompertz_rand(shap,scal) {
   return (gompertz_quantile(shap,scal,randd()));
}
define zipf_pdf(ss,max_kk,kk) {
   auto retvalu;
   if (kk <= 0.0 || max_kk < kk) {
      retvalu = 0.0;
   } else {
      retvalu = 1.0 / (pow(kk,ss) * hnm(max_kk,ss));
   }
   return (retvalu);
}
define zipf_cdf(ss,max_kk,kk) {
   auto retvalu;
   if (kk <= 0.0) {
      retvalu = 0.0;
   } else if (max_kk < kk) {
      retvalu = 1.0;
   } else {
      retvalu = hnm(kk,ss) / hnm(max_kk,ss);
   }
   return (retvalu);
}
define zipf_quantile(ss,max_kk,prbx) {
   auto ii,summ,target;
   target = prbx * hnm(max_kk,ss);
   summ = 0.0;
   ii = 1;
   for (;;) {
      summ += 1.0 / pow(ii,ss);
      if (target <= summ) {
         break; # loop AWAIT
      }
      ii += 1;
   }
   return (ii);
}
define zipf_rand(ss,max_kk) {
   return (zipf_quantile(ss,max_kk,randd()));
}
define beta_pdf(shap_a,shap_b,xx) {
   return (pow(xx,shap_a - 1.0) * pow((1.0 - xx),shap_b -\
         1.0) / beta(shap_a,shap_b));
}
define beta_cdf(shap_a,shap_b,xx) {
   return (betainc(shap_a,shap_b,xx));
}
define beta_quantile(shap_a,shap_b,prbx) {
   auto retvalu,scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,\
         scvx_dy,scvx_ii;
   if (prbx <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= prbx) {
      retvalu = 1.0;
   } else {
      scvx_dx = 0.50;
      scvx_xx = 0.25;
      scvx_yy = prbx - beta_cdf(shap_a,shap_b,scvx_xx);
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = prbx - beta_cdf(shap_a,shap_b,scvx_xx);
         scvx_dy = (scvx_yy - scvx_yp);
         if (iszero(scvx_dy)) {
            break;
         }
         scvx_dx *= - scvx_yy / scvx_dy;
      }
      retvalu = scvx_xx;
   }
   return (retvalu);
}
define beta_rand(shap_a,shap_b) {
   return (beta_quantile(shap_a,shap_b,randd()));
}
define gamma_pdf(shap,xx) {
   auto retvalu;
   if (xx <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = exp(log(xx) * (shap - 1.0) - xx) / tgamma(shap);
   }
   return (retvalu);
}
define gamma_cdf(shap,xx) {
   auto retvalu,rr,ii,sum;
   if (xx <= 0.0 || shap <= 0.0) {
      retvalu = 0.0;
   } else if (isint(shap)) {
      sum = 1.0;
      rr = 1.0;
      for (ii = 1; ii <= shap - 1; ii += 1) {
         rr *= xx / ii;
         sum += rr;
      }
      retvalu = 1.0 - exp(-xx) * sum;
   } else {
      retvalu = rligamma(shap,xx);
   }
   return (retvalu);
}
define gamma_rand(shap) {
   auto i_shape,f_shape,rval,jj,ee,gg,yy,ff,xx,vv,\
         qq,pp;
   i_shape = floor(shap);
   rval = 1.0;
   if (shap < 5) {
      for (jj = 1; jj <= i_shape; jj += 1) {
         rval *= randd();
      }
      rval = -log(rval);
      f_shape = shap - i_shape;
      if (0.00001 < f_shape) {
         pp = cxe / (f_shape + cxe);
         for (;;) {
            vv = log(randd());
            if (randd() < pp) {
               xx = exp(vv / f_shape);
               qq = exp(-xx);
            } else {
               xx = 1.0 - vv;
               qq = exp(log(xx) * (f_shape - 1));
            }
            if (randd() < qq) {
               break; # loop AWAIT
            }
         }
         rval += xx;
      }
   } else {
      ee = shap - 1.0;
      gg = sqrt(shap + ee);
      yy = 0.0;
      ff = 0.0;
      while (rval <= 0.0 || (1.0 + yy * yy) * exp(ee *\
            log(rval / ee) - ff) < randd()) {
         xx = cxpi * randd();
         yy = sin(xx) / cos(xx);
         ff = gg * yy;
         rval = ff + ee;
      }
   }
   return (rval);
}
define chisqr_pdf(df,xx) {
   auto retvalu;
   if (xx <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = (exp((log(xx / 2.0) * df - xx) / 2.0) / (xx *\
            tgamma(df / 2.0)));
   }
   return (retvalu);
}
define chisqr_cdf(df,xx) {
   auto retvalu;
   if (xx <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = (1.0 - ruigamma(df / 2.0,xx / 2.0));
   }
   return (retvalu);
}
define chisqr_rand(df) {
   auto sum,vv,jj;
   sum = 0.0;
   for (jj = 1; jj <= df; jj += 1) {
      vv = gau_rand();
      sum += vv * vv;
   }
   if (! isint(df)) {
      sum += gamma_rand(frac(df) / 2.0) * 2.0;
   }
   return (sum);
}
define binomial_pdf(prob,success,trial) {
   auto retvalu;
   if (success < 0 || trial < success) {
      retvalu = 0.0;
   } else {
      retvalu = comb(trial,success) * pow(prob,success) *\
            pow(1.0 - prob,trial - success);
   }
   return (retvalu);
}
define binomial_cdf(prob,success,trial) {
   auto lsum,sfactor,ss,mu,kk;
   if (prob <= 0.0 || success < 0) {
      lsum = 0.0;
   } else if (1.0 <= prob || trial <= success) {
      lsum = 1.0;
   } else {
      if (trial <= 2 * success) {
         ss = trial - success - 1;
         prob = 1.0 - prob;
      } else {
         ss = success;
      }
      sfactor = pow(1.0 - prob,trial);
      mu = prob / (1.0 - prob);
      lsum = 0.0;
      for (kk = 0; kk <= ss; kk += 1) {
         lsum += sfactor;
         sfactor *= (mu * (trial - kk)) / (kk + 1.0);
      }
      if (ss != success) {
         lsum = 1.0 - lsum;
      }
   }
   return (lsum);
}
define binomial_rand(prob,rr) {
   auto successes;
   successes = 0.0;
   while (0 < rr) {
      if (randd() < prob) {
         successes += 1;
      }
      rr -= 1;
   }
   return (successes);
}
define benford_pdf(max_kk,kk) {
   auto retvalu;
   if (kk <= 0.0 || max_kk <= kk) {
      retvalu = 0.0;
   } else {
      retvalu = log(1.0 + 1.0 / kk) / log(max_kk);
   }
   return (retvalu);
}
define benford_cdf(max_kk,kk) {
   auto retvalu;
   if (kk <= 0.0) {
      retvalu = 0.0;
   } else if (max_kk <= kk) {
      retvalu = 1.0;
   } else {
      retvalu = log(kk + 1.0) / log(max_kk);
   }
   return (retvalu);
}
define benford_rand(max_kk) {
   auto ii,summ,target;
   target = randd();
   summ = 0.0;
   ii = 1;
   for (;;) {
      summ += log(1.0 + 1.0 / ii) / log(max_kk);
      if (target <= summ) {
         break; # loop AWAIT
      }
      ii += 1;
   }
   return (ii);
}
define nbd_pdf(prob,rsuccesses,kfailures) {
   return (comb(rsuccesses + kfailures - 1,kfailures) *\
         pow(1.0 - prob,kfailures) * pow(prob,rsuccesses));
}
define nbd_cdf(prob,rsuccesses,kfailures) {
   return (1.0 - betainc(kfailures + 1,rsuccesses,1.0 - prob));
}
define nbd_rand(prob,rsuccesses) {
   auto failures,rr;
   rr = rsuccesses;
   failures = 0;
   while (0 < rr) {
      if (randd() <= prob) {
         rr -= 1;
      } else {
         failures += 1;
      }
   }
   return (failures);
}
define polya_pdf(prob,rsuccesses,kfailures) {
   return (combx(rsuccesses + kfailures - 1,kfailures) *\
         pow(1.0 - prob,kfailures) * pow(prob,rsuccesses));
}
define polya_cdf(prob,rsuccesses,kfailures) {
   return (1.0 - betainc(kfailures + 1,rsuccesses,1.0 - prob));
}
define polya_rand(tt,prob) {
   auto nn,mm,rr,uu,qq;
   nn = 0;
   mm = tt - 1;
   qq = exp(tt * log(prob));
   rr = qq;
   uu = randd();
   while (rr <= uu) {
      nn += 1;
      mm += 1;
      qq *= (1.0 - prob) * mm / nn;
      rr += qq;
   }
   return (nn);
}
define zeta_pdf(ss,xx) {
   auto retvalu;
   if (xx <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = 1.0 / (zeta(ss) * pow(xx,ss));
   }
   return (retvalu);
}
define zeta_cdf(ss,xx) {
   auto retvalu;
   if (xx <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = hnm(xx,ss) / zeta(ss);
   }
   return (retvalu);
}
define ks_cdf(nn,xx) {
   auto retvalu,two_tt_sqr,kk,sum,tt;
   if (nn <= 0 || xx <= 0.0) {
      retvalu = 0.0;
   } else {
      if (30 < nn) {
         tt = xx;
         two_tt_sqr = 2.0 * tt * tt;
         retvalu = 1.0 - exp(-two_tt_sqr) * (1.0 - 2.0 * tt /\
               (3.0 * sqrt(nn)) - two_tt_sqr * (two_tt_sqr /\
               9.0 - 1.0 / 3.0) / nn);
      } else {
         tt = xx * sqrt(nn);
         sum = 0.0;
         kk = nn;
         while (tt < kk) {
            sum += comb(nn,kk) * pow(kk - tt,kk) * pow(tt +\
                  nn - kk,nn - kk - 1);
            kk -= 1;
         }
         retvalu = 1.0 - sum * tt / pow(nn,nn);
      }
   }
   return (retvalu);
}
define ks_a_cdf(xx) {
   auto sum,sum_prev,vv,kk,retvalu;
   if (xx < 0.0001) {
      retvalu = 0.0;
   } else {
      sum = 0.0;
      vv = -square(cxpi / xx) / 8.0;
      kk = 1;
      for (;;) {
         sum_prev = sum;
         sum += exp(vv * kk * kk);
         if (iseq(sum,sum_prev)) {
            break; # loop AWAIT
         }
         kk += 2;
      }
      retvalu = sum * sqrt(cxtau) / xx;
   }
   return (retvalu);
}
define ks_b_cdf(nn,xx) {
   auto retvalu,nxx;
   if (xx < 0.0001 || nn <= 0) {
      retvalu = 0.0;
   } else {
      nxx = xx + (2.0 * sqrt(nn) + 3.0 * xx - 3.0) / (12.0 * nn);
      retvalu = ks_a_cdf(nxx);
   }
   return (retvalu);
}
define ks_quantile(nn,prbx) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_dy,\
         scvx_ii;
   if (! isbetween(prbx,0.0,1.0)) {
      scvx_xx = 0.0;
   } else {
      scvx_dx = 0.5;
      scvx_xx = 0.25;
      scvx_yy = prbx - ks_cdf(nn,scvx_xx);
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = prbx - ks_cdf(nn,scvx_xx);
         scvx_dy = (scvx_yy - scvx_yp);
         if (iszero(scvx_dy)) {
            break;
         }
         scvx_dx *= - scvx_yy / scvx_dy;
      }
   }
   return (scvx_xx);
}
define t_pdf(dfn,xx) {
   return (tgamma((dfn + 1.0) / 2.0) * pow((1.0 + square(xx)\
         / dfn),(-(dfn + 1.0) / 2.0)) / (sqrt(dfn * cxpi) *\
         tgamma(dfn / 2.0)));
}
define lf_subtprob(nnx,xx) {
   auto aa,bb,ww,zz,yy,ii,nn,retvalu;
   nn = floorl(abs(nnx));
   ww = atan2(xx,sqrt(nn));
   zz = square(cos(ww));
   yy = 1.0;
   ii = nn - 2.0;
   while (2.0 <= ii) {
      yy = 1.0 + (ii - 1.0) / ii * zz * yy;
      ii -= 2.0;
   }
   if (iseven(nn)) {
      aa = sin(ww) / 2.0;
      bb = 0.5;
   } else {
      if (nn == 1) {
         aa = 0.0;
      } else {
         aa = sin(ww) * cos(ww) / cxpi;
      }
      bb = 0.5 + ww / cxpi;
   }
   retvalu = bb + aa * yy;
   if (1.0 < retvalu) {
      retvalu = 1.0;
   }
   return (retvalu);
}
define t_cdf(dfx,xx) {
   return (lf_subtprob(dfx,xx));
}
define lf_t_quantile(ndfx,prbx) {
   auto ux,uxsq,aa_x,bb_x,cc_x,dd_x,ee_x,retvalu,\
         delta,pp_a,nn_a,out_sign;
   if (prbx < 0.5) {
      prbx = 1.0 - prbx;
      out_sign = -1;
   } else {
      out_sign = 1;
   }
   ux = normal_quantile(prbx);
   uxsq = square(ux);
   aa_x = ((1.0) * uxsq + 1.0) / 4.0;
   bb_x = (((5.0) * uxsq + 16.0) * uxsq + 3.0) / 96.0;
   cc_x = ((((3.0) * uxsq + 19.0) * uxsq + 17.0) * uxsq -\
         15.0) / 384.0;
   dd_x = (((((79.0) * uxsq + 776.0) * uxsq + 1482.0) * uxsq\
         - 1920.0) * uxsq - 945.0) / 92160.0;
   ee_x = ((((((27.0) * uxsq + 339.0) * uxsq + 930.0) * uxsq\
         - 1782.0) * uxsq - 765.0) * uxsq - 17955.0) / 368640.0;
   retvalu = ux * (1.0 + (aa_x + (bb_x + (cc_x + (dd_x + ee_x\
         / ndfx) / ndfx) / ndfx) / ndfx) / ndfx);
   if (ndfx <= square(log10(prbx)) + 3.0) {
      nn_a = ndfx + 1.0;
      for (;;) {
         pp_a = lf_subtprob(ndfx,retvalu);
         ee_x = (nn_a * log(nn_a / (ndfx + square(retvalu)))\
               + log(ndfx / nn_a / cxtau) - 1.0 + (1.0 / nn_a\
               - 1.0 / ndfx) / 6.0) / 2.0;
         if (cxdblmaxln / 2.0 < ee_x) {
            delta = 0.0;
         } else {
            delta = (pp_a - prbx) / exp(ee_x);
         }
         retvalu -= delta;
         aa_x = abs(delta) * 10000.0;
         if (iszero(retvalu) || aa_x < retvalu) {
            break; # loop AWAIT
         }
      }
   }
   return (out_sign * retvalu);
}
define t_quantile(dfx,prbx) {
   auto ndfx,retvalu;
   ndfx = floor(abs(dfx));
   if (iszero(prbx - 0.5)) {
      retvalu = 0.0;
   } else if (prbx <= 0.0) {
      retvalu = -cxdblmax;
   } else if (1.0 <= prbx) {
      retvalu = cxdblmax;
   } else {
      retvalu = lf_t_quantile(ndfx,prbx);
   }
   return (retvalu);
}
define t_cdf__1(dfx,xx) {
   auto zz,yy;
   yy = sqrt(dfx + xx * xx);
   zz = (xx + yy) / (2.0 * yy);
   return (betainc__1(dfx / 2.0,dfx / 2.0,zz));
}
define t_quantile__1(dfx,prbx) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_dy,\
         scvx_ii;
   if (! isbetween(prbx,0.0,1.0)) {
      scvx_xx = 0.0;
   } else {
      scvx_dx = 0.5;
      scvx_xx = 0.25;
      scvx_yy = prbx - t_cdf(dfx,scvx_xx);
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = prbx - t_cdf(dfx,scvx_xx);
         scvx_dy = (scvx_yy - scvx_yp);
         if (iszero(scvx_dy)) {
            break;
         }
         scvx_dx *= - scvx_yy / scvx_dy;
      }
   }
   return (scvx_xx);
}
define f_cdf(dfn_a,dfn_b,xx) {
   auto aa,bb,gg;
   aa = dfn_a / 2.0;
   bb = dfn_b / 2.0;
   gg = aa * xx;
   return (beta_cdf(aa,bb,gg / (bb + gg)));
}
define lf_subfprob(dfn_a,dfn_b,xx) {
   auto retvalu,zx,ax,bx,yx,ix,pp_a;
   if (xx <= 0.0) {
      retvalu = 1.0;
   } else if (iseven(dfn_b)) {
      zx = dfn_b / (dfn_b + dfn_a * xx);
      ax = 1.0;
      for (ix = dfn_b - 2; 2 <= ix; ix -= 2) {
         ax = 1.0 + (dfn_a + ix - 2.0) / ix * zx * ax;
      }
      retvalu = 1.0 - (pow(1.0 - zx,dfn_a / 2.0) * ax);
   } else if (iseven(dfn_a)) {
      zx = dfn_a * xx / (dfn_b + dfn_a * xx);
      ax = 1.0;
      for (ix = dfn_a - 2; 2 <= ix; ix -= 2) {
         ax = 1.0 + (dfn_b + ix - 2.0) / ix * zx * ax;
      }
      retvalu = pow(1.0 - zx,dfn_b / 2.0) * ax;
   } else {
      yx = atan2(sqrt(dfn_a * xx / dfn_b),1.0);
      zx = square(sin(yx));
      if (dfn_a == 1) {
         ax = 0.0;
      } else {
         ax = 1.0;
      }
      for (ix = dfn_a - 2; 3 <= ix; ix -= 2) {
         ax = 1.0 + (dfn_b + ix - 2.0) / ix * zx * ax;
      }
      bx = cxpi;
      for (ix = 2; ix <= dfn_b - 1; ix += 2) {
         bx *= (ix - 1.0) / ix;
      }
      pp_a = 2.0 / bx * sin(yx) * pow(cos(yx),dfn_b) * ax;
      zx = square(cos(yx));
      if (dfn_b == 1) {
         ax = 0.0;
      } else {
         ax = 1.0;
      }
      for (ix = dfn_b - 2; 3 <= ix; ix -= 2) {
         ax = 1.0 + (ix - 1.0) / ix * zx * ax;
      }
      retvalu = (pp_a + 1.0 - (4.0 / cxtau) * (yx + sin(yx) *\
            cos(yx) * ax));
      if (retvalu < 0.0) {
         retvalu = 0.0;
      }
   }
   return (retvalu);
}
define lf_subf_two(nx,mm,pp) {
   auto uu,nx_sub_two,xx_prev,xx,zz;
   uu = chisqr_cdf(nx,pp);
   nx_sub_two = nx - 2.0;
   xx = (uu / nx * (1.0 + ((uu - nx_sub_two) / 2.0 + (((4.0 *\
         uu - 11.0 * nx_sub_two) * uu + nx_sub_two * (7.0 *\
         nx - 10.0)) / 24.0 + (((2.0 * uu - 10.0 *\
         nx_sub_two) * uu + nx_sub_two * (17.0 * nx - 26.0))\
         * uu - nx_sub_two * nx_sub_two * (9.0 * nx - 6.0)) /\
         48.0 / mm) / mm) / mm));
   for (;;) {
      if (xx <= 0.0) {
         break;
      }
      zz = exp(((nx + mm) * log((nx + mm) / (nx * xx + mm)) +\
            (nx - 2.0) * log(xx) + log(nx * mm / (nx + mm)) -\
            cxlntwo - log(cxtau) - (1.0 / nx + 1.0 / mm - 1.0\
            / (nx + mm)) / 6.0) / 2.0);
      xx_prev = xx;
      xx += (lf_subfprob(nx,mm,xx) - pp) / zz;
      if (iswithin(xx,xx_prev,0.00001)) {
         break; # loop AWAIT
      }
   }
   return (xx);
}
define lf_subfx(nx,mm,pp) {
   auto retvalu,uu,aa;
   if (iseq(pp,1.0)) {
      retvalu = 0.0;
   } else if (mm == 0) {
      retvalu = 1.0 / square(t_quantile(nx,0.5 - pp / 2.0));
   } else if (nx == 1) {
      retvalu = square(t_quantile(mm,pp / 2.0));
   } else if (mm == 2) {
      uu = chisqr_cdf(mm,1.0 - pp);
      aa = mm - 2.0;
      retvalu = 1.0 / (uu / mm * (1.0 + ((uu - aa) / 2.0 +\
            (((4.0 * uu - 11.0 * aa) * uu + aa * (7.0 * mm -\
            10.0)) / 24.0 + (((2.0 * uu - 10.0 * aa) * uu +\
            aa * (17.0 * mm - 26.0)) * uu - aa * aa * (9.0 *\
            mm - 6.0)) / 48.0 / nx) / nx) / nx));
   } else if (mm < nx) {
      retvalu = 1.0 / lf_subf_two(mm,nx,1.0 - pp);
   } else {
      retvalu = lf_subf_two(nx,mm,pp);
   }
   return (retvalu);
}
define f_quantile(dfn_a,dfn_b,prbx) {
   return (lf_subfx(dfn_a,dfn_b,1.0 - prbx));
}
define f_quantile__1(dfn_a,dfn_b,prbx) {
   auto retvalu,scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,\
         scvx_dy,scvx_ii;
   if (prbx <= 0.0) {
      retvalu = 0.0;
   } else if (1.0 <= prbx) {
      retvalu = 1.0;
   } else {
      scvx_dx = 0.50;
      scvx_xx = 0.25;
      scvx_yy = prbx - f_cdf(dfn_a,dfn_b,scvx_xx);
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = prbx - f_cdf(dfn_a,dfn_b,scvx_xx);
         scvx_dy = (scvx_yy - scvx_yp);
         if (iszero(scvx_dy)) {
            break;
         }
         scvx_dx *= - scvx_yy / scvx_dy;
      }
      retvalu = scvx_xx;
   }
   return (retvalu);
}
define mb_pdf(aa,xx) {
   return (sqrt(4 / cxtau) * xx * xx * exp(-xx * xx / (2 * aa\
         * aa)) / (aa * aa * aa));
}
define mb_cdf(aa,xx) {
   return (erf(xx / (cxsqrttwo * aa)) - sqrt(4 / cxtau) * xx\
         * exp(-xx * xx / (2 * aa * aa)) / aa);
}
define maxwell_boltzmann_pdf(temperature,molecular_mass,\
      velocity) {
   auto aa;
   aa = sqrt(cxboltzmann * temperature / molecular_mass);
   return (mb_pdf(aa,velocity));
}
define maxwell_boltzmann_cdf(temperature,molecular_mass,\
      velocity) {
   auto aa;
   aa = sqrt(cxboltzmann * temperature / molecular_mass);
   return (mb_cdf(aa,velocity));
}
define maxwell_juttner_pdf(temperature,molecular_mass,\
      velocity) {
   auto gmm,bt,rtht,dn,retvalu;
   if (temperature <= 0.0 || velocity <= 0.0 || cxlight <=\
         velocity || molecular_mass <= 0.0) {
      retvalu = 0.0;
   } else {
      rtht = (molecular_mass * cxlight * cxlight) /\
            (cxboltzmann * temperature);
      bt = velocity / cxlight;
      gmm = 1.0 / topyh1(bt);
      dn = besskn(2,rtht);
      if (iszero(dn)) {
         retvalu = 0.0;
      } else {
         retvalu = gmm * gmm * bt * rtht * exp(-gmm * rtht) / dn;
      }
   }
   return (retvalu);
}
define blackbodyl_pdf(wavelen) {
   auto retvalu;
   if (wavelen <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = pow(wavelen,-5.0) / (exp(1.0 / wavelen) - 1.0);
   }
   return (retvalu * 15.0 / pow(cxpi,4.0));
}
define blackbodyf_pdf(freq) {
   auto retvalu;
   if (freq <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = pow(freq,3.0) / (exp(freq) - 1.0);
   }
   return (retvalu * 15.0 / pow(cxpi,4.0));
}
define ints_rand(nn,*prob_arr_pc[]) {
   auto sum,p_ind,rndm,hh;
   sum = 0.0;
   for (p_ind = 0; p_ind <= nn - 1; p_ind += 1) {
      sum += prob_arr_pc[p_ind];
   }
   rndm = randd();
   hh = 0.0;
   for (p_ind = 0; p_ind <= nn - 1; p_ind += 1) {
      hh += prob_arr_pc[p_ind] / sum;
      if (rndm < hh) {
         break;
      }
   }
   return (p_ind);
}
define lf_num2norm(numm) {
   auto retvalu;
   if (numm <= 1) {
      retvalu = 0.0;
   } else {
      retvalu = (3.0 * sqrt(log(numm)) - 1.4 - (0.5 *\
            log(numm) - 0.39) / numm);
   }
   return (retvalu);
}
define stdev2spread(numm,stdevx) {
   auto retvalu;
   if (numm <= 1 || iszero(stdevx)) {
      retvalu = 0.0;
   } else {
      retvalu = (stdevx * lf_num2norm(numm));
   }
   return (retvalu);
}
define spread2stdev(numm,spread) {
   auto retvalu;
   if (numm <= 1 || iszero(spread)) {
      retvalu = 0.0;
   } else {
      retvalu = (spread / lf_num2norm(numm));
   }
   return (retvalu);
}
define maxabs(nn,*data_arr_pc[]) {
   auto ii,maxaby,amaxaby,atemp;
   maxaby = data_arr_pc[0];
   amaxaby = abs(maxaby);
   for (ii = 1; ii <= nn - 1; ii += 1) {
      atemp = abs(data_arr_pc[ii]);
      if (amaxaby < atemp) {
         maxaby = data_arr_pc[ii];
         amaxaby = atemp;
      }
   }
   return (maxaby);
}
define minabs(nn,*data_arr_pc[]) {
   auto ii,minaby,aminaby,atemp;
   minaby = data_arr_pc[0];
   aminaby = abs(minaby);
   for (ii = 1; ii <= nn - 1; ii += 1) {
      atemp = abs(data_arr_pc[ii]);
      if (atemp < aminaby) {
         minaby = data_arr_pc[ii];
         aminaby = atemp;
      }
   }
   return (minaby);
}
define maxabsoffset(offset,nn,*data_arr_pc[]) {
   auto ii,maxaby,delta;
   maxaby = data_arr_pc[0] - offset;
   for (ii = 1; ii <= nn - 1; ii += 1) {
      delta = data_arr_pc[ii] - offset;
      if (abs(maxaby) < abs(delta)) {
         maxaby = delta;
      }
   }
   return (maxaby + offset);
}
define minabsoffset(offset,nn,*data_arr_pc[]) {
   auto ii,minaby,delta;
   minaby = data_arr_pc[0] - offset;
   for (ii = 1; ii <= nn - 1; ii += 1) {
      delta = data_arr_pc[ii] - offset;
      if (abs(delta) < abs(minaby)) {
         minaby = delta;
      }
   }
   return (minaby + offset);
}
define mini(num,*data_arr_pc[]) {
   auto curr,tmp,ii;
   curr = data_arr_pc[0];
   for (ii = 1; ii <= num - 1; ii += 1) {
      tmp = data_arr_pc[ii];
      if (tmp < curr) {
         curr = tmp;
      }
   }
   return (curr);
}
define maxi(num,*data_arr_pc[]) {
   auto curr,tmp,ii;
   curr = data_arr_pc[0];
   for (ii = 1; ii <= num - 1; ii += 1) {
      tmp = data_arr_pc[ii];
      if (curr < tmp) {
         curr = tmp;
      }
   }
   return (curr);
}
define maxmin(num,*data_arr_pc[],*ret_maxmin_arr_p[]) {
   auto tmp,ii,maxx,minn;
   minn = data_arr_pc[0];
   maxx = data_arr_pc[0];
   for (ii = 1; ii <= num - 1; ii += 1) {
      tmp = data_arr_pc[ii];
      if (minn < tmp) {
         minn = tmp;
      }
      if (tmp < maxx) {
         maxx = tmp;
      }
   }
   ret_maxmin_arr_p[0] = maxx;
   ret_maxmin_arr_p[1] = minn;
   return (maxx - minn);
}
define min2(value_a,value_b) {
   auto retvalu;
   if (value_a < value_b) {
      retvalu = value_a;
   } else {
      retvalu = value_b;
   }
   return (retvalu);
}
define max2(value_a,value_b) {
   auto retvalu;
   if (value_b < value_a) {
      retvalu = value_a;
   } else {
      retvalu = value_b;
   }
   return (retvalu);
}
define minabs2(value_a,value_b) {
   auto retvalu;
   if (abs(value_a) < abs(value_b)) {
      retvalu = value_a;
   } else {
      retvalu = value_b;
   }
   return (retvalu);
}
define maxabs2(value_a,value_b) {
   auto retvalu;
   if (abs(value_b) < abs(value_a)) {
      retvalu = value_a;
   } else {
      retvalu = value_b;
   }
   return (retvalu);
}
define variance(nn,*xx_arr_pc[]) {
   auto ii,delta,meanx,variancex;
   meanx = 0.0;
   variancex = 0.0;
   for (ii = 0; ii <= nn - 1; ii += 1) {
      delta = xx_arr_pc[ii] - meanx;
      meanx += delta / (ii + 1.0);
      variancex += delta * (xx_arr_pc[ii] - meanx);
   }
   if (2 <= nn) {
      variancex /= (nn - 1.0);
   } else {
      variancex = 0.0;
   }
   return (variancex);
}
define mean(nn,*xx_arr_pc[]) {
   auto ii,delta,meanx;
   meanx = 0.0;
   for (ii = 0; ii <= nn - 1; ii += 1) {
      delta = xx_arr_pc[ii] - meanx;
      meanx += delta / (ii + 1.0);
   }
   return (meanx);
}
cxlc_stts_num = 0;
cxlc_stts_mean = 1;
cxlc_stts_msq = 2;
cxlc_stts_max = 3;
cxlc_stts_min = 4;
cxlc_stts_magic = 5;
cxlc_stts_count = 6;
cxlc_stts_max_key = 100;
lv_sttx_mtrx[0][0] = 0;
define lf_stts_is_inited(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   auto vll,ii,jj,retvalu_bol;
   vll = lv_sttx_mtrx[0][cxlc_stts_magic];
   if (vll != magicset() && vll != magicnot()) {
      for (ii = 0; ii <= cxlc_stts_max_key - 1; ii += 1) {
         for (jj = 0; jj <= cxlc_stts_magic - 1; jj += 1) {
            lv_sttx_mtrx[ii][jj] = 0.0;
         }
         lv_sttx_mtrx[0][cxlc_stts_magic] = magicnot();
      }
   }
   if (cxlc_stts_max_key <= ix_hndl) {
      retvalu_bol = false;
   } else {
      vll = lv_sttx_mtrx[ix_hndl][cxlc_stts_magic];
      retvalu_bol = ismagic(vll);
   }
   return (retvalu_bol);
}
define lf_stts_find_empty() {
   auto ix_hndl;
   ix_hndl = 0;
   while (lf_stts_is_inited(ix_hndl)) {
      ix_hndl += 1;
   }
   if (cxlc_stts_max_key <= ix_hndl) {
      halt;
   }
   return (ix_hndl);
}
define stts_init(ix_hndl,n_count,meanx,var,minim,maxim) {
   # local-use Bc lv_sttx_mtrx[];
   lv_sttx_mtrx[ix_hndl][cxlc_stts_num] = n_count;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_mean] = meanx;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] = var * (n_count - 1.0);
   lv_sttx_mtrx[ix_hndl][cxlc_stts_min] = minim;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_max] = maxim;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_magic] = magicset();
   return (ix_hndl);
}
define stts_initx(ix_hndl,num_count,meanx,msq,minim,maxim) {
   # local-use Bc lv_sttx_mtrx[];
   lv_sttx_mtrx[ix_hndl][cxlc_stts_num] = num_count;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_mean] = meanx;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] = msq;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_min] = minim;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_max] = maxim;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_magic] = magicset();
   return (ix_hndl);
}
define stts_reset(ix_hndl) {
   return (stts_init(ix_hndl,0.0,0.0,0.0,1.0,0.0));
}
define stts_new() {
   auto ix_hndl;
   ix_hndl = lf_stts_find_empty();
   return (stts_reset(ix_hndl));
}
define stts_delete(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   lv_sttx_mtrx[ix_hndl][cxlc_stts_magic] = magicnot();
   return (ix_hndl);
}
define sttscount(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   return (lv_sttx_mtrx[ix_hndl][cxlc_stts_num]);
}
define sttsmean(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   return (lv_sttx_mtrx[ix_hndl][cxlc_stts_mean]);
}
define sttsmsq(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   return (lv_sttx_mtrx[ix_hndl][cxlc_stts_msq]);
}
define sttsmax(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   return (lv_sttx_mtrx[ix_hndl][cxlc_stts_max]);
}
define sttsmin(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   return (lv_sttx_mtrx[ix_hndl][cxlc_stts_min]);
}
define sttsmagic(ix_hndl) {
   # local-use Bc lv_sttx_mtrx[];
   return (lv_sttx_mtrx[ix_hndl][cxlc_stts_magic]);
}
define sttssum(ix_hndl) {
   return (sttsmean(ix_hndl) * sttscount(ix_hndl));
}
define sttsvar(ix_hndl) {
   auto retvalu;
   if (abs(sttscount(ix_hndl)) <= 1.0) {
      retvalu = 0.0;
   } else {
      retvalu = (sttsmsq(ix_hndl) / (abs(sttscount(ix_hndl) -\
            1.0)));
   }
   return (retvalu);
}
define sttsstdev(ix_hndl) {
   auto retvalu;
   if (sttscount(ix_hndl) <= 1.0) {
      retvalu = 0.0;
   } else {
      retvalu = (sqrt(sttsmsq(ix_hndl) / (sttscount(ix_hndl)\
            - 1.0)));
   }
   return (retvalu);
}
define sttsstdevmean(ix_hndl) {
   auto retvalu;
   if (sttscount(ix_hndl) <= 1.0 || sttsmsq(ix_hndl) <= 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = (sqrt(sttsmsq(ix_hndl)) / (sttscount(ix_hndl)\
            - 1.0));
   }
   return (retvalu);
}
define sttsspread(ix_hndl) {
   return (sttsmax(ix_hndl) - sttsmin(ix_hndl));
}
define stts_update(ix_hndl,new_data) {
   # local-use Bc lv_sttx_mtrx[];
   auto delta,numy;
   if (! lf_stts_is_inited(ix_hndl)) {
      halt;
   }
   delta = new_data - lv_sttx_mtrx[ix_hndl][cxlc_stts_mean];
   lv_sttx_mtrx[ix_hndl][cxlc_stts_num] += 1.0;
   numy = lv_sttx_mtrx[ix_hndl][cxlc_stts_num];
   lv_sttx_mtrx[ix_hndl][cxlc_stts_mean] += (delta / numy);
   lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] += (delta * (new_data\
         - lv_sttx_mtrx[ix_hndl][cxlc_stts_mean]));
   if ((numy < 2.0 || sttsspread(ix_hndl) < 0.0)) {
      lv_sttx_mtrx[ix_hndl][cxlc_stts_min] = new_data;
      lv_sttx_mtrx[ix_hndl][cxlc_stts_max] = new_data;
   } else {
      if (new_data < lv_sttx_mtrx[ix_hndl][cxlc_stts_min]) {
         lv_sttx_mtrx[ix_hndl][cxlc_stts_min] = new_data;
      }
      if (lv_sttx_mtrx[ix_hndl][cxlc_stts_max] < new_data) {
         lv_sttx_mtrx[ix_hndl][cxlc_stts_max] = new_data;
      }
   }
   return (delta);
}
define stts_downdate(ix_hndl,old_data) {
   auto delt,men;
   if (! lf_stts_is_inited(ix_hndl)) {
      halt;
   }
   men = lv_sttx_mtrx[ix_hndl][cxlc_stts_mean];
   delt = old_data - men;
   if (0.0 < lv_sttx_mtrx[ix_hndl][cxlc_stts_num]) {
      lv_sttx_mtrx[ix_hndl][cxlc_stts_num] -= 1;
      if (0.0 < lv_sttx_mtrx[ix_hndl][cxlc_stts_num]) {
         men -= delt / lv_sttx_mtrx[ix_hndl][cxlc_stts_num];
         lv_sttx_mtrx[ix_hndl][cxlc_stts_mean] = men;
         lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] -= delt *\
               (old_data - men);
         if (lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] < 0.0) {
            lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] = 0.0;
         }
      } else {
         lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] = 0.0;
         lv_sttx_mtrx[ix_hndl][cxlc_stts_mean] = 0.0;
      }
   }
   return (delt);
}
define stts_updatex(ix_hndl,nn,*data_arr_pc[]) {
   auto ii,retvalu;
   retvalu = 0.0;
   for (ii = 0; ii <= nn - 1; ii += 1) {
      retvalu += stts_update(ix_hndl,data_arr_pc[ii]);
   }
   return (retvalu);
}
define stts_newx(nn,*data_arr_pc[]) {
   auto ihndl,ii;
   ihndl = stts_new();
   for (ii = 0; ii <= nn - 1; ii += 1) {
      bcdummy = stts_update(ihndl,data_arr_pc[ii]);
   }
   return (ihndl);
}
define stts_shift(ix_hndl,data_shift) {
   # local-use Bc lv_sttx_mtrx[];
   lv_sttx_mtrx[ix_hndl][cxlc_stts_max] += data_shift;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_min] += data_shift;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_mean] += data_shift;
   return (ix_hndl);
}
define stts_scale(ix_hndl,xfactor) {
   # local-use Bc lv_sttx_mtrx[];
   auto newmax,newmin;
   if (0 < xfactor) {
      newmax = lv_sttx_mtrx[ix_hndl][cxlc_stts_max] * xfactor;
      newmin = lv_sttx_mtrx[ix_hndl][cxlc_stts_min] * xfactor;
   } else {
      newmax = lv_sttx_mtrx[ix_hndl][cxlc_stts_min] * xfactor;
      newmin = lv_sttx_mtrx[ix_hndl][cxlc_stts_max] * xfactor;
   }
   lv_sttx_mtrx[ix_hndl][cxlc_stts_min] = newmin;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_max] = newmax;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_mean] *= xfactor;
   lv_sttx_mtrx[ix_hndl][cxlc_stts_msq] *= xfactor * xfactor;
   return (ix_hndl);
}
define stts_copy(hto,hfrom) {
   # local-use Bc lv_sttx_mtrx[];
   auto ii;
   for (ii = 0; ii <= cxlc_stts_count - 1; ii += 1) {
      lv_sttx_mtrx[hto][ii] = lv_sttx_mtrx[hfrom][ii];
   }
   return (hto);
}
define stts_update2(ix_hnda,ix_hndb) {
   auto delta,ncount,nmean,nmsqr,bmin,bmax,amin,amax;
   if (! lf_stts_is_inited(ix_hndb)) {
      halt;
   }
   if (! iszero(sttscount(ix_hndb))) {
      if (! lf_stts_is_inited(ix_hnda)) {
         halt;
      }
      if (iszero(sttscount(ix_hnda))) {
         bcdummy = stts_copy(ix_hnda,ix_hndb);
      } else {
         delta = sttsmean(ix_hndb) - sttsmean(ix_hnda);
         ncount = sttscount(ix_hndb) + sttscount(ix_hnda);
         nmean = (sttsmean(ix_hnda) + delta *\
               (sttscount(ix_hndb) / ncount));
         nmsqr = (sttsmsq(ix_hnda) + sttsmsq(ix_hndb) + delta\
               * delta * (sttscount(ix_hnda) *\
               sttscount(ix_hndb)) / ncount);
         amin = sttsmin(ix_hnda);
         amax = sttsmax(ix_hnda);
         bmin = sttsmin(ix_hndb);
         bmax = sttsmax(ix_hndb);
         if (amax < amin) {
            amin = bmin;
            amax = bmax;
         } else {
            if (bmin < amin) {
               amin = bmin;
            }
            if (amax < bmax) {
               amax = bmax;
            }
         }
         bcdummy = stts_init(ix_hnda,ncount,nmean,nmsqr /\
               (ncount - 1.0),amin,amax);
      }
   }
   return (ix_hnda);
}
cxlc_sttsc_xx = 0;
cxlc_sttsc_yy = 1;
cxlc_sttsc_covar = 2;
cxlc_sttsc_magic = 3;
cxlc_sttsc_count = 4;
lv_crx_mtrx[0][0] = 0;
define lf_corr_is_init(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   auto retvalu_bol,vll;
   if (cxlc_stts_max_key <= ix_chnd) {
      retvalu_bol = false;
   } else {
      vll = lv_crx_mtrx[ix_chnd][cxlc_sttsc_magic];
      retvalu_bol = ismagic(vll);
   }
   return (retvalu_bol);
}
define lf_corr_find_empty() {
   auto ix_chnd;
   ix_chnd = 0;
   while (lf_corr_is_init(ix_chnd)) {
      ix_chnd += 1;
   }
   if (cxlc_stts_max_key <= ix_chnd) {
      halt;
   }
   return (ix_chnd);
}
define corr_new() {
   # local-use Bc lv_crx_mtrx[];
   auto ix_chnd;
   ix_chnd = lf_corr_find_empty();
   lv_crx_mtrx[ix_chnd][cxlc_sttsc_xx] = stts_new();
   lv_crx_mtrx[ix_chnd][cxlc_sttsc_yy] = stts_new();
   lv_crx_mtrx[ix_chnd][cxlc_sttsc_covar] = 0.0;
   lv_crx_mtrx[ix_chnd][cxlc_sttsc_magic] = magicset();
   return (ix_chnd);
}
define corr_delete(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   lv_crx_mtrx[ix_chnd][cxlc_sttsc_magic] = magicnot();
   bcdummy = stts_delete(lv_crx_mtrx[ix_chnd][cxlc_sttsc_xx]);
   bcdummy = stts_delete(lv_crx_mtrx[ix_chnd][cxlc_sttsc_yy]);
   return (ix_chnd);
}
define corr_handlex(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   return (lv_crx_mtrx[ix_chnd][cxlc_sttsc_xx]);
}
define corr_handley(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   return (lv_crx_mtrx[ix_chnd][cxlc_sttsc_yy]);
}
define corr_update(ix_chnd,xx,yy) {
   # local-use Bc lv_crx_mtrx[];
   auto num,ddxx,ddyy,yyhnd,xxhnd;
   yyhnd = lv_crx_mtrx[ix_chnd][cxlc_sttsc_yy];
   xxhnd = lv_crx_mtrx[ix_chnd][cxlc_sttsc_xx];
   num = sttscount(xxhnd);
   ddxx = stts_update(xxhnd,xx);
   ddyy = stts_update(yyhnd,yy);
   lv_crx_mtrx[ix_chnd][cxlc_sttsc_covar] += (ddxx * ddyy *\
         num / (num + 1.0));
   return (lv_crx_mtrx[ix_chnd][cxlc_sttsc_covar]);
}
define corrslope(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   auto den,retvalu,xxhnd;
   xxhnd = lv_crx_mtrx[ix_chnd][cxlc_sttsc_xx];
   den = sttsmsq(xxhnd);
   if (iszero(den)) {
      retvalu = 0.0;
   } else {
      retvalu = lv_crx_mtrx[ix_chnd][cxlc_sttsc_covar] / den;
   }
   return (retvalu);
}
define corry0(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   auto retvalu,yyhnd,xxhnd;
   yyhnd = lv_crx_mtrx[ix_chnd][cxlc_sttsc_yy];
   xxhnd = lv_crx_mtrx[ix_chnd][cxlc_sttsc_xx];
   retvalu = (sttsmean(yyhnd) - corrslope(ix_chnd) *\
         sttsmean(xxhnd));
   return (retvalu);
}
define corrcorr(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   auto retvalu,xxmsq,yymsq,den;
   xxmsq = sttsmsq(lv_crx_mtrx[ix_chnd][cxlc_sttsc_xx]);
   yymsq = sttsmsq(lv_crx_mtrx[ix_chnd][cxlc_sttsc_yy]);
   den = xxmsq * yymsq;
   if (iszero(den)) {
      retvalu = 0.0;
   } else {
      retvalu = (lv_crx_mtrx[ix_chnd][cxlc_sttsc_covar] /\
            sqrt(den));
   }
   return (retvalu);
}
define corrstderr(ix_chnd) {
   # local-use Bc lv_crx_mtrx[];
   auto yyhnd,diff,retvalu;
   yyhnd = lv_crx_mtrx[ix_chnd][cxlc_sttsc_yy];
   diff = sttsmsq(yyhnd) - (corrslope(ix_chnd) *\
         lv_crx_mtrx[ix_chnd][cxlc_sttsc_covar]);
   if (diff < 0.0) {
      retvalu = 0.0;
   } else {
      retvalu = sqrt(diff / (sttscount(yyhnd) - 2.0));
   }
   return (retvalu);
}
define fit_poly(num_points,*pts_arr_pc[],*ret_coeff_arr_p[]) {
   auto i_ind,j_ind,k_ind,prod,cc_arr[];
   for (j_ind = 0; j_ind <= num_points - 1; j_ind += 1) {
      cc_arr[j_ind] = pts_arr_pc[2 * j_ind + 1];
   }
   for (j_ind = 1; j_ind <= num_points - 1; j_ind += 1) {
      k_ind = num_points - 1 - j_ind;
      for (i_ind = num_points - 1; j_ind <= i_ind; i_ind -= 1) {
         cc_arr[i_ind] = ((cc_arr[i_ind - 1] - cc_arr[i_ind])\
               / (pts_arr_pc[2 * k_ind] - pts_arr_pc[2 *\
               i_ind]));
         k_ind -= 1;
      }
   }
   for (j_ind = 0; j_ind <= num_points - 2; j_ind += 1) {
      for (i_ind = num_points - 2; j_ind <= i_ind; i_ind -= 1) {
         prod = cc_arr[i_ind + 1] * pts_arr_pc[2 * (i_ind -\
               j_ind)];
         cc_arr[i_ind] -= prod;
      }
   }
   for (j_ind = 0; j_ind <= num_points - 1; j_ind += 1) {
      ret_coeff_arr_p[j_ind] = cc_arr[j_ind];
   }
   return (num_points);
}
cxlc_parabola_x_axis = 0;
cxlc_parabola_y_extrema = 1;
cxlc_parabola_real_roots = 2;
cxlc_parabola_root_a = 3;
cxlc_parabola_root_b = 4;
cxlc_parabola_coeff_c = 5;
cxlc_parabola_coeff_b = 6;
cxlc_parabola_coeff_a = 7;
lv_parabola_arr[0] = 0;
define parabola_solve(xx_a,yy_a,xx_b,yy_b,xx_c,yy_c) {
   # local-use Bc lv_parabola_arr[];
   auto pts_arr[],cc_arr[],disc,axis,yyextrema,\
         real_roots,roots_arr[];
   pts_arr[0] = xx_a;
   pts_arr[1] = yy_a;
   pts_arr[2] = xx_b;
   pts_arr[3] = yy_b;
   pts_arr[4] = xx_c;
   pts_arr[5] = yy_c;
   bcdummy = fit_poly(3,pts_arr[],cc_arr[]);
   roots_arr[0] = cxdblmax;
   roots_arr[1] = cxdblmax;
   if (iszero(cc_arr[2])) {
      axis = cxdblmax;
      if (iszero(cc_arr[1])) {
         yyextrema = cc_arr[0];
         real_roots = 0;
      } else {
         yyextrema = cxdblmax;
         real_roots = 1;
         roots_arr[0] = (-cc_arr[0] / cc_arr[1]);
      }
   } else {
      axis = (-cc_arr[1] / (2.0 * cc_arr[2]));
      yyextrema = (cc_arr[0] + xx_a * (cc_arr[1] + xx_a *\
            cc_arr[2]));
      disc = (cc_arr[1] * cc_arr[1] - 4.0 * cc_arr[2] *\
            cc_arr[0]);
      if (iszero(disc)) {
         real_roots = 1;
         roots_arr[0] = axis;
      } else if (0 < disc) {
         disc = sqrt(disc) / (2.0 * cc_arr[2]);
         real_roots = 2;
         roots_arr[0] = axis - disc;
         roots_arr[1] = axis + disc;
      } else {
         real_roots = 0;
      }
   }
   lv_parabola_arr[cxlc_parabola_x_axis] = axis;
   lv_parabola_arr[cxlc_parabola_y_extrema] = yyextrema;
   lv_parabola_arr[cxlc_parabola_real_roots] = real_roots;
   lv_parabola_arr[cxlc_parabola_root_a] = roots_arr[0];
   lv_parabola_arr[cxlc_parabola_root_b] = roots_arr[1];
   lv_parabola_arr[cxlc_parabola_coeff_c] = cc_arr[0];
   lv_parabola_arr[cxlc_parabola_coeff_b] = cc_arr[1];
   lv_parabola_arr[cxlc_parabola_coeff_a] = cc_arr[2];
   return (axis);
}
define parabola_get(ii_ind) {
   # local-use Bc lv_parabola_arr[];
   auto retvalu;
   if (0 <= ii_ind && ii_ind <= 7) {
      retvalu = lv_parabola_arr[ii_ind];
   } else {
      retvalu = 0;
   }
   return (retvalu);
}
define parabola_roots(ii_ind) {
   auto retvalu;
   if (0 <= ii_ind && ii_ind <= 1) {
      retvalu = parabola_get(ii_ind + cxlc_parabola_root_a);
   } else {
      retvalu = cxdblmax;
   }
   return (retvalu);
}
define parabola_yextrema() {
   return (parabola_get(cxlc_parabola_y_extrema));
}
define parabola_xaxis() {
   return (parabola_get(cxlc_parabola_x_axis));
}
define parabola_realroots() {
   return (parabola_get(cxlc_parabola_real_roots));
}
cxlc_circle_x = 0;
cxlc_circle_y = 1;
cxlc_circle_radius = 2;
lv_circle_arr[0] = 0;
define circle_solve(x_a,y_a,x_b,y_b,x_c,y_c) {
   # local-use Bc lv_circle_arr[];
   auto y_ba,x_ba,y_ca,x_ca,det,xy_ba,xy_ca,center_x,\
         center_y,radius;
   y_ba = y_b - y_a;
   x_ba = x_b - x_a;
   y_ca = y_c - y_a;
   x_ca = x_c - x_a;
   det = 2.0 * (y_ba * x_ca - y_ca * x_ba);
   if (! iszero(det)) {
      xy_ba = y_ba * (y_a + y_b) + x_ba * (x_a + x_b);
      xy_ca = y_ca * (y_a + y_c) + x_ca * (x_a + x_c);
      center_x = (y_ba * xy_ca - y_ca * xy_ba) / det;
      center_y = (x_ca * xy_ba - x_ba * xy_ca) / det;
      radius = hypot(center_x - x_a,center_y - y_a);
   } else {
      center_x = cxdblmax;
      center_y = cxdblmax;
      radius = cxdblmax;
   }
   lv_circle_arr[cxlc_circle_x] = center_x;
   lv_circle_arr[cxlc_circle_y] = center_y;
   lv_circle_arr[cxlc_circle_radius] = radius;
   return (radius);
}
define circle_get(ii_ind) {
   # local-use Bc lv_circle_arr[];
   auto retvalu;
   if (0 <= ii_ind && ii_ind <= 2) {
      retvalu = lv_circle_arr[ii_ind];
   } else {
      retvalu = 0;
   }
   return (retvalu);
}
define fit_minmax(num_points,*pt_arr_pc[],*ret_coeff_arr_p[]) {
   auto xxp_arr[],yyp_arr[],i_ind,j_ind,k_ind,\
         this_spread,nx_spr,nx_a,nx_b,dxx,dyy,pty,\
         epsxx,epsyy,slope_t,intercept_t,max_dyy,min_dyy;
   epsxx = 0.0;
   epsyy = 0.0;
   for (j_ind = 0; j_ind <= num_points - 1; j_ind += 1) {
      xxp_arr[j_ind] = pt_arr_pc[2 * j_ind];
      yyp_arr[j_ind] = pt_arr_pc[2 * j_ind + 1];
      if (epsxx < abs(xxp_arr[j_ind])) {
         epsxx = abs(xxp_arr[j_ind]);
      }
      if (epsyy < abs(yyp_arr[j_ind])) {
         epsyy = abs(yyp_arr[j_ind]);
      }
   }
   nx_spr = -1;
   nx_a = 0;
   nx_b = 0;
   epsxx *= 16 * cxdbleps;
   epsyy *= 16 * cxdbleps;
   for (i_ind = 1; i_ind <= num_points - 1; i_ind += 1) {
      for (j_ind = 0; j_ind <= i_ind - 1; j_ind += 1) {
         dxx = xxp_arr[i_ind] - xxp_arr[j_ind];
         if (epsxx < abs(dxx)) {
            slope_t = (yyp_arr[i_ind] - yyp_arr[j_ind]) / dxx;
            intercept_t = yyp_arr[i_ind] - slope_t *\
                  xxp_arr[i_ind];
            pty = slope_t * xxp_arr[0] + intercept_t;
            dyy = yyp_arr[0] - pty;
            min_dyy = dyy;
            max_dyy = dyy;
            k_ind = 1;
            while (k_ind < num_points) {
               pty = slope_t * xxp_arr[k_ind] + intercept_t;
               dyy = yyp_arr[k_ind] - pty;
               if (dyy < min_dyy) {
                  min_dyy = dyy;
               }
               if (max_dyy < dyy) {
                  max_dyy = dyy;
               }
               this_spread = max_dyy - min_dyy;
               if ((0 < nx_spr && nx_spr + epsyy <\
                     this_spread) || (min_dyy < - epsyy &&\
                     epsyy < max_dyy)) {
                  break;
               }
               k_ind += 1;
            }
            if (num_points <= k_ind) {
               if (nx_spr < 0 || this_spread < nx_spr - epsyy\
                     || (this_spread <= nx_spr + epsyy &&\
                     abs(nx_a) < abs(slope_t))) {
                  nx_a = slope_t;
                  nx_b = intercept_t + (min_dyy + max_dyy) / 2.0;
                  nx_spr = this_spread;
               }
            }
         }
      }
   }
   ret_coeff_arr_p[1] = nx_a;
   ret_coeff_arr_p[0] = nx_b;
   ret_coeff_arr_p[2] = nx_spr / 2.0;
   return (nx_spr / 2.0);
}
define lf_signcrossproduct(x_a,y_a,x_b,y_b,x_c,y_c) {
   auto cr,bbx_a,bby_a,ccx_a,ccy_a;
   bbx_a = x_b - x_a;
   bby_a = y_b - y_a;
   ccx_a = x_c - x_a;
   ccy_a = y_c - y_a;
   cr = bbx_a * ccy_a - ccx_a * bby_a;
   return (cr);
}
define fitx_minmax(num_points,*pt_arr_pc[],*ret_arr_p[]) {
   auto xxp_arr[],yyp_arr[],chi_arr[],chisize,hh,i_ind,\
         j_ind,k_ind,this_spread,nx_spr,nx_a,nx_b,dxx,\
         pty,dyy,epsxx,epsyy,slope_t,intercept_t,\
         max_dyy,min_dyy,e_ind,t_ind,poh_ind,crx,lmbm_ind;
   epsxx = 0.0;
   epsyy = 0.0;
   lmbm_ind = 0;
   for (j_ind = 0; j_ind <= num_points - 1; j_ind += 1) {
      xxp_arr[j_ind] = pt_arr_pc[2 * j_ind];
      yyp_arr[j_ind] = pt_arr_pc[2 * j_ind + 1];
      if (epsxx < abs(xxp_arr[j_ind])) {
         epsxx = abs(xxp_arr[j_ind]);
      }
      if (epsyy < abs(yyp_arr[j_ind])) {
         epsyy = abs(yyp_arr[j_ind]);
      }
      if (xxp_arr[j_ind] <= xxp_arr[lmbm_ind]) {
         if (xxp_arr[j_ind] < xxp_arr[lmbm_ind] ||\
               yyp_arr[j_ind] <= yyp_arr[lmbm_ind]) {
            lmbm_ind = j_ind;
         }
      }
   }
   nx_spr = -1;
   nx_a = 0;
   nx_b = 0;
   epsxx *= 16 * cxdbleps;
   epsyy *= 16 * cxdbleps;
   poh_ind = lmbm_ind;
   chisize = 0;
   for (;;) {
      chi_arr[chisize] = poh_ind;
      e_ind = 0;
      for (j_ind = 0; j_ind <= num_points - 1; j_ind += 1) {
         if (e_ind == poh_ind) {
            e_ind = j_ind;
         } else {
            t_ind = chi_arr[chisize];
            crx = lf_signcrossproduct(xxp_arr[j_ind],\
                  yyp_arr[j_ind],xxp_arr[t_ind],\
                  yyp_arr[t_ind],xxp_arr[e_ind],\
                  yyp_arr[e_ind]);
            if (crx < 0) {
               e_ind = j_ind;
            }
         }
      }
      chisize += 1;
      if (num_points < chisize) {
         halt;
      }
      poh_ind = e_ind;
      if (e_ind == chi_arr[0]) {
         break; # loop AWAIT
      }
   }
   chi_arr[chisize] = chi_arr[0];
   chisize += 1;
   for (hh = 0; hh <= chisize - 2; hh += 1) {
      i_ind = chi_arr[hh];
      j_ind = chi_arr[hh + 1];
      dxx = xxp_arr[i_ind] - xxp_arr[j_ind];
      if (epsxx < abs(dxx)) {
         slope_t = (yyp_arr[i_ind] - yyp_arr[j_ind]) / dxx;
         intercept_t = yyp_arr[i_ind] - slope_t * xxp_arr[i_ind];
         dyy = yyp_arr[0] - (slope_t * xxp_arr[0] + intercept_t);
         min_dyy = dyy;
         max_dyy = dyy;
         this_spread = 0;
         k_ind = 1;
         while (k_ind < num_points) {
            pty = (slope_t * xxp_arr[k_ind] + intercept_t);
            dyy = yyp_arr[k_ind] - pty;
            if (dyy < min_dyy) {
               min_dyy = dyy;
            }
            if (max_dyy < dyy) {
               max_dyy = dyy;
            }
            this_spread = max_dyy - min_dyy;
            if ((0 < nx_spr && nx_spr + epsyy < this_spread)\
                  || (min_dyy < - epsyy && epsyy < max_dyy)) {
               break;
            }
            k_ind += 1;
         }
         if (num_points <= k_ind) {
            if (nx_spr < 0 || this_spread < nx_spr - epsyy ||\
                  (this_spread <= nx_spr + epsyy && abs(nx_a)\
                  < abs(slope_t))) {
               nx_a = slope_t;
               nx_b = intercept_t + (min_dyy + max_dyy) / 2.0;
               nx_spr = this_spread;
            }
         }
      }
   }
   ret_arr_p[0] = nx_b;
   ret_arr_p[1] = nx_a;
   ret_arr_p[2] = nx_spr / 2.0;
   return (ret_arr_p[2]);
}
define fit_minmax0(num_points,*pts_arr_pc[],*ret_arr_p[]) {
   auto xxp_arr[],yyp_arr[],i_ind,j_ind,k_ind,\
         this_spread,minmaxz_spread,minmaxz_slope,\
         minmaxz_intercept,dxx,dyy,pty,epsxx,epsyy,\
         slope_t,intercept_t,midxx,midyy,max_dyy,min_dyy;
   epsxx = 0.0;
   epsyy = 0.0;
   for (j_ind = 0; j_ind <= num_points - 1; j_ind += 1) {
      xxp_arr[j_ind] = pts_arr_pc[2 * j_ind];
      yyp_arr[j_ind] = pts_arr_pc[2 * j_ind + 1];
      if (epsxx < abs(xxp_arr[j_ind])) {
         epsxx = abs(xxp_arr[j_ind]);
      }
      if (epsyy < abs(yyp_arr[j_ind])) {
         epsyy = abs(yyp_arr[j_ind]);
      }
   }
   minmaxz_spread = -1;
   minmaxz_slope = 0;
   minmaxz_intercept = yyp_arr[0];
   epsxx *= 8 * cxdbleps;
   epsyy *= 8 * cxdbleps;
   for (i_ind = 2; i_ind <= num_points - 1; i_ind += 1) {
      for (j_ind = 2; j_ind <= i_ind - 1; j_ind += 1) {
         midxx = (xxp_arr[i_ind] + xxp_arr[j_ind]) / 2.0;
         midyy = (yyp_arr[i_ind] + yyp_arr[j_ind]) / 2.0;
         dxx = xxp_arr[0] - midxx;
         if (epsxx < abs(dxx)) {
            slope_t = (yyp_arr[0] - midyy) / dxx;
            intercept_t = yyp_arr[0] - slope_t * xxp_arr[0];
            min_dyy = 0;
            max_dyy = 0;
            for (k_ind = 0; k_ind <= num_points - 1; k_ind +=\
                  1) {
               pty = slope_t * xxp_arr[k_ind] + intercept_t;
               dyy = yyp_arr[k_ind] - pty;
               if (dyy < min_dyy) {
                  min_dyy = dyy;
               }
               if (max_dyy < dyy) {
                  max_dyy = dyy;
               }
               this_spread = max_dyy - min_dyy;
               if (0 < minmaxz_spread && minmaxz_spread +\
                     epsyy < this_spread) {
                  break;
               }
            }
            if (minmaxz_spread < 0 || this_spread <\
                  minmaxz_spread - epsyy) {
               minmaxz_slope = slope_t;
               minmaxz_intercept = intercept_t;
               minmaxz_spread = this_spread;
            }
         }
      }
   }
   if (0 <= minmaxz_spread) {
      ret_arr_p[1] = minmaxz_slope;
      ret_arr_p[0] = minmaxz_intercept;
      ret_arr_p[2] = minmaxz_spread / 2.0;
   }
   return (minmaxz_spread / 2.0);
}
define fit_ls(num_points,*pts_arr_pc[],*ret_arr_p[]) {
   auto i_ind,dxx,dyy,xx,yy,slope,mean_yy,ssq_yy,\
         mean_xx,ssq_xx,covariance_xy;
   mean_xx = 0.0;
   ssq_xx = 0.0;
   mean_yy = 0.0;
   ssq_yy = 0.0;
   covariance_xy = 0.0;
   for (i_ind = 0; i_ind <= num_points - 1; i_ind += 1) {
      xx = pts_arr_pc[2 * i_ind];
      dxx = xx - mean_xx;
      mean_xx += dxx / (i_ind + 1);
      ssq_xx += dxx * (xx - mean_xx);
      yy = pts_arr_pc[2 * i_ind + 1];
      dyy = yy - mean_yy;
      mean_yy += dyy / (i_ind + 1);
      ssq_yy += dyy * (yy - mean_yy);
      covariance_xy += dxx * dyy * i_ind / (i_ind + 1.0);
   }
   slope = covariance_xy / ssq_xx;
   ret_arr_p[1] = slope;
   ret_arr_p[0] = mean_yy - slope * mean_xx;
   ret_arr_p[2] = covariance_xy / sqrt(ssq_xx * ssq_yy);
   ret_arr_p[3] = sqrt((ssq_yy - slope * covariance_xy) /\
         (num_points - 2));
   return (ret_arr_p[2]);
}
define fit_ls0(num_points,*pts_arr_pc[],*ret_lsz_arr_p[]) {
   auto xxsum,xysum,dxx,slope,j_ind,i_ind;
   xxsum = 0.0;
   xysum = 0.0;
   for (i_ind = 1; i_ind <= num_points - 1; i_ind += 1) {
      j_ind = 2 * i_ind;
      dxx = (pts_arr_pc[j_ind] - pts_arr_pc[0]);
      xxsum += dxx * dxx;
      xysum += dxx * (pts_arr_pc[j_ind + 1] - pts_arr_pc[1]);
   }
   slope = xysum / xxsum;
   ret_lsz_arr_p[1] = slope;
   ret_lsz_arr_p[0] = (pts_arr_pc[1] - slope * pts_arr_pc[0]);
   return (slope);
}
define sqrt__1(xx) {
   auto yy_curr,yy_prev,zz,power_of_two;
   if (xx <= 0.0) {
      yy_curr = 0.0;
   } else {
      power_of_two = 1.0;
      zz = xx;
      while (4.0 <= zz) {
         zz /= 4.0;
         power_of_two *= 2.0;
      }
      while (zz < 1.0) {
         zz *= 4.0;
         power_of_two /= 2.0;
      }
      yy_curr = (((-0.0353026277858345) * zz +\
            0.502513025246083) * zz + 0.546382637992462);
      for (;;) {
         yy_prev = yy_curr;
         yy_curr = (yy_curr + zz / yy_curr) / 2.0;
         if (iseq(yy_prev,yy_curr)) {
            break; # loop AWAIT
         }
      }
      yy_curr *= power_of_two;
   }
   return (yy_curr);
}
define sqrt__2(xx) {
   auto scvx_xp,scvx_xx,scvx_yp,scvx_yy,scvx_dx,scvx_dy,\
         scvx_ii,ini;
   if (xx <= 0.0) {
      scvx_xx = 0.0;
   } else {
      if (1.0 < xx) {
         ini = xx / 2.0;
      } else {
         ini = 2.0 * xx;
      }
      scvx_dx = ini / 10.0;
      scvx_xx = ini;
      scvx_yy = xx - scvx_xx * scvx_xx;
      for (scvx_ii = 0; scvx_ii <= 20; scvx_ii += 1) {
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         if (iseq(scvx_xp,scvx_xx)) {
            break;
         }
         scvx_yy = xx - scvx_xx * scvx_xx;
         scvx_dy = (scvx_yy - scvx_yp);
         if (iszero(scvx_dy)) {
            break;
         }
         scvx_dx *= - scvx_yy / scvx_dy;
      }
   }
   return (scvx_xx);
}
define sqrt__3(yy) {
   auto nrvx_ii,nrvx_yy,nrvx_xx,nrvx_dy,nrvx_xp,ini;
   if (yy <= 0.0) {
      nrvx_xx = 0.0;
   } else {
      if (1.0 < yy) {
         ini = yy / 2.0;
      } else {
         ini = 2.0 * yy;
      }
      nrvx_xx = ini;
      for (nrvx_ii = 0; nrvx_ii <= 20; nrvx_ii += 1) {
         nrvx_xp = nrvx_xx;
         nrvx_dy = 2.0 * nrvx_xx;
         if (iszero(nrvx_dy)) {
            break;
         }
         nrvx_yy = nrvx_xx * nrvx_xx - yy;
         nrvx_xx -= nrvx_yy / nrvx_dy;
         if (iseq(nrvx_xp,nrvx_xx)) {
            break;
         }
      }
   }
   return (nrvx_xx);
}
define nthroot__1(xx,kk) {
   auto yy_curr,yy_prev,pp,ii;
   if (xx <= 0.0) {
      yy_curr = 0.0;
   } else {
      yy_curr = xx / 2.0;
      for (;;) {
         yy_prev = yy_curr;
         pp = yy_curr;
         for (ii = 2; ii <= kk - 1; ii += 1) {
            pp *= yy_curr;
         }
         yy_curr = (yy_curr * (kk - 1.0) + xx / pp) / kk;
         if (iseq(yy_prev,yy_curr)) {
            break; # loop AWAIT
         }
      }
   }
   return (yy_curr);
}
cxlc_eps = cxdbleps / 16.0;
define cossin_ev(init_ii,xx_rad,addone_mult) {
   auto cval,ii,trig_sum,xr_rad,xr_sqr;
   if (iszero(xx_rad)) {
      trig_sum = 0.0;
   } else {
      xr_rad = fmods(xx_rad,cxtau);
      xr_sqr = -xr_rad * xr_rad;
      cval = 1.0;
      ii = init_ii;
      while (cxlc_eps < abs(cval)) {
         ii += 2;
         cval *= xr_sqr / (ii * (ii - 1.0));
      }
      trig_sum = 1.0 / (ii * (ii + 1.0));
      while (1 < ii) {
         trig_sum += 1.0;
         trig_sum *= xr_sqr / (ii * (ii - 1.0));
         ii -= 2;
      }
      if (addone_mult) {
         trig_sum += 1.0;
         trig_sum *= xr_rad;
      }
   }
   return (trig_sum);
}
define cos__1(xx_rad) {
   return (cossin_ev(0,xx_rad,false) + 1.0);
}
define cosm1__1(xx_rad) {
   return (cossin_ev(0,xx_rad,false));
}
define sin__1(xx_rad) {
   return (cossin_ev(1,xx_rad,true));
}
define sinc__1(xx_rad) {
   auto retvalu;
   if (iszero(xx_rad)) {
      retvalu = 1.0;
   } else {
      if (cxtau / 2.0 < abs(xx_rad)) {
         retvalu = cossin_ev(1,xx_rad,true);
         retvalu /= xx_rad;
      } else {
         retvalu = cossin_ev(1,xx_rad,false) + 1.0;
      }
   }
   return (retvalu);
}
define exp__1(xx) {
   auto ii,term_count,vale,axx,exp_sum,retvalu,\
         squaring_count;
   if (xx < 0.0) {
      axx = -xx;
   } else {
      axx = xx;
   }
   squaring_count = 0;
   while (1.0 < axx) {
      axx /= 2.0;
      squaring_count += 1;
   }
   vale = 1.0;
   term_count = 1;
   while (cxdbleps / 10.0 < vale) {
      term_count += 1;
      vale *= axx / term_count;
   }
   exp_sum = 1.0 / (term_count + 1.0);
   for (ii = term_count; 1 <= ii; ii -= 1) {
      exp_sum = 1.0 + axx * (exp_sum / ii);
   }
   if (xx < 0.0) {
      retvalu = 1.0 / exp_sum;
   } else {
      retvalu = exp_sum;
   }
   for (ii = 1; ii <= squaring_count; ii += 1) {
      retvalu *= retvalu;
   }
   return (retvalu);
}
define exp__2(xx) {
   auto ii,term_count,axx,expmo_sum,retvalu,\
         squaring_count,vale;
   if (xx < 0.0) {
      axx = -xx;
   } else {
      axx = xx;
   }
   squaring_count = 0;
   while (1.0 < axx) {
      axx /= 2.0;
      squaring_count += 1;
   }
   vale = 1.0;
   term_count = 1;
   while (cxdbleps / 4.0 < vale) {
      term_count += 1;
      vale *= axx / term_count;
   }
   expmo_sum = 0.0;
   for (ii = term_count; 1 <= ii; ii -= 1) {
      expmo_sum = axx * (expmo_sum + 1.0) / ii;
   }
   for (ii = 1; ii <= squaring_count; ii += 1) {
      expmo_sum *= (2.0 + expmo_sum);
   }
   if (xx < 0.0) {
      retvalu = 1.0 / (expmo_sum + 1.0);
   } else {
      retvalu = expmo_sum + 1.0;
   }
   return (retvalu);
}
define ln__1(xx) {
   auto yy_curr,logshift,retvalu,tmp;
   scale *= 2;
   logshift = 0.0;
   yy_curr = 8.0 / xx;
   tmp = (cxdbleps);
   while (tmp < yy_curr) {
      logshift -= 16.0 * cxlntwo;
      yy_curr /= 65536.0;
   }
   retvalu = (cxpi / agmean(2.0,yy_curr) + logshift);
   scale /= 2;
   return (retvalu);
}
define ln__2(xx) {
   auto yy_curr,ptwo,term,nn,sum_curr,sum_prev,mant;
   yy_curr = xx;
   ptwo = 0.0;
   while (cxsqrttwo < yy_curr) {
      ptwo += 1.0;
      yy_curr /= 2.0;
   }
   while (yy_curr < 1.0 / cxsqrttwo) {
      ptwo -= 1.0;
      yy_curr *= 2.0;
   }
   mant = (yy_curr - 1.0) / (yy_curr + 1.0);
   sum_curr = 2.0 * mant;
   term = sum_curr;
   mant *= mant;
   nn = 3;
   for (;;) {
      term *= mant;
      sum_prev = sum_curr;
      sum_curr += term / nn;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      nn += 2;
   }
   return (ptwo * cxlntwo + sum_curr);
}
define euler__1() {
   auto twon,exptwon,nn,term,subsum,sum_curr,sum_prev,mm;
   twon = 1.0;
   exptwon = cxe;
   nn = 0;
   for (;;) {
      twon *= 2.0;
      exptwon *= exptwon;
      if (0.1 < cxdbleps * exptwon) {
         break; # loop AWAIT
      }
      nn += 1;
   }
   term = 1.0 / twon;
   subsum = 0.0;
   sum_curr = 0.0;
   mm = 1;
   for (;;) {
      subsum += 1.0 / mm;
      term *= twon / mm;
      sum_prev = sum_curr;
      sum_curr += term * subsum;
      if (iseq(sum_prev,sum_curr)) {
         break; # loop AWAIT
      }
      mm += 1;
   }
   return (twon * sum_curr / exptwon - (nn + 1.0) * cxlntwo);
}
define sphere_d(lata_rad,lona_rad,latb_rad,lonb_rad) {
   auto xc,xd,xe,c_lond,s_lond,c_lata,c_latb,s_lata,\
         s_latb,retvalu;
   c_lata = cos(lata_rad);
   c_latb = cos(latb_rad);
   s_lata = sin(lata_rad);
   s_latb = sin(latb_rad);
   s_lond = sin(lonb_rad - lona_rad);
   c_lond = cos(lonb_rad - lona_rad);
   xc = c_lata * s_latb - s_lata * c_latb * c_lond;
   xd = c_latb * s_lond;
   xe = s_lata * s_latb + c_lata * c_latb * c_lond;
   retvalu = atan2(hypot(xd,xc),xe);
   return (retvalu);
}
define great_circle_distance(lata_rad,lona_rad,latb_rad,\
      lonb_rad) {
   return (sphere_d(lata_rad,lona_rad,latb_rad,lonb_rad));
}
define sphere_distance(lata_rad,lona_rad,latb_rad,lonb_rad\
      ,*ret_dirs_arr_p[]) {
   auto xc,xd,xe,s_lond,c_lond,c_lata,c_latb,s_lata,\
         s_latb,dist;
   c_lata = cos(lata_rad);
   c_latb = cos(latb_rad);
   s_lata = sin(lata_rad);
   s_latb = sin(latb_rad);
   s_lond = sin(lonb_rad - lona_rad);
   c_lond = cos(lonb_rad - lona_rad);
   xc = c_lata * s_latb - s_lata * c_latb * c_lond;
   xd = c_latb * s_lond;
   ret_dirs_arr_p[0] = atan2(xd,xc);
   xe = s_lata * s_latb + c_lata * c_latb * c_lond;
   dist = atan2(hypot(xd,xc),xe);
   xc = c_latb * s_lata - s_latb * c_lata * c_lond;
   xd = c_lata * s_lond;
   ret_dirs_arr_p[1] = -atan2(xd,xc);
   return (dist);
}
define lf_ka(usq) {
   auto hyp;
   hyp = sqrt(1.0 + usq);
   return ((hyp - 1.0) / (hyp + 1.0));
}
define lf_cap_a(usq) {
   auto ka;
   ka = lf_ka(usq);
   return ((1.0 + square(ka / 2.0)) / (1.0 - ka));
}
define lf_cap_b(usq) {
   auto ka;
   ka = lf_ka(usq);
   return (ka * (1.0 - 3.0 * square(ka) / 8.0));
}
define ellipsoid_distance(flat,lata_rad,lona_rad,latb_rad,\
      lonb_rad,*ret_dirs_arr_p[]) {
   auto iflat,cap_ua,cap_ub,lon_diff,c_cap_ua,s_cap_ua,\
         c_cap_ub,s_cap_ub,xx_curr,xx_prev,xc,xd,s_xx,\
         c_xx,c_sig,s_sig,sig,s_alpha,c_alpha_sq,cbsigm\
         ,cap_c,usq,cap_a,cap_b,deltasig,ii,dist;
   iflat = 1.0 - flat;
   cap_ua = atan2(iflat * sin(lata_rad),cos(lata_rad));
   cap_ub = atan2(iflat * sin(latb_rad),cos(latb_rad));
   lon_diff = lonb_rad - lona_rad;
   xx_curr = lon_diff;
   c_cap_ua = cos(cap_ua);
   c_cap_ub = cos(cap_ub);
   s_cap_ua = sin(cap_ua);
   s_cap_ub = sin(cap_ub);
   ii = 0;
   for (;;) {
      s_xx = sin(xx_curr);
      c_xx = cos(xx_curr);
      s_sig = hypot(c_cap_ub * s_xx,c_cap_ua * s_cap_ub -\
            s_cap_ua * c_cap_ub * c_xx);
      c_sig = s_cap_ua * s_cap_ub + c_cap_ua * c_cap_ub * c_xx;
      sig = atan2(s_sig,c_sig);
      s_alpha = c_cap_ua * c_cap_ub * s_xx / s_sig;
      c_alpha_sq = 1.0 - square(s_alpha);
      cbsigm = c_sig - divi(2.0 * s_cap_ua * s_cap_ub,\
            c_alpha_sq,0.0);
      cap_c = ((flat / 16.0) * c_alpha_sq * (4.0 + flat *\
            (4.0 - 3.0 * c_alpha_sq)));
      xx_prev = xx_curr;
      xx_curr = (lon_diff + (1.0 - cap_c) * flat * s_alpha *\
            (sig + cap_c * s_sig * (cbsigm + cap_c * c_sig *\
            (2.0 * square(cbsigm) - 1.0))));
      if (10 < ii && iseq(abs(xx_prev + xx_curr),cxtau)) {
         xx_curr = cxtau / 2.0;
         break;
      }
      if (abs(xx_curr - xx_prev) < (1.0 * 10^-12)) {
         break; # loop AWAIT
      }
      ii += 1;
   }
   usq = c_alpha_sq * (1.0 / square(iflat) - 1.0);
   cap_a = iflat * lf_cap_a(usq);
   cap_b = lf_cap_b(usq);
   deltasig = cap_b * s_sig * (cbsigm + 0.25 * cap_b * (c_sig\
         * (-1.0 + 2.0 * square(cbsigm)) - (1.0 / 6.0) *\
         cap_b * cbsigm * (3.0 + 4.0 * square(s_sig)) * (-3.0\
         + 4.0 * square(cbsigm))));
   dist = cap_a * (sig - deltasig);
   xc = c_cap_ua * s_cap_ub - s_cap_ua * c_cap_ub * c_xx;
   xd = c_cap_ub * s_xx;
   ret_dirs_arr_p[0] = atan2(xd,xc);
   xc = c_cap_ub * s_cap_ua - s_cap_ub * c_cap_ua * c_xx;
   xd = c_cap_ua * s_xx;
   ret_dirs_arr_p[1] = -atan2(xd,xc);
   return (dist);
}
define ellipsoid_destination(flat,lata_rad,lona_rad,\
      heading_rad,distance,*ret_loc_arr_p[]) {
   auto iflat,cap_ua,c_cap_ua,s_cap_ua,sig_rad,\
         sig_rad_prev,sig_rad_delta,c_sig,s_sig,aa,bb,\
         sig_b_rad,s_alpha,c_alpha_sq,twosigm_rad,\
         c_twosigm,c_twosigm_sq,cap_c,usq,cap_a,cap_b,\
         cap_l,alpha_rad,c_heading,s_heading,lamda,xd,xc;
   iflat = 1.0 - flat;
   aa = 1.0;
   bb = iflat * aa;
   cap_ua = atan2(iflat * sin(lata_rad),cos(lata_rad));
   c_cap_ua = cos(cap_ua);
   s_cap_ua = sin(cap_ua);
   c_heading = cos(heading_rad);
   s_heading = sin(heading_rad);
   sig_b_rad = atan2(s_cap_ua,c_cap_ua * c_heading);
   s_alpha = cos(cap_ua) * sin(heading_rad);
   c_alpha_sq = 1.0 - square(s_alpha);
   usq = c_alpha_sq * (square(aa / bb) - 1.0);
   cap_a = lf_cap_a(usq);
   cap_b = lf_cap_b(usq);
   sig_rad_delta = 0.0;
   sig_rad = -10.0;
   for (;;) {
      sig_rad_prev = sig_rad;
      sig_rad = distance / (bb * cap_a) + sig_rad_delta;
      s_sig = sin(sig_rad);
      c_sig = cos(sig_rad);
      twosigm_rad = 2.0 * sig_b_rad + sig_rad;
      c_twosigm = cos(twosigm_rad);
      c_twosigm_sq = square(c_twosigm);
      sig_rad_delta = cap_b * s_sig * (c_twosigm + 0.25 *\
            cap_b * (c_sig * (2.0 * c_twosigm_sq - 1.0) -\
            (cap_b / 6.0) * c_twosigm * (4.0 * square(s_sig)\
            - 3.0) * (4.0 * c_twosigm_sq - 3.0)));
      if (iseq(sig_rad,sig_rad_prev)) {
         break; # loop AWAIT
      }
   }
   xd = s_cap_ua * c_sig + c_cap_ua * s_sig * c_heading;
   xc = iflat * hypot(s_alpha,s_cap_ua * s_sig - c_cap_ua *\
         c_sig * c_heading);
   ret_loc_arr_p[0] = atan2(xd,xc);
   xd = s_sig * s_heading;
   xc = c_cap_ua * c_sig - s_cap_ua * s_sig * c_heading;
   lamda = atan2(xd,xc);
   cap_c = ((flat / 16.0) * c_alpha_sq * (4.0 + flat * (4.0 -\
         3.0 * c_alpha_sq)));
   cap_l = lamda - (1.0 - cap_c) * flat * s_alpha * (sig_rad\
         + cap_c * s_sig * (c_twosigm + cap_c * c_sig * (2.0\
         * c_twosigm_sq - 1.0)));
   ret_loc_arr_p[1] = cap_l + lona_rad;
   alpha_rad = fmodu(cxpi + atan2(s_alpha,c_cap_ua * c_sig *\
         c_heading - s_cap_ua * s_sig),cxtau);
   return (alpha_rad);
}
define ellipsoid_surface(aa,bb,cc) {
   auto absaa,absbb,abscc,phi,sinphi,cosphi,kk,retvalu;
   absaa = abs(aa);
   absbb = abs(bb);
   abscc = abs(cc);
   if (absaa < absbb) {
      kk = absaa;
      absaa = absbb;
      absbb = kk;
   }
   if (absbb < abscc) {
      kk = abscc;
      abscc = absbb;
      absbb = kk;
      if (absaa < absbb) {
         kk = absaa;
         absaa = absbb;
         absbb = kk;
      }
   }
   if (abscc < absaa) {
      cosphi = (abscc / absaa);
      phi = cosinv(cosphi);
      sinphi = sin(phi);
      kk = sqrt((1.0 - abscc * abscc / (absbb * absbb)) /\
            (1.0 - abscc * abscc / (absaa * absaa)));
      retvalu = cxtau * (abscc * abscc + absaa * absbb /\
            sinphi * (sinphi * sinphi * elliptic2ik(kk,phi)\
            + cosphi * cosphi * elliptic1ik(kk,phi)));
   } else {
      retvalu = 2.0 * cxtau * absaa * absaa;
   }
   return (retvalu);
}
define ellipsoid_volume(aa,bb,cc) {
   return (2.0 * cxtau * aa * bb * cc / 3.0);
}
cxlc_shc_shiftshift = 3.85514;
cxlc_shc_stepshift = 8.5;
define shc_shftpoles2steps(shft,poles) {
   auto step_arr[],retvalu;
   if (poles <= 0) {
      retvalu = 0.0;
   } else if (shft < 0) {
      retvalu = 0.0;
   } else if (16 < shft) {
      retvalu = (1.0 * 10^9);
   } else if (poles == 1) {
      step_arr[0] = 1.0;
      step_arr[1] = (8.75664018 * 10^0);
      step_arr[2] = (2.174418277 * 10^1);
      step_arr[3] = (4.709615109 * 10^1);
      step_arr[4] = (9.755325605 * 10^1);
      step_arr[5] = (1.983575685 * 10^2);
      step_arr[6] = (3.9991425188 * 10^2);
      step_arr[7] = (8.0300236937 * 10^2);
      step_arr[8] = (1.60916613901 * 10^3);
      step_arr[9] = (3.22148750069 * 10^3);
      step_arr[10] = (6.44612712926 * 10^3);
      step_arr[11] = (1.289540487229 * 10^4);
      step_arr[12] = (2.579395961911 * 10^4);
      step_arr[13] = (5.159106828928 * 10^4);
      step_arr[14] = (1.0318528839545 * 10^5);
      step_arr[15] = (2.0637372529029 * 10^5);
      step_arr[16] = (4.1275053067337 * 10^5);
      retvalu = step_arr[shft];
   } else if (poles == 2) {
      step_arr[0] = 1.0;
      step_arr[1] = (1.372295755 * 10^1);
      step_arr[2] = (3.383938971 * 10^1);
      step_arr[3] = (7.318281398 * 10^1);
      step_arr[4] = (1.5153838699 * 10^2);
      step_arr[5] = (3.0810336456 * 10^2);
      step_arr[6] = (6.2116437416 * 10^2);
      step_arr[7] = (1.24725288016 * 10^3);
      step_arr[8] = (2.49941335432 * 10^3);
      step_arr[9] = (5.00372613671 * 10^3);
      step_arr[10] = (1.001234749878 * 10^4);
      step_arr[11] = (2.002958840334 * 10^4);
      step_arr[12] = (4.006406905172 * 10^4);
      step_arr[13] = (8.013303000155 * 10^4);
      step_arr[14] = (1.6027095510986 * 10^5);
      step_arr[15] = (3.2054680443102 * 10^5);
      step_arr[16] = (6.4109851712798 * 10^5);
      retvalu = step_arr[shft];
   } else if (poles == 3) {
      step_arr[0] = 1.0;
      step_arr[1] = (1.737173781 * 10^1);
      step_arr[2] = (4.273609545 * 10^1);
      step_arr[3] = (9.238532150 * 10^1);
      step_arr[4] = (1.9128399554 * 10^2);
      step_arr[5] = (3.8890510497 * 10^2);
      step_arr[6] = (7.8406421045 * 10^2);
      step_arr[7] = (1.57434201644 * 10^3);
      step_arr[8] = (3.15487771808 * 10^3);
      step_arr[9] = (6.31593923478 * 10^3);
      step_arr[10] = (1.263805730898 * 10^4);
      step_arr[11] = (2.528229097067 * 10^4);
      step_arr[12] = (5.057075779500 * 10^4);
      step_arr[13] = (1.0114768912723 * 10^5);
      step_arr[14] = (2.0230154729287 * 10^5);
      step_arr[15] = (4.0460928016924 * 10^5);
      step_arr[16] = (8.0922476138170 * 10^5);
      retvalu = step_arr[shft];
   } else if (poles == 4) {
      step_arr[0] = 1.0;
      step_arr[1] = (2.03878236 * 10^1);
      step_arr[2] = (5.009900279 * 10^1);
      step_arr[3] = (1.0828162825 * 10^2);
      step_arr[4] = (2.2418834788 * 10^2);
      step_arr[5] = (4.5579968748 * 10^2);
      step_arr[6] = (9.189270663 * 10^2);
      step_arr[7] = (1.84513549236 * 10^3);
      step_arr[8] = (3.69752950942 * 10^3);
      step_arr[9] = (7.40230620593 * 10^3);
      step_arr[10] = (1.48118537839 * 10^4);
      step_arr[11] = (2.963094667636 * 10^4);
      step_arr[12] = (5.926913086318 * 10^4);
      step_arr[13] = (1.1854549900613 * 10^5);
      step_arr[14] = (2.3709822433702 * 10^5);
      step_arr[15] = (4.7420371217077 * 10^5);
      step_arr[16] = (9.4841452431326 * 10^5);
      retvalu = step_arr[shft];
   } else if (poles == 5) {
      step_arr[0] = 1.0;
      step_arr[1] = (2.301559338 * 10^1);
      step_arr[2] = (5.651862690 * 10^1);
      step_arr[3] = (1.2214337218 * 10^2);
      step_arr[4] = (2.5288215751 * 10^2);
      step_arr[5] = (5.1413464355 * 10^2);
      step_arr[6] = (1.03653347249 * 10^3);
      step_arr[7] = (2.08127953713 * 10^3);
      step_arr[8] = (4.17074621528 * 10^3);
      step_arr[9] = (8.34966697295 * 10^3);
      step_arr[10] = (1.670750214140 * 10^4);
      step_arr[11] = (3.342316957219 * 10^4);
      step_arr[12] = (6.685449836446 * 10^4);
      step_arr[13] = (1.3371716646729 * 10^5);
      step_arr[14] = (2.6744248565129 * 10^5);
      step_arr[15] = (5.3489319815476 * 10^5);
      step_arr[16] = (1.06979462735136 * 10^6);
      retvalu = step_arr[shft];
   } else {
      retvalu = 0.0;
   }
   return (retvalu);
}
define shc_steps2shft(steps) {
   return (lg(steps + cxlc_shc_stepshift) - cxlc_shc_shiftshift);
}
define shc_steps2shftinv(shft) {
   return (pow(2.0,shft + cxlc_shc_shiftshift) -\
         cxlc_shc_stepshift);
}
define shc_shft2steps(shft) {
   return (shc_shftpoles2steps(shft,4));
}
define m2k(mm) {
   return (sqrt(mm));
}
define k2m(kk) {
   return (kk * kk);
}
define a2k(aa) {
   return (sin(aa));
}
define k2a(kk) {
   return (sininv(kk));
}
define a2m(aa) {
   return (square(sin(aa)));
}
define m2a(mm) {
   return (sininv(sqrt(mm)));
}
define m2b(mm) {
   return (1.0 / sqrt(1.0 - mm));
}
define b2m(bb) {
   return (1.0 - 1.0 / (bb * bb));
}
define elliptic1m(mm) {
   auto retvalu,aa_arr[],bb_arr[],cc_arr[],dd;
   if (mm < 1.0) {
      retvalu = cxpi / (2.0 * agmean(1.0,sqrt(1.0 - mm)));
   } else if (1.0 < mm) {
      aa_arr[0] = 1.0;
      aa_arr[1] = 0.0;
      bb_arr[0] = 0.0;
      bb_arr[1] = sqrt(mm - 1.0);
      dd = agcmean(aa_arr[],bb_arr[],cc_arr[]);
      retvalu = cxpi / (2.0 * dd);
   } else {
      retvalu = 20.0;
   }
   return (retvalu);
}
define elliptick(kk) {
   return (elliptic1m(k2m(kk)));
}
define elliptic1m__1(mm) {
   return (carlsonrf(0.0,1.0 - mm,1.0));
}
define elliptic1m__2(mm) {
   auto term,sum_curr,sum_prev,ii;
   term = cxtau / 4.0;
   sum_curr = 0.0;
   ii = 1;
   for (;;) {
      term *= square(mm * ii / (ii + 1.0));
      sum_prev = sum_curr;
      sum_curr += term;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      ii += 2;
   }
   return (sum_curr);
}
define elliptic1im(mm,circ_rad) {
   auto aan,ggn,cc,skip_flag,temp,retvalu,tt,kresult,\
         lcirc_rad,mc,ii,modd,signof,npihlfs,ee;
   mc = 1.0 - mm;
   if (iszero(mm)) {
      retvalu = circ_rad;
   } else if (iszero(mc)) {
      if (cxpi / 2.0 <= abs(circ_rad)) {
         retvalu = cxdblmax;
      } else {
         retvalu = log(tan((cxpi / 2.0 + circ_rad) / 2.0));
      }
   } else {
      npihlfs = floor(circ_rad / (cxpi / 2.0));
      if (isodd(npihlfs)) {
         npihlfs += 1;
      }
      lcirc_rad = circ_rad;
      if (npihlfs == 0) {
         kresult = 0.0;
      } else {
         kresult = elliptic1m(mm);
         lcirc_rad -= npihlfs * cxpi / 2.0;
      }
      if (lcirc_rad < 0.0) {
         lcirc_rad = -lcirc_rad;
         signof = -1;
      } else {
         signof = 1;
      }
      tt = tan(lcirc_rad);
      ggn = sqrt(mc);
      skip_flag = false;
      if (10.0 < abs(tt)) {
         ee = 1.0 / (ggn * tt);
         if (abs(ee) < 10.0) {
            if (npihlfs == 0) {
               kresult = elliptic1m(mm);
            }
            temp = kresult - elliptic1im(mm,atan2(ee,1.0));
            skip_flag = true;
         }
      }
      if (! skip_flag) {
         aan = 1.0;
         ii = 1;
         modd = 0;
         for (;;) {
            temp = ggn / aan;
            lcirc_rad += atan2(tt * temp,1.0) + modd * cxpi;
            modd = floor(lcirc_rad / cxpi + 0.5);
            tt *= (1.0 + temp) / (1.0 - temp * tt * tt);
            cc = (aan - ggn) / 2.0;
            temp = sqrt(aan * ggn);
            aan = (aan + ggn) / 2.0;
            ggn = temp;
            ii += ii;
            if (abs(cc / aan) <= cxdbleps) {
               break; # loop AWAIT
            }
         }
         temp = (atan2(tt,1.0) + modd * cxpi) / (ii * aan);
      }
      if (signof < 0) {
         temp = -temp;
      }
      retvalu = temp + npihlfs * kresult;
   }
   return (retvalu);
}
define elliptic1k(kk) {
   return (elliptic1m(k2m(kk)));
}
define elliptic1ik(kk,circ_rad) {
   return (elliptic1im(k2m(kk),circ_rad));
}
define elliptic1a(aa) {
   return (elliptic1m(a2m(aa)));
}
define elliptic1ia(aa,circ_rad) {
   return (elliptic1im(a2m(aa),circ_rad));
}
define ellipticf(kk,circ_rad) {
   return (elliptic1im(k2m(kk),circ_rad));
}
define elliptic1im__1(mm,circ_rad) {
   auto sinphi,npihlfs,lcirc_rad,kresult;
   npihlfs = floor(circ_rad / (cxpi / 2.0));
   if (isodd(npihlfs)) {
      npihlfs += 1;
   }
   lcirc_rad = circ_rad;
   if (npihlfs == 0) {
      kresult = 0.0;
   } else {
      kresult = elliptic1m(mm) * npihlfs;
      lcirc_rad -= npihlfs * cxpi / 2.0;
   }
   sinphi = sin(lcirc_rad);
   return (sinphi * carlsonrf(square(cos(lcirc_rad)),1.0 -\
         mm * square(sinphi),1.0) + kresult);
}
define elliptic2m(mm) {
   auto aan,ggn,tn,twon,sum,sum_prev,ii,amm,retvalu;
   amm = abs(mm);
   if (amm < 1.0) {
      twon = 0.5;
      aan = 1.0;
      ggn = sqrt(1.0 - mm);
      sum = 1.0 - mm / 2.0;
      ii = 0;
      for (;;) {
         twon *= 2.0;
         tn = aan;
         aan = (aan + ggn) / 2.0;
         ggn = sqrt(tn * ggn);
         sum_prev = sum;
         sum -= twon * (aan * aan - ggn * ggn);
         if (iseq(sum,sum_prev)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = cxpi * sum / (2.0 * aan);
   } else {
      retvalu = 1.0;
   }
   return (retvalu);
}
define elliptice(kk) {
   return (elliptic2m(k2m(kk)));
}
define elliptic2m__1(mm) {
   return (carlsonrf(0.0,1.0 - mm,1.0) - mm * carlsonrd(0.0\
         ,1.0 - mm,1.0) / 3.0);
}
define elliptic2im(mm,circ_rad) {
   auto aan,ggn,cc,errsum,temp,tt,eliptwomm,mmc,ii,\
         modd,npihalfs,signof,lcirc_rad,retvalu;
   if (iszero(mm)) {
      retvalu = circ_rad;
   } else {
      mmc = 1.0 - mm;
      eliptwomm = elliptic2m(mm);
      npihalfs = floor(circ_rad / (cxpi / 2.0));
      if (isodd(npihalfs)) {
         npihalfs += 1;
      }
      lcirc_rad = circ_rad - npihalfs * cxpi / 2.0;
      if (iszero(mmc)) {
         retvalu = sin(lcirc_rad) + npihalfs * eliptwomm;
      } else {
         if (lcirc_rad < 0.0) {
            lcirc_rad = -lcirc_rad;
            signof = -1;
         } else {
            signof = 1;
         }
         tt = tan(lcirc_rad);
         ggn = sqrt(mmc);
         if (abs(tt) < - 1) {
            errsum = 1.0 / (ggn * tt);
         } else {
            errsum = 0.0;
         }
         if (0.0 < abs(errsum) && abs(errsum) < 1000.0) {
            errsum = atan2(1.0,ggn * tt);
            temp = eliptwomm - elliptic2im(mm,errsum) + mm *\
                  sin(circ_rad) * sin(errsum);
         } else {
            cc = sqrt(mm);
            aan = 1.0;
            ii = 1;
            modd = 0;
            while (cxdbleps < abs(cc / aan)) {
               temp = ggn / aan;
               lcirc_rad += atan2(tt * temp,1.0) + modd * cxpi;
               modd = floor(lcirc_rad / cxpi + 0.5);
               tt *= (1.0 + temp) / (1.0 - temp * tt * tt);
               cc = (aan - ggn) / 2.0;
               temp = sqrt(aan * ggn);
               aan = (aan + ggn) / 2.0;
               ggn = temp;
               ii += ii;
               errsum += cc * sin(lcirc_rad);
            }
            temp = eliptwomm * (atan2(tt,1.0) + modd * cxpi)\
                  / (ii * aan * elliptic1m(mm)) + errsum;
         }
         if (signof < 0) {
            temp = -temp;
         }
         retvalu = temp + npihalfs * eliptwomm;
      }
   }
   return (retvalu);
}
define ellipticei(kk,circ_rad) {
   return (elliptic2im(k2m(kk),circ_rad));
}
define elliptic2im__1(mm,circ_rad) {
   auto sinphi,sinphisq,sinphicu,cosphisq,argb,npihlfs,\
         lcirc_rad,kresult;
   npihlfs = floor(circ_rad / (cxpi / 2.0));
   if (isodd(npihlfs)) {
      npihlfs += 1;
   }
   lcirc_rad = circ_rad;
   if (npihlfs == 0) {
      kresult = 0.0;
   } else {
      kresult = elliptic2m(mm) * npihlfs;
      lcirc_rad -= npihlfs * cxpi / 2.0;
   }
   sinphi = sin(lcirc_rad);
   sinphisq = sinphi * sinphi;
   sinphicu = sinphi * sinphisq;
   cosphisq = square(cos(lcirc_rad));
   argb = 1.0 - mm * sinphisq;
   return (sinphi * carlsonrf(cosphisq,argb,1.0) - mm *\
         sinphicu * carlsonrd(cosphisq,argb,1.0) / 3.0 +\
         kresult);
}
define elliptic2k(kk) {
   return (elliptic2m(k2m(kk)));
}
define elliptic2ik(kk,circ_rad) {
   return (elliptic2im(k2m(kk),circ_rad));
}
define elliptic2a(aa) {
   return (elliptic2m(a2m(aa)));
}
define elliptic2ia(aa,circ_rad) {
   return (elliptic2im(a2m(aa),circ_rad));
}
define elliptic3m(nn,mm) {
   auto aan,ggn,ppn,een,qqn,tpp,tag,tn,sum,sum_prev,\
         ii,amm,retvalu;
   amm = abs(mm);
   if (amm < 1.0) {
      aan = 1.0;
      ggn = sqrt(1.0 - mm);
      if (1.0 <= abs(nn)) {
         ppn = sqrt(1.0 - mm / nn);
      } else {
         ppn = sqrt(1.0 - nn);
      }
      qqn = 1.0;
      sum = qqn;
      ii = 0;
      for (;;) {
         tpp = ppn * ppn;
         tag = aan * ggn;
         een = (tpp - tag) / (tpp + tag);
         ppn = (tpp + tag) / (2.0 * ppn);
         qqn = qqn * een / 2.0;
         aan = (aan + ggn) / 2.0;
         ggn = sqrt(tag);
         sum_prev = sum;
         sum += qqn;
         if (iseq(sum,sum_prev) && iseq(aan,ggn)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (20 <= ii) {
            break; # loop AWAIT
         }
      }
      if (1.0 <= abs(nn)) {
         tn = mm * sum / (mm - nn);
      } else {
         tn = 2.0 + sum * nn / (1.0 - nn);
      }
      retvalu = cxpi * tn / (4.0 * aan);
   } else {
      retvalu = 1.0;
   }
   return (retvalu);
}
define elliptic3k(nn,kk) {
   return (elliptic3m(nn,k2m(kk)));
}
define elliptic3ik(nn,kk,circ_rad) {
   return (elliptic3im(nn,k2m(kk),circ_rad));
}
define elliptic3a(nn,aa) {
   return (elliptic3m(nn,a2m(aa)));
}
define elliptic3ia(nn,aa,circ_rad) {
   return (elliptic3im(nn,a2m(aa),circ_rad));
}
define ellipticp(kk,circ_rad) {
   return (elliptic3m(kk,circ_rad));
}
define elliptic3im(nn,mm,circ_rad) {
   auto sp,cp,spq,cpq,spm,spn;
   sp = sin(circ_rad);
   cp = cos(circ_rad);
   spq = sp * sp;
   cpq = cp * cp;
   spm = 1.0 - mm * spq;
   spn = 1.0 - nn * spq;
   return (sp * (carlsonrf(cpq,spm,1.0) + spq * nn *\
         carlsonrj(cpq,spm,1.0,spn) / 3.0));
}
define ellipticpi(nn,kk,circ_rad) {
   return (elliptic3im(nn,k2m(kk),circ_rad));
}
define elliptic3m__1(nn,mm) {
   return (carlsonrf(0.0,1.0 - mm,1.0) + nn * carlsonrj(0.0\
         ,1.0 - mm,1.0,1.0 - nn) / 3.0);
}
define elliptic3im__1(nn,mm,circ_rad) {
   auto sinphi,sinphisq,sinphicu,cosphisq,argb,npihlfs,\
         lcirc_rad,kresult;
   npihlfs = floor(circ_rad / (cxpi / 2.0));
   if (isodd(npihlfs)) {
      npihlfs += 1;
   }
   lcirc_rad = circ_rad;
   if (npihlfs == 0) {
      kresult = 0.0;
   } else {
      kresult = elliptic3m(nn,mm) * npihlfs;
      lcirc_rad -= npihlfs * cxpi / 2.0;
   }
   sinphi = sin(lcirc_rad);
   sinphisq = sinphi * sinphi;
   sinphicu = sinphi * sinphisq;
   cosphisq = square(cos(lcirc_rad));
   argb = 1.0 - mm * sinphisq;
   return (sinphi * carlsonrf(cosphisq,argb,1.0) + (nn /\
         3.0) * sinphicu * carlsonrj(cosphisq,argb,1.0,1.0\
         - nn * sinphisq) + kresult);
}
define jacobiphi(mm,elli_rad) {
   auto ai,bb,circ_rad,geo_mean,twon,aa_arr[],cc_arr[],ii;
   if (mm <= 0.0) {
      circ_rad = taninv(sn(mm,elli_rad) / cn(mm,elli_rad));
   } else if (mm < 1.0) {
      bb = sqrt(1.0 - mm);
      aa_arr[0] = 1.0;
      cc_arr[0] = sqrt(mm);
      twon = 1.0;
      ii = 0;
      while (cxdbleps < abs(cc_arr[ii] / aa_arr[ii])) {
         if (19 - 1 < ii) {
            break;
         }
         ai = aa_arr[ii];
         ii += 1;
         cc_arr[ii] = (ai - bb) / 2.0;
         geo_mean = sqrt(ai * bb);
         aa_arr[ii] = (ai + bb) / 2.0;
         bb = geo_mean;
         twon *= 2.0;
      }
      circ_rad = twon * aa_arr[ii] * elli_rad;
      while (0 < ii) {
         bb = cc_arr[ii] * sin(circ_rad) / aa_arr[ii];
         circ_rad = (sininv(bb) + circ_rad) / 2.0;
         ii -= 1;
      }
   } else {
      circ_rad = taninv(sn(mm,elli_rad) / cn(mm,elli_rad));
   }
   return (circ_rad);
}
define ell2cir(mm,elli_rad) {
   return (jacobiphi(mm,elli_rad));
}
define cir2ell(mm,circ_rad) {
   return (elliptic1im(mm,circ_rad));
}
define jacobicir(mm) {
   return (4.0 * elliptic2m(mm) / sqrt(1.0 - mm));
}
cxlc_elliptic_eps = (1.0 * 10^-9);
lv_mm = -10.0;
lv_elli_rad = -10.0;
lv_arr_arr[0] = 0;
define lv_ellpj(mm,elli_rad,*ret_arr_p[]) {
   # local-use Bc lv_mm;
   # local-use Bc lv_elli_rad;
   auto ai,csx,snx,circ_rad,twon,junk_arr[];
   if (mm < 0.0) {
      snx = -sn(1.0 - mm,elli_rad) + sin(elli_rad) +\
            tanh(elli_rad);
      csx = -cn(-mm,elli_rad) + 2.0 * cos(elli_rad);
      ret_arr_p[0] = snx;
      ret_arr_p[1] = csx;
      ret_arr_p[2] = -dn(-mm,elli_rad) + 2.0;
      ret_arr_p[3] = atan2(snx,csx);
   } else if (mm < cxlc_elliptic_eps) {
      snx = sin(elli_rad);
      csx = cos(elli_rad);
      ai = mm * (elli_rad - snx * csx) / 4.0;
      ret_arr_p[0] = snx - ai * csx;
      ret_arr_p[1] = csx + ai * snx;
      ret_arr_p[2] = 1.0 - mm * snx * snx / 2.0;
      ret_arr_p[3] = elli_rad - ai;
   } else if (mm < 1.0 - cxlc_elliptic_eps) {
      circ_rad = jacobiphi(mm,elli_rad);
      snx = sin(circ_rad);
      ret_arr_p[0] = snx;
      ret_arr_p[1] = cos(circ_rad);
      ret_arr_p[2] = sqrtx(1.0 - mm * snx * snx);
      ret_arr_p[3] = circ_rad;
   } else if (mm <= 1.0) {
      ai = (1.0 - mm) / 4.0;
      csx = cosh(elli_rad);
      snx = tanh(elli_rad);
      twon = csx * sinh(elli_rad);
      ret_arr_p[0] = snx + ai * (twon - elli_rad) / (csx * csx);
      ret_arr_p[3] = 2.0 * atan2(exp(elli_rad),1.0) - cxpi /\
            2.0 + ai * (twon - elli_rad) / csx;
      ai *= snx / csx;
      ret_arr_p[1] = 1.0 / csx - ai * (twon - elli_rad);
      ret_arr_p[2] = 1.0 / csx + ai * (twon + elli_rad);
   } else {
      ai = m2k(mm);
      bcdummy = lv_ellpj(1.0 / mm,elli_rad * ai,junk_arr[]);
      ret_arr_p[0] = junk_arr[0] / ai;
      ret_arr_p[1] = junk_arr[2];
      ret_arr_p[2] = junk_arr[1];
      ret_arr_p[3] = junk_arr[3];
   }
   lv_mm = mm;
   lv_elli_rad = elli_rad;
   return 0;
}
define sn__1(mm,elli_rad) {
   # local-use Bc lv_mm;
   # local-use Bc lv_elli_rad;
   # local-use Bc lv_arr_arr[];
   if (isneq(mm,lv_mm) || isneq(elli_rad,lv_elli_rad)) {
      bcdummy = lv_ellpj(mm,elli_rad,lv_arr_arr[]);
   }
   return (lv_arr_arr[0]);
}
define cn__1(mm,elli_rad) {
   # local-use Bc lv_mm;
   # local-use Bc lv_elli_rad;
   # local-use Bc lv_arr_arr[];
   if (isneq(mm,lv_mm) || isneq(elli_rad,lv_elli_rad)) {
      bcdummy = lv_ellpj(mm,elli_rad,lv_arr_arr[]);
   }
   return (lv_arr_arr[1]);
}
define dn__1(mm,elli_rad) {
   # local-use Bc lv_mm;
   # local-use Bc lv_elli_rad;
   # local-use Bc lv_arr_arr[];
   if (isneq(mm,lv_mm) || isneq(elli_rad,lv_elli_rad)) {
      bcdummy = lv_ellpj(mm,elli_rad,lv_arr_arr[]);
   }
   return (lv_arr_arr[2]);
}
define dn(mm,elli_rad) {
   auto ai,csx,snx,kk,retvalu;
   if (mm < 0.0) {
      retvalu = -dn(-mm,elli_rad) + 2.0;
   } else if (mm < cxlc_elliptic_eps) {
      snx = sin(elli_rad);
      retvalu = 1.0 - mm * snx * snx / 2.0;
   } else if (mm < 1.0 - cxlc_elliptic_eps) {
      snx = sin(jacobiphi(mm,elli_rad));
      retvalu = sqrtx(1.0 - mm * snx * snx);
   } else if (mm <= 1.0) {
      ai = (1.0 - mm) / 4.0;
      csx = cosh(elli_rad);
      snx = sinh(elli_rad);
      retvalu = 1.0 / csx + ai * (csx * snx + elli_rad);
   } else {
      kk = m2k(mm);
      retvalu = cn(1.0 / mm,elli_rad * kk);
   }
   return (retvalu);
}
define cn(mm,elli_rad) {
   auto ai,csx,snx,kk,retvalu;
   if (mm < 0.0) {
      retvalu = -cn(-mm,elli_rad) + 2.0 * cos(elli_rad);
   } else if (mm < cxlc_elliptic_eps) {
      snx = sin(elli_rad);
      csx = cos(elli_rad);
      ai = mm * (elli_rad - snx * csx) / 4.0;
      retvalu = csx + ai * snx;
   } else if (mm < 1.0 - cxlc_elliptic_eps) {
      retvalu = cos(jacobiphi(mm,elli_rad));
   } else if (mm <= 1.0) {
      ai = (1.0 - mm) / 4.0;
      csx = cosh(elli_rad);
      snx = sinh(elli_rad);
      retvalu = 1.0 / csx - ai * (csx * snx + elli_rad);
   } else {
      kk = m2k(mm);
      retvalu = dn(1.0 / mm,elli_rad * kk);
   }
   return (retvalu);
}
define sn(mm,elli_rad) {
   auto ai,csx,snx,kk,retvalu;
   if (mm < 0.0) {
      retvalu = -sn(1.0 - mm,elli_rad) + sin(elli_rad) +\
            tanh(elli_rad);
   } else if (mm < cxlc_elliptic_eps) {
      snx = sin(elli_rad);
      csx = cos(elli_rad);
      ai = mm * (elli_rad - snx * csx) / 4.0;
      retvalu = snx - ai * csx;
   } else if (mm < 1.0 - cxlc_elliptic_eps) {
      retvalu = sin(jacobiphi(mm,elli_rad));
   } else if (mm <= 1.0) {
      ai = (1.0 - mm) / 4.0;
      csx = cosh(elli_rad);
      snx = sinh(elli_rad);
      retvalu = (snx + snx * ai - ai * elli_rad / csx) / csx;
   } else {
      kk = m2k(mm);
      retvalu = sn(1.0 / mm,elli_rad * kk) / kk;
   }
   return (retvalu);
}
define cd(mm,elli_rad) {
   return (cn(mm,elli_rad) / dn(mm,elli_rad));
}
define sd(mm,elli_rad) {
   return (sn(mm,elli_rad) / dn(mm,elli_rad));
}
define nd(mm,elli_rad) {
   return (1.0 / dn(mm,elli_rad));
}
define dc(mm,elli_rad) {
   return (dn(mm,elli_rad) / cn(mm,elli_rad));
}
define nc(mm,elli_rad) {
   return (1.0 / cn(mm,elli_rad));
}
define sc(mm,elli_rad) {
   return (sn(mm,elli_rad) / cn(mm,elli_rad));
}
define ds(mm,elli_rad) {
   return (dn(mm,elli_rad) / sn(mm,elli_rad));
}
define cs(mm,elli_rad) {
   return (cn(mm,elli_rad) / sn(mm,elli_rad));
}
define ns(mm,elli_rad) {
   return (1.0 / sn(mm,elli_rad));
}
define nom(mm) {
   return (exp(-cxpi * elliptic1m(1.0 - mm) / elliptic1m(mm)));
}
define theta1(mm,zz) {
   auto sum_curr,sum_prev,nn,sig,ang,ang_inc,qq;
   sig = 1.0;
   qq = nom(mm);
   sum_curr = 0.0;
   ang = zz;
   ang_inc = 2.0 * zz;
   nn = 0;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += sig * pow(qq,square(nn + 0.5)) * sin(ang);
      ang += ang_inc;
      sig = -sig;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      nn += 1;
   }
   return (2.0 * sum_curr);
}
define theta2(mm,zz) {
   auto sum_curr,sum_prev,nn,ang,ang_inc,qq;
   qq = nom(mm);
   sum_curr = 0.0;
   ang = zz;
   ang_inc = 2.0 * zz;
   nn = 0;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += pow(qq,square(nn + 0.5)) * cos(ang);
      ang += ang_inc;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      nn += 1;
   }
   return (2.0 * sum_curr);
}
define theta3(mm,zz) {
   auto sum_curr,sum_prev,nn,ang,ang_inc,qq;
   qq = nom(mm);
   sum_curr = 0.0;
   ang = 2.0 * zz;
   ang_inc = ang;
   nn = 1;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += pow(qq,nn * nn) * cos(ang);
      ang += ang_inc;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      nn += 1;
   }
   return (1.0 + 2.0 * sum_curr);
}
define theta4(mm,zz) {
   auto sum_curr,sum_prev,nn,ang,ang_inc,qq,sig;
   sig = 1.0;
   qq = nom(mm);
   sum_curr = 0.0;
   ang = 2.0 * zz;
   ang_inc = ang;
   nn = 1;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += sig * pow(qq,nn * nn) * cos(ang);
      ang += ang_inc;
      sig = -sig;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      nn += 1;
   }
   return (1.0 + 2.0 * sum_curr);
}
define nevillethetac(mm,zz) {
   auto sum_curr,sum_prev,nn,qq,km,cos_of,cos_inc;
   km = elliptic1m(mm);
   qq = exp(-cxpi * elliptic1m(1.0 - mm) / km);
   sum_curr = 0.0;
   cos_inc = cxpi * zz / km;
   cos_of = cxpi * zz / (2.0 * km);
   nn = 0;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += pow(qq,nn * nn + nn) * cos(cos_of);
      cos_of += cos_inc;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      nn += 1;
   }
   return (sum_curr * sqrt(cxtau * sqrt(qq / mm) / km));
}
define nevillethetad(mm,zz) {
   auto sum_curr,sum_prev,nn,qq,km,cos_of,cos_inc;
   km = elliptic1m(mm);
   qq = exp(-cxpi * elliptic1m(1.0 - mm) / km);
   sum_curr = 0.0;
   cos_inc = cxpi * zz / km;
   cos_of = cxpi * zz / km;
   nn = 1;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += pow(qq,nn * nn) * cos(cos_of);
      cos_of += cos_inc;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      nn += 1;
   }
   return ((1.0 + 2.0 * sum_curr) * sqrt(cxtau / km) / 2.0);
}
define nevillethetan(mm,zz) {
   auto sum_curr,sum_prev,nn,qq,km,sig,cos_of,cos_inc;
   km = elliptic1m(mm);
   qq = exp(-cxpi * elliptic1m(1.0 - mm) / km);
   sum_curr = 0.0;
   sig = -1.0;
   cos_inc = cxpi * zz / km;
   cos_of = cxpi * zz / km;
   nn = 1;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += sig * pow(qq,nn * nn) * cos(cos_of);
      cos_of += cos_inc;
      sig = -sig;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      nn += 1;
   }
   return ((1.0 + 2.0 * sum_curr) * sqrt(cxtau / (km *\
         sqrt(1.0 - mm))) / 2.0);
}
define nevillethetas(mm,zz) {
   auto sum_curr,sum_prev,nn,qq,km,sig,cos_of,cos_inc;
   km = elliptic1m(mm);
   qq = exp(-cxpi * elliptic1m(1.0 - mm) / km);
   sum_curr = 0.0;
   sig = 1.0;
   cos_inc = cxpi * zz / km;
   cos_of = cxpi * zz / (2.0 * km);
   nn = 0;
   for (;;) {
      sum_prev = sum_curr;
      sum_curr += sig * pow(qq,nn * nn + nn) * sin(cos_of);
      sig = -sig;
      cos_of += cos_inc;
      if (iseq(sum_curr,sum_prev)) {
         break; # loop AWAIT
      }
      nn += 1;
   }
   return (sum_curr * sqrt(cxtau * sqrt(qq / (mm * (1.0 -\
         mm))) / km));
}
define ellipsearea(aa,bb) {
   return (cxpi * aa * bb);
}
define ellipseecc(aa,bb) {
   return (topyh1(ratio(aa,bb)));
}
define ellipsem(aa,bb) {
   auto rati;
   rati = ratio(aa,bb);
   return (1.0 - rati * rati);
}
define ellipseflatness(aa,bb) {
   return (1.0 - ratio(aa,bb));
}
define ellipsen(aa,bb) {
   return (abs(aa - bb) / (aa + bb));
}
define flat2ecc(flt) {
   return (sqrt(flt * (2.0 - flt)));
}
define ecc2flat(ecc) {
   return (1.0 - sqrt(1.0 - ecc * ecc));
}
define ellipsecir(aa_orig,bb_orig) {
   auto aaa,bbb,mm,suma,temp,ii,retvalu;
   if (aa_orig < bb_orig) {
      aaa = bb_orig;
      bbb = aa_orig;
   } else {
      aaa = aa_orig;
      bbb = bb_orig;
   }
   if (bbb <= sqrt(cxdbleps) * aaa) {
      retvalu = 4.0 * aaa;
   } else {
      suma = 0.0;
      mm = 1.0;
      ii = 0;
      for (;;) {
         temp = (aaa + bbb) / 2.0;
         bbb = sqrt(aaa * bbb);
         aaa = temp;
         mm += mm;
         suma += mm * square(aaa - bbb);
         if (iseq(aaa,bbb)) {
            break; # loop AWAIT
         }
         ii += 1;
         if (30 <= ii) {
            break; # loop AWAIT
         }
      }
      retvalu = cxpi * (square(aa_orig + bb_orig) - suma) /\
            (aaa + bbb);
   }
   return (retvalu);
}
define ellipsecir__1(aa,bb) {
   auto major_axis,minor_axis,rati;
   if (aa < bb) {
      major_axis = bb;
      minor_axis = aa;
   } else {
      major_axis = aa;
      minor_axis = bb;
   }
   rati = minor_axis / major_axis;
   return (4.0 * major_axis * elliptic2m(1.0 - rati * rati));
}
define epdf(minvalx,maxvalx,nn,*data_arr_pc[],mm,\
      *ret_pdf_arr_p[]) {
   auto ii,indi,gap_size,retvalu,inc;
   for (ii = 0; ii <= mm - 1; ii += 1) {
      ret_pdf_arr_p[ii] = 0.0;
   }
   inc = 1.0 / nn;
   gap_size = (maxvalx - minvalx) / (mm - 1.0);
   retvalu = 0.0;
   for (ii = 0; ii <= nn - 1; ii += 1) {
      if (data_arr_pc[ii] < minvalx) {
         ret_pdf_arr_p[0] += inc;
      } else if (data_arr_pc[ii] < maxvalx) {
         indi = ceil((data_arr_pc[ii] - minvalx) / gap_size);
         ret_pdf_arr_p[indi] += inc;
      } else {
         retvalu += inc;
      }
   }
   return (retvalu);
}
define ecdf(minvalx,maxvalx,nn,*data_arr_pc[],mm,\
      *ret_cdf_arr_p[]) {
   auto ii,sumcurr;
   bcdummy = epdf(minvalx,maxvalx,nn,data_arr_pc[],mm,\
         ret_cdf_arr_p[]);
   sumcurr = ret_cdf_arr_p[0];
   for (ii = 1; ii <= mm - 1; ii += 1) {
      sumcurr += ret_cdf_arr_p[ii];
      ret_cdf_arr_p[ii] = sumcurr;
   }
   return (sumcurr);
}
define epdf2cdf(nn,*pdf_arr_pc[],*ret_cdf_arr_p[]) {
   auto ii,sumcurr;
   sumcurr = 0.0;
   for (ii = 0; ii <= nn - 1; ii += 1) {
      sumcurr += pdf_arr_pc[ii];
      ret_cdf_arr_p[ii] = sumcurr;
   }
   return (sumcurr);
}
lv_search_target = 0;
define search_check(gg) {
   # local-use Bc lv_search_target;
   auto retvalu;
   if (gg < lv_search_target) {
      retvalu = -1;
   } else if (lv_search_target < gg) {
      retvalu = 1;
   } else {
      retvalu = 0;
   }
   return (retvalu);
}
define search_search(gg) {
   # local-use Bc lv_search_target;
   auto curr,delta,result;
   lv_search_target = gg;
   curr = 1;
   for (delta = 0; delta <= cxintmax; delta += 1) {
      result = search_check(curr);
      if (0 <= result) {
         break;
      }
      curr += curr;
   }
   if (4 <= curr) {
      delta = curr / 4;
      while (1 <= delta) {
         if (0 < result) {
            curr -= delta;
         } else if (result < 0) {
            curr += delta;
         } else {
            break;
         }
         result = search_check(curr);
         if (delta < 2) {
            if (0 < result && 1 < curr) {
               curr -= 1;
            }
            break;
         }
         delta /= 2;
      }
   }
   return (curr);
}
define blackbodyl(wavelen,temperk) {
   auto hc,hc_kt,retvalu;
   if (wavelen <= 0.0 || temperk <= 0.0) {
      retvalu = 0.0;
   } else {
      hc = cxplanck * cxlight;
      hc_kt = hc / (cxboltzmann * temperk);
      retvalu = 2.0 * hc * cxlight / (pow(wavelen,5) *\
            (exp(hc_kt / wavelen) - 1.0));
   }
   return (retvalu);
}
define blackbodyf(wavefreq,temperk) {
   auto h_kt,retvalu;
   if (wavefreq <= 0.0 || temperk <= 0.0) {
      retvalu = 0.0;
   } else {
      h_kt = cxplanck / (cxboltzmann * temperk);
      retvalu = 2.0 * cxplanck * pow(wavefreq,3) /\
            (pow(cxlight,2) * (exp(h_kt * wavefreq) - 1.0));
   }
   return (retvalu);
}
define blackbodymode(temperk) {
   auto hc_kt,retvalu;
   if (temperk <= 0.0) {
      retvalu = 0.0;
   } else {
      hc_kt = cxplanck * cxlight / (cxboltzmann * temperk);
      retvalu = hc_kt / (5.0 + wp(-5.0 * exp(-5.0)));
   }
   return (retvalu);
}
define blackbodypower(temperk) {
   return (cxstefan * pow(temperk,4.0));
}
define bhmass_to_temp(bhmass) {
   return (cxbhmasstemp / bhmass);
}
define bhtemp_to_mass(bhtempk) {
   return (cxbhmasstemp / bhtempk);
}
define bhmass_to_radius(bhmass) {
   return (bhmass / cxbhmass_radius);
}
define bhradius_to_mass(bhradius) {
   return (cxbhmass_radius * bhradius);
}
define bhmass_to_entropy(bhmass) {
   return ((bhmass * bhmass) / cxbhmass2_entropy);
}
define bhentropy_to_mass(bhentropy) {
   return (sqrt(bhentropy * cxbhmass2_entropy));
}
define bhmass_to_power(bhmass) {
   return (cxbhmass2power / (bhmass * bhmass));
}
define bhpower_to_mass(bhpower) {
   return (sqrt(cxbhmass2power / bhpower));
}
define bhmass_to_area(bhmass) {
   return ((bhmass * bhmass) / cxbhmass2_area);
}
define bharea_to_mass(bharea) {
   return (sqrt(cxbhmass2_area * bharea));
}
define bhmass_to_lifetime(bhmass) {
   return ((bhmass * bhmass * bhmass) / cxbhmass3_lifetime);
}
define bhlifetime_to_mass(bhlifetime) {
   return (cbrt(cxbhmass3_lifetime * bhlifetime));
}
define bhmass_to_density(bhmass) {
   return ((bhmass * bhmass) / cxbhmass2_density);
}
define bhdensity_to_mass(bhdensity) {
   return (sqrt(bhdensity * cxbhmass2_density));
}
define pendulum(len_m,ang_offset_rad,grav) {
   return (cxtau * sqrt(len_m / grav) / agmean(1.0,\
         cos(ang_offset_rad / 2.0)));
}
#   DDDDDDDDDDescription ----------------------- kw_description #
define kw_description() {
   print "Usage: bcc [Expression]\n";
   print "   Kw 0-ary Functions: corr_new euler__1 gau_rand jd2";
   print "ymdhmsinv magicnot magicset normal_rand parabola_real";
   print "roots parabola_xaxis parabola_yextrema randd stts_new";
   print " timee";
   print "\n";
   print "   Kw 1-ary Functions: a2k a2m abs agmean1 agmean1inv";
   print " ahmean1 almean1 amean1 aqmean1 b2m bankers bell bell";
   print "x benford_rand bernoulli bernoullid bernoullin bessI0";
   print " bessI1 bessJ0 bessJ1 bessK0 bessK1 bessY0 bessY1 bes";
   print "sY1__1 bharea_to_mass bhdensity_to_mass bhentropy_to_";
   print "mass bhlifetime_to_mass bhmass_to_area bhmass_to_dens";
   print "ity bhmass_to_entropy bhmass_to_lifetime bhmass_to_po";
   print "wer bhmass_to_radius bhmass_to_temp bhpower_to_mass b";
   print "hradius_to_mass bhtemp_to_mass bits_count bits_ls1b b";
   print "its_ls1bpos bits_ms1b bits_ms1bpos bitwisenot blackbo";
   print "dyf_pdf blackbodyl_pdf blackbodymode blackbodypower c";
   print "antor carmichael catalan cauchy_rand cbrt ceil chisqr";
   print "_rand circle_get clip clockhour clockmin clocksec clo";
   print "ckstdev clocksum cnv_dbl2si16 contfra_print contfrac_";
   print "print contfracd_print corr_delete corr_handlex corr_h";
   print "andley corrcorr corrslope corrstderr corry0 cos cos__";
   print "1 cosd cosdinv cosh coshinv cosintegral cosinv cosm1 ";
   print "cosm1__1 cost costinv cot cotd cotdinv coth cothinv c";
   print "otinv cott cottinv csc cscd cscdinv csch cschinv csci";
   print "nv csct csctinv ctz cu cube cuberoot date_easter date";
   print "_pesach date_rosh_hashanah day2dhms day2dhmsinv day2h";
   print "our deg2dms deg2rad deg2sec deg2tur digamma digamma__";
   print "1 digammainv dms2deg dms2rad doomsday ecc2flat Ein el";
   print "liptic1a elliptic1k elliptic1m elliptic1m__1 elliptic";
   print "1m__2 elliptic2a elliptic2k elliptic2m elliptic2m__1 ";
   print "ellipticE ellipticK erf erf__1 erf__2 erf__3 erf__4 e";
   print "rfc erfcinv erfcx erfcxinv erfinv eta eulerphi eulerx";
   print " exp exp__1 exp__2 exp_rand expintegral1 expintegrali";
   print " expm1 fac facinv factor_print factorial factorialdou";
   print "ble factorialinv fibo fibox fiboxinv flat2ecc floor f";
   print "rac fubini fusc g2jewish gamma_rand gau_cdf gau_pdf g";
   print "au_quantile gd gdinv geo_rand ghmean1 ghmean1inv glme";
   print "an1 gmean1 gqmean1 has_primitiveroot haversin heavisi";
   print "de heronianmean1 hlmean1 hmean1 hn hn__1 hour2day hqm";
   print "ean1 hypot1 hypot1inv id int_rand iround iseven isint";
   print " isjewish8short isjewish9short isjewishleap isleapyea";
   print "r ismagic isneg isnegint isodd ispos isposint ispract";
   print "ical isprime issquarefree iszero j2k2dow j2k2jd j2k2k";
   print "wt j2k2uet j2k2ymdhms jacobicir jd264_print jd2dow jd";
   print "2j2k jd2kwt jd2uet jd2ymdhms jewish2g jewish2jd jewis";
   print "h2jdx jewish_months_in_year jewish_yearlength k2a k2m";
   print " k2tempc k2tempf k2tempr ks_a_cdf kwt2j2k kwt2jd kwt2";
   print "uet l10 lg lgamma lgamma__1 lgamma__2 lgammainv lix l";
   print "ixinv lmean1 ln ln1p ln__1 ln__2 lns log log10 log2 l";
   print "ogintegral logistic_rand lqmean1 lucas lucasx m2a m2b";
   print " m2k mertens minkowski mobius n2primish neg nom norma";
   print "l_cdf normal_cdf__1 normal_pdf normal_quantile normal";
   print "_quantile__1 num2char_print parabola_get parabola_roo";
   print "ts partition partitionq pcf pfg pfl poi_rand pow10 po";
   print "w2 prime0 prime1 primecount primecountx primenext pri";
   print "menth primenth__1 primeprev primitiveroot qmean1 rad2";
   print "deg rad2dms rad2dms2 rad2sec rad2tur rand_init randl ";
   print "reci reimann round rto125 rtoi rtoz sba search_check ";
   print "search_search sec sec2deg sec2dhms sec2rad sec2tur se";
   print "cd secdinv sech sechinv secinv sect sectinv shc_shft2";
   print "steps shc_steps2shft shc_steps2shftinv sigma0 sigma1 ";
   print "sigmoid sigmoidinv sign sin sin__1 sinc sinc__1 sincc";
   print " sincinv sind sindinv sinh sinhinv sinintegral sininv";
   print " sint sintinv smooth sq sqinv sqrt sqrt__1 sqrt__2 sq";
   print "rt__3 sqrtx square squareroot stair stts_delete stts_";
   print "reset sttscount sttsmagic sttsmax sttsmean sttsmin st";
   print "tsmsq sttsspread sttsstdev sttsstdevmean sttssum stts";
   print "var supercatalan tan tand tandinv tanh tanhinv taninv";
   print " tant tantinv tempc tempc2k tempc2tempf tempf tempf2k";
   print " tempf2tempc tempr tempr2k tgamma tgamma__1 tgamma__2";
   print " tgamma__3 tgamma__stirling tgammadouble tgammainv to";
   print "pyh1 totient tri tri_rand triinv trip trunc tur2deg t";
   print "ur2rad tur2sec uet2j2k uet2jd uet2kwt uni_rand versin";
   print " wm wminv wp wpinv ymdhms2j2k ymdhms2jd ymdhms_get za";
   print "g zeta zig zigzag";
   print "\n";
   print "   Kw 2-ary Functions: agmean agmean__1 agmeaninva ag";
   print "meaninvg ahmean almean amean aqmean atan2 atan2d atan";
   print "2h atan2t atan2u ballot ballots base_out_print base_o";
   print "utf_print benford_cdf benford_pdf bess_jn bess_yn bes";
   print "sIn bessIn_ps bessJn bessJn_ps bessJv bessKn bessYn b";
   print "essYn_ps bessYv beta beta_rand binomial binomial_rand";
   print " binomialx birthday birthdayinv birthdayx bits_get bi";
   print "ts_set bitshiftl bitshiftr bitwiseand bitwiseor bitwi";
   print "sexor bkn blackbodyf blackbodyl carlsonRC cauchy_cdf ";
   print "cauchy_pdf cauchy_quantile cd ceil2 chisqr_cdf chisqr";
   print "_pdf cir2ell cn cn__1 comb combination combx contraha";
   print "rmonic cs d1diamond_d2 d1lt_d2 d1spiral_d2 d1ur_d2 d2";
   print "diamond_d1 d2hypot_d1 d2lt_d1 d2spiral_d1 d2ur_d1 day";
   print "s_in_month dc ddist dist dlog1 dn dn__1 ds ell2cir el";
   print "lipsearea ellipsecir ellipsecir__1 ellipseecc ellipse";
   print "flatness ellipsem ellipsen elliptic1ia elliptic1ik el";
   print "liptic1im elliptic1im__1 elliptic2ia elliptic2ik elli";
   print "ptic2im elliptic2im__1 elliptic3a elliptic3k elliptic";
   print "3m elliptic3m__1 ellipticEi ellipticF ellipticP entri";
   print "nger eulerian exp_cdf exp_pdf exp_quantile expintegra";
   print "ln factor factorialt floor2 fmod fmod fmods fmodu fmo";
   print "dy fmul gamma_cdf gamma_pdf gcd gcda geo_cdf geo_pdf ";
   print "geo_quantile ghmean glmean gmean gompertz_rand gqmean";
   print " has_primitiveroot_f heronianmean hlmean hmean hnm hq";
   print "mean hypot int_cdf int_pdf int_quantile ints_rand ise";
   print "q isge isgt isle islt ismult ismultl isneq ispractica";
   print "l_f isprimitiveroot issignsame issquarefree_f isss ja";
   print "cobiphi jewish_monthbegin jewish_monthlength ks_b_cdf";
   print " ks_cdf ks_quantile lbeta lcam lcams lcantim lcm lcom";
   print "bx ligamma ligammainv lmean logistic_cdf logistic_pdf";
   print " logistic_quantile logx lpermx lqmean max2 maxabs max";
   print "abs2 maxi mb_cdf mb_pdf mean min2 minabs minabs2 mini";
   print " mobius_f modf mods modulo n2perm_print nbd_rand nc n";
   print "d nevillethetac nevillethetad nevillethetan nevilleth";
   print "etas ns nthroot__1 pareto_rand perm permutation permx";
   print " pochhammer poi_cdf poi_pdf poi_quantile polya_rand p";
   print "olycnum polynum pow powi prime0_f qmean rand_init_arr";
   print "ay ratio repetendlen rligamma rms round2 rtomsd ruiga";
   print "mma sc sd shc_shftpoles2steps sigma sigma0_f sigma1_f";
   print " sn sn__1 spread2stdev stdev2spread stirling1 stirlin";
   print "g2 stts_copy stts_downdate stts_newx stts_scale stts_";
   print "shift stts_update stts_update2 t_cdf t_cdf__1 t_pdf t";
   print "_quantile t_quantile__1 tetracnum tetranum theta1 the";
   print "ta2 theta3 theta4 Tn topyh totient_f trap_rand tri_cd";
   print "f tri_pdf tri_quantile uigamma uigamma__1 uigammainv ";
   print "Un uni_cdf uni_pdf uni_quantile variance zeta_cdf zet";
   print "a_pdf zipf_rand znorder znorder__1";
   print "\n";
   print "   Kw 3-ary Functions: agcmean aghmean atothenmodp at";
   print "othenmodx base_out_fix_print beta_cdf beta_pdf beta_q";
   print "uantile betainc betainc__1 binomial_cdf binomial_pdf ";
   print "bits_assign bkbn cantorll cantorul cantorxx carlsonRD";
   print " carlsonRF chebeval clip2 clip2x corr_update cossin_e";
   print "v divi dlog dlogx ellipsoid_surface ellipsoid_volume ";
   print "elliptic3ia elliptic3ik elliptic3im elliptic3im__1 el";
   print "lipticPi epdf2cdf f11 f_cdf f_quantile f_quantile__1 ";
   print "fibo3 fit_ls fit_ls0 fit_minmax fit_minmax0 fit_poly ";
   print "fitx_minmax fmod2 gompertz_cdf gompertz_pdf gompertz_";
   print "quantile hms2day horner hypot3 ifzero isalmostequal i";
   print "sbetween isbetweenx isfloorsame iswithin jewishymd2jd";
   print " kevy_print lv_ellpj maxabsoffset maxmin maxwell_bolt";
   print "zmann_cdf maxwell_boltzmann_pdf maxwell_juttner_pdf m";
   print "inabsoffset n2comb_print n2perm nbd_cdf nbd_pdf paret";
   print "o_cdf pareto_pdf pareto_quantile pendulum pmean polya";
   print "_cdf polya_pdf remquou roundy sigma_f sigmoid3 sigmoi";
   print "d3d stts_updatex taninv3 trap_cdf trap_pdf trap_quant";
   print "ile ymd2dow ymd2doy ymd2j2k ymd2j2k__1 ymd2jd zipf_cd";
   print "f zipf_pdf zipf_quantile";
   print "\n";
   print "   Kw 4-ary Functions: carlsonRJ f21 great_circle_dis";
   print "tance n2comb sphere_d";
   print "\n";
   print "   Kw 5-ary Functions: sphere_distance";
   print "\n";
   print "   Kw 6-ary Functions: circle_solve ecdf ellipsoid_de";
   print "stination ellipsoid_distance epdf parabola_solve stts";
   print "_init stts_initx";
   print "\n";
}
define kw_desc() {
   print "Usage: bcc [Expression]\n";
   print "   Kw 0-ary Functions: corr_new euler__1 gau_rand jd2";
   print "ymdhmsinv magic(not|set) normal_rand parabola_(realro";
   print "ots|xaxis|yextrema) randd stts_new timee";
   print "\n";
   print "   Kw 1-ary Functions: a2k a2m abs agmean1(inv)? ahme";
   print "an1 almean1 amean1 aqmean1 b2m bankers bellx? benford";
   print "_rand bernoulli[dn]? bess(I[01]|J[01]|K[01]|y(0|1(__1";
   print ")?)) bharea_to_mass bhdensity_to_mass bhentropy_to_ma";
   print "ss bhlifetime_to_mass bhmass_to_(area|density|entropy";
   print "|lifetime|power|radius|temp) bhpower_to_mass bhradius";
   print "_to_mass bhtemp_to_mass bit(s_(count|ls1b(pos)?|ms1b(";
   print "pos)?)|wisenot) blackbody(f_pdf|l_pdf|mode|power) can";
   print "tor carmichael catalan cauchy_rand cbrt ceil chisqr_r";
   print "and circle_get clip clock(hour|min|s(ec|tdev|um)) cnv";
   print "_dbl2si16 contfra(_print|c(_print|d_print)) corr(_(de";
   print "lete|handle[xy])|corr|s(lope|tderr)|y0) cos(|__1|d(in";
   print "v)?|h(inv)?|in(tegral|v)|m1(__1)?|t(inv)?) cot([dht]?";
   print "(inv)?)? csc([dht]?(inv)?)? ctz cu cube(root)? date_(";
   print "easter|pesach|rosh_hashanah) day2(dhms(inv)?|hour) de";
   print "g2(dms|rad|sec|tur) digamma(__1|inv)? dms2(deg|rad) d";
   print "oomsday ecc2flat Ein elliptic(1([ak]|m(__[12])?)|2([a";
   print "k]|m(__1)?)|[EK]) erf(|__([12]|[34])|c(inv|x(inv)?)?|";
   print "inv) eta euler(phi|x) exp(_(_[12]|rand)|integral[1i]|";
   print "m1)? fac(|inv|tor(_print|ial(double|inv)?)) fibo(x(in";
   print "v)?)? flat2ecc floor frac fubini fusc g2jewish gamma_";
   print "rand gau_(cdf|pdf|quantile) gd gdinv geo_rand ghmean1";
   print "(inv)? glmean1 gmean1 gqmean1 has_primitiveroot haver";
   print "sin heaviside heronianmean1 hlmean1 hmean1 hn hn__1\
         cxh";
   print "our2day hqmean1 hypot1(inv)? id int_rand iround is(ev";
   print "en|int|jewish8short|jewish9short|jewishleap|leapyear|";
   print "magic|neg|negint|odd|pos|posint|practical|prime|squar";
   print "efree|zero) j2k2(dow|jd|kwt|uet|ymdhms) jacobicir jd2";
   print "(64_print|dow|j2k|kwt|uet|ymdhms) jewish(2(g|jdx?)|_(";
   print "months_in_year|yearlength)) k2a k2m k2temp[cfr] ks_a_";
   print "cdf kwt2(j(2k|d)|uet) l10 lg lgamma(__[12]|inv)? lix(";
   print "inv)? lmean1 ln ln1p ln__[12] lns log(10|2|i(ntegral|";
   print "stic_rand))? lqmean1 lucasx? m2a m2b m2k mertens mink";
   print "owski mobius n2primish neg nom normal_(cdf(__1)?|pdf|";
   print "quantile(__1)?) num2char_print par(abola_(get|roots)|";
   print "titionq?) pcf pfg pfl poi_rand pow(10|2) prim(e([01]|";
   print "countx?|n(ext|th(__1)?)|prev)|itiveroot) qmean1 rad2(";
   print "d(eg|ms2?)|sec|tur) rand(_init|l) reci reimann round ";
   print "rto(125|[iz]) sba search_(check|search) sec(|2(d(eg|h";
   print "ms)|rad|tur)|[dht]?(inv)?) shc_s(hft2steps|teps2shft(";
   print "inv)?) sig(m(a[01]|oid(inv)?)|n) sin(|__1|c(__1|c|inv";
   print ")?|d(inv)?|h(inv)?|in(tegral|v)|t(inv)?) smooth sq sq";
   print "inv sqrt(__[123]|x)? square(root)? stair stts(_(delet";
   print "e|reset)|count|m(a(gic|x)|ean|in|sq)|s(pread|tdev(mea";
   print "n)?|um)|var) supercatalan tan([dht]?(inv)?)? temp(c(2";
   print "(k|tempf))?|f(2(k|tempc))?|r(2k)?) tgamma(__([123]|st";
   print "irling)|double|inv)? topyh1 totient tri(_rand|inv|p)?";
   print " trunc tur2(deg|rad|sec) uet2(j(2k|d)|kwt) uni_rand v";
   print "ersin wm(inv)? wp(inv)? ymdhms(2j(2k|d)|_get) zag zet";
   print "a zig(zag)?";
   print "\n";
   print "   Kw 2-ary Functions: agmean(__1|inv[ag])? ahmean al";
   print "mean amean aqmean atan2([dh]|[tu])? ballots? base_out";
   print "(_print|f_print) benford_(cdf|pdf) bess(_(jn|yn)|in(_";
   print "ps)?|j(n(_ps)?|v)|Kn|y(n(_ps)?|v)) beta(_rand)? binom";
   print "ial(_rand|x)? birthday(inv|x)? bit(s(_(get|set)|hift[";
   print "lr])|wise(and|or|xor)) bkn blackbody[fl] carlsonRC ca";
   print "uchy_(cdf|pdf|quantile) cd ceil2 chisqr_(cdf|pdf) cir";
   print "2ell cn cn__1 comb(ination|x)? contraharmonic cs d1di";
   print "amond_d2 d1lt_d2 d1spiral_d2 d1ur_d2 d2diamond_d1 d2h";
   print "ypot_d1 d2lt_d1 d2spiral_d1 d2ur_d1 days_in_month dc ";
   print "ddist dist dlog1 dn dn__1 ds ell(2cir|ip(se(area|cir(";
   print "__1)?|ecc|flatness|[mn])|tic(1i([ak]|m(__1)?)|2i([ak]";
   print "|m(__1)?)|3([ak]|m(__1)?)|Ei|[FP]))) entringer euleri";
   print "an exp(_(cdf|pdf|quantile)|integraln) factor(ialt)? f";
   print "loor2 fmod([suy]?)? fmul gamma_(cdf|pdf) gcda? geo_(c";
   print "df|pdf|quantile) ghmean glmean gmean gompertz_rand gq";
   print "mean has_primitiveroot_f heronianmean hlmean hmean hn";
   print "m hqmean hypot int(_(cdf|pdf|quantile)|s_rand) is(eq|";
   print "ge|gt|le|lt|mult|multl|neq|practical_f|primitiveroot|";
   print "signsame|squarefree_f|ss) jacobiphi jewish_month(begi";
   print "n|length) ks_(b_cdf|cdf|quantile) lbeta lca(ms?|ntim)";
   print " lcm lcombx ligamma(inv)? lmean log(istic_(cdf|pdf|qu";
   print "antile)|x) lpermx lqmean max(2|abs2?|i) mb_(cdf|pdf) ";
   print "mean min(2|abs2?|i) mobius_f mod([fs]|ulo) n2perm_pri";
   print "nt nbd_rand nc nd nevilletheta([cd]|[ns]) ns nthroot_";
   print "_1 pareto_rand perm(utation|x)? pochhammer poi_(cdf|p";
   print "df|quantile) poly(a_rand|cnum|num) powi? prime0_f qme";
   print "an rand_init_array ratio repetendlen rligamma rms rou";
   print "nd2 rtomsd ruigamma sc sd shc_shftpoles2steps sigma(0";
   print "_f|1_f)? sn sn__1 spread2stdev stdev2spread stirling[";
   print "12] stts_(copy|downdate|newx|s(cale|hift)|update2?) t";
   print "_cdf(__1)? t_pdf t_quantile(__1)? tetra(cnum|num) the";
   print "ta([12]|[34]) Tn topyh totient_f trap_rand tri_(cdf|p";
   print "df|quantile) uigamma(__1|inv)? Un uni_(cdf|pdf|quanti";
   print "le) variance zeta_(cdf|pdf) zipf_rand znorder(__1)?";
   print "\n";
   print "   Kw 3-ary Functions: agcmean aghmean atothenmod[px]";
   print " base_out_fix_print beta(_(cdf|pdf|quantile)|inc(__1)";
   print "?) binomial_(cdf|pdf) bits_assign bkbn cantor(ll|ul|x";
   print "x) carlsonR[DF] chebeval clip2x? corr_update cossin_e";
   print "v divi dlogx? ellip(soid_(surface|volume)|tic(3i([ak]";
   print "|m(__1)?)|Pi)) epdf2cdf f11 f_cdf f_quantile(__1)? fi";
   print "bo3 fit(_(ls0?|minmax0?|poly)|x_minmax) fmod2 gompert";
   print "z_(cdf|pdf|quantile) hms2day horner hypot3 ifzero is(";
   print "almostequal|between|betweenx|floorsame|within) jewish";
   print "ymd2jd kevy_print lv_ellpj max(absoffset|min|well_(bo";
   print "ltzmann_(cdf|pdf)|juttner_pdf)) minabsoffset n2comb_p";
   print "rint n2perm nbd_(cdf|pdf) pareto_(cdf|pdf|quantile) p";
   print "endulum pmean polya_(cdf|pdf) remquou roundy sigm(a_f";
   print "|oid3d?) stts_updatex taninv3 trap_(cdf|pdf|quantile)";
   print " ymd2(do[wy]|j(2k(__1)?|d)) zipf_(cdf|pdf|quantile)";
   print "\n";
   print "   Kw 4-ary Functions: carlsonRJ f21 great_circle_dis";
   print "tance n2comb sphere_d";
   print "\n";
   print "   Kw 5-ary Functions: sphere_distance";
   print "\n";
   print "   Kw 6-ary Functions: circle_solve ecdf ellipsoid_d(";
   print "estination|istance) epdf parabola_solve stts_initx?";
   print "\n";
}
