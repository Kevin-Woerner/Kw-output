#    Copyright (C) 2020 by Kevin D. Woerner
# 2020-08-29 kdw  Created by TMPDIR/objkdw/Kwsun.fwipp.d
#    Copyright C 2015-2020 by Kevin D. Woerner
# 2020-08-20 kdw  Kw:boolean checks changed
# 2020-08-19 kdw  Kw:comment change
# 2020-08-17 kdw  Kw:macro syntax changed
# 2020-07-29 kdw  Kw:block-def work
# 2020-07-27 kdw  Kw:block syntax
# 2020-07-24 kdw  Kw:comment cleanup
# 2020-07-14 kdw  Kw:c[o]sm1 func
# 2020-07-07 kdw  Kw:sq[r]tx func
# 2020-07-02 kdw  Kw:pend[u]lum func
# 2020-07-01 kdw  Kw:tests modified
# 2020-06-30 kdw  Kw:tests changed
# 2020-06-23 kdw  Kw:func ranam
# 2020-06-18 kdw  Kw:Modulo operator II
# 2020-06-17 kdw  Kw:Modulo operator
# 2020-06-15 kdw  Kw:add prfx to con[t]fra.* funcs
# 2020-06-08 kdw  Kw:integral file
# 2020-06-03 kdw  Kw:writeonly keyword
# 2020-05-30 kdw  Kw:CONST syntax change
# 2020-05-20 kdw  Kw:rmed pr[i]nt_nu[m]2char2
# 2020-05-14 kdw  Kw:block for cbrt
# 2020-05-13 kdw  Kw:lang_.* vars
# 2020-05-12 kdw  Kw:language syntax
# 2020-05-11 kdw  Kw:REPL[A]CE replaced with LO[C]AL_CO[N]ST
# 2020-05-08 kdw  Kw:blocks added
# 2020-05-06 kdw  Kw:rmed boolean vars
# 2020-05-05 kdw  Kw:magic check func changed
# 2020-04-28 kdw  Kw:tweaks here and there
# 2020-04-26 kdw  Kw:BL[O]CK indentation work
# 2020-04-24 kdw  Kw:rem[q]uou func
# 2020-04-23 kdw  Kw:const format change
# 2020-04-19 kdw  Kw:pri[n]t_nu[m]2char rework
# 2020-04-15 kdw  Kw:tests added
# 2020-04-14 kdw  Kw:tests added
# 2020-04-12 kdw  Kw:comment change
# 2020-04-11 kdw  Kw:macro arg format
# 2020-04-10 kdw  Kw:comment change
# 2020-04-08 kdw  Kw:preprocess sigil change
# 2020-04-02 kdw  Kw:no m[o]d func
# 2020-04-01 kdw  Kw:t[a]n to TA[N]
# 2020-03-30 kdw  Kw:bla[c]kbo[d]y work
# 2020-03-29 kdw  Kw:comment change
# 2020-03-16 kdw  Kw:sigm[o]id3d
# 2020-03-09 kdw  Kw:LO[C]AL_.* keywords
# 2020-03-08 kdw  Kw:PR[I]NTVAL change
# 2020-03-06 kdw  Kw:L[A]NG.* names
# 2020-03-03 kdw  Kw:comment change
# 2020-03-01 kdw  Kw:.*_NE[X]T deprecated, et al.
# 2020-02-26 kdw  Kw:comment change
# 2020-02-21 kdw  Kw:ellipse file
# 2020-02-14 kdw  Kw:incomplete beta work
# 2020-02-03 kdw  Kw:.*_LOOP changed
# 2020-01-24 kdw  Kw:func rearrangement
# 2020-01-22 kdw  Kw:kevy func; num2char rework
# 2020-01-21 kdw  Kw:num2char2 experiment
# 2020-01-16 kdw  Kw:func fm[o]ds
# 2020-01-08 kdw  Kw:rmed ran[d]cdf file
# 2019-12-26 kdw  Kw:module name addded to funcs
# 2019-12-11 kdw  Kw:bas[e]_outf func
# 2019-12-06 kdw  Kw:binary search in nu[m]2char
# 2019-11-18 kdw  Kw:black-body work
# 2019-11-17 kdw  Kw:blackbody stuff
# 2019-10-23 kdw  Kw:temperature conversions
# 2019-10-17 kdw  Kw:dont print nl in contfra
# 2019-10-15 kdw  Kw:neg arg for contfrac
# 2019-10-08 kdw  Kw:D[B]LS[I]G rmed
# 2019-10-04 kdw  Kw:comment change
# 2019-09-21 kdw  Kw:several const renamd
# 2019-09-10 kdw  Kw:LAN[G]UAGE NOT to LAN[G]UAGE_N[O]T
# 2019-09-07 kdw  Kw:log1m rmed
# 2019-08-26 kdw  Kw:PRI[N]TS changed to PR[I]NTSTR
# 2019-08-22 kdw  Kw:comment changed
# 2019-08-18 kdw  Kw:B[O]OL changed to B[O]L
# 2019-08-17 kdw  Kw:L[O]G changed to LN
# 2019-08-12 kdw  Kw:insert file cdf
# 2019-08-11 kdw  Kw:language comments
# 2019-08-07 kdw  Kw:language comments
# 2019-08-06 kdw  Kw:rmed backshlashes, macro arg renam
# 2019-06-27 kdw  Kw:float equality work
# 2019-06-26 kdw  Kw:pow work
# 2019-06-12 kdw  Kw:tempf tofrom tempc work
# 2019-06-07 kdw  Kw:die string change
# 2019-06-02 kdw  Kw:NR_ changed to RAPHSON_
# 2019-05-31 kdw  Kw:NR_DO changed to RAPHSON_LOOP; et al
# 2019-05-29 kdw  Kw:comment changed
# 2019-05-28 kdw  Kw:temp_[fc] vars
# 2019-05-26 kdw  Kw:temp[fc] funcs
# 2019-05-24 kdw  Kw:array var renam
# 2019-05-20 kdw  Kw:explicit constants
# 2019-05-08 kdw  Kw:func descripts
# 2019-05-07 kdw  Kw:smooth func[0,1] changed to[-1,1]
# 2019-05-01 kdw  Kw:consts explicit module name
# 2019-04-22 kdw  Kw:F[U]NC keyword
# 2019-04-16 kdw  Kw:THEN, loop_DO keywords experiment
# 2019-03-19 kdw  Kw:re[t]_val changed to re[t]valu
# 2019-03-18 kdw  Kw:macro syntax changed
# 2019-03-09 kdw  Kw:.*mean() func renam
# 2019-03-08 kdw  Kw:is[e]qual changed to is[e]q, et al.
# 2019-03-04 kdw  Kw:loop-limit work
# 2019-02-28 kdw  Kw:REP[L]ACE/DE[F]INE work
# 2019-02-04 kdw  Kw:topy[h] abs changed to ABS
# 2019-01-31 kdw  Kw:topy[h]; iime.hires
# 2019-01-27 kdw  Kw:topy[h]1
# 2019-01-23 kdw  Kw:added call keyword to base-out
# 2019-01-13 kdw  Kw:var rena; reorg
# 2018-12-18 kdw  Kw:kwelements separated
# 2018-12-17 kdw  Kw:base_.* funcs
# 2018-12-12 kdw  Kw:macros.fwip
# 2018-12-10 kdw  Kw:module specific refs
# 2018-12-09 kdw  Kw:cbrt rework using NR
# 2018-12-03 kdw  Kw:newton-raphson method
# 2018-11-29 kdw  Kw:upper cased fwip defined funcs
# 2018-11-28 kdw  Kw:funcs pow2, pow10, log2
# 2018-11-26 kdw  Kw:PL_ prfxs
# 2018-11-06 kdw  Kw:topyh differentiable
# 2018-11-05 kdw  Kw:topyh
# 2018-10-27 kdw  Kw:experiment with other Kw.*.fwip
# 2018-10-08 kdw  Kw:vbdotnet stuff
# 2018-10-05 kdw  Kw:pow rework
# 2018-10-03 kdw  Kw:loop lim now replaced
# 2018-09-27 kdw  Kw:SE[C]ANT comments
# 2018-09-25 kdw  Kw:dot net work
# 2018-09-08 kdw  Kw:SE[C]ANT_DO redef
# 2018-07-23 kdw  Kw:private func renam
# 2018-07-19 kdw  Kw:comments; array reformat
# 2018-07-17 kdw  Kw:private lf_.* funcs
# 2018-07-13 kdw  Kw:float number reformt
# 2018-06-27 kdw  Kw:pow func redefd
# 2018-06-19 kdw  Kw:mved several funcs to simple
# 2018-06-14 kdw  Kw:temp conversion changed
# 2018-06-09 kdw  Kw:mved tests
# 2018-06-07 kdw  Kw:more tests
# 2018-05-22 kdw  Kw:comment change
# 2018-05-20 kdw  Kw:const work
# 2018-05-18 kdw  Kw:LAN[G]UAGE syntax change
# 2018-05-17 kdw  Kw:ARRAY.* and HOR[N]ER syntax
# 2018-05-14 kdw  Kw:BL[O]CK syntax
# 2018-05-13 kdw  Kw:MODE.* syntax change
# 2018-04-24 kdw  Kw:comments
# 2018-04-19 kdw  Kw:consts rework
# 2018-04-03 kdw  Kw:rm() from return
# 2018-04-02 kdw  Kw:Prototype, et al.
# 2018-04-01 kdw  Kw:LAN[G]UAGE_E[N]D
# 2018-03-26 kdw  Kw:macro redef
# 2018-03-17 kdw  Kw:comment change
# 2018-03-12 kdw  Kw:made PP statements not need semicolon
# 2018-02-21 kdw  Kw:temperature conversion work
# 2018-02-19 kdw  Kw:secant and macro refactor
# 2018-02-16 kdw  Kw:iseq, isgt, islt funcs
# 2018-02-10 kdw  Kw:c[o]nstants.f[w]ip
# 2018-02-01 kdw  Kw:temperature stuff
# 2018-01-29 kdw  Kw:julian consts renamd
# 2018-01-04 kdw  Kw:added elliptic.fwip
# 2017-12-13 kdw  Kw:added shc.fwip
# 2017-11-27 kdw  Kw:converted an AW[A]IT loop to a F[O]R loop
# 2017-11-26 kdw  Kw:FR[O]M/B[Y] keywords
# 2017-11-24 kdw  Kw:FR[O]M
# 2017-11-22 kdw  Kw:var renam
# 2017-11-14 kdw  Kw:fm[o]du added
# 2017-11-03 kdw  Kw:fixed f2c(upsidedown conversion factor)
# 2017-10-28 kdw  Kw:horner rework
# 2017-10-22 kdw  Kw:no net change
# 2017-10-21 kdw  Kw:LAN[G]UAGE syntax changed
# 2017-10-06 kdw  Kw:rm astro and earth stuff
# 2017-10-02 kdw  Kw:astro work
# 2017-09-29 kdw  Kw:added squareroot, cuberoot functions
# 2017-09-28 kdw  Kw:const-astro.fwip
# 2017-09-26 kdw  Kw:mved some func to earth
# 2017-09-22 kdw  Kw:comment change
# 2017-09-20 kdw  Kw:number format change
# 2017-09-13 kdw  Kw:vincenty work
# 2017-09-12 kdw  Kw:mved day2[h]ms to julian
# 2017-09-06 kdw  Kw:UNITS support
# 2017-08-31 kdw  Kw:...LAN[G]UAGE
# 2017-08-30 kdw  Kw:s/DBL_/DBL/;s/FLT_/FLT/
# 2017-08-22 kdw  Kw:INS[E]RT_F[I]LE syntax changed
# 2017-08-21 kdw  Kw:.*_P[E]R_.* rmed
# 2017-08-20 kdw  Kw:rmed/renamd .*_P[E]R_.* vars
# 2017-08-18 kdw  Kw:lower case constants
# 2017-08-11 kdw  Kw:var renam
# 2017-07-06 kdw  Kw:minor comment change
# 2017-06-23 kdw  Kw:REPLACE redo
# 2017-06-21 kdw  Kw:LANG_.* AND MASTER.* change
# 2017-06-13 kdw  Kw:comment update
# 2017-06-08 kdw  Kw:magic stuff
# 2017-06-03 kdw  Kw:PRINT.* changed
# 2017-06-01 kdw  Kw:line.fwip added and deleted
# 2017-05-03 kdw  Kw:PROTOTYPE format changed
# 2017-05-02 kdw  Kw:var renam app changed to appr
# 2017-04-20 kdw  Kw:func changed to function
# 2017-04-18 kdw  Kw:bessel
# 2017-04-11 kdw  Kw:partition
# 2017-03-31 kdw  Kw:"NE" changed to "<>", etc
# 2017-03-29 kdw  Kw:"<>" changed to "NE", etc
# 2017-03-24 kdw  Kw:minor reorg
# 2017-03-22 kdw  Kw:minor cleanup
# 2017-03-19 kdw  Kw:minor tweak
# 2017-03-17 kdw  Kw:space after comma
# 2017-03-13 kdw  Kw:VB: pow function
# 2017-03-12 kdw  Kw:shorten long comments
# 2017-03-10 kdw  Kw:get Fw[i]p_Pa[r]se to work
# 2017-03-07 kdw  Kw:futile experiment
# 2017-03-06 kdw  Kw:sigils rmed
# 2017-03-01 kdw  Kw:var[y]log-a[d]d space messup
# 2017-02-28 kdw  Kw:REQ[U]IRE function()
# 2017-02-24 kdw  Kw:REP[L]ACE rework, et al
# 2017-02-23 kdw  Kw:var array nam change
# 2017-02-14 kdw  Kw:FWIP Loop syntax changed
# 2017-02-13 kdw  Kw:FWIP language change
# 2017-02-12 kdw  Kw:FWIP language change
# 2017-02-08 kdw  Kw:.PRO[T]OTYPE
# 2017-01-08 kdw  Kw:INSERT syntax change
# 2017-01-06 kdw  Kw:..LAN[G]UAGE_[I]S.* stuff
# 2017-01-05 kdw  Kw:log1[pm]
# 2016-12-28 kdw  Kw:rearrangement
# 2016-12-27 kdw  Kw:mved earth* to sphere*, et al.
# 2016-12-26 kdw  Kw:mved *_distance funcs to new earth.fwip
# 2016-12-20 kdw  Kw:failed experiment w/ powers
# 2016-12-02 kdw  Kw:..INS[E]RT changed
# 2016-11-28 kdw  Kw:file suffix change
# 2016-11-27 kdw  Kw:square, cube
# 2016-11-25 kdw  Kw:constant renam
# 2016-11-24 kdw  Kw:LAN[G]UAGE_N[O]T to LAN[G]UAGE_IFN[O]T
# 2016-11-23 kdw  Kw:CNST changed to REA[D]ONLY
# 2016-11-22 kdw  Kw:high-precision EU[L]ER calc experiment
# 2016-11-21 kdw  Kw:DE[F] changed to FU[N]C
# 2016-11-20 kdw  Kw:language change
# 2016-11-19 kdw  Kw:minor rearrangement
# 2016-11-17 kdw  Kw:sinx rmed; cbrtx renamd
# 2016-11-16 kdw  Kw:magic stuff
# 2016-11-15 kdw  Kw:MOD/BIT* syntax change
# 2016-11-14 kdw  Kw:mod[u]lo
# 2016-11-11 kdw  Kw:minor refactor
# 2016-11-09 kdw  Kw:FO[R]EVER loop rmed
# 2016-11-08 kdw  Kw:AW[A]IT.*COU[N]T syntax
# 2016-11-07 kdw  Kw:__LANG_* syntax changed
# 2016-11-06 kdw  Kw:isz[e]ro changed to ise[q]ual
# 2016-11-01 kdw  Kw:hyper
# 2016-10-30 kdw  Kw:comment in fmod
# 2016-10-28 kdw  Kw:comment reorg
# 2016-10-14 kdw  Kw:_p added to several vars
# 2016-10-10 kdw  Kw:BC:moved var decls in un and tn
# 2016-10-08 kdw  Kw:lowercased Tn for BC
# 2016-10-07 kdw  Kw:Tn
# 2016-09-28 kdw  Kw:change in vk[k]cp.sh
# 2016-09-19 kdw  Kw:not magic; _[_]INSERT[_]_
# 2016-09-14 kdw  Kw:added() to return statements
# 2016-09-14 kdw  Kw:lang change
# 2016-09-13 kdw  Kw:lang change
# 2016-09-08 kdw  Kw:return statement tweak
# 2016-09-01 kdw  Kw:comment tweak
# 2016-08-25 kdw  Kw:hypot prevent div by 0
# 2016-07-22 kdw  Kw:fmod issues
# 2016-07-19 kdw  Kw:tweak(float numbers)
# 2016-05-25 kdw  Kw:debugging compiler
# 2016-05-24 kdw  Kw:long lines
# 2016-05-18 kdw  Kw:comment change
# 2016-05-12 kdw  Kw:VIS[U]ALBA[S]IC6 rename
# 2016-05-04 kdw  Kw:deprecated P[R]INT
# 2016-05-02 kdw  Kw:debugging on darw[i]n
# 2016-04-27 kdw  Kw:comment tweak
# 2016-03-12 kdw  Kw:cbrt debugging
# 2016-02-29 kdw  Kw:comment tweak
# 2016-01-22 kdw  Kw:long lines
# 2016-01-05 kdw  Kw:minor comment change
# 2015-12-31 kdw  Kw:bounded possible infinite loops
# 2015-12-30 kdw  Kw:__DECLARE__
# 2015-12-28 kdw  Kw:rearranged includes
# 2015-12-28 kdw  Kw:__IF_X__ changed to __IF_NONE__
# 2015-12-21 kdw  Kw:nested __IFs
# 2015-12-11 kdw  Kw:__ENDIF__ renamed
# 2015-12-10 kdw  Kw:i[s]zero stuff
# 2015-12-09 kdw  Kw:debugging
# 2015-12-04 kdw  Kw:end-cr
# 2015-12-03 kdw  Kw:approximations
# 2015-11-27 kdw  Kw:long lines
# 2015-11-26 kdw  Kw:long lines
# 2015-11-19 kdw  Kw:long lines
# 2015-11-15 kdw  Kw:m[a]gic stuff
# 2015-11-13 kdw  Kw:cb[r]t tweak; long lines changed
# 2015-11-12 kdw  Kw:continued fraction expansion
# 2015-11-05 kdw  Kw:par[a]bola.fwip rmed
# 2015-11-02 kdw  Kw:compiler change
# 2015-11-01 kdw  Kw:interp[o]lation
# 2015-10-29 kdw  Kw:refactored c[b]rt
# 2015-10-28 kdw  Kw:refactored c[b]rt
# 2015-10-26 kdw  Kw:fm[o]d2
# 2015-10-22 kdw  Kw:tweak
# 2015-10-18 kdw  Kw:tweak
# 2015-10-17 kdw  Kw:tweak
# 2015-10-16 kdw  Kw:rmed su[n].fwip, add ju[l]ian.fwip
# 2015-10-14 kdw  Kw:su[n].fwip
# 2015-10-13 kdw  Kw:_[_]DEFI[N]E_[_]
# 2015-10-10 kdw  Kw:is* functions moved
# 2015-10-09 kdw  Kw:[agh]+m1 improvements
# 2015-10-08 kdw  Kw:i[n]va[g]m1()
# 2015-10-07 kdw  Kw:L[N]G_MA[X]IMUM
# 2015-10-05 kdw  Kw:i[s]alm[o]stequal
# 2015-10-03 kdw  Kw:ro[u]ndy uses rou[n]d
# 2015-10-02 kdw  Kw:earranged order of functions
# 2015-10-01 kdw  Kw:float equality checks to is.*
# 2015-09-30 kdw  Kw:_[_]IF_[N]OT_.*
# 2015-09-29 kdw  Kw:variables renamed; fixed c[b]rt
# 2015-09-28 kdw  Kw:variable rename in par[a]bola_a[x]is
# 2015-09-27 kdw  Kw:par[a]bola_a[x]is
# 2015-09-27 kdw  Kw:infinite loop in c[b]rt function
# 2015-09-26 kdw  Kw:debugging agm vs BCC
# 2015-09-25 kdw  Kw:B[I]T* format change
# 2015-09-24 kdw  Kw:bit ops changed
# 2015-09-22 kdw  Kw:Units on constants
# 2015-09-22 kdw  Kw:VB6 VBDOTNET: no m[o]d function
# 2015-09-21 kdw  Kw:m[o]d function
# 2015-09-20 kdw  Kw:moved several functions
# 2015-09-19 kdw  Kw:redim redo
# 2015-09-18 kdw  Kw:renamed various
# 2015-09-17 kdw  Kw:at[o]thenmodp, co[n]tfrac
# 2015-09-16 kdw  Kw:functions var[i]ance and ave[r]age
# 2015-09-15 kdw  Kw:long lines changed
# 2015-09-14 kdw  Kw:g[p]f
# 2015-09-11 kdw  Kw:dont print newlines
# 2015-09-10 kdw  Kw:e[r]f stuff
# 2015-09-09 kdw  Kw:rmed empty lines
# 2015-09-08 kdw  Kw:mv global vars to where theyre used
# 2015-09-07 kdw  Kw:n[2]com[b]r
# 2015-09-06 kdw  Kw:bino[m]ial
# 2015-09-04 kdw  Kw:ber[n]oulli[nd], *_EP[S]ILON
# 2015-09-03 kdw  Kw:array passing addressed
# 2015-09-02 kdw  Kw:cli[p] refactor
# 2015-09-01 kdw  Kw:s[t]ts_n[e]w* stuff
# 2015-08-31 kdw  Kw:RE[D]IM stuff
# 2015-08-30 kdw  Kw:BC long lines
# 2015-08-29 kdw  Kw:more BC stuff
# 2015-08-28 kdw  Kw:BC stuff
# 2015-08-27 kdw  Kw:random number work
# 2015-08-26 kdw  Kw:random number work
# 2015-08-25 kdw  Kw:addeed GL[O]BAL designator for Python
# 2015-08-24 kdw  Kw:fixed syntax for VB
# 2015-08-23 kdw  Kw:rmed unneeded()
# 2015-08-22 kdw  Kw:bern[o]ulli refactor
# 2015-08-21 kdw  Kw:kw[2].pl change(C stuff)
# 2015-08-20 kdw  Kw:kw[2].pl change
# 2015-08-19 kdw  Kw:stts_* stuff
# 2015-08-18 kdw  Kw:redid some stat stuff
# 2015-08-17 kdw  Kw:syntax error
# 2015-08-16 kdw  Kw:added CO[N]STs, stts_*
# 2015-08-15 kdw  Kw:tweak
# 2015-08-14 kdw  Kw:rmed() in syntax of WH[I]LE, FO[R], I[F]
# 2015-08-12 kdw  Kw:tweak
# 2015-08-11 kdw  Kw:touched
# 2015-08-10 kdw  Kw:comment changed
# 2015-08-09 kdw  Kw:sigma*, et al.
# 2015-08-08 kdw  Kw:cdf[k]s2; randtri, randnbd, randbin
# 2015-08-07 kdw  Kw:longlines broken up
# 2015-08-06 kdw  Kw:keyword BEG rmed
# 2015-08-05 kdw  Kw:fa[c]torial, et al.
# 2015-08-04 kdw  Kw:std[e]v2sp[r]ead; rto[iz]
# 2015-08-03 kdw  Kw:VB6 VBDOTNET debugging
# 2015-08-02 kdw  Kw:python fixes; GL[O]BAL
# 2015-08-01 kdw  Kw:python fixes; CONT[I]NUE
# 2015-07-31 kdw  Kw:F[O]R loops
# 2015-07-30 kdw  Kw:refactor
# 2015-07-29 kdw  Kw:refactor / more functions
# 2015-07-28 kdw  Kw:refactor / rename
# 2015-07-27 kdw  Kw:typo
# 2015-07-17 kdw  Kw:*normal stuff
# 2015-07-16 kdw  Kw:e[r]f
# 2015-07-15 kdw  Kw:W[0]
# 2015-07-14 kdw  Kw:gamma
# 2015-07-13 kdw  Kw:created
IMPORT_MASTER;
# insert master functions before other code
#TEST:atan2(-1,1)==-PI/4;
#TEST:atan2(-1,-1)==-3*PI/4;
#TEST:atan2(1,-1)==3*PI/4;
#TEST:atan2(0,-18)==PI;
#TEST:atan2(0,18)-0;
#TEST:atan2(-18,0)==-PI/2;
#TEST:atan2(18,0)==PI/2;
#TEST:cbrt(3)==1.44224957030740838232163831078010958839186925;
#TEST:ln(3)==1.09861228866810969139524523692252570464749055782;
#TEST:exp(2)==7.38905609893065022723042746057500781318031557055;
#TEST:sin(1)==0.84147098480789650665250232163029899962256306080;
#TEST:cos(1)==0.54030230586813971740093660744297660373231042062;
#TEST:log(exp(4.7))==4.7;
#TEST:cbrt(pow(2.73,3))==2.73;
#TEST:pow(frac(sqrt(17))+floor(sqrt(17)),2)==17;
# Start doing things, ..
#   IIIIIIIIIInsert-Begin ------------------------- Macros.fwip #
#    COPYRIGHT C 2018-2020 by Kevin D. Woerner
# 2020-08-17 kdw  Macros:macro syntax changed
# 2020-07-24 kdw  Macros:comment cleanup
# 2020-06-20 kdw  Macros:comment change
# 2020-04-26 kdw  Macros:block indentation
# 2020-04-23 kdw  Macros:const format change
# 2020-04-12 kdw  Macros:comment change
# 2020-04-11 kdw  Macros:macro arg format
# 2020-04-08 kdw  Macros:preprocess sigil change
# 2020-03-06 kdw  Macros:RE[P]LACE / IN[D]EX changes
# 2020-03-03 kdw  Macros:comment changed:odd chars
# 2020-03-02 kdw  Macros:s/_NE[X]T/_E[N]D/g
# 2020-02-26 kdw  Macros:HO[R]NER rmed
# 2020-02-14 kdw  Macros:incomplete beta work
# 2020-02-03 kdw  Macros:.*_LOOP changed
# 2019-11-19 kdw  Macros:format change
# 2019-10-04 kdw  Macros:comment change
# 2019-10-02 kdw  Macros:macro arg format change
# 2019-08-24 kdw  Macros:for and count loops have from clause
# 2019-08-14 kdw  Macros:comments added
# 2019-08-13 kdw  Macros:reorg ho[r]ner
# 2019-08-06 kdw  Macros:rmed backslashes, macro arg renam
# 2019-06-02 kdw  Macros:NR_ to RAPHSON_
# 2019-05-31 kdw  Macros:NR_DO to RAPHSON_LOOP; et al
# 2019-05-29 kdw  Macros:comment changed
# 2019-05-16 kdw  Macros:loop limit def mved
# 2019-03-18 kdw  Macros:macro syntax changed
# 2019-03-08 kdw  Macros:is[e]qual to is[e]q, et al.
# 2019-03-06 kdw  Macros:is.* funcs changed
# 2019-03-04 kdw  Macros:loop-limit work
# 2019-02-28 kdw  Macros:REP[L]ACE/DE[F]INE work
# 2019-02-19 kdw  Macros:macro syntax
# 2019-02-13 kdw  Macros:comment work
# 2018-12-20 kdw  Macros:work on module specific functions
# 2018-12-12 kdw  Macros:created
# limit for loops
#   IIIIIIIIIInsert-End --------------------------- Macros.fwip #
#   IIIIIIIIIInsert-Begin ---------------------- constants.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-19 kdw  constants:comment change
# 2020-08-18 kdw  constants:minor tweaks
# 2020-08-17 kdw  constants:macro syntax changed
# 2020-07-09 kdw  constants:sqrttwo constant
# 2020-06-30 kdw  constants:black hole stuff
# 2020-06-29 kdw  constants:hal[a]qim def mved
# 2020-06-23 kdw  constants:.*si.* and .*ui.* prefxes
# 2020-06-22 kdw  constants:local-use mved befroe var decls
# 2020-06-02 kdw  constants:rmed several .*_err  consts
# 2020-05-30 kdw  constants:CONST syntax change
# 2020-05-29 kdw  constants:macro work
# 2020-05-27 kdw  constants:rmed "/" from some comments
# 2020-05-14 kdw  constants:lower case consts
# 2020-05-13 kdw  constants:lang_.* vars
# 2020-05-12 kdw  constants:language syntax
# 2020-04-28 kdw  constants:minor tweak
# 2020-04-23 kdw  constants:const format change
# 2020-04-20 kdw  constants:language work
# 2020-04-11 kdw  constants:macro arg format
# 2020-04-08 kdw  constants:preprocess sigil change
# 2020-03-23 kdw  constants:electron mass a
# 2020-03-21 kdw  constants:DBL[M]AX redefd
# 2020-03-06 kdw  constants:L[A]NG.* names
# 2020-03-03 kdw  constants:comment change
# 2020-02-28 kdw  constants:const suffix rmed; wave stuff
# 2020-02-26 kdw  constants:s/INV/_REC/
# 2020-02-25 kdw  constants:comment cleanup
# 2020-02-14 kdw  constants:incomplete beta work
# 2020-02-10 kdw  constants:EM frequencies
# 2019-12-17 kdw  constants:failed experiment
# 2019-12-13 kdw  constants:stefan redefd to avoid underflow II
# 2019-12-11 kdw  constants:stefan redefd to avoid underflow
# 2019-11-20 kdw  constants:POW[2-5] macros
# 2019-11-18 kdw  constants:.*MASS and .*_MASS work
# 2019-11-08 kdw  constants:hal[a]qim
# 2019-11-06 kdw  constants:earth-solar day
# 2019-10-24 kdw  constants:information units
# 2019-10-23 kdw  constants:bekenstein
# 2019-10-22 kdw  constants:proton radius updated
# 2019-10-11 kdw  constants:more length and frequency constants
# 2019-10-10 kdw  constants:A2 units
# 2019-10-08 kdw  constants:comment change
# 2019-10-07 kdw  constants:DBL.* chage
# 2019-10-04 kdw  constants:comment change
# 2019-10-02 kdw  constants:macro arg format change
# 2019-10-01 kdw  constants:ry[d]berg.* work
# 2019-09-28 kdw  constants:work
# 2019-09-26 kdw  constants:const renam
# 2019-09-25 kdw  constants:TT.* changes
# 2019-09-24 kdw  constants:uamu
# 2019-09-23 kdw  constants:minor tweak
# 2019-09-22 kdw  constants:s/J[D]_AT_/JDSEC_AT_/g
# 2019-09-21 kdw  constants:several const renamd
# 2019-09-19 kdw  constants:battery update
# 2019-09-18 kdw  constants:molar mass constant
# 2019-09-10 kdw  constants:LAN[G]UAGE NOT to LAN[G]UAGE_N[O]T
# 2019-09-09 kdw  constants:comments on gravity[ab]
# 2019-09-08 kdw  constants:gravitational const update
# 2019-09-05 kdw  constants:comment text added to cntse macro
# 2019-09-04 kdw  constants:cnstn macro
# 2019-09-03 kdw  constants:dalton work
# 2019-09-01 kdw  constants:comment changes
# 2019-08-30 kdw  constants:he[i]ght/wid[t]h are VB6 reserved
# 2019-08-29 kdw  constants:dimension work
# 2019-08-28 kdw  constants:hect?are defined
# 2019-08-22 kdw  constants:" - " to " + - " to make units happy
# 2019-08-17 kdw  constants:L[O]G to L[N]
# 2019-08-15 kdw  constants:CON[S]TANT to CON[S]T keyword change
# 2019-08-13 kdw  constants:reorg f[o]urth macro
# 2019-08-11 kdw  constants:comment cleanup
# 2019-08-09 kdw  constants:refactor
# 2019-08-07 kdw  constants:language comments
# 2019-08-06 kdw  constants:rmed backslashes
# 2019-07-23 kdw  constants:DBL.* redef
# 2019-07-22 kdw  constants:macro cleanup
# 2019-07-09 kdw  constants:comment
# 2019-07-03 kdw  constants:tweak
# 2019-07-02 kdw  constants:macro renam
# 2019-07-01 kdw  constants:more .*_ERR consts
# 2019-06-12 kdw  constants:tempc to tempf work; volume defs
# 2019-06-10 kdw  constants:reorg
# 2019-06-04 kdw  constants:rmed SR const
# 2019-05-31 kdw  constants:comment changed
# 2019-05-29 kdw  constants:comment changed
# 2019-05-28 kdw  constants:colors updated
# 2019-05-24 kdw  constants:hubble const update
# 2019-05-22 kdw  constants:rmed unneeded()s
# 2019-05-20 kdw  constants:short abbrevs; Capitalization
# 2019-05-15 kdw  constants:tweaked
# 2019-05-14 kdw  constants:M_[EPN] rmed(C, VB have problems)
# 2019-05-08 kdw  constants:hydrogen line work II
# 2019-05-07 kdw  constants:particle mass work
# 2019-05-06 kdw  constants:hydrogen line work
# 2019-05-04 kdw  constants:planck.* error
# 2019-05-03 kdw  constants:error work; hydrogen line
# 2019-05-01 kdw  constants:reorg; point
# 2019-04-26 kdw  constants:added torr,bar,mmhg
# 2019-04-25 kdw  constants:error reorg
# 2019-04-23 kdw  constants:electron Mass redo
# 2019-04-22 kdw  constants:universe mass
# 2019-04-18 kdw  constants:gas density
# 2019-04-16 kdw  constants:BHRAD[I]US2DENSITY
# 2019-03-19 kdw  constants:re[t]_val to re[t]valu
# 2019-03-18 kdw  constants:macro syntax changed
# 2019-03-15 kdw  constants:reorg order of ops to avoid < 1E-50
# 2019-03-08 kdw  constants:rmed defines
# 2019-03-05 kdw  constants:mved unitgm
# 2019-03-01 kdw  constants:added "+" after "E"
# 2019-02-28 kdw  constants:REP[L]ACE/DE[F]INE work
# 2019-02-04 kdw  constants:kwt epoch changed
# 2019-01-23 kdw  constants:fourth macro; refactor
# 2019-01-14 kdw  constants:iso binary prefxes
# 2018-12-23 kdw  constants:charge is fundamental
# 2018-12-21 kdw  constants:alpha, et al. mass
# 2018-12-07 kdw  constants:explicit imported funcitons
# 2018-11-30 kdw  constants:rm PA[S]CAL def
# 2018-11-07 kdw  constants:cardinals
# 2018-11-05 kdw  constants:J[CDM].* consts
# 2018-11-01 kdw  constants:rearrange
# 2018-10-08 kdw  constants:vbdotnet stuff
# 2018-10-03 kdw  constants:rearrange
# 2018-10-02 kdw  constants:comment fix
# 2018-09-15 kdw  constants:minor moacro def change
# 2018-07-21 kdw  constants:reformat
# 2018-07-13 kdw  constants:float number reformt
# 2018-07-10 kdw  constants:added "+" to exponents
# 2018-07-09 kdw  constants:alpha redefd
# 2018-06-27 kdw  constants:const work
# 2018-06-25 kdw  constants:kcd constant
# 2018-06-14 kdw  constants:temps redo
# 2018-06-13 kdw  constants:reorg
# 2018-05-18 kdw  constants:LAN[G]UAGE syntax change
# 2018-05-02 kdw  constants:atomic masses changed
# 2018-04-29 kdw  constants:stefans constant
# 2018-04-28 kdw  constants:updated values
# 2018-04-25 kdw  constants:50 deci places on constants
# 2018-04-24 kdw  constants:feingenbaum, apery constants
# 2018-04-23 kdw  constants:m(ps)s
# 2018-04-15 kdw  constants:kwt work
# 2018-04-14 kdw  constants:ep(oc)hx renamd to kwt
# 2018-04-10 kdw  constants:e(po)chx-u(ni)x-diff
# 2018-04-01 kdw  constants:LAN[G]UAGE_E[N]D
# 2018-03-26 kdw  constants:jpkg = joule / kg = light**2
# 2018-03-20 kdw  constants:minor debugging
# 2018-03-16 kdw  constants:format of constant and index change
# 2018-03-15 kdw  constants:_it vs _th stuff
# 2018-03-14 kdw  constants:mved temp stuff; power/energy work
# 2018-03-13 kdw  constants:stefan boltzmann rework
# 2018-03-12 kdw  constants:made PP statements not need ":"
# 2018-03-11 kdw  constants:mved iso-prefxes, et al.
# 2018-03-09 kdw  constants:constify to constx
# 2018-03-08 kdw  constants:constify
# 2018-03-06 kdw  constants:rpm redefd
# 2018-03-05 kdw  constants:cube renam
# 2018-02-22 kdw  constants:ep(oc)hx refactor
# 2018-02-20 kdw  constants:comments changed
# 2018-02-19 kdw  constants:secant and macro refactor
# 2018-02-17 kdw  constants:expandnow changed
# 2018-02-15 kdw  constants:descriptors commented out
# 2018-02-14 kdw  constants:minor refactor
# 2018-02-10 kdw  constants:refactor; redef of several
# 2018-02-03 kdw  constants:degree fahrenheit units stuff
# 2018-02-01 kdw  constants:degree fahrenheit stuff
# 2018-01-30 kdw  constants:reorg
# 2018-01-29 kdw  constants:julian consts renamd
# 2018-01-28 kdw  constants:time const name change
# 2018-01-26 kdw  constants:FL[I]CK added
# 2018-01-22 kdw  constants:parens; JDSEC_AT_.* redo
# 2018-01-11 kdw  constants:CODATA 2017
# 2017-11-04 kdw  constants:multiple =
# 2017-11-03 kdw  constants:reorg
# 2017-10-26 kdw  constants:reorg
# 2017-10-24 kdw  constants:number underscore
# 2017-10-23 kdw  constants:lang is any fix
# 2017-10-22 kdw  constants:more constants
# 2017-10-21 kdw  constants:macros start with "at""at"
# 2017-10-20 kdw  constants:COM[M]ENT/"at""at"[S]Q syntax change
# 2017-10-16 kdw  constants:stellar day
# 2017-10-15 kdw  constants:sun mass
# 2017-10-13 kdw  constants:nuclear mass ratios
# 2017-10-07 kdw  constants:0epochx redefd;
# 2017-10-03 kdw  constants:KM
# 2017-10-02 kdw  constants:several consts from const-astro
# 2017-10-01 kdw  constants:ATM
# 2017-09-29 kdw  constants:PARSEC, AU moved to here
# 2017-09-28 kdw  constants:c(on)st-as(tr)o.f(wi)p
# 2017-09-27 kdw  constants:EA[R]THGR[A]VITY[AB]
# 2017-09-26 kdw  constants:VONK(LI)TZING and J(OS)EPHSON
# 2017-09-25 kdw  constants:EP(OC)HX redefd
# 2017-09-22 kdw  constants:comment change
# 2017-09-21 kdw  constants:comment change
# 2017-09-20 kdw  constants:julian date work
# 2017-09-17 kdw  constants:more units work
# 2017-09-16 kdw  constants:other base units rmed
# 2017-09-15 kdw  constants:fail
# 2017-09-14 kdw  constants:other base units
# 2017-09-12 kdw  constants:rework of date constants
# 2017-09-08 kdw  constants:more UNITS support
# 2017-09-07 kdw  constants:more UNITS support
# 2017-09-06 kdw  constants:more UNITS support
# 2017-09-06 kdw  constants:UNITS support
# 2017-08-31 kdw  constants:...LAN[G]UAGE
# 2017-08-30 kdw  constants:s/DBL_/DBL/;s/FLT_/FLT/
# 2017-08-28 kdw  constants:re-uppercased const nams
# 2017-08-24 kdw  constants:EP[O]CHX experiment
# 2017-08-22 kdw  constants:comment change
# 2017-08-21 kdw  constants:.*_P[E]R_.* rmed
# 2017-08-20 kdw  constants:rmed/renamd .*_P[E]R_.* vars
# 2017-08-18 kdw  constants:lower case consts
# 2017-08-17 kdw  constants:siderealday redef; G* consts
# 2017-06-21 kdw  constants:LANG_.* AND MASTER.* change
# 2017-06-19 kdw  constants:DBL* constsnt changed
# 2017-04-21 kdw  constants:comment change
# 2017-04-13 kdw  constants:rm unused consts
# 2017-04-12 kdw  constants:allow _ to start names
# 2017-04-03 kdw  constants:failed experiment
# 2017-03-30 kdw  constants:comments
# 2017-03-28 kdw  constants:comments on language
# 2017-03-27 kdw  constants:double max
# 2017-03-21 kdw  constants:long line error vs pytho
# 2017-03-10 kdw  constants:get Fw[i]p_Pa[r]se to work
# 2017-03-07 kdw  constants:C(ON)S(TA)NT format changed
# 2017-03-06 kdw  constants:sigils rmed, et al.
# 2017-03-01 kdw  constants:var[y]log-a[d]d space messup
# 2017-02-24 kdw  constants:LAN[G]UAGE change
# 2017-02-14 kdw  constants:cnv_dbl2* renam
# 2017-02-13 kdw  constants:FWIP language change
# 2017-02-12 kdw  constants:FWIP language change
# 2017-01-06 kdw  constants:.*_SIGN[I]FIGANCE
# 2017-01-06 kdw  constants:..LAN[G]UAGE_.* change
# 2016-12-31 kdw  constants:PLA[N]CKCHARGE, et al.
# 2016-12-28 kdw  constants:more *_MAX, *_MIN consts
# 2016-12-26 kdw  constants:earth[AB], et al.
# 2016-12-25 kdw  constants:REV to TURN
# 2016-12-24 kdw  constants:rmed grad support
# 2016-12-20 kdw  constants:indent preprocess stuff
# 2016-12-18 kdw  constants:lunar stuff
# 2016-12-09 kdw  constants:epx per sec changed
# 2016-12-08 kdw  constants:comment change
# 2016-12-07 kdw  constants:comment change
# 2016-12-04 kdw  constants:comment change
# 2016-12-02 kdw  constants:rmed unused defines
# 2016-11-30 kdw  constants:minus sign problems
# 2016-11-25 kdw  constants:renamd consts
# 2016-11-24 kdw constants:LAN[G]UAGE_N[O]T to LAN[G]UAGE_IFN[O]T
# 2016-11-23 kdw  constants:C(ON)ST to C(ON)S(TA)NT
# 2016-11-22 kdw  constants:high-precision eu(le)r experiment
# 2016-11-21 kdw  constants:D(EF) to F(UN)C
# 2016-11-20 kdw  constants:language change
# 2016-11-19 kdw  constants:angle stuff
# 2016-11-14 kdw  constants:LANG_ stuff
# 2016-11-09 kdw  constants:underscores added to names
# 2016-11-03 kdw  constants:julian stuff
# 2016-11-02 kdw  constants:comment reorg
# 2016-10-28 kdw  constants:comment reorder
# 2016-10-27 kdw  constants:comment typo
# 2016-09-13 kdw  constants:lang change
# 2016-09-07 kdw  constants:rmed unused code
# 2016-09-01 kdw  constants:L(I2); comment tweak
# 2016-08-26 kdw  constants:comments
# 2016-08-23 kdw  constants:one-letter vars
# 2016-08-19 kdw  constants:ARC*
# 2016-08-17 kdw  constants:PLAN[C]K*
# 2016-08-16 kdw  constants:comment
# 2016-08-15 kdw  constants:refactor
# 2016-08-12 kdw  constants:refactor temperature stuff
# 2016-08-11 kdw  constants:refactor temperature stuff
# 2016-08-07 kdw  constants:week stuff
# 2016-08-05 kdw  constants:VB6 VBDOTNET: "in" is a keyword
# 2016-08-04 kdw  constants:OUNCE, KILOGRAM, METER
# 2016-08-02 kdw  constants:SECOND, et al.; Julian stuff
# 2016-07-28 kdw  constants:D(AY)E / YAR renamed
# 2016-07-26 kdw  constants:D(AY)_PER*
# 2016-07-18 kdw  constants:astronomical constants
# 2016-07-14 kdw  constants:more time constants
# 2016-07-13 kdw  constants:time and rev constants
# 2016-05-26 kdw  constants:rmed unused const
# 2016-05-24 kdw  constants:long lines
# 2016-05-18 kdw  constants:indent vs Py(th)on problems
# 2016-05-16 kdw  constants:temperature consts changed
# 2016-05-12 kdw  constants:VI(SU)AL(BA)SIC6 rename
# 2016-03-12 kdw  constants:BC: scale increased
# 2016-02-29 kdw  constants:comment tweak
# 2015-12-30 kdw  constants:O(ME)GA definition problems
# 2015-12-21 kdw  constants:nested __(IF).*s
# 2015-12-11 kdw  constants:_[_]DE[F]INE_[_] refactor
# 2015-12-11 kdw  constants:_[_]EN[D]IF_[_] obsoleted
# 2015-12-10 kdw  constants:epsilons redefined
# 2015-12-03 kdw  constants:renamed constants
# 2015-12-01 kdw  constants:use only 25 decimal places
# 2015-11-26 kdw  constants:longl lines
# 2015-11-16 kdw  constants:tweak
# 2015-11-13 kdw  constants:e[u]ler change
# 2015-11-12 kdw  constants:tweak
# 2015-10-14 kdw  constants:DEGR[E]E_PER_[R]ADIAN
# 2015-10-13 kdw  constants:created
# Base SI units
CONST KILOGRAM 1.0;#M
CONST METER 1.0;#L
CONST SECOND 1.0;#T
CONST KELVIN 1.0;#K
CONST AMPERE 1.0;#I
CONST COULOMB AMPERE * SECOND;#TI
#CONST COULOMB 1.0;        #C
#CONST AMPERE COULOMB / SECOND; #CT-1
CONST MOLE 1.0;#N
CONST CANDELA 1.0;#J
CONST BIT 1.0;#B
CONST RADIAN 1.0;#A
CONST STERADIAN RADIAN * RADIAN;#A2
CONST METRE METER;#L
CONST KG KILOGRAM;#M
#CONST M METER;     #L
#CONST S SECOND;     #T
#CONST C COULOMB;   #TI
#CONST CD CANDELA;    #J # VB conflict with cd()
CONST RAD RADIAN;#A
# All base SI units(KILOGRAM, METER, KELVIN, SECOND,
#   AMPERE, MOLE, CANDELA, RADIAN)
# should be defined by this point
##    NUMBERS --- ----- ----- ----- ----- ----- ----- ----- -----
LANGUAGE LANG_BC LANG_PERL LANG_PYTHON LANG_UNITS:# formulas
   CONST E EXP(1.0);#1
   CONST TAU 8.0 * ATAN2(1.0, 1.0) / RAD;#1
   CONST PHI 0.5 + SQRT(5.0) / 2.0;#1
   CONST LNTWO LN(2.0);#1
   CONST LNTEN LN(10.0);#1
   CONST SQRTTWO SQRT(2.0);#1
LANGUAGE_END# formulas
LANGUAGE_NOT LANG_BC LANG_PERL LANG_PYTHON LANG_UNITS:# formulas
   CONST E
         2.71828182845904523536028747135266249775724709369996;#1
   CONST TAU
         6.28318530717958647692528676655900576839433879875021;#1
   CONST PHI
         1.61803398874989484820458683436563811772030917980576;#1
   CONST LNTWO
         0.69314718055994530941723212145817656807550013436026;#1
   CONST LNTEN
         2.30258509299404568401799145468436420760110148862877;#1
   CONST SQRTTWO
         1.41421356237309504880168872420969807856967187537695;#1
LANGUAGE_END# formulas
CONST EULER 0.57721566490153286060651209008240243104215934;#1
CONST FEIGENBAUM 4.669201609102990671853203820466201617258;#1
CONST APERY 1.20205690315959428539973816151144999076498629;#1
CONST PI TAU / 2.0;#1
# ISO prefixes
CONST YOTTA 1.0E+24;#1
CONST ZETTA 1.0E+21;#1
CONST EXA 1.0E+18;#1
CONST PETA 1.0E+15;#1
CONST TERA 1.0E+12;#1
CONST GIGA 1.0E+9;#1
CONST MEGA 1.0E+6;#1
CONST KILO 1.0E+3;#1
CONST HECTO 1.0E+2;#1
CONST DECA 1.0E+1;#1
CONST DECI 1.0E-1;#1
CONST CENTI 1.0E-2;#1
CONST MILLI 1.0E-3;#1
CONST MICRO 1.0E-6;#1
CONST NANO 1.0E-9;#1
CONST PICO 1.0E-12;#1
CONST FEMTO 1.0E-15;#1
CONST ATTO 1.0E-18;#1
CONST ZEPTO 1.0E-21;#1
CONST YOCTO 1.0E-24;#1
CONST KIBI 1024.0;#1
CONST MEBI KIBI * KIBI;#1
CONST GIBI MEBI * KIBI;#1
CONST TEBI GIBI * KIBI;#1
CONST PEBI TEBI * KIBI;#1
CONST EXBI PEBI * KIBI;#1
CONST ZEBI EXBI * KIBI;#1
CONST YOBI ZEBI * KIBI;#1
# following name conflicts with "sec" trig function
# CONS TANT SEC         SECOND;               #T
#   Standard-derived-units -- ----- ----- ----- ----- ----- -----
CONST MPS METER / SECOND;#LT-1
CONST MPSS METER / (SECOND * SECOND);#LT-2
CONST UNITGM METER * MPS * MPS;#L3T-2
CONST NEWTON KILOGRAM * MPSS;#MLT-2
CONST JOULE NEWTON * METER;#ML2T-2
#CONST PASCAL NEWTON / (METER * METER);  #ML-1T-2
CONST PA NEWTON / (METER * METER);#ML-1T-2
CONST WATT JOULE / SECOND;#ML2T-3
CONST HERTZ 1.0 / SECOND;#T-1
CONST AMP AMPERE;#I
#CONST        A AMPERE;                  #I
CONST VOLT WATT / AMPERE;#ML2T-4I-1
CONST OHM VOLT / AMPERE;#ML2T-2I-1
CONST HENRY OHM * SECOND;#ML2T-2I-2
CONST FARAD COULOMB / VOLT;#T4I2M-1L-2
CONST SIEMENS 1.0 / OHM;#T3I2M-1L-2
CONST WEBER VOLT * SECOND;#ML2T-2I-1
CONST TESLA WEBER / (METER * METER);#MT-2I-1
CONST LUMEN CANDELA * STERADIAN;#JA2
CONST LUX LUMEN / (METER * METER);#JA2L-2
#   SI-constants  2019-05-20 - ---- ----- ----- ----- ----- -----
CONST BOLTZMANN 1.380649E-23 * JOULE / KELVIN;#ML2T-2K-1
CONST BOLTZMANN_ERR 0;#1
CONST ELECTRONCHARGE 1.602176634E-19 * COULOMB;#TI
CONST ELECTRONCHARGE_ERR 0;#1
CONST LIGHT 2.99792458E+8 * METER / SECOND;#LT-1
CONST LIGHT_ERR 0;#1
CONST AVOGADRO 6.02214076E+23 / MOLE;#N-1
CONST AVOGADRO_ERR 0;#1
CONST PLANCK 6.62607015E-34 * JOULE * SECOND;#ML2T-1
CONST PLANCK_ERR 0;#1
CONST KCD 6.83E+2 * LUMEN / WATT;#JA2S3M-1L-2
CONST KCD_ERR 0;#1
CONST dvCsHz 9.19263177E+9 / SECOND;#T-1
CONST dvCsWAVELENGTH LIGHT / dvCsHz;#L
CONST dvCsWAVENUMBER 1.0 / dvCsWAVELENGTH;#L-1
CONST dvCsENERGY PLANCK * dvCsHz;#ML-2T-2
CONST dvCs_ERR 0;#1
CONST kB BOLTZMANN;#ML2T-2K-1
CONST kB_ERR BOLTZMANN_ERR;#1
CONST ELEMENTARYCHARGE ELECTRONCHARGE;#TI
CONST ELEMENTARYCHARGE_ERR ELECTRONCHARGE_ERR;#1
CONST PLANCKBAR PLANCK / TAU;#ML2T-1
CONST PLANCKBAR_ERR PLANCK_ERR;#1
CONST h PLANCK;#ML2T-1
CONST h_ERR PLANCK_ERR;#1
CONST HBAR PLANCKBAR;#ML2T-1
CONST HBAR_ERR PLANCKBAR_ERR;#1
CONST BOLTZMANN_REC 1.0 / BOLTZMANN;#T2KM-1L-2
CONST ELECTRONCHARGE_REC 1.0 / ELECTRONCHARGE;#T-1I-1
CONST LIGHT_REC 1.0 / LIGHT;#TL-1
CONST AVOGADRO_REC 1.0 / AVOGADRO;#N
CONST dvCsHz_REC 1.0 / dvCsHz;#T
CONST PLANCK_REC 1.0 / PLANCK;#TM-1L-2
CONST h_REC PLANCK_REC;#TM-1L-2
CONST kB_REC BOLTZMANN_REC;#T2KM-1L-2
CONST KGHz KG * LIGHT * LIGHT / PLANCK;#T-1
CONST KGWAVELENGTH LIGHT / KGHz;#L
CONST KGWAVENUMBER 1.0 / KGWAVELENGTH;#L-1
CONST KGENERGY PLANCK * KGHz;#ML-2T-2
#   Exact-constants --- ----- ----- ----- ----- ----- ----- -----
CONST GRAVITY 9.80665 * MPSS;#LT-2
CONST GRAVITY_ERR 0;#1
CONST ATMOSPHERE 1.01325E+5 * PA;#ML-1T-2
CONST ATMOSPHERE_ERR 0;#1
CONST AU 1.495978707E+11 * METER;#L
CONST AU_ERR 0;#1
#   EXACT-derived-constants -- ---- ----- ----- ----- ----- -----
CONST JOSEPHSON 2.0 * ELECTRONCHARGE / PLANCK;#T2IM-1L-2
CONST JOSEPHSON_ERR 0;#1
CONST VONKLITZING PLANCK / (ELECTRONCHARGE * ELECTRONCHARGE);
      #ML2T-3I-2
CONST VONKLITZING_ERR 0;#1
CONST FARADAY ELECTRONCHARGE * AVOGADRO;#TIN-1
CONST FARADAY_ERR 0;#1
CONST GAS BOLTZMANN * AVOGADRO;#ML2T-2K-1N-1
CONST GAS_ERR 0;#1
#   CODATA-2018 Measured-constants  ----- ----- ----- ----- -----
CONST GRAVITATION 6.67430E-11 * UNITGM / KILOGRAM;#L3T-2M-1
CONST GRAVITATION_ERR 2.2E-5;#1
CONST RYDBERG 1.0973731568160E+7 * LIGHT / METER;#T-1
CONST RYDBERG_ERR 1.9E-12;#1
CONST G GRAVITATION;#L3T-2M-1
CONST G_ERR GRAVITATION_ERR;#1
CONST ALPHA 7.2973525664E-3;#1
CONST ALPHA_ERR 2.3E-10;#1
CONST ALPHA_REC 1.0 / ALPHA;#1
CONST ALPHA_REC_ERR ALPHA_ERR;#1
##    NUMBER LIMITS --- ----- ----- ----- ----- ----- ----- -----
CONST FLTSIG 23;#1
CONST FLTMAN 8;#1
CONST FLTEPS 1.1920928955078125E-7;
#1 # 2 ** -FLTSIG
# 2 ** 2 ** (FLTMAN - 1) * (1 - FLTEPS / 2)
CONST FLTMAX 3.402823466385288598E+38;#1
CONST DBLMAXLN Kw.LNTWO * 1024;
LANGUAGE LANG_BC:# different DBL resolution
   CONST DBLSIG scale * Kw.LNTEN / Kw.LNTWO;#1
   CONST DBLEPS EXP(Kw.LNTEN * (1.0 - scale));#1
   CONST DBLMAX EXP(DBLMAXLN) * (1.0 - DBLEPS);
   # BC #1
LANGUAGE_END# different DBL resolution
LANGUAGE_NOT LANG_BC:# DBLEPS/DBLMAX  # different DBL resolution
   CONST DBLSIG 52;#1
   CONST DBLMAN 11;#1
   CONST DBLEPS 2.220446049250313E-16;
   #1 # 2 ** -DBLSIG
   # 2 ** 2 ** (DBLMAN - 1) * (1.0 - DBLEPS / 2)
   CONST DBLMAX 1.79769313486227E+308;#1
LANGUAGE_END# different DBL resolution
CONST SI16MAX 32767;#1
CONST SI16MIN - 32768;#1
CONST UI16MAX 65535;#1
CONST SI32MAX 2147483647;#1
CONST SI32MIN - 2147483648;#1
CONST UI32MAX 4294967295;#1
CONST INTMAX SI32MAX;#1
CONST MONTHS_IN_YEAR 12;#TT-1
##    TIME  ----- ----- ----- ----- ----- ----- ----- ----- -----
CONST MINUTE 60.0 * SECOND;#T
CONST HOUR 60.0 * MINUTE;#T
CONST DAY 24.0 * HOUR;#T
LANGUAGE_NOT LANG_VB6 LANG_VBDOTNET:# DAY is a function
   CONST EARTHSOLARDAY DAY;#T
LANGUAGE_END# DAY is a function
CONST WEEK 7.0 * DAY;#T
CONST FLICK SECOND / 705600000.0;#T
CONST JULIANDAY DAY;#T
CONST JULIANYEAR 365.25 * JULIANDAY;#T
CONST JULIANCENTURY 100 * JULIANYEAR;#T
CONST JULIANMILLENNIUM 1000 * JULIANYEAR;#T
CONST JDAY JULIANDAY;#T
CONST JYEAR JULIANYEAR;#T
CONST JCENTURY JULIANCENTURY;#T
CONST JMILLENNIUM JULIANMILLENNIUM;#T
CONST JD JULIANDAY;#T
CONST JY JULIANYEAR;#T
CONST JC JULIANCENTURY;#T
CONST JM JULIANMILLENNIUM;#T
CONST JEWISH_FIRST_MONTH 7;#1
CONST GYEAR 365.2425 * DAY;#T
CONST GREGORIANYEAR GYEAR;#T
# following needs to be of form(P / 2**Q * SECOND)
# where 1 <= P < 16777216 and 1 <= Q < 23
CONST KWT 0.1875 * SECOND;#T
CONST UET SECOND;#T
CONST J2K DAY;#T
CONST J2KDAY DAY;#T
# 0000-01-00T00:00:00
CONST JDSEC_AT_0GREGORIAN 1721058.5 * JDAY;#T
# 1960-11-02T03:52:12
CONST JDSEC_AT_0KWT 2437240.66125 * JDAY;#T
# 2000-01-01T12:00:00
CONST JDSEC_AT_0J2K 2451545.0 * JDAY;#T
# 1970-01-01T00:00:00
CONST JDSEC_AT_0UET 2440587.5 * JDAY;#T
# TAI1970-01-01T00:00:00.000Z == TT1970-01-01T00:00:032.184Z
# by definition
CONST TT_AT_0TAI 32.184 * Kw.SECOND;#T
# as of 2018-01-01
CONST TT_AT_0UT1 68.97 * Kw.SECOND;#T
##    MASS  ----- ----- ----- ----- ----- ----- ----- ----- -----
CONST GRAM 0.001 * KILOGRAM;#M
CONST POUND 0.45359237 * KILOGRAM;#M
CONST LB POUND;#M
CONST OUNCE 0.0625 * POUND;#M
CONST TON 2000.0 * POUND;#M
CONST TONNE 1000.0 * KILOGRAM;#M
CONST GRAIN POUND / 7000;#M
CONST CARAT 0.2 * GRAM;#M
##    LENGTH ---- ----- ----- ----- ----- ----- ----- ----- -----
CONST MM MILLI * METER;#L
CONST INCH 0.0254 * METER;#L
CONST FOOT 12.0 * INCH;#L
CONST FT FOOT;#L
CONST YARD 3.0 * FOOT;#L
CONST MILE 5280.0 * FOOT;#L
CONST POINT INCH / 72.0;#L
##    ACCELERATION ---- ----- ----- ----- ----- ----- ----- -----
CONST STANDARDGRAVITY GRAVITY;#LT-2
# See https://en.wikipedia.org/wiki/Theoretical_gravity
#    and https://en.wikipedia.org/wiki/Clairauts_theorem
CONST EARTHGRAVITYA 9.7803253359 * MPSS;#LT-2
CONST EARTHGRAVITYB 9.8321849378 * MPSS;#LT-2
##    GRAVITATIONAL --- ----- ----- ----- ----- ----- ----- -----
# following is based on NASA
CONST GRAVITATIONNASA 6.67259E-11 * UNITGM / KILOGRAM;#L3T-2M-1
# following is based on IERS
CONST GRAVITATIONIERS 6.67428E-11 * UNITGM / KILOGRAM;#L3T-2M-1
##    FORCE ----- ----- ----- ----- ----- ----- ----- ----- -----
CONST KGF KILOGRAM * GRAVITY;#MLT-2
CONST LBF POUND * GRAVITY;#MLT-2
##    PRESSURE -- ----- ----- ----- ----- ----- ----- ----- -----
CONST ATM ATMOSPHERE;#ML-1T-2
CONST STANDARDATMOSPHERE ATMOSPHERE;#ML-1T-2
CONST TORR ATMOSPHERE / 760;#ML-1T-2
CONST BAR 1E+5 * PA;#ML-1T-2
CONST MMHG 13595.1 * KILOGRAM * GRAVITY * MM / (METER * METER
      * METER);#ML-1T-2
CONST INHG MMHG * INCH / MM;#ML-1T-2
CONST PSI POUND * GRAVITY / (INCH * INCH);#ML-1T-2
##    TEMPERATURE  ---- ----- ----- ----- ----- ----- ----- -----
CONST DEGC KELVIN;#K
CONST DEGF KELVIN / 1.8;#K
CONST DEGR DEGF;#K
CONST K_AT_0TEMPC 273.15 * DEGC;#K
CONST K_AT_0TEMPF 459.67 * DEGF;#K
CONST K_AT_0TEMPR 0.0 * DEGR;#K
##    SPEED ----- ----- ----- ----- ----- ----- ----- ----- -----
CONST MACH 331.46 * MPS;#LT-1
CONST MPH MILE / HOUR;#LT-1
##    AREA  ----- ----- ----- ----- ----- ----- ----- ----- -----
CONST HECTARE 10000 * METER * METER;#L2
CONST ARE 100 * METER * METER;#L2
CONST ACRE MILE * MILE / 640.0;#L2
CONST BARN 1E-28 * METER * METER;#L2
##    VOLUME ---- ----- ----- ----- ----- ----- ----- ----- -----
CONST LITER METER * METER * METER / 1000.0;#L3
CONST LITRE LITER;#L3
CONST GALLON 231.0 * INCH * INCH * INCH;#L3
CONST QUART GALLON / 4.0;#L3
CONST PINT QUART / 2.0;#L3
CONST CUP PINT / 2.0;#L3
CONST FLOZ CUP / 8.0;#L3
CONST TBLSP FLOZ / 2.0;#L3
CONST TSP TBLSP / 3.0;#L3
CONST BARREL 42.0 * GALLON;#L3
##    CHARGE ---- ----- ----- ----- ----- ----- ----- ----- -----
CONST AH AMPERE * HOUR;#TI
##    ENERGY ---- ----- ----- ----- ----- ----- ----- ----- -----
# Thermochemical Calorie
CONST CALORIE 4.184 * JOULE;#ML2T-2
# International Steam Table Calorie
CONST CAL_IT 4.1868 * JOULE;#ML2T-2
CONST CAL_TH CALORIE;#ML2T-2
CONST CAL CALORIE;#ML2T-2
CONST BTU_TH CAL_TH * POUND * DEGF / (GRAM * DEGC);#ML2T-2
CONST BTU_IT CAL_IT * POUND * DEGF / (GRAM * DEGC);#ML2T-2
CONST BTU CALORIE * POUND * DEGF / (GRAM * DEGC);#ML2T-2
CONST HP 550.0 * FOOT * POUND * GRAVITY / SECOND;#ML2T-2
CONST HORSEPOWER HP;#ML2T-2
CONST HPMETRIC 75 * KILOGRAM * GRAVITY * MPS;#ML2T-2
CONST ELECTRONVOLT ELECTRONCHARGE * VOLT;#ML2T-2
CONST ERG 1E-7 * JOULE;#ML2T-2
CONST FOE 1E+44 * JOULE;#ML2T-2
CONST AAABATTERYCHARGE 2.1 * AH;#IT
CONST AAABATTERYVOLTAGE 1.5 * VOLT;#ML2I-1T-3
CONST AAABATTERY AAABATTERYCHARGE * AAABATTERYVOLTAGE;#ML2T-2
CONST AAABATTERYENERGY AAABATTERY;#ML2T-2
CONST AABATTERYCHARGE 2.7 * AH;#IT
CONST AABATTERYVOLTAGE 1.5 * VOLT;#ML2I-1T-3
CONST AABATTERY AABATTERYCHARGE * AABATTERYVOLTAGE;#ML2T-2
CONST AABATTERYENERGY AABATTERY;#ML2T-2
CONST CBATTERYCHARGE 8.0 * AH;#IT
CONST CBATTERYVOLTAGE 1.5 * VOLT;#ML2I-1T-3
CONST CBATTERY CBATTERYCHARGE * CBATTERYVOLTAGE;#ML2T-2
CONST CBATTERYENERGY CBATTERY;#ML2T-2
CONST DBATTERYCHARGE 12 * AH;#IT
CONST DBATTERYVOLTAGE 1.5 * VOLT;#ML2I-1T-3
CONST DBATTERY DBATTERYCHARGE * DBATTERYVOLTAGE;#ML2T-2
CONST DBATTERYENERGY DBATTERY;#ML2T-2
CONST NINEVOLTCHARGE 0.565 * AH;#IT
CONST NINEVOLTVOLTAGE 9.0 * VOLT;#ML2I-1T-3
CONST NINEVOLT NINEVOLTCHARGE * NINEVOLTVOLTAGE;#ML2T-2
CONST NINEVOLTENERGY NINEVOLT;#ML2T-2
CONST NINEVOLTBATTERYCHARGE NINEVOLTCHARGE;#IT
CONST NINEVOLTBATTERYVOLTAGE NINEVOLTVOLTAGE;#ML2I-1T-3
CONST NINEVOLTBATTERY NINEVOLTBATTERYCHARGE
      * NINEVOLTBATTERYVOLTAGE;#ML2T-2
CONST NINEVOLTBATTERYENERGY NINEVOLTBATTERY;#ML2T-2
CONST PHONEBATTERYCHARGE 3.0 * AH;#IT
CONST PHONEBATTERYVOLTAGE 3.8 * VOLT;#ML2I-1T-3
CONST PHONEBATTERY PHONEBATTERYCHARGE * PHONEBATTERYVOLTAGE;
      #ML2T-2
CONST PHONEBATTERYENERGY PHONEBATTERY;#ML2T-2
CONST CARBATTERYCHARGE 45.0 * AH;#IT
CONST CARBATTERYVOLTAGE 12.0 * VOLT;#ML2I-1T-3
CONST CARBATTERY CARBATTERYCHARGE * CARBATTERYVOLTAGE;#ML2T-2
CONST CARBATTERYENERGY CARBATTERY;#ML2T-2
##    LIGHT  ---- ----- ----- ----- ----- ----- ----- ----- -----
#CONST MICROWAVE 1.224E-1 * METER;         #L
CONST MICROWAVEHz 2.45E+9 / SECOND;#T-1
CONST MICROWAVEWAVELENGTH LIGHT / MICROWAVEHz;#L
CONST MICROWAVEWAVENUMBER 1.0 / MICROWAVEWAVELENGTH;#L-1
CONST MICROWAVEENERGY PLANCK * MICROWAVEHz;#ML-2T-2
CONST LFHz 1.00E+5 / SECOND;#T-1
CONST LFWAVELENGTH LIGHT / LFHz;#L
CONST LFWAVENUMBER 1.0 / LFWAVELENGTH;#L-1
CONST LFENERGY PLANCK * LFHz;#ML-2T-2
CONST MFHz 1.00E+6 / SECOND;#T-1
CONST MFWAVELENGTH LIGHT / MFHz;#L
CONST MFWAVENUMBER 1.0 / MFWAVELENGTH;#L-1
CONST MFENERGY PLANCK * MFHz;#ML-2T-2
CONST HFHz 1.00E+7 / SECOND;#T-1
CONST HFWAVELENGTH LIGHT / HFHz;#L
CONST HFWAVENUMBER 1.0 / HFWAVELENGTH;#L-1
CONST HFENERGY PLANCK * HFHz;#ML-2T-2
CONST VHFHz 1.00E+8 / SECOND;#T-1
CONST VHFWAVELENGTH LIGHT / VHFHz;#L
CONST VHFWAVENUMBER 1.0 / VHFWAVELENGTH;#L-1
CONST VHFENERGY PLANCK * VHFHz;#ML-2T-2
CONST UHFHz 1.00E+9 / SECOND;#T-1
CONST UHFWAVELENGTH LIGHT / UHFHz;#L
CONST UHFWAVENUMBER 1.0 / UHFWAVELENGTH;#L-1
CONST UHFENERGY PLANCK * UHFHz;#ML-2T-2
CONST SHFHz 1.00E+10 / SECOND;#T-1
CONST SHFWAVELENGTH LIGHT / SHFHz;#L
CONST SHFWAVENUMBER 1.0 / SHFWAVELENGTH;#L-1
CONST SHFENERGY PLANCK * SHFHz;#ML-2T-2
CONST EHFHz 1.00E+11 / SECOND;#T-1
CONST EHFWAVELENGTH LIGHT / EHFHz;#L
CONST EHFWAVENUMBER 1.0 / EHFWAVELENGTH;#L-1
CONST EHFENERGY PLANCK * EHFHz;#ML-2T-2
CONST THFHz 1.00E+12 / SECOND;#T-1
CONST THFWAVELENGTH LIGHT / THFHz;#L
CONST THFWAVENUMBER 1.0 / THFWAVELENGTH;#L-1
CONST THFENERGY PLANCK * THFHz;#ML-2T-2
CONST FIRHz 1.00E+12 / SECOND;#T-1
CONST FIRWAVELENGTH LIGHT / FIRHz;#L
CONST FIRWAVENUMBER 1.0 / FIRWAVELENGTH;#L-1
CONST FIRENERGY PLANCK * FIRHz;#ML-2T-2
CONST MIRHz 1.00E+13 / SECOND;#T-1
CONST MIRWAVELENGTH LIGHT / MIRHz;#L
CONST MIRWAVENUMBER 1.0 / MIRWAVELENGTH;#L-1
CONST MIRENERGY PLANCK * MIRHz;#ML-2T-2
CONST NIRHz 1.00E+14 / SECOND;#T-1
CONST NIRWAVELENGTH LIGHT / NIRHz;#L
CONST NIRWAVENUMBER 1.0 / NIRWAVELENGTH;#L-1
CONST NIRENERGY PLANCK * NIRHz;#ML-2T-2
CONST REDWAVELENGTH 7.00E-7 * METER;#L
CONST REDHz LIGHT / REDWAVELENGTH;#T-1
CONST REDWAVENUMBER 1.0 / REDWAVELENGTH;#L-1
CONST REDENERGY PLANCK * REDHz;#ML-2T-2
CONST ORANGEWAVELENGTH 6.20E-7 * METER;#L
CONST ORANGEHz LIGHT / ORANGEWAVELENGTH;#T-1
CONST ORANGEWAVENUMBER 1.0 / ORANGEWAVELENGTH;#L-1
CONST ORANGEENERGY PLANCK * ORANGEHz;#ML-2T-2
CONST YELLOWWAVELENGTH 5.80E-7 * METER;#L
CONST YELLOWHz LIGHT / YELLOWWAVELENGTH;#T-1
CONST YELLOWWAVENUMBER 1.0 / YELLOWWAVELENGTH;#L-1
CONST YELLOWENERGY PLANCK * YELLOWHz;#ML-2T-2
CONST YELLOWGREENHz 540E+12 / SECOND;#T-1
CONST YELLOWGREENWAVELENGTH LIGHT / YELLOWGREENHz;#L
CONST YELLOWGREENWAVENUMBER 1.0 / YELLOWGREENWAVELENGTH;#L-1
CONST YELLOWGREENENERGY PLANCK * YELLOWGREENHz;#ML-2T-2
CONST GREENWAVELENGTH 5.30E-7 * METER;#L
CONST GREENHz LIGHT / GREENWAVELENGTH;#T-1
CONST GREENWAVENUMBER 1.0 / GREENWAVELENGTH;#L-1
CONST GREENENERGY PLANCK * GREENHz;#ML-2T-2
CONST BLUEWAVELENGTH 5.00E-7 * METER;#L
CONST BLUEHz LIGHT / BLUEWAVELENGTH;#T-1
CONST BLUEWAVENUMBER 1.0 / BLUEWAVELENGTH;#L-1
CONST BLUEENERGY PLANCK * BLUEHz;#ML-2T-2
CONST VIOLETWAVELENGTH 4.20E-7 * METER;#L
CONST VIOLETHz LIGHT / VIOLETWAVELENGTH;#T-1
CONST VIOLETWAVENUMBER 1.0 / VIOLETWAVELENGTH;#L-1
CONST VIOLETENERGY PLANCK * VIOLETHz;#ML-2T-2
CONST NUVHz 1.00E+15 / SECOND;#T-1
CONST NUVWAVELENGTH LIGHT / NUVHz;#L
CONST NUVWAVENUMBER 1.0 / NUVWAVELENGTH;#L-1
CONST NUVENERGY PLANCK * NUVHz;#ML-2T-2
CONST EUVHz 1.00E+16 / SECOND;#T-1
CONST EUVWAVELENGTH LIGHT / EUVHz;#L
CONST EUVWAVENUMBER 1.0 / EUVWAVELENGTH;#L-1
CONST EUVENERGY PLANCK * EUVHz;#ML-2T-2
CONST UVAWAVELENGTH 3.60E-7 * METER;#L
CONST UVAHz LIGHT / UVAWAVELENGTH;#T-1
CONST UVAWAVENUMBER 1.0 / UVAWAVELENGTH;#L-1
CONST UVAENERGY PLANCK * UVAHz;#ML-2T-2
CONST UVBWAVELENGTH 3.00E-7 * METER;#L
CONST UVBHz LIGHT / UVBWAVELENGTH;#T-1
CONST UVBWAVENUMBER 1.0 / UVBWAVELENGTH;#L-1
CONST UVBENERGY PLANCK * UVBHz;#ML-2T-2
CONST UVCWAVELENGTH 1.90E-7 * METER;#L
CONST UVCHz LIGHT / UVCWAVELENGTH;#T-1
CONST UVCWAVENUMBER 1.0 / UVCWAVELENGTH;#L-1
CONST UVCENERGY PLANCK * UVCHz;#ML-2T-2
CONST SXHz 3.00E+17 / SECOND;#T-1
CONST SXWAVELENGTH LIGHT / SXHz;#L
CONST SXWAVENUMBER 1.0 / SXWAVELENGTH;#L-1
CONST SXENERGY PLANCK * SXHz;#ML-2T-2
CONST SXXWAVELENGTH 1.00E-9 * METER;#L
CONST SXXHz LIGHT / SXXWAVELENGTH;#T-1
CONST SXXWAVENUMBER 1.0 / SXXWAVELENGTH;#L-1
CONST SXXENERGY PLANCK * SXXHz;#ML-2T-2
CONST HXHz 1.00E+19 / SECOND;#T-1
CONST HXWAVELENGTH LIGHT / HXHz;#L
CONST HXWAVENUMBER 1.0 / HXWAVELENGTH;#L-1
CONST HXENERGY PLANCK * HXHz;#ML-2T-2
CONST GAMMAHz 1.00E+20 / SECOND;#T-1
CONST GAMMAWAVELENGTH LIGHT / GAMMAHz;#L
CONST GAMMAWAVENUMBER 1.0 / GAMMAWAVELENGTH;#L-1
CONST GAMMAENERGY PLANCK * GAMMAHz;#ML-2T-2
##    ANGLE ----- ----- ----- ----- ----- ----- ----- ----- -----
CONST TURN TAU * RADIAN;#A
CONST ARCDEGREE TURN / 360.0;#A
CONST ARCMINUTE ARCDEGREE / 60.0;#A
CONST ARCSECOND ARCMINUTE / 60.0;#A
CONST GRAD TURN / 400.0;#A
CONST ARCDEG ARCDEGREE;#A
CONST ARCMIN ARCMINUTE;#A
CONST ARCSEC ARCSECOND;#A
CONST SQUAREDEGREE ARCDEGREE * ARCDEGREE;#A2
CONST SQDEG SQUAREDEGREE;#A2
CONST SPHERESURFACE 2 * Kw.TAU * STERADIAN;#A2
##    INFORMATION ----- ----- ----- ----- ----- ----- ----- -----
CONST SHANNON BIT;#B
CONST NAT BIT / Kw.LNTWO;#B
CONST HARTLEY Kw.LNTEN / Kw.LNTWO * BIT;#B
CONST HART HARTLEY;#B
CONST DIT HARTLEY;#B
CONST BAN HARTLEY;#B
##    ANGULAR SPEED --- ----- ----- ----- ----- ----- ----- -----
CONST RPM TURN / MINUTE;#AT-1
CONST RPS TURN / SECOND;#AT-1
##    NUCLEAR RELATED - ----- ----- ----- ----- ----- ----- -----
CONST FINESTRUCTURE ALPHA;#1
CONST FINESTRUCTURE_ERR ALPHA_ERR;#1
CONST FINESTRUCTURE_REC ALPHA_REC;#1
CONST FINESTRUCTURE_REC_ERR ALPHA_ERR;#1
CONST MAGNETIC 2.0 * VONKLITZING * ALPHA / LIGHT;#ML/T2I2
CONST MAGNETIC_ERR ALPHA_ERR;#1
CONST MU0 MAGNETIC;#ML/T2I2
CONST MU0_ERR ALPHA_ERR;#1
# follows from LIGHT**2 * MAGNETIC * ELECTRIC 1.0
CONST ELECTRIC 1.0 / (LIGHT * LIGHT * MU0);#ML/T2I2
CONST ELECTRIC_ERR ALPHA_ERR;#1
CONST EPSILON0 ELECTRIC;#ML/T2I2
CONST EPSILON0_ERR ALPHA_ERR;#1
CONST COULOMBCONST 1.0 / (2.0 * TAU * ELECTRIC);#ML3/T4I2
CONST COULOMBCONST_ERR ALPHA_ERR;#1
CONST PROTONRADIUS 8.414E-16 * METER;#L
CONST PROTONRADIUS_ERR 2.2E-3;#1
CONST MOLARMASS 0.99999999965 * GRAM / MOLE;#M/N
CONST MOLARMASS_ERR 2.0E-10;#1
CONST MOLARMASSX (1.0 - 3.5E-10) * GRAM / MOLE;#M/N
CONST MOLARMASSX_ERR 2.0E-10;#1
# defined to be exactly Mass(CARBON_12)/12
CONST DALTON MOLARMASS / AVOGADRO;#M
CONST DALTON_ERR MOLARMASS_ERR;#1
CONST AMU DALTON;#M
CONST AMU_ERR DALTON_ERR;#1
CONST ATOMICMASSUNIT DALTON;#M
CONST ATOMICMASSUNIT_ERR DALTON_ERR;#1
CONST UAMU DALTON;#M
CONST UAMU_ERR DALTON_ERR;#1
CONST RYDBERGHz RYDBERG;#T-1
CONST RYDBERGWAVELENGTH LIGHT / RYDBERGHz;#L
CONST RYDBERGWAVENUMBER 1.0 / RYDBERGWAVELENGTH;#L-1
CONST RYDBERGENERGY PLANCK * RYDBERGHz;#ML-2T-2
CONST ELECTRONMASSA 2.0 * RYDBERGHz * PLANCK / (LIGHT * LIGHT
      * ALPHA * ALPHA);#M
CONST ELECTRONMASSA_ERR 2.0 * ALPHA_ERR;#1
CONST ELECTRONMASS 5.48579909065E-4 * AMU;#M
CONST ELECTRONMASS_ERR 2.9E-11;#1
CONST ELECTRON_MASS ELECTRONMASS * AVOGADRO;#MN-1
CONST ELECTRONENERGY ELECTRONMASS * LIGHT * LIGHT;#ML-2T-2
CONST ELECTRONHz ELECTRONENERGY / PLANCK;#T-1
CONST ELECTRONWAVELENGTH LIGHT / ELECTRONHz;#L
CONST UPQUARKMASS 0.00216 * AMU;#M
CONST UPQUARKMASS_ERR 0.2;#1
CONST UPQUARK_MASS UPQUARKMASS * AVOGADRO;#MN-1
CONST UPQUARKENERGY UPQUARKMASS * LIGHT * LIGHT;#ML-2T-2
CONST UPQUARKHz UPQUARKENERGY / PLANCK;#T-1
CONST UPQUARKWAVELENGTH LIGHT / UPQUARKHz;#L
CONST DOWNQUARKMASS 0.00514 * AMU;#M
CONST DOWNQUARKMASS_ERR 0.1;#1
CONST DOWNQUARK_MASS DOWNQUARKMASS * AVOGADRO;#MN-1
CONST DOWNQUARKENERGY DOWNQUARKMASS * LIGHT * LIGHT;#ML-2T-2
CONST DOWNQUARKHz DOWNQUARKENERGY / PLANCK;#T-1
CONST DOWNQUARKWAVELENGTH LIGHT / DOWNQUARKHz;#L
CONST MUONMASS 0.1134289259 * AMU;#M
CONST MUONMASS_ERR 2.2E-8;#1
CONST MUON_MASS MUONMASS * AVOGADRO;#MN-1
CONST MUONENERGY MUONMASS * LIGHT * LIGHT;#ML-2T-2
CONST MUONHz MUONENERGY / PLANCK;#T-1
CONST MUONWAVELENGTH LIGHT / MUONHz;#L
CONST PROTONMASS 1.007276466812 * AMU;#M
CONST PROTONMASS_ERR 8.9E-11;#1
CONST PROTON_MASS PROTONMASS * AVOGADRO;#MN-1
CONST PROTONENERGY PROTONMASS * LIGHT * LIGHT;#ML-2T-2
CONST PROTONHz PROTONENERGY / PLANCK;#T-1
CONST PROTONWAVELENGTH LIGHT / PROTONHz;#L
CONST NEUTRONMASS 1.00866491595 * AMU;#M
CONST NEUTRONMASS_ERR 4.8E-10;#1
CONST NEUTRON_MASS NEUTRONMASS * AVOGADRO;#MN-1
CONST NEUTRONENERGY NEUTRONMASS * LIGHT * LIGHT;#ML-2T-2
CONST NEUTRONHz NEUTRONENERGY / PLANCK;#T-1
CONST NEUTRONWAVELENGTH LIGHT / NEUTRONHz;#L
CONST TAUMASS 1.90754 * AMU;#M
CONST TAUMASS_ERR 6.8E-5;#1
CONST TAU_MASS TAUMASS * AVOGADRO;#MN-1
CONST TAUENERGY TAUMASS * LIGHT * LIGHT;#ML-2T-2
CONST TAUHz TAUENERGY / PLANCK;#T-1
CONST TAUWAVELENGTH LIGHT / TAUHz;#L
CONST DEUTERONMASS 2.013553212745 * AMU;#M
CONST DEUTERONMASS_ERR 2.0E-11;#1
CONST DEUTERON_MASS DEUTERONMASS * AVOGADRO;#MN-1
CONST HELIONMASS 3.0149322467175 * AMU;#M
CONST HELIONMASS_ERR 3.2E-11;#1
CONST HELION_MASS HELIONMASS * AVOGADRO;#MN-1
CONST TRITONMASS 3.01550071621 * AMU;#M
CONST TRITONMASS_ERR 4.0E-11;#1
CONST TRITON_MASS TRITONMASS * AVOGADRO;#MN-1
CONST ALPHAMASS 4.001506179127 * AMU;#M
CONST ALPHAMASS_ERR 1.6E-11;#1
CONST ALPHA_MASS ALPHAMASS * AVOGADRO;#MN-1
CONST HYDROGENRADIUS (HBAR / (ELECTRONMASS * LIGHT * ALPHA));#L
CONST HYDROGENRADIUS_ERR ALPHA_ERR;#1
CONST BOHRRADIUS HYDROGENRADIUS;#L
CONST BOHRRADIUS_ERR ALPHA_ERR;#1
CONST HIHz 1420405751.7667 * HERTZ;#T-1
CONST HIWAVELENGTH LIGHT / HIHz;#L
CONST HIWAVENUMBER 1.0 / HIWAVELENGTH;#L-1
CONST HIENERGY PLANCK * HIHz;#ML-2T-2
CONST HYDROGENLINE HIWAVELENGTH;#L
CONST HYDROGENLINE_ERR 6.3E-13;#1
CONST HI LIGHT / HIHz;#L
CONST HI_ERR HYDROGENLINE_ERR;#1
##    PLANCK UNITS ---- ----- ----- ----- ----- ----- ----- -----
# Planck units and constants
# PLANCKCHARGE = ELECTRONCHARGE / SQRT(ALPHA)
# PLANCKLENGTH = SQRT(HBAR * GRAVITATION / LIGHT**3)
# PLANCKTIME   = SQRT(HBAR * GRAVITATION / LIGHT**5)
# PLANCKMASS   = SQRT(HBAR * LIGHT / GRAVITATION)
# PLANCKENERGY = SQRT(HBAR * LIGHT**5 / GRAVITATION)
# PLANCKTEMP   = SQRT(HBAR * LIGHT**5 / GRAVITATION) / BOLTZMANN
LANGUAGE LANG_VB6 LANG_VBDOTNET:# VB: no sqrt in consts
   CONST PLANCKMASS 2.176434366592856178609495E-8 * KILOGRAM;#M
   CONST PLANCKCHARGE 1.87554603814952214E-18 * COULOMB;#TI
LANGUAGE_END# VB: no sqrt in consts
LANGUAGE_NOT LANG_VB6 LANG_VBDOTNET:# not VB: sqrt in consts
   CONST PLANCKMASS SQRT(HBAR * LIGHT / GRAVITATION);#M
   CONST PLANCKCHARGE ELECTRONCHARGE / SQRT(ALPHA);#TI
LANGUAGE_END# not VB: sqrt in consts
CONST PLANCKENERGY PLANCKMASS * LIGHT * LIGHT;#ML2/T2
CONST PLANCKTEMP PLANCKENERGY / BOLTZMANN;#K
CONST PLANCKLENGTH HBAR / PLANCKMASS / LIGHT;#L
CONST PLANCKTIME PLANCKLENGTH / LIGHT;#T
CONST STEFAN (TAU * TAU * LIGHT * BOLTZMANN) * ((BOLTZMANN
      / (LIGHT * HBAR)) * (BOLTZMANN / (LIGHT * HBAR))
      * (BOLTZMANN / (LIGHT * HBAR))) / 240.0;#M/K4T3
CONST STEFAN_ERR 0;#1
##    SPORTS RELATED -- ----- ----- ----- ----- ----- ----- -----
CONST PINGPONGBALLRADIUS 0.02 * METER;#L
CONST GOLFBALLRADIUS 0.02135 * METER;#L
CONST TENNISBALLRADIUS 0.03325 * METER;#L
CONST BASEBALLRADIUS 9.125 * INCH / TAU;#L
CONST SOFTBALLRADIUS 12 * INCH / TAU;#L
CONST SOCCERBALLRADIUS 0.69 * METER / TAU;#L
CONST BASKETBALLRADIUS 0.75 * METER / TAU;#L
CONST PINGPONGBALLMASS 2.7 * GRAM;#M
CONST GOLFBALLMASS 45.93 * GRAM;#M
CONST TENNISBALLMASS 57.7 * GRAM;#M
CONST BASEBALLMASS 146.5 * GRAM;#M
CONST SOFTBALLMASS 187 * GRAM;#M
CONST BASKETBALLMASS 620 * GRAM;#M
CONST SOCCERBALLMASS 430 * GRAM;#M
CONST MARATHON 42195 * METER;#L
##    US COINS -- ----- ----- ----- ----- ----- ----- ----- -----
CONST PENNYTHICKNESS 1.55E-3 * METER;#L
CONST NICKELTHICKNESS 1.95E-3 * METER;#L
CONST DIMETHICKNESS 1.35E-3 * METER;#L
CONST QUARTERTHICKNESS 1.75E-3 * METER;#L
CONST PENNYRADIUS 9.525E-3 * METER;#L
CONST NICKELRADIUS 1.061E-2 * METER;#L
CONST DIMERADIUS 8.955E-3 * METER;#L
CONST QUARTERRADIUS 1.213E-2 * METER;#L
CONST PENNYMASS 2.5 * GRAM;#M
CONST NICKELMASS 5.0 * GRAM;#M
CONST DIMEMASS 0.005 * POUND;#M
CONST QUARTERMASS 0.0125 * POUND;#M
##    ASTRONOMIC  ----- ----- ----- ----- ----- ----- ----- -----
CONST MOONMONTH 29.530587981 * DAY;#T
CONST MILKYWAYAGE 8.3E+9 * JYEAR;#T
CONST UNIVERSEAGE 13.799E+9 * JYEAR;#T
CONST LIGHTYEAR LIGHT * JYEAR;#L
CONST ASTRONOMICALUNIT AU;#L
CONST PARSEC 1296000.0 * AU / TAU;#L
CONST PROXIMACENTAURI 39.9E+15 * METER;#L
CONST MILKYWAYRADIUS 6.0E+4 * LIGHTYEAR;#L
CONST GALACTICCENTER 2.64E+4 * LIGHTYEAR;#L
CONST UNIVERSERADIUS UNIVERSEAGE * LIGHT;#L
CONST MILKYWAYMASS 1.4E+42 * KILOGRAM;#M
CONST UNIVERSEMASS 1.46E+53 * KILOGRAM;#M
CONST SOLARCONSTANT 1361.0 * WATT / (METER * METER);#MT-3
CONST EINSTEIN 4 * TAU * GRAVITATION / (LIGHT * LIGHT * LIGHT
      * LIGHT);#T2M-1L-1
CONST EINSTEIN_ERR GRAVITATION_ERR;#1
CONST HUBBLE 67.66E-3 * METER / (SECOND * PARSEC);#T-1
CONST HUBBLE_ERR 6E-3;#1
CONST BHMASSTEMP (HBAR * (LIGHT * LIGHT * LIGHT) / (4.0 * TAU
      * GRAVITATION * BOLTZMANN));#MK
CONST BHMASS_RADIUS 0.5 * LIGHT * LIGHT / GRAVITATION;#ML-1
CONST BHMASS3_LIFETIME (PLANCK * (LIGHT * LIGHT * LIGHT
      * LIGHT)) / (2560 * TAU * TAU * GRAVITATION
      * GRAVITATION);#M3T-1
CONST BHRADIUS2DENSITY 1.5 * BHMASS_RADIUS / TAU;#LM-1
CONST BHENTROPY_AREA (TAU * (LIGHT * LIGHT * LIGHT)
      * BOLTZMANN) / (4 * PLANCK * GRAVITATION);#MK-1T-2
CONST BEKENSTEININFORMATION (TAU * TAU * NAT) / (PLANCK
      * LIGHT);#BM-1L-1
CONST BEKENSTEINENTROPY (TAU * TAU * BOLTZMANN) / (PLANCK
      * LIGHT);#K-1L-1
##    GEOGRAPHIC  ----- ----- ----- ----- ----- ----- ----- -----
CONST ELEVATIONMAX 8848.0 * METER;#L
CONST ELEVATIONMIN - 10994.0 * METER;#L
##    GEOLOGIC -- ----- ----- ----- ----- ----- ----- ----- -----
CONST KPGBOUNDARY 65.5E+6 * JYEAR;#T
CONST TRJBOUNDARY 199.6E+6 * JYEAR;#T
CONST MILKYWAYDAY 250.0E+6 * JYEAR;#T
CONST PTRBOUNDARY 251.4E+6 * JYEAR;#T
CONST NPBOUNDARY 542.0E+6 * JYEAR;#T
CONST LIFEAGE 3.85E+9 * JYEAR;#T
CONST GIANTIMPACT 4.533E+9 * JYEAR;#T
CONST EARTHAGE 4.56717E+9 * JYEAR;#T
##    RATIONAL NUMBERS  ----- ----- ----- ----- ----- ----- -----
CONST PPQ 1E-15;#1
CONST PPT 1E-12;#1
CONST PPB 1E-9;#1
CONST PPM 1E-6;#1
##    DIMENSIONAL ----- ----- ----- ----- ----- ----- ----- -----
CONST MASS KILOGRAM;#M
CONST LENGTH METER;#L
CONST DISTANCE LENGTH;#L
CONST TEMPERATURE KELVIN;#K
CONST TIME SECOND;#T
CONST ANGLE RADIAN;#A
CONST SOLID_ANGLE STERADIAN;#A2
CONST SPEED LENGTH / TIME;#LT-1
CONST ACCELERATION SPEED / TIME;#LT-2
CONST FORCE MASS * ACCELERATION;#MLT-2
CONST ENERGY FORCE * LENGTH;#ML2T-2
CONST ACTION ENERGY * TIME;#ML2T-1
CONST POWER ENERGY / TIME;#ML2T-3
CONST AREA LENGTH * LENGTH;#L2
CONST VOLUME LENGTH * LENGTH * LENGTH;#L3
CONST DENSITY MASS / VOLUME;#ML-3
CONST SPECIFICHEAT ENERGY / (MASS * TEMPERATURE);#L2T-2K-1
CONST PRESSURE FORCE / AREA;#ML-1T-2
CONST VISCOSITY FORCE * TIME / AREA;#ML-1T-1
CONST FREQUENCY 1 / TIME;#T-1
CONST CHARGE AMPERE * SECOND;#IT
CONST CURRENT CHARGE / TIME;#I
CONST VOLTAGE POWER / CURRENT;#ML2T-3I-1
CONST RESISTANCE VOLTAGE / CURRENT;#ML2T-3I-2
CONST INDUCTANCE RESISTANCE * TIME;#ML2T-2I-2
CONST CAPACITANCE CHARGE / VOLTAGE;#I2T4M-1L-2
CONST CONDUCTANCE 1.0 / RESISTANCE;#I2T3M-1L-2
CONST MAGNETICFLUX VOLTAGE * TIME;#ML2T-2I-1
CONST MAGNETICINDUCTION MAGNETICFLUX / AREA;#MT-2I-1
#   IIIIIIIIIInsert-End ------------------------ constants.fwip #
#TEST:EULER==0.57721566490153286060651209008240243104215933594;
#   IIIIIIIIIInsert-Begin ------------------------- simple.fwip #
#    COPYRIGHT C 2018-2020 by Kevin D. Woerner
# 2020-07-24 kdw  simple:comment cleanup
# 2020-06-18 kdw  simple:comment to ratio
# 2020-06-16 kdw  simple:D[I]V keyword deprecated
# 2020-06-15 kdw  simple:ra[t]io func added
# 2020-05-30 kdw  simple:horner added
# 2020-05-28 kdw  simple:debugging parsing routines
# 2020-04-22 kdw  simple:bison work
# 2020-04-21 kdw  simple:comments
# 2020-04-14 kdw  simple:tests added
# 2020-04-12 kdw  simple:comment change
# 2020-03-03 kdw  simple:comment change
# 2019-10-29 kdw  simple:[OE]GF comments
# 2019-10-28 kdw  simple:GF comments
# 2019-07-08 kdw  simple:sq[i]nv func
# 2019-06-02 kdw  simple:func desc added
# 2019-05-22 kdw  simple:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-03-19 kdw  simple:re[t]_val to re[t]valu
# 2018-09-28 kdw  simple:st[e]p to st[a]ir renam
# 2018-09-26 kdw  simple:sq, cu funcs
# 2018-09-18 kdw  simple:clip2 error
# 2018-09-17 kdw  simple:func renam
# 2018-07-30 kdw  simple:cli[p]2_
# 2018-07-13 kdw  simple:float number reformt
# 2018-06-19 kdw  simple:created
# OGF(f();x) = SUM f(n)*x**n FROM 0 TO Inf
# EGF(f();x) = SUM f(n)*x**n/factorial(n) FROM 0 TO Inf
# OGF(1;x) = 1 / (1 - x)
#   FFFFFFFFFFunction -------------------------------------- id #
FUNC DBL id(DBL xx):
   # XX; just return XX
   # OGF(id();x) = x / (1 - x)**2
   RETURN xx;
FUNC_END
#TEST:id(id(1.456))-1.456;
#TEST:id(-1.456)+1.456;
## Arithmetic functions
#   FFFFFFFFFFunction ------------------------------------ reci #
FUNC DBL reci(DBL xx):
   # 1.0 / XX; reciprical
   # OGF(reci();x) = -LN(1 - x)
   RETURN 1.0 / xx;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- neg #
FUNC DBL neg(DBL xx):
   # -XX; negation
   RETURN - xx;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- square #
FUNC DBL square(DBL xx):
   # XX * XX; square
   # OGF(square();x) = x * (x + 1) / (1 - x)**3
   # EGF(square();x) = x * (x + 1) * EXP(x)
   RETURN xx * xx;
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- sq #
FUNC DBL sq(DBL xx):
   # XX * XX; square
   RETURN xx * xx;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- sqinv #
FUNC DBL sqinv(DBL xx):
   # square root
   RETURN SQRT(xx);
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ cube #
FUNC DBL cube(DBL xx):
   # XX * XX * XX; cube
   # OGF(cube();x) = x * (1 + 4 * x + x * x) / (1 - x)**4
   RETURN xx * xx * xx;
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- cu #
FUNC DBL cu(DBL xx):
   # XX * XX * XX; cube
   RETURN xx * xx * xx;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ sign #
FUNC DBL sign(DBL xx):
   # SIGN(XX) = -1  iff XX in(-INF,0)
   #          = 0   iff XX == 0.0
   #          = 1   iff XX in(0,INF)
   DBL retvalu;
   IF xx < 0.0:
      retvalu = -1.0;
   ELSIF 0.0 < xx:
      retvalu = 1.0;
   ELSE:
      retvalu = 0.0;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- stair #
FUNC DBL stair(DBL xx):
   # STAIR(XX) = 0 iff XX in(-INF,0)
   #          = 1 iff XX in[0,INF)
   DBL retvalu;
   IF xx < 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- heaviside #
FUNC DBL heaviside(DBL xx):
   # HEAVISIDE(XX) = 0   iff XX in(-INF,0)
   #               = 0.5 iff XX == 0.0
   #               = 1   iff XX in(0,INF)
   DBL retvalu;
   IF xx < 0.0:
      retvalu = 0.0;
   ELSIF 0.0 < xx:
      retvalu = 1.0;
   ELSE:
      retvalu = 0.5;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ divi #
FUNC DBL divi(DBL numer
      , DBL denom
      , DBL def_val):
   # if DENOM == 0, DEF_VAL; else, NUMER/DENOM
   DBL retvalu;
   IF denom < 0.0 OR 0.0 < denom:
      retvalu = numer / denom;
   ELSE:
      retvalu = def_val;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ clip #
FUNC DBL clip(DBL xx):
   # The value in[0, +INF) closest to XX
   DBL retvalu;
   IF xx < 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = xx;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- clip2 #
FUNC DBL clip2(DBL xx
      , DBL xlow
      , DBL xhigh):
   # The value in[XLOW, XHIGH] closest to XX
   # Undefined if XHIGH < XLOW
   DBL retvalu;
   IF xx <= xlow:
      retvalu = xlow;
   ELSIF xx <= xhigh:
      retvalu = xx;
   ELSE:
      retvalu = xhigh;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- clip2x #
FUNC DBL clip2x(DBL xx
      , DBL xa
      , DBL xb):
   # if XA < XB then
   #    the return value YY is the closest number to XX
   #       in the interval[XA,XB]
   # else
   #    the return value YY is the closest number to XX
   #       outside the interval(XB,XA)
   DBL retvalu;
   IF xb < xa:
      IF xx <= xb OR xa <= xx:
         retvalu = xx;
      ELSIF 2.0 * xx < xa + xb:
         retvalu = xb;
      ELSE:
         retvalu = xa;
      IF_END
   ELSE:
      IF xx <= xa:
         retvalu = xa;
      ELSIF xx <= xb:
         retvalu = xx;
      ELSE:
         retvalu = xb;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- sba #
FUNC DBL sba(DBL xx):
   # if XX in[-1, 1], XX; else, 1/XX
   DBL retvalu;
   IF - 1.0 < xx AND xx < 1.0:
      retvalu = xx;
   ELSE:
      retvalu = 1.0 / xx;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- ratio #
FUNC DBL ratio(DBL aa
      , DBL bb):
   # ratio of AA and BB in[-1,1]
   DBL rati;
   IF ABS(aa) < ABS(bb):
      rati = aa / bb;
   ELSE:
      rati = bb / aa;
   IF_END
   RETURN rati;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- horner #
FUNC DBL horner(DBL xx
      , INT deg
      , READONLY DBL coefh_arr_pc[]):
   # evaluate a polynomial of degree DEG
   # with coefficients COEFH_PC at XX
   #   SUM[II FROM 0 TO DEG; XX**II * COEFH_ARR_PC[II]]
   # THIS ACCESSES LOCATION COEFH_ARR_PC[DEG],
   #   SO COEFH_ARR_PC[] MUST HAVE AT LEAST DEG + 1 VALUES IN IT
   INT jj;
   DBL sum_curr;
   sum_curr = coefh_arr_pc[deg];
   FOR jj FROM deg - 1 TO 0 BY - 1:
      sum_curr *= xx;
      sum_curr += coefh_arr_pc[jj];
   FOR_END
   RETURN sum_curr;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- chebeval #
FUNC DBL chebeval(DBL xx
      , INT deg
      , READONLY DBL cheb_arr_pc[]):
   # Evaluate Chebyshev series sum
   #   SUM[II FROM 0 TO DEG; Tn(II, XX) * CHEB_ARR_PC[II]]
   # THIS ACCESSES LOCATION CHEB_ARR_PC[DEG],
   #   SO CHEB_ARR_PC[] MUST HAVE AT LEAST DEG + 1 VALUES IN IT
   DBL ba;
   DBL bb;
   DBL bc;
   INT ii;
   xx *= 2;
   ba = cheb_arr_pc[deg];
   bb = 0.0;
   bc = 0.0;
   FOR ii FROM deg - 1 TO 0 BY - 1:
      bc = bb;
      bb = ba;
      ba = xx * bb - bc + cheb_arr_pc[ii];
   FOR_END
   RETURN (ba - bc) / 2.0;
FUNC_END
#   IIIIIIIIIInsert-End --------------------------- simple.fwip #
## Exponential related functions
#   FFFFFFFFFFunction -------------------------------------- ln #
FUNC DBL ln(DBL xx):
   # logrithm, base E, of XX
   RETURN LN(xx);
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- lg #
FUNC DBL lg(DBL xx):
   # log base 2 of XX
   RETURN LN(xx) / LNTWO;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- log10 #
FUNC DBL log10(DBL xx):
   # log base 10 of XX
   RETURN LN(xx) / LN(10.0);
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- l10 #
FUNC DBL l10(DBL xx):
   # log base 10 of XX
   RETURN LN(xx) / LN(10.0);
FUNC_END
#TEST:l10(100)==2;
LANGUAGE_NOT LANG_C:# C has log2
   #   FFFFFFFFFFunction --------------------------------- log2 #
   FUNC DBL log2(DBL xx):
      # log base 2 of XX
      RETURN LN(xx) / LNTWO;
   FUNC_END
LANGUAGE_END# C has log2
LANGUAGE_NOT LANG_C LANG_PYTHON:# C, PYTHON have fmod
   #   FFFFFFFFFFunction --------------------------------- fmod #
   FUNC DBL fmod(DBL xx
         , DBL yymodulus):
      #    == XX - RTOZ(XX / YYMODULUS) * YYMODULUS
      # return value has same sign as XX
      DBL retvalu;
      DBL qu;
      IF yymodulus < 0.0 OR 0.0 < yymodulus:
         qu = xx / yymodulus;
         IF qu < 0.0:
            retvalu = xx - CEIL(qu) * yymodulus;
         ELSE:
            retvalu = xx - FLOOR(qu) * yymodulus;
         IF_END
      ELSE:
         retvalu = 0.0;
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------------- modf #
   FUNC DBL modf(DBL xx
         , WRITEONLY DBL ret_int_arr_p[]):
      # Split xx into a integer part returned in RET_INT_ARR_P,
      #   and an fractional part which is returned
      DBL retvalu;
      DBL int_part;
      IF xx < 0.0:
         int_part = CEIL(xx);
      ELSIF 0.0 < xx:
         int_part = FLOOR(xx);
      ELSE:
         int_part = 0;
      IF_END
      ret_int_arr_p[0] = xx - int_part;
      RETURN retvalu;
   FUNC_END
LANGUAGE_END# C, PYTHON have fmod
#   FFFFFFFFFFunction ----------------------------------- fmody #
FUNC DBL fmody(DBL xx
      , DBL yymodulus):
   #    == XX - FLOOR(XX / YYMODULUS) * YYMODULUS
   # return value has same sign as YYMODULUS
   DBL retvalu;
   IF yymodulus < 0.0 OR 0.0 < yymodulus:
      retvalu = xx - FLOOR(xx / yymodulus) * yymodulus;
   ELSE:
      retvalu = 0.0;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- fmodu #
FUNC DBL fmodu(DBL xx
      , DBL yymodulus):
   #   == XX - FLOOR(XX / ABS(YYMODULUS)) * ABS(YYMODULUS)
   # return value always has a positive sign
   # ZZ in[0, ABS(YYMODULUS)) such that
   #    XX = NN * YYMODULUS + ZZ for some integer NN
   DBL retvalu;
   IF yymodulus < 0.0 OR 0.0 < yymodulus:
      retvalu = fmod(xx, yymodulus);
      IF retvalu < 0.0:
         retvalu += ABS(yymodulus);
      IF_END
   ELSE:
      retvalu = 0.0;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:fmodu(-5.7,-2)==0.3;
#TEST:fmodu(5.7,-2)==1.7;
#   FFFFFFFFFFunction --------------------------------- remquou #
FUNC DBL remquou(DBL xx
      , DBL yymodulus
      , WRITEONLY DBL ret_int_arr_p[]):
   # return value is remainder of XX / YYMODULUS
   # RET_INT_ARR_P[0] is always positive
   DBL retvalu;
   DBL qu;
   DBL fl;
   IF yymodulus < 0.0 OR 0.0 < yymodulus:
      qu = xx / yymodulus;
      fl = FLOOR(qu);
      retvalu = qu - fl;
   ELSE:
      fl = 0.0;
      retvalu = xx;
   IF_END
   ret_int_arr_p[0] = fl;
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- fmods #
FUNC DBL fmods(DBL xx
      , DBL yymodulus):
   # ZZ in[-ABS(YYMODULUS)/2,ABS(YYMODULUS)/2) such that
   #    XX = NN * YYMODULUS + ZZ for some integer NN
   DBL retvalu;
   DBL ayy;
   DBL lim;
   IF yymodulus < 0.0 OR 0.0 < yymodulus:
      retvalu = fmod(xx, yymodulus);
      ayy = ABS(yymodulus);
      lim = ayy / 2;
      IF retvalu < - lim:
         retvalu += ayy;
      ELSIF lim <= retvalu:
         retvalu -= ayy;
      IF_END
   ELSE:
      retvalu = 0.0;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:pow(5,3)==125;
#TEST:pow(5,-3)==0.008;
#   FFFFFFFFFFunction ------------------------------------ pow2 #
FUNC DBL pow2(DBL expo):
   # 2**EXPO
   RETURN POW(2.0, expo);
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- pow10 #
FUNC DBL pow10(DBL expo):
   # 10**EXPO
   RETURN POW(10.0, expo);
FUNC_END
#   FFFFFFFFFFunction --------------------------------- sigmoid #
FUNC DBL sigmoid(DBL xx):
   # SIGMOID function(-inf, inf) to(0, 1)
   RETURN 1.0 / (1.0 + EXP(-xx));
FUNC_END
#   FFFFFFFFFFunction ------------------------------ sigmoidinv #
FUNC DBL sigmoidinv(DBL xx):
   # inverse SIGMOID function(0, 1) to(-inf, inf)
   RETURN - LN(((1.0 / xx - 0.5) - 0.5));
FUNC_END
#   FFFFFFFFFFunction -------------------------------- sigmoid3 #
FUNC DBL sigmoid3(DBL aa
      , DBL bb
      , DBL xx):
   # An infinitely differential function(-Inf,Inf) to(0,1)
   # going thru points(0, AA) and(1,BB)
   # sigmoid(xx) = sigmoid3(0.5, E / (E + 1), xx);
   DBL retvalu;
   DBL alfa;
   DBL xzero;
   DBL taa;
   IF aa <= 0 OR 1.0 <= aa OR bb <= 0.0 OR 1.0 <= bb:
      retvalu = 0.0;
   ELSE:
      taa = LN((1.0 - aa) / aa);
      alfa = LN((1.0 - bb) / bb) - taa;
      xzero = -taa / alfa;
      retvalu = 1.0 / (1.0 + EXP(alfa * (xx - xzero)));
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- taninv3 #
FUNC DBL taninv3(DBL aa
      , DBL bb
      , DBL xx):
   # a function in arctan family passing through points
   #   (0,AA) and(1,BB)
   DBL retvalu;
   DBL alfa;
   DBL taa;
   IF aa <= 0 OR 1.0 <= aa OR bb <= 0.0 OR 1.0 <= bb:
      retvalu = 0.0;
   ELSE:
      taa = TAN((aa - 0.5) * Kw.PI);
      alfa = TAN((bb - 0.5) * Kw.PI) - taa;
      retvalu = taninv(alfa * xx + taa) / Kw.PI + 0.5;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- sigmoid3d #
FUNC DBL sigmoid3d(DBL aa
      , DBL bb
      , DBL xx):
   # derivative of sigmoid3()
   DBL retvalu;
   DBL alfa;
   DBL xzero;
   DBL taa;
   DBL expa;
   IF aa <= 0 OR 1.0 <= aa OR bb <= 0.0 OR 1.0 <= bb:
      retvalu = 0.0;
   ELSE:
      taa = LN((1.0 - aa) / aa);
      alfa = LN((1.0 - bb) / bb) - taa;
      xzero = -taa / alfa;
      expa = EXP(alfa * (xx - xzero));
      retvalu = -alfa * expa / Kw.square(1 + expa);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- sqrtx #
FUNC DBL sqrtx(DBL xx):
   # a real-valued extension of the square root functions
   DBL retvalu;
   IF xx < 0.0:
      retvalu = -SQRT(-xx);
   ELSE:
      retvalu = SQRT(xx);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- smooth #
FUNC DBL smooth(DBL xx):
   # An infinitely differential function[-1,1] to[0,1]
   DBL retvalu;
   IF xx <= - 1.0:
      retvalu = 0.0;
   ELSIF 1.0 <= xx:
      retvalu = 1.0;
   ELSE:
      retvalu = sigmoid(4.0 * xx / (1.0 - xx * xx));
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- hypot #
FUNC DBL hypot(DBL xx
      , DBL yy):
   # length of hypotenuse of a right triangle
   #      with legs XX and YY
   # sqrt(XX*XX+YY*YY), avoiding round off error
   DBL retvalu;
   DBL axx;
   DBL ayy;
   axx = ABS(xx);
   ayy = ABS(yy);
   IF axx < ayy:
      retvalu = ayy;
      ayy = axx;
      axx = retvalu;
   IF_END
   # Now 0 <= ayy <= axx
   IF 0.0 < axx:
      IF ayy < Kw.DBLEPS * axx:
         retvalu = axx;
      ELSE:
         ayy /= axx;
         retvalu = axx * SQRT(1.0 + ayy * ayy);
      IF_END
   ELSE:
      retvalu = 0.0;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:hypot(3.0,4.0)==5.0;
#   FFFFFFFFFFunction ---------------------------------- hypot1 #
FUNC DBL hypot1(DBL xx):
   # length of hypotenuse of a right triangle
   #    with legs XX and 1.0
   # sqrt(1 + XX*XX), avoiding round off error
   RETURN hypot(1.0, xx);
FUNC_END
#TEST:square(hypot1(2))==5.0;
#   FFFFFFFFFFunction ------------------------------- hypot1inv #
FUNC DBL hypot1inv(DBL xx):
   # length of aleg of a right triangle
   # with hypotenuse 1.0 and other leg XX
   # sqrt(XX * XX - 1); i.e. HYPOT1INV(HYPOT1(XX))==XX
   RETURN SQRT(xx * xx - 1.0);
FUNC_END
#TEST:hypot1inv(sqrt(5))==2.0;
#   FFFFFFFFFFunction ---------------------------------- hypot3 #
FUNC DBL hypot3(DBL xx
      , DBL yy
      , DBL zz):
   # distance from(XX,YY,ZZ) to(0,0,0)
   RETURN SQRT(xx * xx + yy * yy + zz * zz);
FUNC_END
#TEST:hypot3(1,2,3)==sqrt(14);
#   FFFFFFFFFFunction ----------------------------------- topyh #
FUNC DBL topyh(DBL xx
      , DBL yy):
   # length of a leg of a right triangle with
   # hypotenuse XX and other leg YY
   # sqrt(abs(XX*XX-YY*YY))
   DBL retvalu;
   DBL xsq;
   DBL ysq;
   xsq = xx * xx;
   ysq = yy * yy;
   IF ysq <= 0.0:
      retvalu = xx;
   ELSIF xsq <= 0:
      retvalu = yy;
   ELSIF xsq < ysq:
      xsq /= ysq;
      retvalu = -sign(xx) * SQRT(1.0 - xsq) * ABS(yy);
   ELSE:
      ysq /= xsq;
      retvalu = SQRT(1.0 - ysq) * xx;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:topyh(13,12)==5;
#   FFFFFFFFFFunction ---------------------------------- topyh1 #
FUNC DBL topyh1(DBL xx):
   # length of leg of a right triangle with
   # hypotenuse 1.0 and other leg XX
   # topyh(1.0,XX) == SQRT(1 - XX * XX)
   DBL retvalu;
   IF xx < - 1.0 OR 1.0 < xx:
      retvalu = -SQRT(xx * xx - 1.0);
   ELSE:
      retvalu = SQRT(1.0 - xx * xx);
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:topyh1(0.5)==sqrt(3)/2;
#   FFFFFFFFFFunction ---------------------------- cnv_dbl2si16 #
FUNC INT cnv_dbl2si16(DBL xx):
   # safely convert a DOUBLE to an 16-bit signed INTEGER
   DBL retvalu;
   IF xx <= Kw.SI16MIN:
      retvalu = Kw.SI16MIN;
   ELSIF xx <= Kw.SI16MAX:
      retvalu = FLOORL(xx + 0.5);
   ELSE:
      retvalu = Kw.SI16MAX;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- k2tempc #
FUNC DBL k2tempc(DBL temp_k):
   # Kelvin temperature to a Celcius temperature
   RETURN (temp_k - Kw.K_AT_0TEMPC) * Kw.KELVIN / Kw.DEGC;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- tempc2k #
FUNC DBL tempc2k(DBL temp_c):
   # Celcius temperature to a Kelvin temperature
   RETURN temp_c * Kw.DEGC / Kw.KELVIN + Kw.K_AT_0TEMPC;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- tempc #
FUNC DBL tempc(DBL temp_c):
   # Celcius temperature to a Kelvin temperature
   RETURN tempc2k(temp_c);
FUNC_END
#   FFFFFFFFFFunction --------------------------------- k2tempf #
FUNC DBL k2tempf(DBL temp_k):
   # Kelvin temperature to a Fahrenheit temperature
   RETURN (temp_k - Kw.K_AT_0TEMPF) * Kw.KELVIN / Kw.DEGF;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- tempf2k #
FUNC DBL tempf2k(DBL temp_f):
   # Fahrenheit temperature to a Kelvin temperature
   RETURN temp_f * Kw.DEGF / Kw.KELVIN + Kw.K_AT_0TEMPF;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- tempf #
FUNC DBL tempf(DBL temp_f):
   # Fahrenheit temperature to a Kelvin temperature
   RETURN tempf2k(temp_f);
FUNC_END
#   FFFFFFFFFFunction --------------------------------- k2tempr #
FUNC DBL k2tempr(DBL temp_k):
   # Kelvin temperature to a Rankine temperature
   RETURN (temp_k - Kw.K_AT_0TEMPR) * Kw.KELVIN / Kw.DEGR;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- tempr2k #
FUNC DBL tempr2k(DBL temp_r):
   # Rankine temperature to a Kelvin temperature
   RETURN temp_r * Kw.DEGR / Kw.KELVIN + Kw.K_AT_0TEMPR;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- tempr #
FUNC DBL tempr(DBL temp_r):
   # Rankine temperature to a Kelvin temperature
   RETURN tempr2k(temp_r);
FUNC_END
#   FFFFFFFFFFunction ----------------------------- tempf2tempc #
FUNC DBL tempf2tempc(DBL temp_f):
   # Fahrenheit temperature to a Celsius temperature
   RETURN k2tempc(tempf2k(temp_f));
FUNC_END
#   FFFFFFFFFFunction ----------------------------- tempc2tempf #
FUNC DBL tempc2tempf(DBL temp_c):
   # Celsius temperature to a Fahrenheit temperature
   RETURN k2tempf(tempc2k(temp_c));
FUNC_END
#TEST:tempf2k(212)==373.15;
#TEST:tempf2tempc(185)==85;
#TEST:tempc2tempf(37)==98.6;
#TEST:tempf2tempc(tempc2tempf(3.2))==3.2;
#   IIIIIIIIIInsert-Begin ----------------------------- is.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-20 kdw  is:boolean checks changed
# 2020-08-17 kdw  is:macro syntax changed
# 2020-07-24 kdw  is:comment cleanup
# 2020-07-23 kdw  is:is[n]eq
# 2020-06-18 kdw  is:Modulo operator II
# 2020-06-17 kdw  is:Modulo operator
# 2020-05-29 kdw  is:keyword trial
# 2020-05-18 kdw  is:reorg
# 2020-05-13 kdw  is:comment trivially changed
# 2020-05-07 kdw  is:boolean vars work
# 2020-05-06 kdw  is:rmed boolean vars
# 2020-04-28 kdw  is:tweaks here and there
# 2020-04-26 kdw  is:tweak
# 2020-04-13 kdw  is:numeric inequality work
# 2020-04-11 kdw  is:macro arg format
# 2020-04-08 kdw  is:preprocess sigil change
# 2020-04-01 kdw  is:failed experiment
# 2020-03-25 kdw  is:ifz[e]ro func
# 2020-03-17 kdw  is:isl[e]apyear renam
# 2020-03-05 kdw  is:s/TRU[E]VAL/TR[U]E/;s/FALS[E]VAL/FA[L]SE/;
# 2020-03-03 kdw  is:comment change
# 2019-12-27 kdw  is:eplicit K[w] module
# 2019-12-26 kdw  is:module name addded to funcs
# 2019-11-20 kdw  is:is-func macro
# 2019-09-11 kdw  is:is--leapyear rework
# 2019-08-18 kdw  is:B[O]OL to B[O]L
# 2019-08-11 kdw  is:comment cleanup
# 2019-06-26 kdw  is:isss rework
# 2019-06-04 kdw  is:isfl[o]orsame func
# 2019-06-02 kdw  is:func desc added
# 2019-05-29 kdw  is:comment changed
# 2019-05-22 kdw  is:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-05-01 kdw  is:consts explicit module name
# 2019-03-19 kdw  is:re[t]_val to re[t]valu
# 2019-03-08 kdw  is:is[e]qual to is[e]q, et al.
# 2019-03-06 kdw  is:is.* funcs changed
# 2019-01-31 kdw  is:var renm
# 2018-11-30 kdw  is:comment cleanup
# 2018-07-13 kdw  is:float number reformt
# 2018-05-18 kdw  is:LAN[G]UAGE syntax change
# 2018-04-03 kdw  is:rm() from return
# 2018-04-02 kdw  is:Pro?totype, et al.
# 2018-04-01 kdw  is:LAN[G]UAGE_E[N]D
# 2018-02-16 kdw  is:iseq, isgt, islt, itss functions
# 2017-11-14 kdw  is:use fm[o]du instead of fm[o]d
# 2017-10-23 kdw  is:lang is any fix
# 2017-10-21 kdw  is:macros start with "at"
# 2017-10-20 kdw  is:LAN[G]UAGE syntax changed
# 2017-09-25 kdw  is:is?_lea?pyear rework
# 2017-08-30 kdw  is:s/DBL_/DBL/;s/FLT_/FLT/
# 2017-06-21 kdw  is:LAN[G].* AND MASTER.* change
# 2017-06-08 kdw  is:mved magic stuff out
# 2017-05-03 kdw  is:PROT?OTYPE format changed
# 2017-04-21 kdw  is:func to function; var renam
# 2017-03-10 kdw  is:get Fw[i]p_Pa[r]se to work
# 2017-03-07 kdw  is:INS?ERT etal
# 2017-03-06 kdw  is:sigils rmed
# 2017-03-01 kdw  is:space after RET?URN
# 2017-02-28 kdw  is:REQ[U]IRE function()
# 2017-02-24 kdw  is:LAN[G]UAGE change
# 2017-02-14 kdw  is:cnv_dbl2* renam
# 2017-02-12 kdw  is:FWIP language change
# 2017-02-08 kdw  is:"?[?]"PROT?OTYPE
# 2017-02-06 kdw  is:comment change
# 2017-01-06 kdw  is:?[?]LAN[G]UAGE_[I]F deprecated
# 2017-01-03 kdw  is:boolean  consts changed
# 2016-12-31 kdw  is:var renam
# 2016-12-28 kdw  is:issamesign refactor5D
# 2016-12-20 kdw  is:indent ?[?] lines
# 2016-12-03 kdw  is:comment change
# 2016-12-02 kdw  is:debugging BC(dbl_epsi == 0)
# 2016-11-23 kdw  is:comment change
# 2016-11-21 kdw  is:DE?F to FU?NC
# 2016-11-20 kdw  is:language change
# 2016-11-18 kdw  is:refactor
# 2016-11-16 kdw  is:ma?gic stuff
# 2016-11-15 kdw  is:M?OD/B?IT* syntax change
# 2016-11-14 kdw  is:LA[N]G stuff
# 2016-11-07 kdw  is:i[s]equal refactor
# 2016-11-06 kdw  is:i[s]equal refactor
# 2016-11-04 kdw  is:i[s]zero refactor
# 2016-10-28 kdw  is:comment reorder
# 2016-09-14 kdw  is:lang change
# 2016-07-22 kdw  is:debugging stuff
# 2016-07-08 kdw  is:variable rename
# 2016-07-01 kdw  is:issignsame
# 2016-06-30 kdw  is:isw?ithin
# 2016-05-26 kdw  is:variable rename(greg*year to gregyear)
# 2016-04-27 kdw  is:comment change
# 2016-04-11 kdw  is:variable rename(yea?r to gregorianyear)
# 2016-02-23 kdw  is:refactor of i?salm?ostequal
# 2015-12-30 kdw  is:_?_DEC?LARE_?_
# 2015-12-11 kdw  is:_[_]EN[D]IF_[_] obsoleted
# 2015-12-10 kdw  is:isfltequal, isdblequal refactor
# 2015-12-09 kdw  is:isd[b]lequal refactor
# 2015-12-07 kdw  is:is[m]ultl
# 2015-11-26 kdw  is:long lines
# 2015-11-15 kdw  is:m[a]gic stuff
# 2015-10-14 kdw  is:isl[e]apyear
# 2015-10-10 kdw  is:created
#   FFFFFFFFFFunction ---------------------------------- iszero #
FUNC BOL iszero(DBL xx):
   # XX == 0.0
   RETURN 0.0 <= xx AND xx <= 0.0;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- iseven #
FUNC BOL iseven(DBL xx):
   # floor of XX is even
   RETURN Kw.fmodu(xx, 2.0) < 1.0;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- isodd #
FUNC BOL isodd(DBL xx):
   # floor of XX is odd
   RETURN 1.0 <= Kw.fmodu(xx, 2.0);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- ismult #
FUNC BOL ismult(DBL xx
      , DBL mult):
   # floor of XX mod MULT < 1.0
   RETURN Kw.fmodu(xx, mult) < 1.0;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- ismultl #
FUNC BOL ismultl(INT xx
      , INT mult):
   # XX == 0 mod MULT
   BOL retvalu_bol;
   MODE_INTEGER:
      IF xx % mult == 0:
         retvalu_bol = TRUE;
      ELSE:
         retvalu_bol = FALSE;
      IF_END
   MODE_INTEGER_END
   RETURN retvalu_bol;
FUNC_END
#TEST:ismultl(21,7)-isodd(7);
#TEST:ismultl(22,7)-iseven(7);
#   FFFFFFFFFFunction ------------------------------------ isgt #
FUNC BOL isgt(DBL xx
      , DBL yy):
   # YY < XX
   RETURN yy < xx;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ islt #
FUNC BOL islt(DBL xx
      , DBL yy):
   # XX < YY
   RETURN xx < yy;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ isge #
FUNC BOL isge(DBL xx
      , DBL yy):
   # YY < XX
   RETURN yy <= xx;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ isle #
FUNC BOL isle(DBL xx
      , DBL yy):
   # XX < YY
   RETURN xx <= yy;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- ispos #
FUNC BOL ispos(DBL xx):
   # 0 < XX
   RETURN 0.0 < xx;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- isneg #
FUNC BOL isneg(DBL xx):
   # XX < 0
   RETURN xx < 0.0;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ iseq #
FUNC BOL iseq(DBL xx
      , DBL yy):
   # IF XX == 0 THEN  ABS(YY) <= Kw.DBLEPS;
   # ELSE YY == XX * (1 + EE) where ABS(EE) <= Kw.DBLEPS
   BOL retvalu_bol;
   DBL epsx;
   DBL diffxy;
   retvalu_bol = FALSE;
   IF Kw.iszero(xx):
      IF ABS(yy) <= Kw.DBLEPS:
         retvalu_bol = TRUE;
      IF_END
   ELSE:
      epsx = 2.0 * xx * Kw.DBLEPS;
      diffxy = xx - yy;
      IF epsx < 0.0:
         epsx = -epsx;
      IF_END
      IF - epsx <= diffxy AND diffxy <= epsx:
         retvalu_bol = TRUE;
      IF_END
   IF_END
   RETURN retvalu_bol;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- isneq #
FUNC BOL isneq(DBL xx
      , DBL yy):
   BOL retvalu_bol;
   IF xx < yy OR yy < xx:
      retvalu_bol = TRUE;
   ELSE:
      retvalu_bol = FALSE;
   IF_END
   RETURN retvalu_bol;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- isint #
FUNC BOL isint(DBL xx):
   # XX is an integer
   RETURN Kw.iseq(xx, FLOOR(xx));
FUNC_END
#   FFFFFFFFFFunction -------------------------------- isnegint #
FUNC BOL isnegint(DBL xx):
   # XX is a negative integer
   RETURN xx < 0.0 AND Kw.iseq(xx, FLOOR(xx));
FUNC_END
#   FFFFFFFFFFunction -------------------------------- isposint #
FUNC BOL isposint(DBL xx):
   # XX is a positive integer
   RETURN 0.0 < xx AND Kw.iseq(xx, FLOOR(xx));
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- ifzero #
FUNC DBL ifzero(DBL cond
      , DBL tru_val
      , DBL fal_val):
   # If COND is zero return TRU_VAL, else FAL_VAL
   DBL retvalu;
   IF cond < 0.0 OR 0.0 < cond:
      retvalu = fal_val;
   ELSE:
      retvalu = tru_val;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------- isalmostequal #
FUNC BOL isalmostequal(DBL xx
      , DBL yy
      , DBL epsratio):
   # Is ratio of XX and YY within EPSRATIO of 1.0?
   # TRUE if abs(XX - YY) < abs(XX * EPSRATIO)
   RETURN ABS(xx - yy) <= ABS(epsratio * xx);
FUNC_END
#   FFFFFFFFFFunction -------------------------------- iswithin #
FUNC BOL iswithin(DBL xx
      , DBL yy
      , DBL delta):
   # Is ABS(YY - XX) <= DELTA
   # Is distance of XX and YY less than DELTA?
   RETURN xx - delta <= yy AND yy <= xx + delta;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ isbetweenx #
FUNC BOL isbetweenx(DBL xx
      , DBL min_xx
      , DBL max_xx):
   # Is MIN_XX < XX < MAX_XX?
   # is between exclusive of endpoints
   RETURN min_xx < xx AND xx < max_xx;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- isbetween #
FUNC BOL isbetween(DBL xx
      , DBL min_xx
      , DBL max_xx):
   # Is MIN_XX <= XX <= MAX_XX?
   # is between inclusive of endpoints
   RETURN min_xx <= xx AND xx <= max_xx;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ isleapyear #
FUNC BOL isleapyear(INT gregyear):
   # Gregorian year GREGYEAR is a leap year
   BOL retvalu_bol;
   INT rema;
   retvalu_bol = FALSE;
   IF (gregyear % 4) == 0:
      rema = (gregyear % 400);
      IF rema <> 100 AND rema <> 200 AND rema <> 300:
         retvalu_bol = TRUE;
      IF_END
   IF_END
   RETURN retvalu_bol;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ isss #
FUNC BOL isss(DBL xx
      , DBL yy):
   # Do XX and YY have same sign, or both equal 0?
   BOL retvalu_bol;
   IF 0.0 < xx:
      IF 0.0 < yy:
         retvalu_bol = TRUE;
         # both positive
      ELSE:
         retvalu_bol = FALSE;
         # XX positive, YY not
      IF_END
   ELSIF xx < 0.0:
      IF yy < 0.0:
         retvalu_bol = TRUE;
         # both negative
      ELSE:
         retvalu_bol = FALSE;
         # XX negative, YY not
      IF_END
   ELSE:
      # xx == 0.0
      IF 0.0 < yy OR yy < 0.0:
         retvalu_bol = FALSE;
         # XX zero, YY not
      ELSE:
         retvalu_bol = TRUE;
         # both zero
      IF_END
   IF_END
   RETURN retvalu_bol;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ issignsame #
FUNC BOL issignsame(DBL xx
      , DBL yy):
   # Do XX and YY have same sign?
   RETURN Kw.isss(xx, yy);
FUNC_END
#   FFFFFFFFFFunction ----------------------------- isfloorsame #
FUNC BOL isfloorsame(DBL xx
      , DBL yy
      , DBL multy):
   # Is floor(XX*MULTY) == floor(YY*MULTY)?
   RETURN Kw.iseq(FLOOR(xx * multy), FLOOR(yy * multy));
FUNC_END
#TEST:iseven(4) - isgt(5,2);
#TEST:ismult(49,7) - ispos(4);
#TEST:isodd(4) - isneg(55);
#   IIIIIIIIIInsert-End ------------------------------- is.fwip #
BLOCK:# MAGIC stuff
   BLOCK_DEF CONST LC_MAGIC_INT 2070108020;
   BLOCK_DEF CONST LC_MAGIC_INT_NOT 301040105;
   #   FFFFFFFFFFunction ----------------------------- magicset #
   FUNC INT magicset(NUL):
      # return "magic" number
      RETURN LC_MAGIC_INT;
   FUNC_END
   #   FFFFFFFFFFunction ----------------------------- magicnot #
   FUNC INT magicnot(NUL):
      # return something NOT "magic" number
      RETURN LC_MAGIC_INT_NOT;
   FUNC_END
BLOCK_END# MAGIC stuff
#   FFFFFFFFFFunction --------------------------------- ismagic #
FUNC BOL ismagic(INT xx):
   # does XX equal magic number
   RETURN iseq(xx, magicset());
FUNC_END
#   IIIIIIIIIInsert-Begin -------------------------- round.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-17 kdw  round:comment change
# 2020-07-24 kdw  round:comment cleanup
# 2020-04-17 kdw  round:comment change
# 2020-04-12 kdw  round:comment change
# 2020-02-03 kdw  round:.*_LOOP changed
# 2019-12-27 kdw  round:eplicit K[w] module
# 2019-12-26 kdw  round:module name addded to funcs
# 2019-09-17 kdw  round:rmed c[n]v_db[l]2i32
# 2019-09-12 kdw  round:mved mod.* funcs to number
# 2019-08-18 kdw  round:L[O]G changed to L[N]
# 2019-08-11 kdw  round:comment change
# 2019-06-27 kdw  round:mod.* rework
# 2019-06-26 kdw  round:roundy rework
# 2019-05-29 kdw  round:comment changed
# 2019-05-22 kdw  round:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-03-19 kdw  round:re[t]_val changed to re[t]valu
# 2019-03-08 kdw  round:is[e]qual changed to is[e]q, et al.
# 2019-03-06 kdw  round:is.* funcs changed
# 2018-07-17 kdw  round:private lf_.* funcs
# 2018-07-13 kdw  round:float number reformt
# 2018-04-27 kdw  round:func descriptions
# 2018-04-03 kdw  round:rm() from return
# 2017-11-22 kdw  round:var renam
# 2017-11-14 kdw  round:mvd fm[o]du to Kw
# 2017-09-22 kdw  round:moved finite-step funcitons to Kw.fwip
# 2017-09-05 kdw  round:fmod2 now uses fmodu
# 2017-08-31 kdw  round:REQ[U]IRES rmed
# 2017-04-21 kdw  round:func changed to function
# 2017-03-24 kdw  round:comment tweak
# 2017-03-17 kdw  round:space after comma
# 2017-03-10 kdw  round:get Fw[i]p_Pa[r]se to work
# 2017-03-06 kdw  round:sigils rmed
# 2017-03-01 kdw  round:var[y]log-a[d]d space messup
# 2017-02-28 kdw  round:REQ[U]IRE function()
# 2017-02-14 kdw  round:cnv_dbl2* renam
# 2017-02-13 kdw  round:FWIP language change
# 2017-02-12 kdw  round:FWIP language change
# 2016-11-21 kdw  round:DE?F changed to FU?NC
# 2016-11-20 kdw  round:language change
# 2016-11-04 kdw  round:debugging
# 2016-10-30 kdw  round:fmul
# 2016-10-28 kdw  round:comment reorder
# 2016-09-13 kdw  round:lang change
# 2016-09-14 kdw  round:added() to return statements
# 2016-09-13 kdw  round:lang change
# 2016-07-22 kdw  round:rmed frac2, et al.
# 2016-07-15 kdw  round:failed experiment
# 2016-05-18 kdw  round:comment change
# 2015-12-03 kdw  round:long lines
# 2015-11-27 kdw  round:long lines
# 2015-11-24 kdw  round:rt[o]125 refactor
# 2015-11-17 kdw  round:ro[u]nd2
# 2015-11-12 kdw  round:rmed spurious comments
# 2015-10-10 kdw  round:created
#   FFFFFFFFFFunction ------------------------------------ rtoz #
FUNC DBL rtoz(DBL xx):
   # round towards zero
   DBL retvalu;
   IF xx < 0.0:
      retvalu = CEIL(xx);
   ELSE:
      retvalu = FLOOR(xx);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ rtoi #
FUNC DBL rtoi(DBL xx):
   # round away from zero
   DBL retvalu;
   IF 0.0 <= xx:
      retvalu = CEIL(xx);
   ELSE:
      retvalu = FLOOR(xx);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- bankers #
FUNC DBL bankers(DBL xx):
   # round using bankers rounding
   DBL retvalu;
   retvalu = FLOOR(xx + 0.5);
   IF Kw.isint(xx + 0.5) AND Kw.isodd(retvalu):
      retvalu -= 1.0;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- round #
FUNC DBL round(DBL xx):
   # round to nearest integer(X.5 rounds up)
   DBL retvalu;
   retvalu = FLOOR(xx + 0.5);
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- iround #
FUNC INT iround(DBL xx):
   # round to nearest integer(X.5 rounds up)
   INT retvalu;
   retvalu = FLOOR(xx + 0.5);
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- round2 #
FUNC DBL round2(DBL xx
      , DBL yy):
   # round to the nearest multiple of YY
   DBL retvalu;
   IF Kw.iszero(yy):
      retvalu = xx;
   ELSE:
      retvalu = Kw.round(xx / yy) * yy;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- roundy #
FUNC DBL roundy(DBL xx
      , DBL yy
      , DBL shf):
   # (round to the nearest multiple of YY) minus SHF
   DBL retvalu;
   IF yy < 0.0 OR 0.0 < yy:
      retvalu = (Kw.round((xx - shf) / yy) * yy + shf);
   ELSE:
      retvalu = xx;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- rtomsd #
FUNC DBL rtomsd(DBL fs
      , INT msds):
   # round to the most signifigant MSDS digits
   #   rtomsd(1.2345678, 6) == 1.23457
   DBL retvalu;
   DBL signs;
   INT logi;
   IF Kw.iszero(fs):
      retvalu = 0.0;
   ELSE:
      IF fs < 0.0:
         signs = -1.0;
         fs = -fs;
      ELSE:
         signs = 1.0;
      IF_END
      logi = FLOOR(Kw.log10(fs) - msds + 1.0);
      retvalu = signs * Kw.round2(fs, POW(10.0, logi));
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- rto125 #
FUNC DBL rto125(DBL fs):
   # round the given number to the nearest 1-2-5:
   #[1.0, SQRT(2))       =[1.000, 1.414) to 1.0
   #[SQRT(2), SQRT(10))  =[1.414, 3.162) to 2.0
   #[SQRT(10), SQRT(50)) =[3.162, 7.071) to 5.0
   #[SQRT(50), 10)       =[7.071, 10.00) to 10.0
   DBL signs;
   DBL tmpf;
   DBL valu;
   DBL pow_ten;
   DBL retvalu;
   IF Kw.iszero(fs):
      retvalu = 0.0;
   ELSE:
      IF fs < 0.0:
         signs = -1.0;
         fs = -fs;
      ELSE:
         signs = 1.0;
      IF_END
      pow_ten = POW(10.0, FLOOR(Kw.log10(fs)));
      # POW_TEN is the largest power of 10 <= FS
      tmpf = fs / pow_ten;
      # TMPF is in[1.0, 10)
      IF tmpf < SQRT(2.0):
         valu = 1.0;
      ELSIF tmpf < SQRT(10.0):
         valu = 2.0;
      ELSIF tmpf < SQRT(50.0):
         valu = 5.0;
      ELSE:
         valu = 10.0;
      IF_END
      retvalu = signs * pow_ten * valu;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- floor2 #
FUNC DBL floor2(DBL xx
      , DBL yy):
   # floor2(XX,YY)=maximum ZZ ST: ZZ=NN*YY<=XX for integer NN
   # the greatest multiple of YY <= XX
   DBL retvalu;
   IF Kw.iszero(yy):
      retvalu = 0.0;
   ELSE:
      retvalu = FLOOR(xx / ABS(yy)) * ABS(yy);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- ceil2 #
FUNC DBL ceil2(DBL xx
      , DBL yy):
   # ceil2(XX,YY)=minimum ZZ ST: X<=ZZ=NN*YY for integer NN
   DBL retvalu;
   IF Kw.iszero(yy):
      retvalu = 0.0;
   ELSE:
      retvalu = CEIL(xx / ABS(yy)) * ABS(yy);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- fmod2 #
FUNC DBL fmod2(DBL xx
      , DBL minn
      , DBL maxx):
   # fmod2(XX,MINX,MAXX)=ZZ in[MINN, MAXX)
   #   ST: XX=NN*(MAXX-MINX)+ZZ for integer NN
   DBL retvalu;
   IF Kw.iseq(maxx, minn):
      retvalu = 0.0;
   ELSE:
      retvalu = Kw.fmodu(xx - minn, maxx - minn) + minn;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ frac #
FUNC DBL frac(DBL xx):
   # frac(XX) = ZZ in[0, 1) ST: XX=NN+ZZ for integer NN
   # frac(XX) = XX - FLOOR(XX)
   RETURN xx - FLOOR(xx);
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- trunc #
FUNC DBL trunc(DBL xx):
   # trunc(XX) = frac(XX) if 0 <= XX
   # trunc(XX) = -frac(-XX) if XX < 0
   DBL retvalu;
   IF 0.0 <= xx:
      retvalu = xx - FLOOR(xx);
   ELSE:
      retvalu = xx - CEIL(xx);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ fmul #
FUNC DBL fmul(DBL xx
      , DBL pp):
   # fmul(XX,PP)=ZZ in[1, PP) ST: XX=PP**NN*ZZ for integer NN
   DBL lpp;
   lpp = LN(pp);
   RETURN EXP(lpp * Kw.frac(LN(xx) / lpp));
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ dist #
FUNC DBL dist(DBL xx
      , DBL mm):
   # the distance of XX from the nearest multiple of MM:
   # dist(XX,MM)=ZZ in[0, ABS(MM)/2] ST:
   #   ABS(XX-NN*MM)=ZZ for integer NN
   DBL retvalu;
   DBL axx;
   DBL amm;
   axx = ABS(xx);
   amm = ABS(mm);
   retvalu = Kw.fmod(axx, amm);
   IF amm < 2.0 * retvalu:
      retvalu = amm - retvalu;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- ddist #
FUNC DBL ddist(DBL xx
      , DBL mm):
   # ddist(XX,MM)=ZZ in(-ABS(MM/2), ABS(MM)]
   #    ST: XX=NN*MM+ZZ for integer NN
   DBL retvalu;
   DBL rema;
   DBL amm;
   IF Kw.iszero(mm):
      retvalu = 0.0;
   ELSE:
      amm = ABS(mm);
      rema = xx - FLOOR(xx / amm) * amm;
      IF amm < 2.0 * rema:
         rema -= amm;
      IF_END
      retvalu = rema;
   IF_END
   RETURN retvalu;
FUNC_END
#   IIIIIIIIIInsert-End ---------------------------- round.fwip #
#   IIIIIIIIIInsert-Begin --------------------------- trig.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-19 kdw  trig:comment change
# 2020-08-17 kdw  trig:macro syntax changed
# 2020-08-03 kdw  trig:explicit module for pi and tau
# 2020-08-02 kdw  trig:g[d] func
# 2020-07-29 kdw  trig:block-def work
# 2020-07-27 kdw  trig:block syntax
# 2020-07-24 kdw  trig:s/LO[C]AL_/BL[O]CK_/
# 2020-07-23 kdw  trig:minor reorg
# 2020-07-22 kdw  trig:var rename w/ circ_
# 2020-06-30 kdw  trig:tests changed
# 2020-06-12 kdw  trig:uppercased tan function
# 2020-06-03 kdw  trig:writeonly keyword
# 2020-05-30 kdw  trig:CONST syntax change
# 2020-05-14 kdw  trig:block for sinc
# 2020-04-14 kdw  trig:tests added
# 2020-04-12 kdw  trig:comment change
# 2020-04-11 kdw  trig:macro arg format
# 2020-04-08 kdw  trig:preprocess sigil change
# 2020-03-03 kdw  trig:comment changed:odd chars
# 2020-03-02 kdw  trig:s/_N[E]XT/_E[N]D/
# 2020-02-25 kdw  trig:comment cleanup
# 2020-02-03 kdw  trig:.*_LOOP changed
# 2019-12-27 kdw  trig:eplicit K[w] module
# 2019-12-26 kdw  trig:module name addded to funcs
# 2019-11-19 kdw  trig:macro var name change
# 2019-10-04 kdw  trig:comment change
# 2019-10-02 kdw  trig:macro arg format change
# 2019-09-11 kdw  trig:macro arg name change
# 2019-08-17 kdw  trig:L[O]G to L[N]
# 2019-08-11 kdw  trig:comment cleanup
# 2019-08-06 kdw  trig:rmed backslashes, macro arg renam
# 2019-07-02 kdw  trig:macro renam
# 2019-06-04 kdw  trig:angle conversion macros; func comments
# 2019-06-02 kdw  trig:NR_ to RAPHSON_
# 2019-05-31 kdw  trig:NR_DO to RAPHSON_LOOP; et al
# 2019-05-30 kdw  trig:s/(ar[c]deg)ree/arcdeg/
# 2019-05-21 kdw  trig:function keyword
# 2019-05-08 kdw  trig:comments
# 2019-05-01 kdw  trig:consts explicit module name
# 2019-03-19 kdw  trig:re[t]_val to re[t]valu
# 2019-03-18 kdw  trig:macro syntax changed
# 2019-03-16 kdw  trig:use to[p]yh1
# 2019-03-08 kdw  trig:rmed defines
# 2019-03-06 kdw  trig:is.* funcs changed
# 2019-02-28 kdw  trig:DE[F]INE playing
# 2019-02-19 kdw  trig:se[c]inv fixed
# 2019-02-12 kdw  trig:deg[2]ra func rmed
# 2019-02-08 kdw  trig:comment
# 2019-01-28 kdw  trig:sinc work
# 2019-01-13 kdw  trig:var rena; reorg
# 2018-12-08 kdw  trig:comment change
# 2018-12-03 kdw  trig:sincinv function
# 2018-11-28 kdw  trig:sinc function
# 2018-10-08 kdw  trig:vbdotnet stuff
# 2018-10-05 kdw  trig:trig macros rework
# 2018-04-27 kdw  trig:func descriptions
# 2018-04-10 kdw  trig:macros changed
# 2018-04-09 kdw  trig:[tdr]2[rdt] func renam
# 2018-04-03 kdw  trig:rm() from return
# 2018-03-26 kdw  trig:macro redef
# 2018-02-21 kdw  trig:inv trig func renam: s/a(.*)/inv/
# 2018-02-19 kdw  trig:secant and macro refactor
# 2018-02-17 kdw  trig:expandnow changed
# 2018-02-13 kdw  trig:expand preprocess stuff
# 2018-01-29 kdw  trig:tur2deg,deg2tur functs
# 2018-01-26 kdw  trig:comments
# 2017-10-25 kdw  trig:d[m]s functions; suffixes some vars
# 2017-08-29 kdw  trig:experiment
# 2017-08-20 kdw  trig:rmed/renamd .*_P[E]R_.* vars
# 2017-04-21 kdw  trig:unneeded plus signs rmed
# 2017-04-20 kdw  trig:func to function
# 2017-03-10 kdw  trig:get Fw[i]p_Pa[r]se to work
# 2017-03-07 kdw  trig:INS[E]RT etal
# 2017-03-06 kdw  trig:sigils rmed
# 2017-03-01 kdw  trig:space after RET?URN
# 2017-02-13 kdw  trig:FWIP language change
# 2017-02-12 kdw  trig:FWIP language change
# 2017-01-08 kdw  trig:include consts
# 2016-12-25 kdw  trig:"rev" to "t"
# 2016-12-25 kdw  trig:atan2h
# 2016-11-24 kdw  trig:spaces around operator
# 2016-11-21 kdw  trig:DE[F] to FU[N]C
# 2016-11-20 kdw  trig:language change
# 2016-11-20 kdw  trig:comment cleanup
# 2016-11-19 kdw  trig:"p" to "rev"
# 2016-11-16 kdw  trig:comments
# 2016-11-15 kdw  trig:*inv functions added
# 2016-09-15 kdw  trig:lang change
# 2016-09-13 kdw  trig:lang change
# 2016-05-12 kdw  trig:Co[p]yright comment changed
# 2016-04-27 kdw  trig:forced double division in places
# 2016-01-15 kdw  trig:tweak
# 2015-12-03 kdw  trig:renamed constants
# 2015-12-02 kdw  trig:renamed functions; requires line
# 2015-11-24 kdw  trig:ex[p]app[r]ox2 refactor
# 2015-11-23 kdw  trig:expa syntax error
# 2015-11-22 kdw  trig:expa
# 2015-11-20 kdw  trig:sina; SINa, COSa refactor
# 2015-11-19 kdw  trig:cosa
# 2015-11-18 kdw  trig:long lines changed
# 2015-11-17 kdw  trig:long lines changed
# 2015-11-13 kdw  trig:long lines addressed
# 2015-10-22 kdw  trig:a[t]an2.*
# 2015-10-14 kdw  trig:RA[D]IAN_PER_[R]EV, et al.
# 2015-09-20 kdw  trig:created
#   IIIIIIIIIInsert-Begin ------------------------- Macros.fwip #
#   IIIIIIIIIInsert-End --------------------------- Macros.fwip #
#   FFFFFFFFFFunction ------------------------------------ sinc #
FUNC DBL sinc(DBL xx_rad):
   # YY = SIN(XX) / XX
   DBL retvalu;
   IF xx_rad < 0.0 OR 0.0 < xx_rad:
      retvalu = SIN(xx_rad) / xx_rad;
   ELSE:
      retvalu = 1;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- sincinv #
FUNC DBL sincinv(DBL yy):
   # Solve SINC(XX) = YY for YY in the interval
   #   (sinc(LC_SINC_MIN_X),1.0) -> (LC_SINC_MIN_X,0)
   DBL min_yy;
   DBL min_xx;
   DBL start_xx;
   DBL aa;
   DBL bb;
   INT nrvx_ii;
   DBL nrvx_yy;
   DBL nrvx_xx;
   DBL nrvx_dy;
   DBL nrvx_xp;
   # X value where sinc(X) has its minimum
   min_xx = 4.4934094579090641753079882808139693729311345;
   min_yy = sinc(min_xx);
   IF yy <= min_yy:
      # XX such that d(SINC(XX)) / dXX == 0
      #   i.e.  (XX * COS(XX) - SIN(XX)) / XX**2 == 0
      nrvx_xx = min_xx;
   ELSIF yy < 1.0:
      # SINC(XX) = YY implies SIN(XX) - YY * XX = 0
      aa = yy - min_yy;
      bb = 1.0 - yy;
      start_xx = (aa * SQRT(5.0 * bb) + bb * (min_xx - SQRT(6
            * aa))) / (1.0 - min_yy);
      # return XX where
      #    SIN(nrvx_xx) - yy * nrvx_xx(XX) == 0
      # BEG Newton-Raphson Calculation
      nrvx_xx = start_xx;
      FOR nrvx_ii FROM 0 TO 20:
         nrvx_xp = nrvx_xx;
         nrvx_dy = COS(nrvx_xx) - yy;
         IF Kw.iszero(nrvx_dy):
            FOR_EXIT;
         IF_END
         nrvx_yy = SIN(nrvx_xx) - yy * nrvx_xx;
         nrvx_xx -= nrvx_yy / nrvx_dy;
         IF Kw.iseq(nrvx_xp, nrvx_xx):
            FOR_EXIT;
         IF_END
      FOR_END
      # END Newton-Raphson Calculation
   ELSE:
      # 1.0 <= yy
      nrvx_xx = 0.0;
   IF_END
   RETURN nrvx_xx;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- sincc #
FUNC DBL sincc(DBL xx_rad):
   # YY = SINC(XX) = SIN(XX) / XX via Taylor series
   DBL trigsign;
   DBL xr_rad;
   DBL sum_curr;
   DBL sum_prev;
   DBL nxr_sqr;
   INT ii;
   DBL term;
   DBL retvalu;
   IF Kw.iszero(xx_rad):
      retvalu = 1.0;
   ELSE:
      xr_rad = Kw.fmod(xx_rad, Kw.TAU);
      # now 0 <= XR_RAD  < Kw.TAU
      IF Kw.TAU / 2.0 < xr_rad:
         xr_rad = Kw.TAU - xr_rad;
         trigsign = -1.0;
      ELSE:
         trigsign = 1.0;
      IF_END
      IF Kw.TAU / 4.0 < xr_rad:
         xr_rad = Kw.TAU / 2.0 - xr_rad;
      IF_END
      nxr_sqr = -xr_rad * xr_rad;
      sum_curr = xr_rad;
      # 1
      term = xr_rad;
      AWAIT Kw.iseq(sum_curr, sum_prev) COUNT ii FROM 2 BY 2:
         term *= nxr_sqr / (ii * (ii - 1));
         sum_prev = sum_curr;
         sum_curr += term;
      AWAIT_END
      retvalu = trigsign * sum_curr * xr_rad / xx_rad;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- versin #
FUNC DBL versin(DBL circ_rad):
   # calculate YY = VERSIN(XX) = 1 - COS(X) via Taylor series
   DBL trigsign;
   DBL xr_rad;
   DBL xr_sqr;
   INT ii;
   DBL sum_curr;
   DBL term;
   DBL sum_prev;
   xr_rad = Kw.fmod(circ_rad, Kw.TAU);
   # now 0 <= XR_RAD  < Kw.TAU
   IF Kw.TAU / 2.0 < xr_rad:
      # cos(x) = cos(Kw.TAU - x)
      xr_rad = Kw.TAU - xr_rad;
   IF_END
   IF Kw.TAU / 4.0 < xr_rad:
      # cos(x) = -cos(Kw.TAU / 2 - x)
      xr_rad = Kw.TAU / 2.0 - xr_rad;
      trigsign = -1.0;
   ELSE:
      trigsign = 1.0;
   IF_END
   xr_sqr = -xr_rad * xr_rad;
   sum_curr = 1.0 / 2.0;
   term = 1.0 / 2.0;
   AWAIT Kw.iseq(sum_curr, sum_prev) COUNT ii FROM 4 BY 2:
      term *= xr_sqr / (ii * (ii - 1));
      sum_prev = sum_curr;
      sum_curr += term;
   AWAIT_END
   sum_curr *= - xr_sqr;
   IF trigsign < 0:
      sum_curr = 2.0 - sum_curr;
   IF_END
   RETURN sum_curr;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- haversin #
FUNC DBL haversin(DBL circ_rad):
   # YY = VERSINE(XX) / 2 = (1 - COS(XX)) / 2
   RETURN versin(circ_rad) / 2.0;
FUNC_END
#   Angle-conversion-functions ---- ----- ----- ----- ----- -----
#   FFFFFFFFFFunction --------------------------------- tur2deg #
FUNC DBL tur2deg(DBL circ_tur):
   # convert turns to degrees
   RETURN circ_tur * Kw.TURN / Kw.ARCDEG;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- deg2tur #
FUNC DBL deg2tur(DBL circ_deg):
   # convert degrees to turns
   RETURN circ_deg * Kw.ARCDEG / Kw.TURN;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- tur2rad #
FUNC DBL tur2rad(DBL circ_tur):
   # convert turns to radians
   RETURN circ_tur * Kw.TURN / Kw.RADIAN;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- rad2tur #
FUNC DBL rad2tur(DBL circ_rad):
   # convert radians to turns
   RETURN circ_rad * Kw.RADIAN / Kw.TURN;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- tur2sec #
FUNC DBL tur2sec(DBL circ_tur):
   # convert turns to arcsecs
   RETURN circ_tur * Kw.TURN / Kw.ARCSEC;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- sec2tur #
FUNC DBL sec2tur(DBL circ_sec):
   # convert arcsecs to turns
   RETURN circ_sec * Kw.ARCSEC / Kw.TURN;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- rad2deg #
FUNC DBL rad2deg(DBL circ_rad):
   # convert radians to degrees
   RETURN circ_rad * Kw.RADIAN / Kw.ARCDEG;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- deg2rad #
FUNC DBL deg2rad(DBL circ_deg):
   # convert degrees to radians
   RETURN circ_deg * Kw.ARCDEG / Kw.RADIAN;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- rad2sec #
FUNC DBL rad2sec(DBL circ_rad):
   # convert radians to arcsecs
   RETURN circ_rad * Kw.RADIAN / Kw.ARCSEC;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- sec2rad #
FUNC DBL sec2rad(DBL circ_sec):
   # convert arcsecs to radians
   RETURN circ_sec * Kw.ARCSEC / Kw.RADIAN;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- deg2sec #
FUNC DBL deg2sec(DBL circ_deg):
   # convert degrees to arcsecs
   RETURN circ_deg * Kw.ARCDEG / Kw.ARCSEC;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- sec2deg #
FUNC DBL sec2deg(DBL circ_sec):
   # convert arcsecs to degrees
   RETURN circ_sec * Kw.ARCSEC / Kw.ARCDEG;
FUNC_END
#TEST:deg2rad(rad2deg(183))==183;
#   FFFFFFFFFFunction --------------------------------- rad2dms #
FUNC DBL rad2dms(DBL xx_rads):
   # convert radians to deg.minut-sec
   DBL dd_deg;
   DBL mm_min;
   DBL dg;
   dg = rad2deg(xx_rads);
   dd_deg = FLOOR(dg);
   dg = (dg - dd_deg) * Kw.ARCDEG / Kw.ARCMIN;
   mm_min = FLOOR(dg);
   dg = (dg - mm_min) * Kw.ARCMIN / Kw.ARCSEC;
   RETURN dd_deg + (mm_min + dg / 100.0) / 100.0;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- rad2dms2 #
FUNC DBL rad2dms2(DBL circ_rads):
   # convert radians to deg.minut-sec
   DBL dg;
   DBL dd_deg_arr[2];
   DBL mm_min_arr[2];
   dg = rad2deg(circ_rads);
   dg = Kw.modf(dg, dd_deg_arr[]) * Kw.ARCDEG / Kw.ARCMIN;
   dg = Kw.modf(dg, mm_min_arr[]) * Kw.ARCMIN / Kw.ARCSEC;
   RETURN dd_deg_arr[0] + (mm_min_arr[0] + dg / 100.0) / 100.0;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- dms2rad #
FUNC DBL dms2rad(DBL circ_dms):
   # convert a number of the form DD.MMSS*... to radians
   DBL dd_deg;
   DBL mm_min;
   DBL dg;
   dd_deg = FLOOR(circ_dms);
   dg = (circ_dms - dd_deg) * 100.0;
   mm_min = FLOOR(dg);
   dg = (dg - mm_min) * 100.0;
   RETURN (dg * Kw.ARCSEC + mm_min * Kw.ARCMIN + dd_deg
         * Kw.ARCDEG) / Kw.RADIAN;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- deg2dms #
FUNC DBL deg2dms(DBL circ_deg):
   # convert degrees to DD.MMSS+ format
   RETURN rad2dms(deg2rad(circ_deg));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- dms2deg #
FUNC DBL dms2deg(DBL circ_dms):
   # convert DD.MMSS+ format to degrees
   RETURN rad2deg(dms2rad(circ_dms));
FUNC_END
#   Other-Trig-functions ---- ----- ----- ----- ----- ----- -----
#   FFFFFFFFFFunction ------------------------------------- cot #
FUNC DBL cot(DBL circ_rad):
   # Cotangent Range(-Inf, Inf)
   RETURN COS(circ_rad) / SIN(circ_rad);
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- sec #
FUNC DBL sec(DBL circ_rad):
   # Secant Range[1, Inf) or[-1, -Inf)
   RETURN 1.0 / COS(circ_rad);
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- csc #
FUNC DBL csc(DBL circ_rad):
   # Cosecant Range[1, Inf) or[-1, -Inf)
   RETURN 1.0 / SIN(circ_rad);
FUNC_END
#   Inverse-trig-functions -- ----- ----- ----- ----- ----- -----
#   FFFFFFFFFFunction ---------------------------------- sininv #
FUNC DBL sininv(DBL xx):
   # inverse sine[-1, 1] to[-Kw.TAU/4, Kw.TAU/4]
   RETURN ATAN2(xx, Kw.topyh1(xx));
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- cosinv #
FUNC DBL cosinv(DBL xx):
   # inverse cosine[-1, 1] to[Kw.TAU/2, 0]
   RETURN ATAN2(Kw.topyh1(xx), xx);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- taninv #
FUNC DBL taninv(DBL xx):
   # inverse tangent(-Inf, Inf) to(-Kw.TAU/4, Kw.TAU/4)
   RETURN ATAN2(xx, 1.0);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- cotinv #
FUNC DBL cotinv(DBL xx):
   # inverse cotangent(-Inf, Inf) to(Kw.TAU/2, 0)
   RETURN ATAN2(1.0, xx);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- secinv #
FUNC DBL secinv(DBL xx):
   # inverse secant[1, Inf) to[0, Kw.TAU/4)
   #              AND (-Inf, -1] to(-Kw.TAU/4, 0]
   RETURN ATAN2(SQRT(xx * xx - 1.0), Kw.sign(xx));
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- cscinv #
FUNC DBL cscinv(DBL xx):
   # inverse cosecant[1, Inf) to[Kw.TAU/4, 0)
   #              AND (-Inf, -1] to(0, -Kw.TAU/4]
   RETURN ATAN2(Kw.sign(xx), SQRT(xx * xx - 1.0));
FUNC_END
#   Hyperbolic-Trig-functions ----- ----- ----- ----- ----- -----
#   FFFFFFFFFFunction ------------------------------------ sinh #
FUNC DBL sinh(DBL hyp_rad):
   # Hyperbolic Sine(-Inf, Inf) to(-Inf, Inf)
   RETURN (EXP(hyp_rad) - EXP(-hyp_rad)) / 2.0;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ cosh #
FUNC DBL cosh(DBL hyp_rad):
   # Hyperbolic Cosine(-Inf, 0, Inf) to(Inf, 1, Inf)
   RETURN (EXP(hyp_rad) + EXP(-hyp_rad)) / 2.0;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ tanh #
FUNC DBL tanh(DBL hyp_rad):
   # Hyperbolic Tangent(-Inf, Inf) to(-1, 1)
   RETURN sinh(hyp_rad) / cosh(hyp_rad);
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ coth #
FUNC DBL coth(DBL hyp_rad):
   # Hyperbolic Cotangent
   # (-Inf, 0) to(-1, -Inf); (0, Inf) to(Inf, 1);
   RETURN cosh(hyp_rad) / sinh(hyp_rad);
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ sech #
FUNC DBL sech(DBL hyp_rad):
   # Hyperbolic Secant
   # (-Inf, 0, Inf) to(0, 1, 0)
   RETURN 1.0 / cosh(hyp_rad);
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ csch #
FUNC DBL csch(DBL hyp_rad):
   # Hyperbolic Cosecant
   # (-Inf, 0) to(-0, -Inf); (0, Inf) to(Inf, 0);
   RETURN 1.0 / sinh(hyp_rad);
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- gd #
FUNC DBL gd(DBL hyp_rad):
   # convert HYP_RAD into CIRC_RAD
   #        xx     1
   # INTEGRATE  ------- dt
   #         0  COSH(t)
   #    SIN(GD(X)) = TANH(X)
   #    TAN(GD(X)) = SINH(X)
   #    COS(GD(X)) = 1 / COSH(X)
   RETURN 2.0 * ATAN2(EXP(hyp_rad), 1.0) - Kw.PI / 2.0;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- gdinv #
FUNC DBL gdinv(DBL xx):
   # Inverse Gudermannian function
   #        xx    1
   # INTEGRATE  ------ dt
   #         0  COS(t)
   DBL xxn;
   xxn = Kw.fmods(xx, Kw.PI);
   RETURN LN(ABS((1.0 + SIN(xxn)) / COS(xxn)));
FUNC_END
#   Inverse-hyperbolic-trig-functions --- ----- ----- ----- -----
#   FFFFFFFFFFunction --------------------------------- sinhinv #
FUNC DBL sinhinv(DBL xx):
   # Inverse Hyperbolic Sine(-Inf, Inf) to(-Inf, Inf)
   RETURN LN(xx + SQRT(xx * xx + 1.0));
FUNC_END
#TEST:sinhinv(sinh(3.5))==3.5;
#   FFFFFFFFFFunction --------------------------------- coshinv #
FUNC DBL coshinv(DBL xx):
   # Inverse Hyperbolic Cosine[1, Inf) to[0, Inf)
   RETURN LN(xx + SQRT(xx * xx - 1.0));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- tanhinv #
FUNC DBL tanhinv(DBL xx):
   # Inverse Hyperbolic Tangent(-1, 1) to(-Inf, Inf)
   RETURN LN((1.0 + xx) / (1.0 - xx)) / 2.0;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- cothinv #
FUNC DBL cothinv(DBL xx):
   # Inverse Hyperbolic Cotangent
   # (-Inf, -1) to(0, -Inf); (1, Inf) to(Inf, 0)
   RETURN LN((xx + 1.0) / (xx - 1.0)) / 2.0;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- sechinv #
FUNC DBL sechinv(DBL xx):
   # Inverse Hyperbolic Secant(0, 1] to(Inf, 0]
   RETURN LN((1.0 + Kw.topyh1(xx)) / xx);
FUNC_END
#   FFFFFFFFFFunction --------------------------------- cschinv #
FUNC DBL cschinv(DBL xx):
   # Inverse Hyperbolic Cosecant[1, Inf) to(0, Inf)
   RETURN LN((1.0 + SQRT(1.0 + xx * xx)) / xx);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- atan2h #
FUNC DBL atan2h(DBL xx
      , DBL yy):
   # Inverse Hyperbolic Tangent
   DBL retvalu;
   IF ABS(yy) <= ABS(xx):
      retvalu = 0.0;
   ELSE:
      retvalu = LN((yy + xx) / (yy - xx)) / 2.0;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- atan2u #
FUNC DBL atan2u(DBL xx
      , DBL yy):
   # inverse tangent in[0,Kw.TAU)
   RETURN Kw.fmodu(ATAN2(xx, yy), Kw.tur2rad(1.0));
FUNC_END
#   Trig-functions-in-degrees ----- ----- ----- ----- ----- -----
#   FFFFFFFFFFunction ------------------------------------ sind #
FUNC DBL sind(DBL circ_deg):
   # The SINE of the angle given in CIRC_Degrees
   RETURN SIN(deg2rad(circ_deg));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- sindinv #
FUNC DBL sindinv(DBL xx):
   # The inverse of SINE in Degrees
   RETURN rad2deg(sininv(xx));
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ cosd #
FUNC DBL cosd(DBL circ_deg):
   # The COSINE of the angle given in CIRC_Degrees
   RETURN COS(deg2rad(circ_deg));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- cosdinv #
FUNC DBL cosdinv(DBL xx):
   # The inverse of COSINE in Degrees
   RETURN rad2deg(cosinv(xx));
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ tand #
FUNC DBL tand(DBL circ_deg):
   # The TANGENT of the angle given in CIRC_Degrees
   RETURN TAN(deg2rad(circ_deg));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- tandinv #
FUNC DBL tandinv(DBL xx):
   # The inverse of TANGENT in Degrees
   RETURN rad2deg(taninv(xx));
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ cotd #
FUNC DBL cotd(DBL circ_deg):
   # The COTANGENT of the angle given in CIRC_Degrees
   RETURN cot(deg2rad(circ_deg));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- cotdinv #
FUNC DBL cotdinv(DBL xx):
   # The inverse of COTANGENT in Degrees
   RETURN rad2deg(cotinv(xx));
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ secd #
FUNC DBL secd(DBL circ_deg):
   # The SECANT of the angle given in CIRC_Degrees
   RETURN sec(deg2rad(circ_deg));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- secdinv #
FUNC DBL secdinv(DBL xx):
   # The inverse of SECANT in Degrees
   RETURN rad2deg(secinv(xx));
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ cscd #
FUNC DBL cscd(DBL circ_deg):
   # The COSECANT of the angle given in CIRC_Degrees
   RETURN csc(deg2rad(circ_deg));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- cscdinv #
FUNC DBL cscdinv(DBL xx):
   # The inverse of COSECANT in Degrees
   RETURN rad2deg(cscinv(xx));
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- atan2d #
FUNC DBL atan2d(DBL xx
      , DBL yy):
   # The inverse Tangent of XX / YY in Degrees
   RETURN rad2deg(ATAN2(xx, yy));
FUNC_END
#TEST:sindinv(sqrt(0.5))==45;
#TEST:tand(tandinv(1.98))==1.98;
#TEST:square(tand(30))==1/3.0;
#   Trig-functions-in-turns   ----- ----- ----- ----- ----- -----
#   FFFFFFFFFFunction ------------------------------------ sint #
FUNC DBL sint(DBL circ_tur):
   # The SINE of the angle given in CIRC_Turns
   RETURN SIN(tur2rad(circ_tur));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- sintinv #
FUNC DBL sintinv(DBL xx):
   # The inverse of SINE in Turns
   RETURN rad2tur(sininv(xx));
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ cost #
FUNC DBL cost(DBL circ_tur):
   # The COSINE of the angle given in CIRC_Turns
   RETURN COS(tur2rad(circ_tur));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- costinv #
FUNC DBL costinv(DBL xx):
   # The inverse of COSINE in Turns
   RETURN rad2tur(cosinv(xx));
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ tant #
FUNC DBL tant(DBL circ_tur):
   # The TANGENT of the angle given in CIRC_Turns
   RETURN TAN(tur2rad(circ_tur));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- tantinv #
FUNC DBL tantinv(DBL xx):
   # The inverse of TANGENT in Turns
   RETURN rad2tur(taninv(xx));
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ cott #
FUNC DBL cott(DBL circ_tur):
   # The COTANGENT of the angle given in CIRC_Turns
   RETURN cot(tur2rad(circ_tur));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- cottinv #
FUNC DBL cottinv(DBL xx):
   # The inverse of COTANGENT in Turns
   RETURN rad2tur(cotinv(xx));
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ sect #
FUNC DBL sect(DBL circ_tur):
   # The SECANT of the angle given in CIRC_Turns
   RETURN sec(tur2rad(circ_tur));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- sectinv #
FUNC DBL sectinv(DBL xx):
   # The inverse of SECANT in Turns
   RETURN rad2tur(secinv(xx));
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ csct #
FUNC DBL csct(DBL circ_tur):
   # The COSECANT of the angle given in CIRC_Turns
   RETURN csc(tur2rad(circ_tur));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- csctinv #
FUNC DBL csctinv(DBL xx):
   # The inverse of COSECANT in Turns
   RETURN rad2tur(cscinv(xx));
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- atan2t #
FUNC DBL atan2t(DBL xx
      , DBL yy):
   # The inverse Tangent of XX / YY in Turns
   RETURN rad2tur(ATAN2(xx, yy));
FUNC_END
#TEST:square(cost(0.125))==0.5;
#   IIIIIIIIIInsert-End ----------------------------- trig.fwip #
#   FFFFFFFFFFunction ------------------------------------ ln1p #
FUNC DBL ln1p(DBL xx):
   # ln(1 + XX) accurately via
   # ln(1+x) = (x**1/1 - x**2/2 + x**3/3 - x**4/4 + ...
   #         = x(1 - x(1/2 + x(1/3 - x(1/4 + ...
   DBL retvalu;
   DBL sum_curr;
   DBL jj;
   DBL start;
   IF 0.1 < ABS(xx):
      retvalu = LN(1.0 + xx);
   ELSIF Kw.iszero(xx):
      retvalu = 0.0;
   ELSE:
      start = CEIL(ABS(LN(Kw.DBLEPS) / LN(ABS(xx))));
      IF start < 2:
         start = 2;
      IF_END
      sum_curr = 0.0;
      FOR jj FROM start TO 1 BY - 1:
         sum_curr = 1.0 / jj - sum_curr * xx;
      FOR_END
      retvalu = sum_curr * xx;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- expm1 #
FUNC DBL expm1(DBL xx):
   # exp(XX) - 1 accurately via
   #    == x**1/1 + x**2/2 + x**3/6 + x**4/24 ...
   #    == x(1 + x/2(1 + x/3(1 + x/4(...
   DBL retvalu;
   DBL sum_curr;
   DBL jj;
   DBL start;
   IF 0.1 < ABS(xx):
      retvalu = EXP(xx) - 1.0;
   ELSIF Kw.iszero(xx):
      retvalu = 0.0;
   ELSE:
      start = CEIL(ABS(LN(Kw.DBLEPS) / LN(ABS(xx))));
      IF start < 2:
         start = 2;
      IF_END
      sum_curr = 0.0;
      FOR jj FROM start TO 1 BY - 1:
         sum_curr = xx * (1.0 + sum_curr) / jj;
      FOR_END
      retvalu = sum_curr;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- cosm1 #
FUNC DBL cosm1(DBL xx):
   # cos(XX) - 1 accurately via
   #    == - x**2/2 + x**4/24 - x**6/720 ...
   #    == - x**2/2(1 - x**2/12(1 + x**2/30(1 - ...
   DBL retvalu;
   DBL sum_curr;
   DBL jj;
   DBL start;
   DBL xr_sqr;
   IF 0.1 < ABS(xx):
      retvalu = COS(xx) - 1.0;
   ELSIF Kw.iszero(xx):
      retvalu = 0.0;
   ELSE:
      start = CEIL(ABS(LN(Kw.DBLEPS) / LN(ABS(xx))));
      IF start < 6:
         start = 6;
      ELSIF Kw.isodd(start):
         start += 1;
      IF_END
      xr_sqr = -xx * xx;
      sum_curr = 1.0 / (start * (start + 1));
      FOR jj FROM start TO 2 BY - 2:
         sum_curr += 1;
         sum_curr *= xr_sqr / (jj * (jj - 1));
      FOR_END
      retvalu = sum_curr;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- lns #
FUNC DBL lns(DBL xx):
   # log of ABS(XX), bounded
   DBL aa;
   DBL retvalu;
   aa = ABS(xx);
   IF aa < 1.0 / DBLMAX:
      retvalu = -DBLMAXLN - 1.0;
   ELSE:
      retvalu = LN(aa);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ trip #
FUNC DBL trip(DBL xx):
   # piecewise linear function from -1 to 1, period 1
   # TRIP(0)=1  TRIP(0.5)=-1  TRIP(1)=1
   DBL retvalu;
   DBL fx;
   fx = 4.0 * frac(xx);
   IF fx < 2.0:
      retvalu = 1.0 - fx;
   ELSE:
      retvalu = fx - 3.0;
   IF_END
   RETURN retvalu;
FUNC_END
BLOCK:# cube root
   #   FFFFFFFFFFunction --------------------- lf_cbrtx_gt_zero #
   BLOCK_DEF FUNC DBL lf_cbrtx_gt_zero(DBL xx):
      # power of 2 closest to cuberoot of ABS(XX)
      # only call this with a positive 0 argument
      # if XX in[27/64,64/27) then
      #    ZZ in[1,8) and YY == 1
      DBL yy;
      DBL zz;
      zz = 64.0 * xx / 27.0;
      # (4/3)**3
      yy = 1.0;
      WHILE zz <= 1.0:
         zz *= 8.0;
         yy /= 2.0;
      WHILE_END
      WHILE 8.0 < zz:
         zz /= 8.0;
         yy *= 2.0;
      WHILE_END
      # Now 1.0 < zz <= 8.0
      RETURN yy;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------------- cbrt #
   FUNC DBL cbrt(DBL yy):
      # cube root of YY sans logarithms or exponentials
      # using Newton-Raphson method on  F(XX) = XX * XX * XX - YY
      DBL ayy;
      DBL init_xx;
      INT nrvx_ii;
      DBL nrvx_yy;
      DBL nrvx_xx;
      DBL nrvx_dy;
      DBL nrvx_xp;
      ayy = ABS(yy);
      IF 0.0 < ayy:
         # find a quick approximation of ABS(YY)**(1/3)
         init_xx = lf_cbrtx_gt_zero(ayy);
         IF yy < 0:
            init_xx = -init_xx;
         IF_END
         # refine approximation using NR method on
         #       nrvx_xx**3 - YY = 0
         # return XX where
         #    nrvx_xx * nrvx_xx - yy / nrvx_xx(XX) == 0
         # BEG Newton-Raphson Calculation
         nrvx_xx = init_xx;
         FOR nrvx_ii FROM 0 TO 20:
            nrvx_xp = nrvx_xx;
            nrvx_dy = 3 * nrvx_xx;
            IF Kw.iszero(nrvx_dy):
               FOR_EXIT;
            IF_END
            nrvx_yy = nrvx_xx * nrvx_xx - yy / nrvx_xx;
            nrvx_xx -= nrvx_yy / nrvx_dy;
            IF Kw.iseq(nrvx_xp, nrvx_xx):
               FOR_EXIT;
            IF_END
         FOR_END
         # END Newton-Raphson Calculation
      ELSE:
         nrvx_xx = 0.0;
      IF_END
      RETURN nrvx_xx;
   FUNC_END
BLOCK_END
      #   FFFFFFFFFFunction --------------------------------
   #cuberoot #
FUNC DBL cuberoot(DBL xx):
   # convienent name
   RETURN cbrt(xx);
FUNC_END
#   FFFFFFFFFFunction ------------------------------ squareroot #
FUNC DBL squareroot(DBL xx):
   # convienent name
   RETURN SQRT(xx);
FUNC_END
BLOCK:# continued fraction
   #   FFFFFFFFFFunction ---------------- lf_continued_fraction #
   BLOCK_DEF FUNC INT lf_continued_fraction(DBL orig
         , INT show_diff):
      INT whole;
      DBL xx;
      DBL epsilon;
      INT den_a;
      INT den_b;
      INT den_c;
      INT num_a;
      INT num_b;
      INT num_c;
      DBL diff;
      INT steps;
      DBL appr;
      steps = 0;
      xx = orig;
      den_b = 0;
      num_b = 1;
      den_a = 1;
      num_a = 0;
      epsilon = Kw.DBLEPS / 2.0;
      AWAIT ABS(diff) < epsilon:
         # DBLEPS * 2**n
         whole = FLOORL(xx);
         den_c = den_b * whole + den_a;
         num_c = num_b * whole + num_a;
         den_a = den_b;
         num_a = num_b;
         den_b = den_c;
         num_b = num_c;
         steps += 1;
         appr = (1.0 * num_b / den_b);
         diff = orig - appr;
         PRINTSTR("");
         PRINTVAL(whole);
         IF 0 <= show_diff:
            PRINTSTR(STRING_TAB);
            PRINTVAL(num_b);
            PRINTSTR(" / ");
            PRINTVAL(den_b);
            PRINTSTR(STRING_TAB);
            PRINTVAL(appr);
            IF 0 < show_diff:
               PRINTSTR(STRING_TAB);
               PRINTVAL(diff);
            IF_END
            PRINTSTR(STRING_NL);
         ELSE:
            PRINTSTR(" ");
         IF_END
         IF Kw.iseq(xx, whole):
            AWAIT_EXIT;
         IF_END
         xx = 1.0 / (xx - whole);
         epsilon *= 2.0;
      AWAIT_END
      RETURN steps;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------ print_contfra #
   FUNC INT print_contfra(DBL orig):
      # Print continued fraction coeffs of ORIG
      RETURN lf_continued_fraction(orig, - 1);
   FUNC_END
   #   FFFFFFFFFFunction ----------------------- print_contfrac #
   FUNC INT print_contfrac(DBL orig):
      # Print continued fraction of ORIG
      RETURN lf_continued_fraction(orig, 0);
   FUNC_END
   #   FFFFFFFFFFunction ---------------------- print_contfracd #
   FUNC INT print_contfracd(DBL orig):
      # Print continued fraction of ORIG w/ diffs
      RETURN lf_continued_fraction(orig, 1);
   FUNC_END
BLOCK_END# continued fraction
#   FFFFFFFFFFunction -------------------------- print_num2char #
FUNC INT print_num2char(INT num):
   # print NUM as a character 0-9a-zA-Z_?
   IF num < 32:
      IF num < 16:
         IF num < 8:
            IF num < 4:
               IF num < 2:
                  IF num < 1:
                     PRINTSTR("0");
                  ELSE:
                     PRINTSTR("1");
                  IF_END
               ELSIF num < 3:
                  PRINTSTR("2");
               ELSE:
                  PRINTSTR("3");
               IF_END
            ELSIF num < 6:
               IF num < 5:
                  PRINTSTR("4");
               ELSE:
                  PRINTSTR("5");
               IF_END
            ELSIF num < 7:
               PRINTSTR("6");
            ELSE:
               PRINTSTR("7");
            IF_END
         ELSIF num < 12:
            IF num < 10:
               IF num < 9:
                  PRINTSTR("8");
               ELSE:
                  PRINTSTR("9");
               IF_END
            ELSIF num < 11:
               PRINTSTR("a");
            ELSE:
               PRINTSTR("b");
            IF_END
         ELSIF num < 14:
            IF num < 13:
               PRINTSTR("c");
            ELSE:
               PRINTSTR("d");
            IF_END
         ELSIF num < 15:
            PRINTSTR("e");
         ELSE:
            PRINTSTR("f");
         IF_END
      ELSIF num < 24:
         IF num < 20:
            IF num < 18:
               IF num < 17:
                  PRINTSTR("g");
               ELSE:
                  PRINTSTR("h");
               IF_END
            ELSIF num < 19:
               PRINTSTR("i");
            ELSE:
               PRINTSTR("j");
            IF_END
         ELSIF num < 22:
            IF num < 21:
               PRINTSTR("k");
            ELSE:
               PRINTSTR("l");
            IF_END
         ELSIF num < 23:
            PRINTSTR("m");
         ELSE:
            PRINTSTR("n");
         IF_END
      ELSIF num < 28:
         IF num < 26:
            IF num < 25:
               PRINTSTR("o");
            ELSE:
               PRINTSTR("p");
            IF_END
         ELSIF num < 27:
            PRINTSTR("q");
         ELSE:
            PRINTSTR("r");
         IF_END
      ELSIF num < 30:
         IF num < 29:
            PRINTSTR("s");
         ELSE:
            PRINTSTR("t");
         IF_END
      ELSIF num < 31:
         PRINTSTR("u");
      ELSE:
         PRINTSTR("v");
      IF_END
   ELSIF num < 48:
      IF num < 40:
         IF num < 36:
            IF num < 34:
               IF num < 33:
                  PRINTSTR("w");
               ELSE:
                  PRINTSTR("x");
               IF_END
            ELSIF num < 35:
               PRINTSTR("y");
            ELSE:
               PRINTSTR("z");
            IF_END
         ELSIF num < 38:
            IF num < 37:
               PRINTSTR("A");
            ELSE:
               PRINTSTR("B");
            IF_END
         ELSIF num < 39:
            PRINTSTR("C");
         ELSE:
            PRINTSTR("D");
         IF_END
      ELSIF num < 44:
         IF num < 42:
            IF num < 41:
               PRINTSTR("E");
            ELSE:
               PRINTSTR("F");
            IF_END
         ELSIF num < 43:
            PRINTSTR("G");
         ELSE:
            PRINTSTR("H");
         IF_END
      ELSIF num < 46:
         IF num < 45:
            PRINTSTR("I");
         ELSE:
            PRINTSTR("J");
         IF_END
      ELSIF num < 47:
         PRINTSTR("K");
      ELSE:
         PRINTSTR("L");
      IF_END
   ELSIF num < 56:
      IF num < 52:
         IF num < 50:
            IF num < 49:
               PRINTSTR("M");
            ELSE:
               PRINTSTR("N");
            IF_END
         ELSIF num < 51:
            PRINTSTR("O");
         ELSE:
            PRINTSTR("P");
         IF_END
      ELSIF num < 54:
         IF num < 53:
            PRINTSTR("Q");
         ELSE:
            PRINTSTR("R");
         IF_END
      ELSIF num < 55:
         PRINTSTR("S");
      ELSE:
         PRINTSTR("T");
      IF_END
   ELSIF num < 60:
      IF num < 58:
         IF num < 57:
            PRINTSTR("U");
         ELSE:
            PRINTSTR("V");
         IF_END
      ELSIF num < 59:
         PRINTSTR("W");
      ELSE:
         PRINTSTR("X");
      IF_END
   ELSIF num < 62:
      IF num < 61:
         PRINTSTR("Y");
      ELSE:
         PRINTSTR("Z");
      IF_END
   ELSIF num < 63:
      PRINTSTR("_");
   ELSIF num < 64:
      PRINTSTR("?");
   ELSE:
      PRINTSTR("(");
      PRINTVAL(num);
      PRINTSTR(")");
   IF_END
   RETURN num;
FUNC_END
#   FFFFFFFFFFunction -------------------------- print_base_out #
FUNC INT print_base_out(INT num
      , INT baset):
   # print NUM out in base BASET
   # return number of characters printed
   INT digits_arr[65];
   INT dig_count;
   INT ii;
   MODE_INTEGER:
      IF num < 0:
         PRINTSTR("-");
         num = -num;
      IF_END
      dig_count = 0;
      AWAIT num == 0:
         digits_arr[dig_count] = num % baset;
         dig_count += 1;
         num = FLOORL(num / baset);
      AWAIT_END
      FOR ii FROM dig_count - 1 TO 0 BY - 1:
         CALL print_num2char(digits_arr[ii]);
      FOR_END
   MODE_INTEGER_END
   RETURN dig_count;
FUNC_END
#   FFFFFFFFFFunction ------------------------- print_base_outf #
FUNC INT print_base_outf(DBL num
      , INT baset):
   # print NUM out in base BASET
   # return number of characters printed
   INT dig_count;
   INT ii;
   DBL frc;
   INT dig;
   INT lim;
   dig_count = 0;
   IF num < 0.0:
      PRINTSTR("-");
      num = -num;
      dig_count += 1;
   IF_END
   dig_count += print_base_out(FLOORL(num), baset) + 1;
   PRINTSTR(".");
   lim = CEILL(-lg(DBLEPS) / lg(baset));
   frc = frac(num) * baset;
   ii = 1;
   WHILE ii <= lim AND NOT Kw.iszero(frc):
      dig = FLOORL(frc);
      CALL print_num2char(dig);
      frc -= dig;
      frc *= baset;
      ii += 1;
   WHILE_END
   RETURN dig_count + lim;
FUNC_END
#   IIIIIIIIIInsert-Begin -------------------------- hyper.fwip #
#    COPYRIGHT C 2016-2020 by Kevin D. Woerner
# 2020-08-05 kdw  hyper:minor refactor
# 2020-07-24 kdw  hyper:comment cleanup
# 2020-04-12 kdw  hyper:comment change
# 2020-03-03 kdw  hyper:comment changed:odd chars
# 2020-03-02 kdw  hyper:s/_N[E]XT/_E[N]D/
# 2020-01-07 kdw  hyper:comment change; f11()
# 2019-12-26 kdw  hyper:module name addded to funcs
# 2019-10-04 kdw  hyper:comment change
# 2019-08-24 kdw  hyper:for and count loops have from clause
# 2019-08-11 kdw  hyper:comment change
# 2019-08-06 kdw  hyper:rmed backslashes, macro arg renam
# 2019-05-29 kdw  hyper:comment changed
# 2019-05-22 kdw  hyper:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-03-08 kdw  hyper:is[e]qual to is[e]q, et al.
# 2019-03-06 kdw  hyper:is.* funcs changed
# 2019-01-13 kdw  hyper:comment changed; varname change
# 2019-01-03 kdw  hyper:Await counter changed
# 2018-12-29 kdw  hyper:comments
# 2018-04-03 kdw  hyper:rm() from return
# 2017-11-26 kdw  hyper:FR[O]M/B[Y] keywords; deprecate CO[U]NT
# 2017-04-21 kdw  hyper:func to function
# 2017-03-06 kdw  hyper:sigils rmed
# 2017-02-27 kdw  hyper:refactor(single return)
# 2017-02-14 kdw  hyper:FWIP Loop syntax changed
# 2017-02-12 kdw  hyper:FWIP language change
# 2016-11-21 kdw  hyper:DE?F to FU?NC
# 2016-11-20 kdw  hyper:language change
# 2016-11-11 kdw  hyper:refactor
# 2016-11-08 kdw  hyper:Await loop
# 2016-11-02 kdw  hyper:backslash added to long line; arg check
# 2016-11-01 kdw  hyper:created
#   FFFFFFFFFFunction ------------------------------------- f21 #
FUNC DBL f21(DBL aa
      , DBL bb
      , DBL cc
      , DBL zz):
   # Hypergeometric series 2F1(AA, BB; CC; ZZ)
   # LN(1+ZZ) == ZZ * F21(1, 1, 2, -ZZ)
   # ZZ**(-AA) == F21(AA, 1, 1, 1 - ZZ)
   # SININV(ZZ) == ZZ * F21(0.5, 0.5, 1.5, ZZ * ZZ)
   DBL sum_curr;
   DBL sum_prev;
   DBL term;
   DBL nn;
   IF 1 < ABS(zz):
      sum_curr = 0.0;
   ELSE:
      sum_curr = 1.0;
      term = 1.0;
      AWAIT Kw.iseq(sum_curr, sum_prev) COUNT nn FROM 0:
         term *= ((aa + nn) * (bb + nn) * zz / ((cc + nn) * (1
               + nn)));
         sum_prev = sum_curr;
         sum_curr += term;
      AWAIT_END
   IF_END
   RETURN sum_curr;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- f11 #
FUNC DBL f11(DBL aa
      , DBL bb
      , DBL zz):
   # Hypergeometric series 1F1(AA; BB; ZZ)
   DBL sum_curr;
   DBL sum_prev;
   DBL term;
   DBL nn;
   IF 1 < ABS(zz):
      sum_curr = 0.0;
   ELSE:
      sum_curr = 1.0;
      term = 1.0;
      AWAIT Kw.iseq(sum_curr, sum_prev) COUNT nn FROM 0:
         term *= ((aa + nn) * zz / ((bb + nn) * (1 + nn)));
         sum_prev = sum_curr;
         sum_curr += term;
      AWAIT_END
   IF_END
   RETURN sum_curr;
FUNC_END
#   IIIIIIIIIInsert-End ---------------------------- hyper.fwip #
#   IIIIIIIIIInsert-Begin ------------------------ lambert.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-19 kdw  lambert:comment change
# 2020-08-17 kdw  lambert:macro syntax changed
# 2020-07-27 kdw  lambert:block syntax
# 2020-07-24 kdw  lambert:comment cleanup
# 2020-05-14 kdw  lambert:local funcs only in blocks
# 2020-05-13 kdw  lambert:comment trivially changed
# 2020-05-11 kdw  lambert:local-func syntax changed
# 2020-05-01 kdw  lambert:comment changed
# 2020-04-26 kdw  lambert:block indentation
# 2020-04-14 kdw  lambert:tests added
# 2020-04-12 kdw  lambert:comment change
# 2020-04-08 kdw  lambert:preprocess sigil change
# 2020-03-09 kdw  lambert:LO[C]AL_.* keywords
# 2020-03-01 kdw  lambert:.*_NE[X]T deprecated, et al.
# 2020-02-28 kdw  lambert:poly eval work
# 2020-02-26 kdw  lambert:arr[a]y and hor[n]er work
# 2019-12-27 kdw  lambert:eplicit K[w] module
# 2019-12-26 kdw  lambert:module name addded to funcs
# 2019-11-17 kdw  lambert:include Macros file
# 2019-08-24 kdw  lambert:for and count loops have from clause
# 2019-08-17 kdw  lambert:L[O]G to L[N]
# 2019-08-11 kdw  lambert:comment cleanup
# 2019-08-06 kdw  lambert:array format issues
# 2019-05-29 kdw  lambert:comment changed
# 2019-05-24 kdw  lambert:local replaced private
# 2019-05-22 kdw  lambert:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-05-16 kdw  lambert:loop limit def mved
# 2019-05-01 kdw  lambert:consts explicit module name
# 2019-03-19 kdw  lambert:re[t]_val to re[t]valu
# 2019-03-18 kdw  lambert:macro syntax changed
# 2019-03-11 kdw  lambert:comments to array dcls
# 2019-03-08 kdw  lambert:is[e]qual to is[e]q, et al.
# 2019-03-04 kdw  lambert:loop-limit work
# 2019-01-03 kdw  lambert:Await counter changed
# 2018-07-19 kdw  lambert:comments; array reformat
# 2018-07-17 kdw  lambert:private lf_.* funcs
# 2018-07-13 kdw  lambert:float number reformt
# 2018-05-17 kdw  lambert:AR(R)AY.* and HOR[N]ER syntax
# 2018-05-16 kdw  lambert:A(R)RAY syntax
# 2018-04-03 kdw  lambert:rm() from return
# 2018-02-16 kdw  lambert:minor refactor
# 2018-01-08 kdw  lambert:w[mp] and inv
# 2017-11-26 kdw  lambert:FR[O]M and B[Y] keywords
# 2017-11-22 kdw  lambert:var renam
# 2017-08-30 kdw  lambert:s/DBL_/DBL/;s/FLT_/FLT/
# 2017-05-31 kdw  lambert:fvar rename; comments
# 2017-04-30 kdw  lambert:func to function
# 2017-03-19 kdw  lambert:comment changed
# 2017-03-10 kdw  lambert:get Fw[i]p_Pa[r]se to work
# 2017-03-06 kdw  lambert:sigils rmed
# 2017-03-01 kdw  lambert:var[y]log-a[d]d space messup
# 2017-02-28 kdw  lambert:REQ[U]IRE function()
# 2017-02-27 kdw  lambert:lf_l(a)mbert_iter
# 2017-02-20 kdw  lambert:vars renamd
# 2017-02-14 kdw  lambert:FWIP Loop syntax changed; LNG to INT
# 2017-02-12 kdw  lambert:FWIP language change
# 2016-11-23 kdw  lambert:int to lng
# 2016-11-21 kdw  lambert:D(E)F to F(U)NC
# 2016-11-20 kdw  lambert:language change
# 2016-11-16 kdw  lambert:comments
# 2016-11-15 kdw  lambert:MOD/BIT* syntax change
# 2016-11-14 kdw  lambert:Ha(l)ley algorithm correction
# 2016-11-11 kdw  lambert:sec(a)nt algorithm refactor
# 2016-11-08 kdw  lambert:A(W)AIT.*CO(U)NT syntax
# 2016-11-07 kdw  lambert:refactor lf_lambertwx
# 2016-11-07 kdw  lambert:__LA[N]G* syntax change
# 2016-10-31 kdw  lambert:E(X)ITL(O)OP
# 2016-09-15 kdw  lambert:lang change
# 2016-09-13 kdw  lambert:lang change
# 2016-05-18 kdw  lambert:comment change
# 2015-12-31 kdw  lambert:bounded possible infinite loops
# 2015-12-30 kdw  lambert:tweak
# 2015-12-14 kdw  lambert:long lines
# 2015-12-11 kdw  lambert:s/LC_// from some consts
# 2015-12-10 kdw  lambert:added[] to array args
# 2015-12-02 kdw  lambert:requires line
# 2015-11-23 kdw  lambert:refactor
# 2015-11-18 kdw  lambert:simplified approximation
# 2015-11-17 kdw  lambert:F[O]R format changed
# 2015-11-13 kdw  lambert:long lines addressed
# 2015-10-11 kdw  lambert:refactor / renamed functions
# 2015-10-09 kdw  lambert:renamed i[n]v functions
# 2015-09-30 kdw  lambert:rmed unused variables
# 2015-09-29 kdw  lambert:debugging c[b]rt
# 2015-09-27 kdw  lambert:debugging
# 2015-09-20 kdw  lambert:created
#   IIIIIIIIIInsert-Begin ------------------------- Macros.fwip #
#   IIIIIIIIIInsert-End --------------------------- Macros.fwip #
BLOCK:
      #   FFFFFFFFFFunction ----------------------
   #lf_lambert_iter #
   BLOCK_DEF FUNC DBL lf_lambert_iter(DBL xx, DBL nearw_zero):
      ## Lamberts W0(x) function defined by x=y*exp(y)
      INT ii;
      DBL eww;
      DBL tnn;
      DBL snn;
      DBL unn;
      DBL delta;
      DBL wjj;
      DBL wjj_prev;
      # Should have XX about NEARW_ZERO * EXP(NEARW_ZERO)
      wjj = nearw_zero;
      # refine result using Halleys method
      AWAIT Kw.iseq(wjj, wjj_prev) COUNT ii FROM 0 TO 20:
         eww = EXP(wjj);
         tnn = wjj * eww - xx;
         snn = (wjj + 2.0) / (2.0 * (wjj + 1));
         unn = (wjj + 1.0) * eww;
         delta = tnn / (tnn * snn - unn);
         wjj_prev = wjj;
         wjj += delta;
      AWAIT_END
      # Should have WJJ = W(XX), I.E. XX = WJJ * EXP(WJJ)
      RETURN wjj;
   FUNC_END
   #   FFFFFFFFFFunction ----------------------------------- wp #
   FUNC DBL wp(DBL xx):
      # lambert function: (-Inf,-1/E,+Inf) to(-1,-1,+Inf)
      # XX = W0 * EXP(W0)
      DBL tnn;
      DBL snn;
      DBL near_w;
      DBL retvalu;
      IF xx <= - EXP(-1.0):
         # -0.367879+
         retvalu = -1.0;
      ELSE:
         # Get an approximation of NEAR_W = Wp(XX)
         IF xx < 3.0:
            # (-EXP(-1),3)
            snn = Kw.E * xx + 1.0;
            near_w = Kw.cbrt(snn) - 1.0 + 0.025 * (snn / Kw.E);
         ELSE:
            #[3,Inf)
            snn = LN(xx);
            tnn = LN(LN(xx));
            near_w = snn - tnn + tnn / snn;
         IF_END
         # Now NEAR_W is an approximation of NEAR_W = WP(XX)
         # I.E. XX about NEAR_W * EXP(NEAR_W)
         retvalu = lf_lambert_iter(xx, near_w);
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ----------------------------------- wm #
   FUNC DBL wm(DBL xx):
      # lambert function:[-1/E,0) to[-1,-Inf)
      # XX = WM1 * EXP(WM1)
      INT ii;
      DBL near_w;
      DBL retvalu;
      DBL tnn;
      DBL numer;
      DBL denom;
      IF xx <= - EXP(-1.0):
         # (-Inf,-0.367879+)
         retvalu = -1.0;
      ELSE:
         # Get an approximation of NEAR_W = WM(XX)
         IF xx < - 0.303:
            # (-1/E,-0.303)
            tnn = -SQRT(2.0 * (1.0 + Kw.E * xx));
            near_w = ((((((((((226287557.0 / 37623398400.0)
                  * tnn - 1963.0 / 204120.0) * tnn + 680863.0
                  / 43545600.0) * tnn - 221.0 / 8505.0) * tnn
                  + 769.0 / 17280.0) * tnn - 43.0 / 540.0)
                  * tnn + 11.0 / 72.0) * tnn - 1.0 / 3.0) * tnn
                  + 1.0) * tnn - 1.0);
         ELSIF xx < - 0.0510129:
            #[-0.303,-0.0510129)
            numer = (((6.5794931769023040E+2) * xx
                  + 2.5388810188892484E+2) * xx
                  - 7.8141767239074400E+0);
            denom = ((((((1.4779341280760887E+3) * xx
                  + 9.6217849696986600E+2) * xx
                  + 6.8260739999094280E+2) * xx
                  + 9.9985670831076100E+1) * xx
                  - 6.0439587136908080E+1) * xx
                  + 1.0000000000000000E+0);
            near_w = numer / denom;
         ELSIF xx < 0.0:
            #[-0.0510129,0)
            near_w = LN(-xx);
            FOR ii FROM 0 TO 8:
               near_w = LN(xx / near_w);
            FOR_END
         ELSE:
            #[0,Inf)
            near_w = Kw.DBLMAX;
         IF_END
         # Now NEAR_W is an approximation of NEAR_W = WM(XX)
         # I.E. XX about NEAR_W * EXP(NEAR_W)
         retvalu = lf_lambert_iter(xx, near_w);
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END
      #   FFFFFFFFFFunction -----------------------------------
   #wpinv #
FUNC DBL wpinv(DBL zz):
   # inverse lambert function == x*exp(x):
   # (-Inf,-1/E,+Inf)  to(0,-1,+Inf)
   RETURN zz * EXP(zz);
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- wminv #
FUNC DBL wminv(DBL zz):
   # inverse lambert function == x*exp(x):
   # (-Inf,-1/E,+Inf)  to(0,-1,+Inf)
   RETURN zz * EXP(zz);
FUNC_END
#TEST:wpinv(wp(1.56))-1.56;
#TEST:wp(TAU)     -(TAU/exp(wp(TAU)));
#   IIIIIIIIIInsert-End -------------------------- lambert.fwip #
#   IIIIIIIIIInsert-Begin ----------------------- integral.fwip #
#    COPYRIGHT C 2020 by Kevin D. Woerner
# 2020-07-07 kdw  integral:tests changed II
# 2020-06-30 kdw  integral:tests changed
# 2020-06-16 kdw  integral:comments changed
# 2020-06-09 kdw  integral:car[l]son.* functions
# 2020-06-08 kdw  integral:created
# functions defined by integrals
#   FFFFFFFFFFunction ----------------------------- sinintegral #
FUNC DBL sinintegral(DBL xx):
   #        xx  SIN(t)
   # INTEGRATE  ------ dt
   #         0    t
   # via Taylor Series
   DBL sum_curr;
   DBL sum_prev;
   DBL term;
   DBL kk;
   DBL xsq;
   IF Kw.iszero(xx):
      sum_curr = 0.0;
   ELSE:
      sum_curr = xx;
      term = xx;
      xsq = xx * xx;
      AWAIT Kw.iseq(sum_curr, sum_prev) COUNT kk FROM 3 BY 2:
         term *= - xsq / (kk * (kk - 1.0));
         sum_prev = sum_curr;
         sum_curr += term / kk;
      AWAIT_END
   IF_END
   RETURN sum_curr;
FUNC_END
#   FFFFFFFFFFunction ----------------------------- cosintegral #
FUNC DBL cosintegral(DBL xx):
   #        xx  -COS(t)
   # INTEGRATE  ------- dt
   #         0     t
   # via Taylor Series
   DBL sum_curr;
   DBL sum_prev;
   DBL term;
   DBL kk;
   DBL xsq;
   IF Kw.iszero(xx):
      sum_curr = -Kw.DBLMAX;
   ELSE:
      sum_curr = Kw.EULER + LN(ABS(xx));
      term = 1.0;
      xsq = xx * xx;
      AWAIT Kw.iseq(sum_curr, sum_prev) COUNT kk FROM 2 BY 2:
         term *= - xsq / (kk * (kk - 1.0));
         sum_prev = sum_curr;
         sum_curr += term / kk;
      AWAIT_END
   IF_END
   RETURN sum_curr;
FUNC_END
#TEST:cosintegral(3.38418042255118642639785114640206045);
#   FFFFFFFFFFunction ------------------------------------- Ein #
FUNC DBL Ein(DBL xx):
   #        xx  1 - EXP(-t)
   # INTEGRATE  ----------- dt
   #         0      t
   # via Taylor Series
   DBL sum_curr;
   DBL sum_prev;
   DBL term;
   DBL kk;
   sum_curr = 0;
   term = -1;
   AWAIT Kw.iseq(sum_curr, sum_prev) COUNT kk FROM 1:
      term *= - xx / kk;
      sum_prev = sum_curr;
      sum_curr += term / kk;
   AWAIT_END
   RETURN sum_curr;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- expintegrali #
FUNC DBL expintegrali(DBL xx):
   # "Exponential" integral
   #       INF  -EXP(-t)
   # INTEGRATE  -------- dt
   #       -xx     t
   DBL retvalu;
   retvalu = Kw.EULER + LN(ABS(xx)) - Kw.Ein(-xx);
   RETURN retvalu;
FUNC_END
#TEST:expintegrali(0.37250741078136663446199186658012);
#   FFFFFFFFFFunction ---------------------------- expintegraln #
FUNC DBL expintegraln(INT nn
      , DBL xx):
   #       INF  EXP(-t * xx)
   # INTEGRATE  ------------ dt
   #         1      t**nn
   RETURN POW(xx, nn - 1) * Kw.uigamma(1 - nn, xx);
FUNC_END
#   FFFFFFFFFFunction ---------------------------- expintegral1 #
FUNC DBL expintegral1(DBL xx):
   #       INF  EXP(-t)
   # INTEGRATE  ------- dt
   #        xx      t
   DBL retvalu;
   retvalu = -Kw.EULER - LN(ABS(xx)) + Kw.Ein(xx);
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------- logintegral #
FUNC DBL logintegral(DBL xx):
   #        xx    1
   # INTEGRATE  ----- dt
   #         0  LN(t)
   # via Taylor Series
   DBL sum;
   DBL lnx;
   DBL yy;
   INT nn;
   DBL sum_prev;
   DBL limit;
   DBL retvalu;
   IF xx <= 1.0:
      retvalu = 0.0;
   ELSE:
      lnx = LN(xx);
      sum = 0.0;
      yy = 1.0;
      limit = 1.6 * LN(xx) + 40;
      AWAIT Kw.iseq(sum, sum_prev) COUNT nn FROM 1 TO limit:
         yy *= lnx / nn;
         sum_prev = sum;
         sum += yy / nn;
      AWAIT_END
      retvalu = Kw.EULER + LN(lnx) + sum;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- carlsonRF #
FUNC DBL carlsonRF(DBL xx
      , DBL yy
      , DBL zz):
   #       INF          0.5
   # INTEGRATE  ----------------------------- dt
   #        0     ---------------------------
   #             / (t + xx) (t + yy) (t + zz)
   #            V
   # via AGM method
   DBL sqx;
   DBL sqy;
   DBL sqz;
   DBL lmbd;
   AWAIT Kw.iseq(xx, yy) AND Kw.iseq(yy, zz):
      sqx = SQRT(xx);
      sqy = SQRT(yy);
      sqz = SQRT(zz);
      lmbd = sqx * sqy + sqx * sqz + sqy * sqz;
      xx = (xx + lmbd) / 4.0;
      yy = (yy + lmbd) / 4.0;
      zz = (zz + lmbd) / 4.0;
   AWAIT_END
   RETURN 1.0 / SQRT(xx);
FUNC_END
#TEST:carlsonRF(2,1,1)==coshinv(sqrt(2));
#TEST:carlsonRF(3,3,3)==1.0/sqrt(3);
#TEST:carlsonRF(2,4,4)==cosinv(sqrt(0.5))/sqrt(2);
#   FFFFFFFFFFunction ------------------------------- carlsonRC #
FUNC DBL carlsonRC(DBL xx
      , DBL yy):
   #       INF        0.5
   # INTEGRATE  ---------------------- dt
   #         0             -----------
   #            (t + YY)  / (t + XX)
   #                     V
   # via AGM method
   # carlsonRC(xx,yy) == carlsonRF(xx, yy, yy);
   DBL lmbd;
   AWAIT Kw.iseq(xx, yy):
      lmbd = 2 * SQRT(xx * yy) + yy;
      xx = (xx + lmbd) / 4.0;
      yy = (yy + lmbd) / 4.0;
   AWAIT_END
   RETURN 1.0 / SQRT(xx);
FUNC_END
#   FFFFFFFFFFunction ------------------------------- carlsonRJ #
FUNC DBL carlsonRJ(DBL xx
      , DBL yy
      , DBL zz
      , DBL pp):
   #       INF                  1.5
   # INTEGRATE  -------------------------------------- dt
   #         0             ---------------------------
   #            (t + pp)  / (t + xx) (t + yy) (t + zz)
   #                     V
   # via AGM method
   DBL sqx;
   DBL sqy;
   DBL sqz;
   DBL lmbd;
   DBL pfour;
   DBL alfa;
   DBL beta;
   DBL sigm;
   pfour = 1.0;
   sigm = 0.0;
   AWAIT Kw.iseq(xx, yy) AND Kw.iseq(yy, zz) AND Kw.iseq(zz, pp):
      sqx = SQRT(xx);
      sqy = SQRT(yy);
      sqz = SQRT(zz);
      lmbd = sqx * sqy + sqx * sqz + sqy * sqz;
      alfa = pp * (sqx + sqy + sqz) + sqx * sqy * sqz;
      alfa *= alfa;
      beta = pp * (pp + lmbd) * (pp + lmbd);
      sigm += pfour * Kw.carlsonRC(alfa, beta);
      pfour /= 4.0;
      xx = (xx + lmbd) / 4.0;
      yy = (yy + lmbd) / 4.0;
      zz = (zz + lmbd) / 4.0;
      pp = (pp + lmbd) / 4.0;
   AWAIT_END
   RETURN 3.0 * sigm;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- carlsonRD #
FUNC DBL carlsonRD(DBL xx
      , DBL yy
      , DBL zz):
   #       INF           1.5
   # INTEGRATE  -------------------------------------- dt
   #         0             ---------------------------
   #            (t + zz)  / (t + xx) (t + yy) (t + zz)
   #                     V
   # carlsonRD(xx,yy,zz) = carlsonRJ(xx,yy,zz,zz)
   # via AGM method
   DBL sqx;
   DBL sqy;
   DBL sqz;
   DBL lmbd;
   DBL pfour;
   DBL alfa;
   DBL beta;
   DBL sigm;
   pfour = 1.0;
   sigm = 0.0;
   AWAIT Kw.iseq(xx, yy) AND Kw.iseq(yy, zz):
      sqx = SQRT(xx);
      sqy = SQRT(yy);
      sqz = SQRT(zz);
      lmbd = sqx * sqy + sqx * sqz + sqy * sqz;
      alfa = zz * (sqx + sqy + sqz) + sqx * sqy * sqz;
      alfa *= alfa;
      beta = zz * (zz + lmbd) * (zz + lmbd);
      sigm += pfour * Kw.carlsonRC(alfa, beta);
      pfour /= 4.0;
      xx = (xx + lmbd) / 4.0;
      yy = (yy + lmbd) / 4.0;
      zz = (zz + lmbd) / 4.0;
   AWAIT_END
   RETURN 3.0 * sigm;
FUNC_END
#   IIIIIIIIIInsert-End ------------------------- integral.fwip #
#   IIIIIIIIIInsert-Begin ------------------------- number.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-20 kdw  number:boolean checks changed
# 2020-08-19 kdw  number:comment change
# 2020-08-17 kdw  number:macro syntax changed
# 2020-08-12 kdw  number:allow args <0 in znorder
# 2020-08-02 kdw  number:var renam g[d]
# 2020-07-29 kdw  number:block-def work
# 2020-07-27 kdw  number:block syntax
# 2020-07-25 kdw  number:s/BITWISE/BIT/
# 2020-07-24 kdw  number:s/LO[C]AL_/BL[O]CK_/
# 2020-07-10 kdw  number:prim[e]nth__1 func
# 2020-07-08 kdw  number:practical number check
# 2020-07-02 kdw  number:test modified
# 2020-07-01 kdw  number:tests modified
# 2020-06-30 kdw  number:tests changed
# 2020-06-29 kdw  number:BC:prim[e]nth problem
# 2020-06-22 kdw  number:local-use mved befroe var decls
# 2020-06-19 kdw  number:comments added
# 2020-06-18 kdw  number:rmed unused func
# 2020-06-17 kdw  number:modulo parens
# 2020-06-15 kdw  number:repete[n]dlen func
# 2020-06-08 kdw  number:integral function stuff
# 2020-06-06 kdw  number:comment change
# 2020-06-03 kdw  number:another test
# 2020-05-30 kdw  number:CONST syntax change
# 2020-05-18 kdw  number:while condition change
# 2020-05-16 kdw  number:comment change
# 2020-05-13 kdw  number:comment trivially changed
# 2020-05-11 kdw  number:REPL[A]CE replaced with LO[C]AL_CO[N]ST
# 2020-05-08 kdw  number:primitive root work
# 2020-05-07 kdw  number:func rearranged
# 2020-05-06 kdw  number:rmed boolean vars
# 2020-04-30 kdw  number:forever loop changed
# 2020-04-29 kdw  number:block work
# 2020-04-28 kdw  number:tweaks here and there
# 2020-04-26 kdw  number:bison work
# 2020-04-23 kdw  number:const format change
# 2020-04-17 kdw  number:gcd rework
# 2020-04-15 kdw  number:mertens rework
# 2020-04-14 kdw  number:tests added
# 2020-04-13 kdw  number:numeric inequality work
# 2020-04-12 kdw  number:comment change
# 2020-04-10 kdw  number:comment change
# 2020-04-09 kdw  number:MO[D]E syntax change
# 2020-04-08 kdw  number:preprocess sigil change
# 2020-04-04 kdw  number:n2pr[i]mish
# 2020-03-31 kdw  number:LA[B]S renam
# 2020-03-26 kdw  number:l[i]x tests
# 2020-03-25 kdw  number:tests
# 2020-03-09 kdw  number:LO[C]AL_.* keywords
# 2020-03-08 kdw  number:PR[I]NTVAL change
# 2020-03-06 kdw  number:L[A]NG.* names
# 2020-03-05 kdw  number:TRU[E]VAL into TR[U]E; FALS[E]VAL into
   #FA[L]SE
# 2020-03-03 kdw  number:commment change; lang diff simplified
# 2020-03-02 kdw  number:rmed unused pfn_.* funcs
# 2020-03-01 kdw  number:rmed useless semicolons
# 2020-02-24 kdw  number:function comments
# 2020-02-11 kdw  number:lambda to carmichael for python
# 2020-02-03 kdw  number:car[m]ichael_lam[b]da to lam[b]da
# 2020-01-31 kdw  number:var renam; lambda improvemants
# 2020-01-28 kdw  number:work on funcs w/ array args
# 2020-01-27 kdw  number:primecount.* reorg
# 2020-01-24 kdw  number:func.* Woerner
# 2020-01-21 kdw  number:prim[e]nth fixed
# 2020-01-20 kdw  number:isprime work
# 2020-01-18 kdw  number:.*prim[e]nth() work
# 2020-01-14 kdw  number:dlog.* funcs
# 2020-01-09 kdw  number:bk(bn) funcs
# 2020-01-08 kdw  number:cantorial work II
# 2020-01-07 kdw  number:cantorial work
# 2020-01-04 kdw  number:cantorx ternary funciton
# 2020-01-02 kdw  number:cantor ternary funciton
# 2019-12-31 kdw  number:minkowski ?()
# 2019-12-27 kdw  number:eplicit K[w] module
# 2019-12-26 kdw  number:module name addded to funcs
# 2019-12-06 kdw  number:rmed some useless comments
# 2019-12-03 kdw  number:fixed comment in factorize
# 2019-12-02 kdw  number:is[s]quar[e]fr[e]e
# 2019-11-17 kdw  number:include Macros file
# 2019-11-05 kdw  number:l prefxd to some abs
# 2019-10-29 kdw  number:[OE]GF comments
# 2019-10-28 kdw  number:GF comments
# 2019-10-04 kdw  number:comment change
# 2019-09-19 kdw  number:rmed li function(still have lix)
# 2019-09-17 kdw  number:rmed c[n]v_dbl]2i32
# 2019-09-12 kdw  number:mod.* funcs; rmed pfn
# 2019-09-10 kdw  number:LAN[G]UAGE NOT to LAN[G]UAGE_N[O]T
# 2019-09-06 kdw  number:comments in chebyshev polys
# 2019-08-29 kdw  number:typo in func e[t]a
# 2019-08-24 kdw  number:for and count loops have from clause
# 2019-08-18 kdw  number:B[O]OL to B[O]L
# 2019-08-17 kdw  number:L[O]G to LN
# 2019-08-11 kdw  number:language comments
# 2019-08-06 kdw  number:rmed backshlashes, macro arg renam
# 2019-07-08 kdw  number:trii[n]v
# 2019-07-03 kdw  number:var renam "s/ind/_ind/;s/__ind/_ind/"
# 2019-06-26 kdw  number:eta function rewrite
# 2019-06-02 kdw  number:func desc added
# 2019-05-31 kdw  number:NR_DO to RAPHSON_LOOP; et al
# 2019-05-29 kdw  number:comment changed
# 2019-05-24 kdw  number:array var renam
# 2019-05-21 kdw  number:a to the n mod p func nn made dbl
# 2019-05-16 kdw  number:loop limit def mved
# 2019-05-01 kdw  number:consts explicit module name
# 2019-03-19 kdw  number:re[t]_val to re[t]valu
# 2019-03-18 kdw  number:macro syntax changed
# 2019-03-08 kdw  number:is[e]qual to is[e]q, et al.
# 2019-03-06 kdw  number:loop limit changed
# 2019-03-01 kdw  number:writeable keyword
# 2019-01-12 kdw  number:lu[c]as.* funcs
# 2019-01-03 kdw  number:Await counter changed
# 2018-11-29 kdw  number:upper cased fwip defined funcs
# 2018-10-26 kdw  number:pfn; renam s/lpf/pfl/,s/gpf/pfg/
# 2018-10-08 kdw  number:vbdotnet stuff
# 2018-09-26 kdw  number:var renam
# 2018-09-16 kdw  number:func renam
# 2018-09-08 kdw  number:li[x]inv/SE[C]ANT work
# 2018-09-03 kdw  number:primeprev, primenext funcs
# 2018-07-28 kdw  number:l[c]antim func
# 2018-07-26 kdw  number:lc[a]ntim func
# 2018-07-17 kdw  number:private lf_.* funcs
# 2018-07-16 kdw  number:l[c]am funcfibo
# 2018-06-13 kdw  number:mved tests
# 2018-06-09 kdw  number:mved tests
# 2018-06-08 kdw  number:more test values
# 2018-06-04 kdw  number:test values
# 2018-05-31 kdw  number:factor var renam
# 2018-05-30 kdw  number:factor rework
# 2018-05-28 kdw  number:.*_() functions
# 2018-05-26 kdw  number:Mertens function
# 2018-05-22 kdw  number:trivial syntax error
# 2018-05-18 kdw  number:l[i] function loop limit
# 2018-05-14 kdw  number:BL[O]CK syntax change
# 2018-04-03 kdw  number:rm() from return
# 2018-04-01 kdw  number:LAN[G]UAGE_E[N]D
# 2018-03-26 kdw  number:macro redef
# 2018-02-19 kdw  number:secant and macro refactor
# 2018-02-16 kdw  number:e[t]a refactor
# 2017-11-26 kdw  number:FR[O]M and B[Y] keywords
# 2017-11-22 kdw  number:var renam
# 2017-11-21 kdw  number:FR[O]M
# 2017-10-23 kdw  number:lang is any fix
# 2017-10-21 kdw  number:macros start with "at""at"
# 2017-10-20 kdw  number:SEC[A]NT syntax change
# 2017-08-30 kdw  number:s/DBL_/DBL/;s/FLT_/FLT/
# 2017-08-27 kdw  number:comment change
# 2017-08-22 kdw  number:comment change
# 2017-08-20 kdw  number:rmed/renamd .*_P[E]R_.* vars
# 2017-06-21 kdw  number:LAN[G].* AND MA[S]TER.* change
# 2017-05-30 kdw  number:appro[x]pn
# 2017-05-15 kdw  number:polycnum, tetra[c]num
# 2017-05-13 kdw  number:polynum, tri
# 2017-04-21 kdw  number:func to function
# 2017-04-11 kdw  number:long lines
# 2017-04-10 kdw  number:partition memoized
# 2017-03-30 kdw  number:comment cleanup
# 2017-03-17 kdw  number:space after comma
# 2017-03-12 kdw  number:shorten long comments
# 2017-03-10 kdw  number:get Fw[i]p_Pa[r]se to work
# 2017-03-07 kdw  number:INS[E]RT etal
# 2017-03-06 kdw  number:sigils rmed
# 2017-03-01 kdw  number:var[y]log-a[d]d space messup
# 2017-02-28 kdw  number:REQ[U]IRE function()
# 2017-02-24 kdw  number:array var renam
# 2017-02-20 kdw  number:var renam
# 2017-02-19 kdw  number:Li redef
# 2017-02-14 kdw  number:FWIP Loop syntax changed
# 2017-02-13 kdw  number:FWIP language change
# 2017-02-12 kdw  number:FWIP language change
# 2017-02-08 kdw  number:SE[C]ANT stuff; syntax error in Li
# 2017-02-07 kdw  number:SE[C]ANT stuff
# 2017-02-06 kdw  number:SE[C]ANT / CO[U]NT syntax
# 2017-02-03 kdw  number:SE[C]ANT stuff
# 2017-01-06 kdw  number:..LAN[G]_[U]AGE_[I]F deprecated
# 2016-12-30 kdw  number:ipow to powi
# 2016-12-28 kdw  number:handle uppercase funcs in fw[i]pp
# 2016-12-20 kdw  number:indent "?" lines
# 2016-12-01 kdw  number:rmed L[I]2
# 2016-11-27 kdw  number:long lines
# 2016-11-23 kdw  number:C[N]ST to REA[D]ONLY
# 2016-11-22 kdw  number:fixed[l]i
# 2016-11-21 kdw  number:D[F]to FU[N]C
# 2016-11-20 kdw  number:laanguage change
# 2016-11-19 kdw  number:isp[r]ime
# 2016-11-15 kdw  number:M[O]D/B[I]T* syntax change
# 2016-11-14 kdw  number:comment cleanup
# 2016-11-11 kdw  number:sec[a]nt algorithm refactor
# 2016-11-09 kdw  number:more AW[A]IT loops
# 2016-10-31 kdw  number:AW[A]IT
# 2016-10-30 kdw  number:EX[I]TL[O]OP
# 2016-10-28 kdw  number:comment reorder
# 2016-10-14 kdw  number:_p
# 2016-10-03 kdw  number:isp[r]ime algorithm
# 2016-09-27 kdw  number:pcf new algorithm
# 2016-09-26 kdw  number:pcf debugged
# 2016-09-25 kdw  number:pcf
# 2016-09-22 kdw  number:eulerphi
# 2016-09-21 kdw  number:comment change
# 2016-09-15 kdw  number:comment change
# 2016-09-14 kdw  number:lang change
# 2016-09-08 kdw  number:eta tweak
# 2016-09-06 kdw  number:eta tweak
# 2016-09-02 kdw  number:tweak
# 2016-09-01 kdw  number:li, Lix
# 2016-04-27 kdw  number:_[_]BL[O]CK* change
# 2016-03-03 kdw  number:fixed problem in fa[c]tor; get_factor
# 2015-12-31 kdw  number:bounded possible infinite loops
# 2015-12-30 kdw  number:isdblequal renamed
# 2015-12-28 kdw  number:variable renamed; requires tweaked
# 2015-12-14 kdw  number:array sigils
# 2015-12-07 kdw  number:ism[u]ltl
# 2015-11-17 kdw  number:block comments
# 2015-11-12 kdw  number:change long line
# 2015-10-19 kdw  number:LA[B]S
# 2015-10-13 kdw  number:ato[t]henm[o]dx
# 2015-10-12 kdw  number:fi[b]ox
# 2015-10-11 kdw  number:fi[b]oinv; fixed fi[b]o3
# 2015-09-30 kdw  number:use ip[o]w function
# 2015-09-29 kdw  number:layout tweak
# 2015-09-25 kdw  number:B[I]T*, M[O]D format change
# 2015-09-24 kdw  number:bit ops changed
# 2015-09-22 kdw  number:_[_]* format changed
# 2015-09-21 kdw  number:BC:modulus problem
# 2015-09-20 kdw  number:created
#   IIIIIIIIIInsert-Begin ------------------------- Macros.fwip #
#   IIIIIIIIIInsert-End --------------------------- Macros.fwip #
#   FFFFFFFFFFunction ------------------------------------ powi #
FUNC INT powi(INT xx
      , INT nn):
   # XX**NN(assumes 0 < nn)
   INT pp;
   INT sqx;
   pp = 1;
   sqx = xx;
   WHILE 0 < nn:
      IF Kw.isodd(nn):
         pp *= sqx;
      IF_END
      sqx *= sqx;
      nn = BITSHIFTR(nn, 1);
   WHILE_END
   RETURN pp;
FUNC_END
#TEST:powi(3,5)-243;
#   FFFFFFFFFFunction ----------------------------- atothenmodp #
FUNC INT atothenmodp(INT aa
      , INT nn
      , INT pp):
   # AA to NN modulo PP
   INT retvalu;
   INT cc;
   MODE_INTEGER:
      IF pp == 0:
         retvalu = 0;
      ELSE:
         IF pp < 0:
            pp = -pp;
         IF_END
         IF nn < 0:
            nn = nn % pp;
            IF nn < 0:
               nn += pp;
            IF_END
         IF_END
         retvalu = 1;
         cc = aa % pp;
         WHILE 0 < nn:
            IF Kw.isodd(nn):
               retvalu = (retvalu * cc) % pp;
               nn = (nn - 1) / 2;
            ELSE:
               nn /= 2;
            IF_END
            cc = (cc * cc) % pp;
         WHILE_END
      IF_END
   MODE_INTEGER_END
   RETURN retvalu;
FUNC_END
#TEST:atothenmodp(2,10,100)-24;
#   FFFFFFFFFFunction ----------------------------- atothenmodx #
FUNC DBL atothenmodx(DBL aa
      , DBL nn
      , DBL pp):
   # AA**NN mod PP
   RETURN Kw.frac(EXP(nn * LN(aa) - LN(pp))) * pp;
FUNC_END
#TEST:atothenmodx(3.14,10,10)==4.37338664347031806976;
#TEST:atothenmodx(TAU,10,10)==0.6155090134770858907493574099313;
#   FFFFFFFFFFunction ------------------------------------- ctz #
FUNC INT ctz(INT nn):
   # Number of trailing 0s in binary expansion of NN
   #    or number of 2s in factorization of NN
   INT ii;
   ii = 0;
   WHILE 0 == BITAND(nn, 1):
      ii += 1;
      nn = BITSHIFTR(nn, 1);
   WHILE_END
   RETURN ii;
FUNC_END
#TEST:ctz(24)-3;
#   FFFFFFFFFFunction ------------------------------------- gcd #
FUNC INT gcd(INT aa
      , INT bb):
   # GCD of AA and BB
   INT cc;
   MODE_INTEGER:
      aa = ABSL(aa);
      bb = ABSL(bb);
      IF bb <= 0:
         bb = aa;
      ELSE:
         WHILE 0 < aa:
            cc = aa;
            aa = bb % aa;
            bb = cc;
         WHILE_END
      IF_END
   MODE_INTEGER_END
   RETURN bb;
FUNC_END
#TEST:gcd(70,168)-14;
#   FFFFFFFFFFunction ------------------------------------ gcda #
FUNC INT gcda(INT nn
      , READONLY INT num_arr_pc[]):
   # GCD of all numbers in AA_PC
   INT ind;
   INT gc;
   gc = num_arr_pc[0];
   FOR ind FROM 1 TO nn - 1:
      gc = gcd(gc, num_arr_pc[ind]);
   FOR_END
   RETURN gc;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- lcm #
FUNC INT lcm(INT aa
      , INT bb):
   # LCM of AA and BB
   RETURN aa * bb / gcd(aa, bb);
FUNC_END
#TEST:lcm(20,24)-120;
#   FFFFFFFFFFunction ------------------------------------ lcam #
FUNC INT lcam(INT aa
      , INT bb):
   # LC Almost M of AA and BB
   # I.E. smallest integer JJ greater then 1 such that
   #    JJ mod AA = -1, 0, or 1 AND
   #    JJ mod BB = -1, 0, or 1.
   INT ii;
   INT mm;
   IF bb < aa:
      ii = aa;
      aa = bb;
      bb = ii;
   IF_END
   AWAIT - 2 <= mm AND mm <= 2 COUNT ii FROM bb BY bb:
      mm = mods(ii, aa);
   AWAIT_END
   IF mm == - 2:
      ii += 1;
   ELSIF 0 <= mm:
      ii -= 1;
   IF_END
   RETURN ii;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- lcams #
FUNC INT lcams(INT aa
      , INT bb):
   # strict LC Almost M of AA and BB
   # I.E. smallest integer JJ such that
   #    MAX(AA,BB) < JJ
   #    JJ mod AA = -1, 0, or 1 AND
   #    JJ mod BB = -1, 0, or 1
   INT ii;
   INT mm;
   IF bb < aa:
      ii = aa;
      aa = bb;
      bb = ii;
   IF_END
   AWAIT - 2 <= mm AND mm <= 2 COUNT ii FROM 2 * bb BY bb:
      mm = mods(ii, aa);
   AWAIT_END
   IF mm == - 2:
      ii += 1;
   ELSIF 0 <= mm:
      ii -= 1;
   IF_END
   RETURN ii;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- lcantim #
FUNC INT lcantim(INT aa
      , INT bb):
   # LC Anti M of odd numbers AA and BB
   INT haa;
   INT hbb;
   INT ii;
   INT rema;
   INT odd_mask;
   IF Kw.isposint(aa) AND Kw.isposint(bb):
      odd_mask = 0;
      IF Kw.isodd(aa):
         odd_mask = 1;
      IF_END
      IF Kw.isodd(bb):
         odd_mask += 2;
      IF_END
      IF 2 == odd_mask OR (bb < aa AND odd_mask <> 1):
         ii = bb;
         bb = aa;
         aa = ii;
      IF_END
      haa = FLOORL(aa / 2);
      hbb = FLOORL(bb / 2);
      ii = hbb;
      AWAIT aa * bb <= ii:
         rema = Kw.dist(ii, aa);
         IF rema == haa:
            AWAIT_EXIT;
         ELSIF odd_mask == 3 AND rema == haa + 1:
            AWAIT_EXIT;
         IF_END
         ii += bb;
      AWAIT_END
      IF aa * bb <= ii:
         ii = 0;
      IF_END
   ELSE:
      ii = 0;
   IF_END
   RETURN ii;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- factor #
FUNC INT factor(INT nn
      , WRITEONLY INT ret_fctr_arr_p[]):
   # factorize NN into RET_FCTR_ARR_P[]
   # return NPF, number of prime factors
   # places 0 into RET_FCTR_ARR_P[NPF]
   INT pp;
   INT fctr_ind;
   INT inc;
   MODE_INTEGER:
      fctr_ind = 0;
      nn = ABSL(nn);
      IF nn <= 3:
         ret_fctr_arr_p[fctr_ind] = nn;
         fctr_ind = 1;
      ELSE:
         FOR pp FROM 2 TO 3:
            WHILE 0 == nn % pp:
               ret_fctr_arr_p[fctr_ind] = pp;
               fctr_ind += 1;
               nn /= pp;
            WHILE_END
         FOR_END
         pp = 1;
         inc = 4;
         AWAIT nn < pp * pp:
            pp += inc;
            inc = 6 - inc;
            WHILE 0 == nn % pp:
               ret_fctr_arr_p[fctr_ind] = pp;
               fctr_ind += 1;
               nn /= pp;
            WHILE_END
         AWAIT_END
         IF 1 < nn:
            ret_fctr_arr_p[fctr_ind] = nn;
            fctr_ind += 1;
         IF_END
      IF_END
   MODE_INTEGER_END
   ret_fctr_arr_p[fctr_ind] = 0;
   RETURN fctr_ind;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- modulo #
FUNC INT modulo(INT xxn
      , INT yymod):
   # return ZZ in[0,ABS(YYMOD)) such that ZZ = XXN mod YYMOD
   INT retvalu;
   MODE_INTEGER:
      retvalu = xxn % yymod;
      IF retvalu < 0:
         retvalu += ABSL(yymod);
      IF_END
   MODE_INTEGER_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ mods #
FUNC INT mods(INT xxn
      , INT yymod):
   # return ZZ in[-ABS(YYMOD)/2,ABS(YYMOD)/2]
   # such that ZZ = XXN mod YYMOD
   INT retvalu;
   INT ayy;
   INT axx;
   MODE_INTEGER:
      ayy = FLOORL(ABSL(yymod));
      axx = ABSL(xxn);
      retvalu = axx % ayy;
      IF 0 < retvalu:
         WHILE ayy < 2 * retvalu:
            retvalu -= ayy;
         WHILE_END
      ELSIF retvalu < 0:
         WHILE 2 * retvalu < - ayy:
            retvalu += ayy;
         WHILE_END
      IF_END
   MODE_INTEGER_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- pfl #
FUNC INT pfl(INT nn):
   # Least Prime Factor of NN
   INT small_factor;
   INT lim;
   INT divid;
   MODE_INTEGER:
      IF nn < 2:
         small_factor = 1;
      ELSIF nn % 2 == 0:
         small_factor = 2;
      ELSIF nn % 3 == 0:
         small_factor = 3;
      ELSIF nn % 5 == 0:
         small_factor = 5;
      ELSIF nn % 7 == 0:
         small_factor = 7;
      ELSE:
         # NN has no factors < 11
         lim = FLOORL(SQRT(nn));
         divid = 11;
         small_factor = nn;
         WHILE divid <= lim:
            IF nn % divid == 0:
               small_factor = divid;
               WHILE_EXIT;
            IF_END
            divid += 2;
            IF nn % divid == 0:
               small_factor = divid;
               WHILE_EXIT;
            IF_END
            divid += 4;
         WHILE_END
      IF_END
   MODE_INTEGER_END
   RETURN small_factor;
FUNC_END
#TEST:pfl(11*17*23)-11;
#   FFFFFFFFFFunction ------------------------------------- pfg #
FUNC INT pfg(INT nn):
   # Greatest prime factor
   INT mm;
   INT ff;
   mm = nn;
   AWAIT mm == 1:
      ff = pfl(mm);
      mm /= ff;
   AWAIT_END
   RETURN ff;
FUNC_END
#TEST:pfg(11*17*23)-23;
#   FFFFFFFFFFunction --------------------------------- isprime #
FUNC BOL isprime(INT nn):
   # True iff ABS(NN) is prime
   BOL retvalu_bol;
   INT ann;
   ann = ABSL(nn);
   IF ann == 2 OR ann == 3 OR ann == 5 OR ann == 7:
      retvalu_bol = TRUE;
      # NN is 2,3,5,7
   ELSIF ann < 11:
      retvalu_bol = FALSE;
      # NN is 1,4,6,8,9,10
   ELSIF pfl(ann) == ann:
      retvalu_bol = TRUE;
      # 11 <= NN and prime
   ELSE:
      retvalu_bol = FALSE;
      # 11 <= NN and not prime
   IF_END
   RETURN retvalu_bol;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- primeprev #
FUNC INT primeprev(INT pp):
   # largest prime less than PP
   INT retvalu;
   INT rema;
   INT inc;
   INT qq;
   MODE_INTEGER:
      IF pp <= 7:
         IF pp < 0:
            retvalu = -primenext(-pp);
         ELSIF 5 < pp:
            retvalu = 5;
         ELSIF 3 < pp:
            retvalu = 3;
         ELSIF 2 < pp:
            retvalu = 2;
         ELSE:
            retvalu = -2;
         IF_END
      ELSE:
         rema = pp % 6;
         qq = pp - rema;
         # qq <= pp
         IF rema <= 1:
            qq -= 1;
            # now qq == 5 mod 6
            inc = 4;
         ELSE:
            qq += 1;
            # now qq == 1 mod 6
            inc = 2;
         IF_END
         WHILE NOT Kw.isprime(qq):
            qq -= inc;
            inc = 6 - inc;
         WHILE_END
         retvalu = qq;
      IF_END
   MODE_INTEGER_END
   RETURN retvalu;
FUNC_END
#TEST:primeprev(37)-31;
#   FFFFFFFFFFunction ------------------------------- primenext #
FUNC INT primenext(INT pp):
   # smallest prime more than PP
   INT retvalu;
   INT rema;
   INT inc;
   INT qq;
   MODE_INTEGER:
      IF pp < 7:
         IF pp < 0:
            retvalu = -primeprev(-pp);
         ELSIF pp < 2:
            retvalu = 2;
         ELSIF pp < 3:
            retvalu = 3;
         ELSIF pp < 5:
            retvalu = 5;
         ELSE:
            retvalu = 7;
         IF_END
      ELSE:
         rema = (pp + 1) % 6;
         qq = (pp + 1) - rema;
         IF rema <= 1:
            qq += 1;
            # Now qq == 1 mod 6
            inc = 4;
         ELSE:
            qq += 5;
            # Now qq == 5 mod 6
            inc = 2;
         IF_END
         WHILE NOT Kw.isprime(qq):
            qq += inc;
            inc = 6 - inc;
         WHILE_END
         retvalu = qq;
      IF_END
   MODE_INTEGER_END
   RETURN retvalu;
FUNC_END
#TEST:primenext(24)-29;
BLOCK:# Prime count
   BLOCK_DEF INT lv_pcf_end = 0;
   BLOCK_DEF DBL lv_pcf_arr[0];
   #   FFFFFFFFFFunction --------------------------- primecount #
   FUNC INT primecount(DBL xx):
      # Prime Counting Function == number of primes <= XX
      # using memoization
      BLOCK_USE lv_pcf_arr[];
      BLOCK_USE lv_pcf_end;
      INT retvalu;
      INT poss_prime;
      INT s_ind;
      INT ps_ind;
      INT pcf_val;
      MODE_INTEGER:
         IF xx < 7:
            IF xx < 3:
               IF xx < 2:
                  retvalu = 0;
               ELSE:
                  retvalu = 1;
               IF_END
            ELSE:
               IF xx < 5:
                  retvalu = 2;
               ELSE:
                  retvalu = 3;
               IF_END
            IF_END
         ELSE:
            # 7 <= xx
            s_ind = FLOORL((xx - 5) / 2) - FLOORL((xx - 3) / 6);
            # 5 <= XX forces 0 <= S_IND
            IF lv_pcf_end <= s_ind:
               # LV_PCF_END should be even, but lets be safe
               ps_ind = lv_pcf_end;
               IF lv_pcf_end <= 0:
                  pcf_val = 2;
               ELSE:
                  pcf_val = lv_pcf_arr[lv_pcf_end - 1];
               IF_END
               lv_pcf_end = Kw.ceil2(s_ind + 1, 2);
               REDIM lv_pcf_arr[], lv_pcf_end;
               # LV_PCF_END should be even, hence so will PS_IND,
               # but lets be safe
               poss_prime = 3 * ps_ind - (ps_ind % 2) + 5;
               WHILE ps_ind <= s_ind:
                  IF Kw.isprime(poss_prime):
                     # 5 mod 6
                     pcf_val += 1;
                  IF_END
                  lv_pcf_arr[ps_ind] = pcf_val;
                  poss_prime += 2;
                  ps_ind += 1;
                  # PS_IND is now odd
                  IF Kw.isprime(poss_prime):
                     # 1 mod 6
                     pcf_val += 1;
                  IF_END
                  lv_pcf_arr[ps_ind] = pcf_val;
                  poss_prime += 4;
                  ps_ind += 1;
                  # PS_IND is now even
               WHILE_END
            IF_END
            retvalu = lv_pcf_arr[s_ind];
         IF_END
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END
BLOCK_END# Prime count
#TEST:primecount(10000)-1229;
#   FFFFFFFFFFunction ------------------------------------- pcf #
FUNC INT pcf(DBL xx):
   # another name for prime counting function
   RETURN primecount(xx);
FUNC_END
#TEST:pcf(1000)-168;
#   FFFFFFFFFFunction ----------------------------- primecountx #
FUNC INT primecountx(DBL xx):
   # Prime Counting Function == number of primes <= XX
   INT retvalu;
   INT poss_prime;
   INT inc;
   INT pcf_val;
   IF xx < 7:
      IF xx < 3:
         IF xx < 2:
            retvalu = 0;
         ELSE:
            retvalu = 1;
         IF_END
      ELSE:
         IF xx < 5:
            retvalu = 2;
         ELSE:
            retvalu = 3;
         IF_END
      IF_END
   ELSE:
      # 7 <= xx
      pcf_val = 4;
      poss_prime = 11;
      inc = 2;
      WHILE poss_prime <= xx:
         IF Kw.isprime(poss_prime):
            pcf_val += 1;
         IF_END
         poss_prime += inc;
         inc = 6 - inc;
      WHILE_END
      retvalu = pcf_val;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- eta #
FUNC DBL eta(DBL xx):
   # Dirichlets eta function(alternating zeta) for real args
   # 1/1**XX - 1/2**XX + 1/3**XX - 1/4**XX + 1/5**XX ...
   DBL sum;
   DBL sump;
   INT tt;
   INT nn;
   INT kk;
   INT s_ind;
   DBL retvalu;
   DBL pm_one;
   DBL ps_arr[];
   DBL temp_arr[];
   DBL term;
   IF 0 < xx:
      tt = 0;
      term = -LN(Kw.DBLEPS) / xx;
      IF term < LN(4000):
         kk = CEILL(EXP(term));
         sum = 0;
         pm_one = -1.0;
         AWAIT Kw.iseq(sump, sum) COUNT nn FROM 1 TO kk:
            pm_one = -pm_one;
            term = pm_one * POW(nn, - xx);
            tt += 1;
            sump = sum;
            sum += term;
         AWAIT_END
         retvalu = sum - 0.5 * term;
      ELSE:
         # use Eulers transformation of alternating series
         sum = 0;
         pm_one = -1.0;
         REDIM ps_arr[], 402;
         REDIM temp_arr[], 402;
         ps_arr[0] = -POW(2, - xx);
         tt += 1;
         temp_arr[0] = ps_arr[0];
         AWAIT Kw.iseq(sump, sum) COUNT nn FROM 1 TO 400:
            pm_one = -pm_one;
            ps_arr[nn] = ps_arr[nn - 1] + pm_one * POW(nn + 2,
                  - xx);
            tt += 1;
            temp_arr[nn] = ps_arr[nn];
            FOR kk FROM nn - 1 TO 0 BY - 1:
               temp_arr[kk] = (temp_arr[kk] + temp_arr[kk + 1])
                     / 2.0;
            FOR_END
            sump = sum;
            sum = temp_arr[0];
         AWAIT_END
         s_ind = FLOORL(nn / 3);
         sum = (4 * temp_arr[s_ind] + 3 * temp_arr[s_ind + 1])
               / 7;
         REDIM temp_arr[];
         REDIM ps_arr[];
         retvalu = sum + 1.0;
      IF_END
   ELSIF xx < 0:
      retvalu = 0.0;
   ELSE:
      retvalu = 0.5;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:eta(2)      ==PI*PI/12;
#TEST:eta(4)      ==pow(PI,4)*7/720;
#TEST:eta(6)      ==pow(PI,6)*31/30240;
#TEST:eta(8)      ==pow(PI,8)*127/1209600;
#TEST:eta(10)     ==pow(PI,10)*73/6842880;
#TEST:eta(12)     ==pow(PI,12)*1414477/1307674368000;
#TEST:eta(1)      ==ln(2);
#   FFFFFFFFFFunction ------------------------------------ zeta #
FUNC DBL zeta(DBL xx):
   # Reimanns zeta function for real args
   # 1/1**XX + 1/2**XX + 1/3**XX + 1/4**XX + 1/5**XX ...
   DBL retvalu;
   IF 1 < xx:
      retvalu = eta(xx) / (1.0 - POW(2.0, 1.0 - xx));
   ELSE:
      retvalu = 0.0;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:zeta(2)      ==PI*PI/6;
#TEST:zeta(3)      ==APERY;
#TEST:zeta(4)      ==PI*PI*PI*PI/90;
#   FFFFFFFFFFunction ----------------------------------- fibo3 #
FUNC DBL fibo3(INT nn
      , DBL fib_a
      , DBL fib_b):
   # NNth Fibonacci-like number
   # starting with FIB_A and FIB_B
   # OGF(fibo3(,a,b);x) = (x * (a - b) - a) / (x * x - x + 1)
   INT ii;
   DBL tt;
   DBL retvalu;
   IF nn == 0:
      retvalu = fib_a;
   ELSE:
      FOR ii FROM 2 TO nn:
         tt = fib_b;
         fib_b += fib_a;
         fib_a = tt;
      FOR_END
      retvalu = fib_b;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:fibo3(10,2,1)/123-1;
#   FFFFFFFFFFunction ------------------------------------ fibo #
FUNC DBL fibo(INT nn):
   # NNth Fibonacci number
   # OGF(fibo();x) = -x / (x * x + x - 1)
   RETURN fibo3(nn, 0, 1);
FUNC_END
#TEST:fibo(10)/55-1;
#   FFFFFFFFFFunction ----------------------------------- fibox #
FUNC DBL fibox(DBL xx):
   # NNth Fibonacci-like number, interpolated
   DBL zz;
   DBL retvalu;
   IF LN(Kw.DBLMAX) / LN(Kw.PHI) < ABS(xx):
      retvalu = 0.0;
   ELSE:
      zz = POW(Kw.PHI, xx);
      retvalu = (zz - COS(Kw.PI * xx) / zz) / SQRT(5.0);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- fiboxinv #
FUNC DBL fiboxinv(DBL yy):
   # inverse of Fibonacci numbers
   # following points are on curve(x, fibox(x))
   #    (0.791621807914573, 0.896946387424606)
   #    (1.094576105145116, 1.009824331847821) local MAX
   #    (1.676688372662104, 0.896946387424606) local MIN
   #    (2.014889804296742, 1.009824331847821)
   # SO, between 0.896946387424606 and 1.009824331847821
   #    fiboxinv is not uniquely defined.  This function
   #    tries to deliver smallest positive value; i.e
   #       fiboxinv(X) < 1.094576105145116
   #          for all X < 1.009824331847821
   DBL scvx_xp;
   DBL scvx_xx;
   DBL scvx_yp;
   DBL scvx_yy;
   DBL scvx_dx;
   DBL scvx_dy;
   INT scvx_ii;
   DBL x_init;
   IF yy <= 0:
      scvx_xx = 0.0;
   ELSE:
      IF yy <= 0.2:
         x_init = 0.075;
      ELSIF yy <= 0.896946387424606:
         x_init = 0.8 * yy - 0.15;
      ELSIF yy <= 1.009824331847821:
         x_init = 0.92;
      ELSE:
         x_init = LN(yy * SQRT(5.0)) / LN(Kw.PHI);
      IF_END
      # return XX where
      #   yy - fibox(scvx_xx)XX == 0
      # BEG Secant Calculation
      scvx_dx = 0.05;
      scvx_xx = x_init;
      scvx_yy = yy - fibox(scvx_xx);
      FOR scvx_ii FROM 0 TO 20:
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         IF Kw.iseq(scvx_xp, scvx_xx):
            FOR_EXIT;
         IF_END
         scvx_yy = yy - fibox(scvx_xx);
         scvx_dy = (scvx_yy - scvx_yp);
         IF Kw.iszero(scvx_dy):
            FOR_EXIT;
         IF_END
         scvx_dx *= - scvx_yy / scvx_dy;
      FOR_END
      # END Secant Calculation
   IF_END
   RETURN scvx_xx;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- lucas #
FUNC DBL lucas(INT nn):
   # NNth Lucas number
   # OGF(lucas();x) = (x - 2) / (x * x + x - 1)
   RETURN fibo3(nn, 2, 1);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- lucasx #
FUNC DBL lucasx(DBL xx):
   # NNth Lucas-like number, interpolated
   DBL zz;
   DBL retvalu;
   IF LN(Kw.DBLMAX) / LN(Kw.PHI) < ABS(xx):
      retvalu = 0.0;
   ELSE:
      zz = POW(Kw.PHI, xx);
      retvalu = (zz + COS(Kw.PI * xx) / zz);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ fusc #
FUNC INT fusc(INT nn):
   # Stern-Brocot sequence
   # defined recursively by
   #    fusc(1) = 1,
   #    fusc(2 * n) = fusc(n), and
   #    fusc(2 * n + 1) = fusc(n) + fusc(n + 1)
   INT aa;
   INT bb;
   aa = 1;
   bb = 0;
   WHILE 0 < nn:
      IF Kw.isodd(nn):
         bb += aa;
      ELSE:
         aa += bb;
      IF_END
      nn = BITSHIFTR(nn, 1);
   WHILE_END
   RETURN bb;
FUNC_END
#TEST:fusc(10000)/43-1;
#   FFFFFFFFFFunction -------------------------------------- Tn #
FUNC DBL Tn(INT nn
      , DBL xx):
   # evaluate NNth Chebyshev polynomial at XX
   #    Tn(0,XX) = 1
   #    Tn(1,XX) = XX
   #    Tn(NN,XX) = 2 * XX * Tn(NN - 1, XX) - Tn(NN - 2, XX)
   # Tn(NN, COS(YY)) = COS(NN * YY)
   DBL retvalu;
   DBL tnm_a;
   DBL tnm_b;
   DBL tnn;
   INT kk;
   IF nn == 0:
      retvalu = 1.0;
   ELSIF nn == 1:
      retvalu = xx;
   ELSIF nn == 2:
      retvalu = 2.0 * xx * xx - 1.0;
   ELSE:
      tnm_a = 2.0 * xx * xx - 1.0;
      tnm_b = xx;
      tnn = tnm_a;
      FOR kk FROM 3 TO nn:
         tnn = (2.0 * xx * tnm_a) - tnm_b;
         tnm_b = tnm_a;
         tnm_a = tnn;
      FOR_END
      retvalu = tnn;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:Tn(6,0.4)==0.782272;
#   FFFFFFFFFFunction -------------------------------------- Un #
FUNC DBL Un(INT nn
      , DBL xx):
   # evaluate NNth Chebyshev polynomial of type 2 at XX
   #    Un(0,XX) = 1
   #    Un(1,XX) = 2 * XX
   #    Un(NN,XX) = 2 * XX * Un(NN - 1, XX) - Un(NN - 2, XX)
   # Un(NN, COS(YY)) = SIN((NN + 1) * YY) / SIN(YY)
   DBL retvalu;
   DBL tnm_a;
   DBL tnm_b;
   DBL tnn;
   INT kk;
   IF nn == 0:
      retvalu = 1.0;
   ELSIF nn == 1:
      retvalu = 2.0 * xx;
   ELSE:
      tnm_a = 2.0 * xx;
      tnm_b = 1.0;
      tnn = tnm_a;
      FOR kk FROM 2 TO nn:
         tnn = (2.0 * xx * tnm_a) - tnm_b;
         tnm_b = tnm_a;
         tnm_a = tnn;
      FOR_END
      retvalu = tnn;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:Un(6,0.4)==1.054144;
#   FFFFFFFFFFunction ------------------------------------- tri #
FUNC DBL tri(DBL nn):
   # NNth triangular number
   # OGF(tri();x) = x / (1 - x)**3
   RETURN nn * (nn + 1) / 2;
FUNC_END
#TEST:tri(10)/55-1;
#   FFFFFFFFFFunction ---------------------------------- triinv #
FUNC DBL triinv(DBL nn):
   # NNth triangular number inverse
   DBL retvalu;
   IF - 0.125 < nn:
      retvalu = (SQRT(8.0 * nn + 1.0) - 1.0) / 2.0;
   ELSE:
      retvalu = -0.5;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:triinv(55)/10-1;
#   FFFFFFFFFFunction --------------------------------- polynum #
FUNC DBL polynum(DBL ss
      , DBL nn):
   # NNth polygonal number with SS sides;
   RETURN (ss - 2) * nn * (nn - 1) / 2 + nn;
FUNC_END
#TEST:polynum(7,5)/55-1;
#   FFFFFFFFFFunction -------------------------------- polycnum #
FUNC DBL polycnum(DBL ss
      , DBL nn):
   # NNth central polygonal number with SS sides
   RETURN ss * nn * (nn - 1) / 2 + 1;
FUNC_END
#TEST:polycnum(7,5)/71-1;
#   FFFFFFFFFFunction -------------------------------- tetranum #
FUNC DBL tetranum(DBL ss
      , DBL nn):
   # NNth tetrahedral number
   RETURN nn * (nn + 1) * ((ss - 2) * nn + 5 - ss) / 6;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- tetracnum #
FUNC DBL tetracnum(DBL ss
      , DBL nn):
   # NNth central tetrahedral number
   RETURN nn * (ss * nn * nn + 6 - ss) / 6;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- minkowski #
FUNC DBL minkowski(DBL xx):
   # Minkowski question-mark function ?XX
   # d?XX/dXX == 0 at rationals
   # If pp/qq and rr/ss are rational
   #       with ABS(pp*ss-rr*qq) == 1 Then
   #   ?((pp + rr) / (qq + ss)) = (?(pp/qq) + ?(rr/ss)) / 2
   # ?0 = 0 and ?1 = 1
   DBL pp;
   DBL qq;
   DBL rr;
   DBL ss;
   DBL mm;
   DBL nn;
   DBL dd;
   DBL yy;
   pp = FLOOR(xx);
   qq = 1;
   rr = pp + 1;
   ss = 1;
   dd = 1.0;
   yy = pp;
   AWAIT Kw.iseq(yy + dd, yy):
      dd /= 2.0;
      mm = pp + rr;
      nn = qq + ss;
      IF xx < mm / nn:
         rr = mm;
         ss = nn;
      ELSE:
         yy += dd;
         pp = mm;
         qq = nn;
      IF_END
   AWAIT_END
   RETURN yy;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- cantorxx #
FUNC DBL cantorxx(DBL bb
      , DBL ee
      , DBL xx):
   # Cantor ternary function / Devil Staircase
   DBL yy;
   DBL rest;
   DBL dd;
   DBL ulmt;
   IF ee < 0.0 OR bb < 0.0 OR 1.0 < ee + bb:
      yy = xx;
   ELSE:
      ulmt = 1.0 - ee;
      # in(0,1]
      # point(BB**N,0.5**N) and(BB**N*(1-EE),0.5**N)
      #    are on the devil staircase for N = 0,1,2,3,4...
      yy = FLOOR(xx);
      rest = (xx - yy);
      dd = 0.5;
      AWAIT Kw.iseq(yy + dd, yy) OR Kw.iszero(rest):
         IF ulmt <= rest:
            yy += dd;
            rest = Kw.frac((rest - ulmt) / ee);
         ELSIF bb <= rest:
            yy += dd;
            AWAIT_EXIT;
         ELSE:
            rest = Kw.frac(rest / bb);
         IF_END
         dd /= 2.0;
      AWAIT_END
   IF_END
   RETURN yy;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- cantor #
FUNC DBL cantor(DBL xx):
   # Cantor ternary function / Devil Staircase
   # cantor(XX) == cantorxx(1/3, 1/3, XX)
   RETURN cantorxx(1.0 / 3.0, 1.0 / 3.0, xx);
FUNC_END
#TEST:cantor(0.5)/0.5-1;
#   FFFFFFFFFFunction -------------------------------- cantorul #
FUNC DBL cantorul(DBL bb
      , DBL ee
      , DBL xx):
   # upper limit for Devil staircase
   # cantorxx(a,b,x)       <= cantorul(a,b,x) for x in[0,1]
   # 1 - cantorul(b,a,1-x) <= cantorxx(a,b,x) for x in[0,1]
   RETURN POW(0.5, LN(xx) / LN(bb) + 0.0 * ee);
FUNC_END
#   FFFFFFFFFFunction -------------------------------- cantorll #
FUNC DBL cantorll(DBL bb
      , DBL ee
      , DBL xx):
   # lower limit for Devil staircase
   # cantorll(a,b,x) <= cantorxx(a,b,x)       for x in[0,1]
   # cantorxx(a,b,x) <= 1 - cantorll(b,a,1-x) for x in[0,1]
   RETURN POW(0.5, LN(xx / (1.0 - ee)) / LN(bb) + 1.0);
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- dlogx #
FUNC INT dlogx(INT aa
      , INT bb
      , INT nn):
   # Brute-force discrete logarithm
   # return 0 < KK where AA**KK = BB mod NN
   # return -1 if none found
   INT ii;
   INT pp;
   INT retvalu;
   MODE_INTEGER:
      pp = aa;
      retvalu = -1;
      FOR ii FROM 1 TO nn:
         IF pp == bb:
            retvalu = ii;
            FOR_EXIT;
         IF_END
         pp = (pp * aa) % nn;
      FOR_END
   MODE_INTEGER_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ dlog #
FUNC INT dlog(INT aa
      , INT bb
      , INT nn):
   # find KK such that AA**KK=BB mod NN
   # THIS ASSUMES AA IS A GENERATOR OF THE
   # MULTIPLICATIVE GROUP OF INTEGER MODULO MM
   INT sqnn;
   INT cur;
   INT atothesqnn;
   INT atothens;
   INT ii;
   INT log_arr[];
   INT retvalu;
   MODE_INTEGER:
      IF aa == bb:
         retvalu = 1;
      ELSIF aa <= 0 OR bb <= 0 OR nn <= 0:
         retvalu = -1;
      ELSIF 1 < gcd(aa, nn) OR (NOT isprimitiveroot(aa, nn)):
         retvalu = dlogx(aa, bb, nn);
      ELSE:
         sqnn = CEILL(SQRT(nn));
         REDIM log_arr[], nn;
         FOR ii FROM 0 TO nn - 1:
            log_arr[ii] = 0;
         FOR_END
         atothesqnn = atothenmodp(aa, sqnn, nn);
         # Store all values of aa**(sqnn*ii) of LHS
         cur = atothesqnn;
         FOR ii FROM 1 TO sqnn:
            IF log_arr[cur] == 0:
               log_arr[cur] = ii;
            IF_END
            cur = (cur * atothesqnn) % nn;
         FOR_END
         cur = bb % nn;
         retvalu = -1;
         FOR ii FROM 0 TO sqnn:
            # Calculate(aa ** ii) * bb and check
            # for collision
            IF 0 < log_arr[cur]:
               atothens = log_arr[cur] * sqnn - ii;
               IF atothens < nn:
                  retvalu = atothens;
                  FOR_EXIT;
               IF_END
            IF_END
            cur = (cur * aa) % nn;
         FOR_END
         REDIM log_arr[];
      IF_END
   MODE_INTEGER_END
   RETURN retvalu;
FUNC_END
#TEST:dlog(6,2,11)-9;
#TEST:dlog(5,2,11)+1;
#   FFFFFFFFFFunction ----------------------------------- dlog1 #
FUNC INT dlog1(INT aa
      , INT nn):
   # return KK such that AA**KK = 1 mod NN
   RETURN dlog(aa, 1, nn);
FUNC_END
BLOCK:# Mertens function
   BLOCK_DEF INT lv_mertens_end = 0;
   BLOCK_DEF INT lv_mertens_arr[0];
   #   FFFFFFFFFFunction ------------------------------ mertens #
   FUNC INT mertens(INT nn):
      # sum of mobius function from 0 to NN
      # I.E. count of square-free integers up to NN
      #    that have an even number of prime factors,
      #    minus count of those that have an odd number
      BLOCK_USE lv_mertens_arr[];
      BLOCK_USE lv_mertens_end;
      INT retvalu;
      INT kk;
      IF nn < 0:
         retvalu = 0;
      ELSE:
         IF lv_mertens_end <= 0:
            lv_mertens_end = 4;
            REDIM lv_mertens_arr[], lv_mertens_end;
            lv_mertens_arr[0] = 0;
            lv_mertens_arr[1] = 1;
            lv_mertens_arr[2] = 0;
            lv_mertens_arr[3] = -1;
         IF_END
         IF lv_mertens_end <= nn:
            kk = lv_mertens_end;
            lv_mertens_end = nn + 1;
            REDIM lv_mertens_arr[], lv_mertens_end;
            WHILE kk < lv_mertens_end:
               lv_mertens_arr[kk] = lv_mertens_arr[kk - 1]
                     + mobius(kk);
               kk += 1;
            WHILE_END
         IF_END
         retvalu = lv_mertens_arr[nn];
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END#TEST:mertens(114)+6;
#   FFFFFFFFFFunction --------------------- has_primitiveroot_f #
FUNC BOL has_primitiveroot_f(INT nf
      , READONLY INT fac_arr_pc[]):
   # number  previously factored into FAC_ARR_P[0..(NF - 1)]
   #    has a primitive root iff
   #          it is a power of a odd prime
   #       or twice a power of a odd prime
   INT ind;
   ind = 0;
   IF 1 < nf:
      IF fac_arr_pc[0] == 2:
         ind += 1;
      IF_END
      IF 2 < fac_arr_pc[ind]:
         WHILE ind < nf - 1:
            IF fac_arr_pc[ind] < fac_arr_pc[ind + 1]:
               WHILE_EXIT;
            IF_END
            ind += 1;
         WHILE_END
      IF_END
   IF_END
   RETURN ind == (nf - 1);
FUNC_END
#TEST:has_primitiveroot(4)-iseven(4)
#TEST:has_primitiveroot(8)-isodd(8)
#   FFFFFFFFFFunction -------------------------------- sigma0_f #
FUNC INT sigma0_f(INT nf
      , READONLY INT fac_arr_pc[]):
   # count of divisors of number previously factored into
   #   FAC_ARR_P[0..(NF - 1)]
   INT ind;
   INT retvalu;
   INT exp_i;
   retvalu = 1;
   exp_i = 2;
   FOR ind FROM 0 TO nf - 2:
      IF fac_arr_pc[ind] == fac_arr_pc[ind + 1]:
         exp_i += 1;
      ELSE:
         retvalu *= exp_i;
         exp_i = 2;
      IF_END
   FOR_END
   RETURN retvalu * exp_i;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- sigma1_f #
FUNC INT sigma1_f(INT nf
      , READONLY INT fac_arr_pc[]):
   # sum of divisors of number previously factored into
   #   FAC_ARR_P[0..(NF - 1)]
   INT ind;
   INT retvalu;
   INT exp_i;
   INT prm_prev;
   INT prm_curr;
   retvalu = 1;
   exp_i = 2;
   prm_prev = fac_arr_pc[0];
   FOR ind FROM 1 TO nf - 1:
      prm_curr = fac_arr_pc[ind];
      IF prm_prev == prm_curr:
         exp_i += 1;
      ELSE:
         retvalu *= (powi(prm_prev, exp_i) - 1) / (prm_prev - 1);
         exp_i = 2;
         prm_prev = prm_curr;
      IF_END
   FOR_END
   RETURN retvalu * (powi(prm_prev, exp_i) - 1) / (prm_prev - 1);
FUNC_END
#   FFFFFFFFFFunction --------------------------------- sigma_f #
FUNC INT sigma_f(INT powy
      , INT nf
      , READONLY INT fac_arr_pc[]):
   # sum of POWYth power of divisors of NN
   #    previously factored into FAC_ARR_P[0..(NF - 1)]
   INT ind;
   INT retvalu;
   INT exp_i;
   INT prm_curr;
   INT prm_prev;
   INT pw;
   IF powy == 0:
      retvalu = sigma0_f(nf, fac_arr_pc[]);
   ELSIF powy == 1:
      retvalu = sigma1_f(nf, fac_arr_pc[]);
   ELSE:
      retvalu = 1;
      exp_i = 2;
      prm_prev = fac_arr_pc[0];
      FOR ind FROM 1 TO nf - 1:
         prm_curr = fac_arr_pc[ind];
         IF prm_prev == prm_curr:
            exp_i += 1;
         ELSE:
            pw = powi(prm_prev, powy);
            retvalu *= ((powi(pw, exp_i) - 1) / (pw - 1));
            exp_i = 2;
            prm_prev = prm_curr;
         IF_END
      FOR_END
      pw = powi(prm_prev, powy);
      retvalu *= ((powi(pw, exp_i) - 1) / (pw - 1));
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------- ispractical_f #
FUNC BOL ispractical_f(INT nf
      , READONLY INT fac_arr_pc[]):
   # test if number previously factored into
   #      FAC_ARR_P[0..(NF - 1)] is practical
   # I.E. all positive integers <= NN can be represented
   #      as sums of distinct factors of NN
   INT ind;
   INT sgma;
   INT exp_i;
   INT prm_curr;
   INT prm_prev;
   BOL retvalu_bol;
   IF 2 < fac_arr_pc[0]:
      retvalu_bol = FALSE;
   ELSE:
      retvalu_bol = TRUE;
      sgma = 1;
      exp_i = 2;
      prm_prev = fac_arr_pc[0];
      FOR ind FROM 1 TO nf - 1:
         prm_curr = fac_arr_pc[ind];
         IF prm_prev == prm_curr:
            exp_i += 1;
         ELSE:
            sgma *= (powi(prm_prev, exp_i) - 1) / (prm_prev - 1);
            IF 1 + sgma < prm_curr:
               retvalu_bol = FALSE;
               FOR_EXIT;
            IF_END
            exp_i = 2;
            prm_prev = prm_curr;
         IF_END
      FOR_END
   IF_END
   RETURN retvalu_bol;
FUNC_END
#   FFFFFFFFFFunction -------------------------- issquarefree_f #
FUNC BOL issquarefree_f(INT nf
      , READONLY INT fac_arr_pc[]):
   # test if NN is squarefree that was
   #    previously factored into FAC_ARR_P[0..(NF - 1)]
   INT ind;
   BOL retvalu_bol;
   retvalu_bol = TRUE;
   FOR ind FROM 1 TO nf - 1:
      IF fac_arr_pc[ind - 1] == fac_arr_pc[ind]:
         retvalu_bol = FALSE;
         FOR_EXIT;
      IF_END
   FOR_END
   RETURN retvalu_bol;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- totient_f #
FUNC INT totient_f(INT nf
      , READONLY INT fac_arr_pc[]):
   # count of numbers < NN and relatively prime to NN
   #    where NN is number previously factored
   #    into FAC_ARR_P[0..(NF - 1)]
   INT ind;
   INT retvalu;
   MODE_INTEGER:
      retvalu = 1;
      FOR ind FROM 0 TO nf - 2:
         IF fac_arr_pc[ind] == fac_arr_pc[ind + 1]:
            retvalu *= fac_arr_pc[ind];
         ELSE:
            retvalu *= (fac_arr_pc[ind] - 1);
         IF_END
      FOR_END
      retvalu *= (fac_arr_pc[nf - 1] - 1);
   MODE_INTEGER_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- mobius_f #
FUNC INT mobius_f(INT nf
      , READONLY INT fac_arr_pc[]):
   # MOBIUS function of NN
   #    previously factored into FAC_ARR_P[0..(NF - 1)]
   # if NN has a squared prime factor, 0;
   # else if NN has an even number of factors, 1
   # else -1
   INT retvalu;
   INT ind;
   IF Kw.iseven(nf):
      retvalu = 1;
   ELSE:
      retvalu = -1;
   IF_END
   FOR ind FROM 1 TO nf - 1:
      IF fac_arr_pc[ind - 1] == fac_arr_pc[ind]:
         retvalu = 0;
         FOR_EXIT;
      IF_END
   FOR_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- prime0_f #
FUNC INT prime0_f(INT nf
      , READONLY INT fac_arr_pc[]):
   # count of distinct prime factors of NN
   #    previously factored into FAC_ARR_P[0..(NF - 1)]
   INT ind;
   INT prm_curr;
   INT prm_prev;
   INT retvalu;
   retvalu = 1;
   prm_prev = fac_arr_pc[0];
   FOR ind FROM 1 TO nf - 1:
      prm_curr = fac_arr_pc[ind];
      IF prm_prev < prm_curr:
         retvalu += 1;
      IF_END
      prm_prev = prm_curr;
   FOR_END
   RETURN retvalu;
FUNC_END
BLOCK:# Prime factors
   BLOCK_DEF CONST LC_MAX_FACTORS 65;
   # 1
   #   FFFFFFFFFFunction ------------------------- print_factor #
   FUNC INT print_factor(INT nn):
      # Print out all prime factors of number NN
      INT ind;
      INT fac_arr[LC_MAX_FACTORS];
      INT nf;
      nf = factor(nn, fac_arr[]);
      PRINTVAL(nn);
      PRINTSTR(":");
      FOR ind FROM 0 TO nf - 1:
         PRINTSTR(" ");
         PRINTVAL(fac_arr[ind]);
      FOR_END
      PRINTSTR(STRING_NL);
      RETURN nf;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------- mobius #
   FUNC INT mobius(INT nn):
      # MOBIUS function
      #    if NN has a squared prime factor, 0;
      #    else if NN has an even number of factors, 1
      #    else -1
      INT nf;
      INT fac_arr[LC_MAX_FACTORS];
      nf = factor(nn, fac_arr[]);
      RETURN mobius_f(nf, fac_arr[]);
   FUNC_END
   #TEST:mobius(19)+1;
   #TEST:mobius(20)-0;
   #TEST:mobius(21)-1;
   #   FFFFFFFFFFunction ---------------------- isprimitiveroot #
   FUNC BOL isprimitiveroot(INT aa
         , INT nn):
      # test if AA is a primitive root of NN
      INT toti;
      INT nf_toti;
      INT ind;
      INT prm;
      BOL retvalu_bol;
      INT fac_arr[LC_MAX_FACTORS];
      IF aa <= 1 OR 1 < gcd(aa, nn):
         retvalu_bol = FALSE;
      ELSIF aa == 2:
         retvalu_bol = Kw.isodd(nn);
      ELSE:
         toti = totient(nn);
         nf_toti = factor(toti, fac_arr[]);
         IF atothenmodp(aa, toti / fac_arr[0], nn) == 1:
            retvalu_bol = FALSE;
         ELSE:
            retvalu_bol = TRUE;
            FOR ind FROM 1 TO nf_toti - 1:
               IF fac_arr[ind - 1] <> fac_arr[ind]:
                  prm = fac_arr[ind];
                  IF atothenmodp(aa, toti / prm, nn) == 1:
                     retvalu_bol = FALSE;
                     FOR_EXIT;
                  IF_END
               IF_END
            FOR_END
         IF_END
      IF_END
      RETURN retvalu_bol;
   FUNC_END
   #TEST:isprimitiveroot(5,11)-isodd(4);
   #TEST:isprimitiveroot(6,11)-iseven(4);
   #   FFFFFFFFFFunction ------------------------------- prime0 #
   FUNC INT prime0(INT nn):
      # count of distinct prime factors of NN
      INT nf;
      INT fac_arr[LC_MAX_FACTORS];
      nf = factor(nn, fac_arr[]);
      RETURN prime0_f(nf, fac_arr[]);
   FUNC_END
   #TEST:prime0(240)-3;
   #TEST:prime0(241)-1;
   #TEST:prime0(243)-1;
   #   FFFFFFFFFFunction ------------------------------- prime1 #
   FUNC INT prime1(INT nn):
      # count prime factors of NN, including multiplicities
      INT fac_arr[LC_MAX_FACTORS];
      RETURN factor(nn, fac_arr[]);
   FUNC_END
   #TEST:prime1(240)-6;
   #TEST:prime1(241)-1;
   #TEST:prime1(243)-5;
   #   FFFFFFFFFFunction ------------------------------- sigma0 #
   FUNC INT sigma0(INT nn):
      # count of divisors of NN
      INT nf;
      INT fac_arr[LC_MAX_FACTORS];
      nf = factor(nn, fac_arr[]);
      RETURN sigma0_f(nf, fac_arr[]);
   FUNC_END
   #TEST:sigma0(12)-6;
   #   FFFFFFFFFFunction ------------------------------- sigma1 #
   FUNC INT sigma1(INT nn):
      # sum of divisors of NN
      INT nf;
      INT fac_arr[LC_MAX_FACTORS];
      nf = factor(nn, fac_arr[]);
      RETURN sigma1_f(nf, fac_arr[]);
   FUNC_END
   #TEST:sigma1(28)-56;
   #TEST:sigma1(29)-30;
   #TEST:sigma1(30)-72;
   #   FFFFFFFFFFunction -------------------------------- sigma #
   FUNC INT sigma(INT powy
         , INT nn):
      # sum of POWYth power of divisors of NN
      INT nf;
      INT fac_arr[LC_MAX_FACTORS];
      INT retvalu;
      IF nn <= 1:
         retvalu = nn;
      ELSIF powy == 0:
         retvalu = sigma0(nn);
      ELSIF powy == 1:
         retvalu = sigma1(nn);
      ELSE:
         nf = factor(nn, fac_arr[]);
         retvalu = sigma_f(powy, nf, fac_arr[]);
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------ totient #
   FUNC INT totient(INT nn):
      # count of numbers < NN and relatively prime to NN
      INT fac_arr[LC_MAX_FACTORS];
      INT nf;
      nf = factor(nn, fac_arr[]);
      RETURN totient_f(nf, fac_arr[]);
   FUNC_END
   #TEST:totient(141)-92;
   #TEST:totient(142)-70;
   #TEST:totient(143)-120;
   #   FFFFFFFFFFunction -------------------- has_primitiveroot #
   FUNC BOL has_primitiveroot(INT nn):
      # number has a primitive root iff
      #    it is a power of a odd prime
      #    or twice a power of a odd prime
      INT nf;
      INT fac_arr[LC_MAX_FACTORS];
      BOL retvalu_bol;
      IF nn < 2:
         retvalu_bol = FALSE;
      ELSE:
         nf = factor(nn, fac_arr[]);
         retvalu_bol = has_primitiveroot_f(nf, fac_arr[]);
      IF_END
      RETURN retvalu_bol;
   FUNC_END
   #TEST:has_primitiveroot(191)-isprime(191);
   #TEST:has_primitiveroot(250)-iseven(250);
   #TEST:has_primitiveroot(8);
   #   FFFFFFFFFFunction ------------------------- issquarefree #
   FUNC BOL issquarefree(INT nn):
      # test if NN is squarefree
      INT nf;
      INT fac_arr[LC_MAX_FACTORS];
      BOL retvalu_bol;
      IF nn < 1:
         retvalu_bol = FALSE;
      ELSIF nn < 3:
         retvalu_bol = TRUE;
      ELSE:
         nf = factor(nn, fac_arr[]);
         retvalu_bol = issquarefree_f(nf, fac_arr[]);
      IF_END
      RETURN retvalu_bol;
   FUNC_END
   #   FFFFFFFFFFunction -------------------------- ispractical #
   FUNC BOL ispractical(INT nn):
      # test if NN is practical
      # I.E. all positive integers <= NN can be represented
      #      as sums of distinct factors of NN
      INT nf;
      INT fac_arr[LC_MAX_FACTORS];
      BOL retvalu_bol;
      IF nn < 1:
         retvalu_bol = FALSE;
      ELSIF nn < 3:
         retvalu_bol = TRUE;
      ELSE:
         nf = factor(nn, fac_arr[]);
         retvalu_bol = ispractical_f(nf, fac_arr[]);
      IF_END
      RETURN retvalu_bol;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------ primitiveroot #
   FUNC INT primitiveroot(INT nn):
      # smallest primitive root of multiplicative group
      #    modulo NN, if it exists. 0 otherwise.
      INT ind;
      INT nf_toti;
      INT toti;
      INT mm;
      INT fac_arr[LC_MAX_FACTORS];
      INT prm;
      INT retvalu;
      MODE_INTEGER:
         IF nn < 2:
            retvalu = 0;
         ELSIF nn < 5:
            retvalu = nn - 1;
         ELSIF NOT has_primitiveroot(nn):
            retvalu = 0;
         ELSE:
            toti = totient(nn);
            nf_toti = factor(toti, fac_arr[]);
            mm = 2;
            retvalu = 0;
            WHILE mm < nn AND retvalu <= 0:
               IF gcd(mm, nn) == 1:
                  retvalu = mm;
                  prm = 0;
                  FOR ind FROM 0 TO nf_toti - 1:
                     IF prm <> fac_arr[ind]:
                        prm = fac_arr[ind];
                        IF atothenmodp(mm, toti / prm, nn) == 1:
                           retvalu = 0;
                           FOR_EXIT;
                        IF_END
                     IF_END
                  FOR_END
               IF_END
               mm += 1;
            WHILE_END
         IF_END
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END
   #TEST:primitiveroot(191)-19;
   #TEST:primitiveroot(8);
   #   FFFFFFFFFFunction --------------------------- carmichael #
   FUNC INT carmichael(INT nn):
      # Carmichael lambda function
      # smallest MM such that AA**MM = 1 mod NN
      #      for all AA coprime to NN
      INT ind;
      INT nf;
      INT lmbd;
      INT prm;
      INT pk;
      INT fac_arr[LC_MAX_FACTORS];
      MODE_INTEGER:
         IF nn < 8:
            lmbd = totient(nn);
         ELSE:
            nf = factor(nn, fac_arr[]);
            ind = 0;
            WHILE ind < nf AND fac_arr[ind] == 2:
               ind += 1;
            WHILE_END
            IF 2 < ind:
               lmbd = BITSHIFTL(1, ind - 2);
            ELSE:
               lmbd = 1;
            IF_END
            WHILE ind < nf:
               prm = fac_arr[ind];
               pk = prm - 1;
               WHILE ind < nf - 1 AND prm == fac_arr[ind + 1]:
                  ind += 1;
                  pk *= prm;
               WHILE_END
               lmbd = lcm(lmbd, pk);
               ind += 1;
            WHILE_END
         IF_END
      MODE_INTEGER_END
      RETURN lmbd;
   FUNC_END
   #TEST:carmichael(35)-12;
   #TEST:carmichael(24)-2;
   #   FFFFFFFFFFunction ------------------------------ znorder #
   FUNC INT znorder(INT aa
         , INT nn):
      # smallest positive integer PP such that
      #   AA ** PP == 1 mod NN
      # 0 if none exist
      INT ind;
      INT fac_arr[LC_MAX_FACTORS];
      INT nfkk;
      INT kk;
      INT ab;
      INT ek;
      INT prm_i;
      INT exp_i;
      MODE_INTEGER:
         IF nn == 0 OR aa == 0:
            kk = 0;
         ELSE:
            IF nn < 0:
               nn = -nn;
            IF_END
            WHILE aa < 0:
               aa += nn;
            WHILE_END
            IF nn <= 1:
               # znorder(aa,0) = 0, znorder(aa,1) = 1
               kk = nn;
            ELSIF aa <= 1:
               # znorder(0,nn) = 0, znorder(1,nn) = 1(nn > 1)
               kk = aa;
            ELSIF 1 < gcd(aa, nn):
               kk = 0;
            ELSE:
               # Cohen 1.4.3 using Carmichael Lambda function
               kk = carmichael(nn);
               nfkk = factor(kk, fac_arr[]);
               exp_i = 1;
               FOR ind FROM 0 TO nfkk - 1:
                  prm_i = fac_arr[ind];
                  kk /= prm_i;
                  IF ind + 1 < nfkk AND prm_i == fac_arr[ind
                        + 1]:
                     exp_i += 1;
                  ELSE:
                     ab = atothenmodp(aa, kk, nn);
                     FOR ek FROM 0 TO exp_i:
                        IF ab == 1:
                           FOR_EXIT;
                        IF_END
                        kk *= prm_i;
                        ab = atothenmodp(ab, prm_i, nn);
                     FOR_END
                     IF exp_i < ek:
                        kk = 0;
                        FOR_EXIT;
                     IF_END
                     exp_i = 1;
                  IF_END
               FOR_END
            IF_END
         IF_END
      MODE_INTEGER_END
      RETURN kk;
   FUNC_END
   #TEST:znorder(37,1000)-100;
BLOCK_END
      #   FFFFFFFFFFunction -----------------------------
   #repetendlen #
FUNC INT repetendlen(INT denm
      , INT basee):
   # return the repetend length of 1 / DENM in base BASEE
   INT gdn;
   INT retvalu;
   AWAIT 1 == gdn:
      gdn = gcd(denm, basee);
      denm /= gdn;
   AWAIT_END
   IF denm == 1:
      retvalu = 0;
   ELSE:
      retvalu = znorder(basee, denm);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ print_kevy #
FUNC INT print_kevy(INT den
      , INT start
      , INT basee):
   # print out number in base BASEE, starting with digit START
   #    such that to divide number by DEN you move first digit of
   #    number to last
   # I.E. Given DEN, START, and BASEE: find NN such that
   #   START * (BASEE ** NN - DEN) == 0 mod(BASEE * DEN - 1)
   #   Then print out this number in base BASEE:
   #      DEN * START * (BASEE ** NN - DEN) / (BASEE * DEN - 1)
   # Return number of digits printed
   INT numer;
   INT valu;
   INT leny;
   MODE_INTEGER:
      leny = 0;
      IF start < basee * den:
         numer = start;
         valu = start;
         AWAIT numer == start OR den * basee < leny:
            CALL print_num2char(valu);
            leny += 1;
            valu = FLOORL(numer / den);
            numer = (numer % den) * basee + valu;
         AWAIT_END
         IF basee <= start:
            PRINTSTR("-");
            PRINTVAL(FLOORL(start / basee));
         IF_END
      IF_END
   MODE_INTEGER_END
   RETURN leny;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- eulerphi #
FUNC INT eulerphi(INT nn):
   # count of numbers < NN and relatively prime to NN
   RETURN totient(nn);
FUNC_END
#   FFFFFFFFFFunction ------------------------------ znorder__1 #
FUNC INT znorder__1(INT bb
      , INT mdls):
   # return NN where BB**NN = 1 mod MDLS
   INT nn;
   INT pp;
   MODE_INTEGER:
      IF 1 < gcd(bb, mdls):
         nn = 0;
      ELSE:
         pp = 1;
         AWAIT pp == 1 COUNT nn FROM 1 TO mdls:
            pp = (pp * bb) % mdls;
         AWAIT_END
      IF_END
   MODE_INTEGER_END
   RETURN nn;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- bkn #
FUNC INT bkn(INT bb
      , INT kk):
   # return NN where BB**NN - 1 = 0 mod(KK * BB - 1)
   RETURN znorder(bb, kk * bb - 1);
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ bkbn #
FUNC INT bkbn(INT bb
      , INT kk
      , INT bbb):
   # return NN where KK*BBB*(BB**NN - 1) = 0 mod(KK * BB - 1)
   INT mdls;
   MODE_INTEGER:
      mdls = kk * bb - 1;
      IF mdls % bbb == 0:
         mdls /= bbb;
      IF_END
   MODE_INTEGER_END
   RETURN znorder(bb, mdls);
FUNC_END
BLOCK:# Li, Lix variables
   BLOCK_DEF DBL lv_li_two = 0;
   #   FFFFFFFFFFunction ---------------------------------- lix #
   FUNC DBL lix(DBL xx):
      # logintegral(XX) - logintegral(2)
      BLOCK_USE lv_li_two;
      # if LV_LI_TWO is not defd, def it
      IF lv_li_two <= 0:
         lv_li_two = Kw.logintegral(2.0);
      IF_END
      RETURN Kw.logintegral(xx) - lv_li_two;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------- lixinv #
   FUNC DBL lixinv(DBL yy):
      # return XX such that YY = lix(XX)
      DBL scvx_xp;
      DBL scvx_xx;
      DBL scvx_yp;
      DBL scvx_yy;
      DBL scvx_dx;
      DBL scvx_dy;
      INT scvx_ii;
      DBL x_init;
      x_init = yy / LN(yy);
      # return XX where
      #   yy - lix(scvx_xx)XX == 0
      # BEG Secant Calculation
      scvx_dx = 0.05;
      scvx_xx = x_init;
      scvx_yy = yy - lix(scvx_xx);
      FOR scvx_ii FROM 0 TO 20:
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         IF Kw.iseq(scvx_xp, scvx_xx):
            FOR_EXIT;
         IF_END
         scvx_yy = yy - lix(scvx_xx);
         scvx_dy = (scvx_yy - scvx_yp);
         IF Kw.iszero(scvx_dy):
            FOR_EXIT;
         IF_END
         scvx_dx *= - scvx_yy / scvx_dy;
      FOR_END
      # END Secant Calculation
      RETURN scvx_xx;
   FUNC_END
BLOCK_END
#TEST:lix(0)==-1.04516378011749278484458888919461313652261557815;
#TEST:lix(3)==1.11842481454969918803233347815310823001950063430;
#TEST:lix(0)==lix(1.451369234883381050283968485892027449493032);
#   FFFFFFFFFFunction ----------------------------- primenth__1 #
FUNC DBL primenth__1(DBL nn):
   # an approximation of NNth prime
   DBL logn;
   DBL loglogn;
   DBL retvalu;
   IF nn < 0:
      retvalu = 0;
   ELSIF nn < 4.25:
      retvalu = 1.6 * nn + 0.1;
   ELSE:
      logn = LN(nn);
      loglogn = LN(logn);
      retvalu = nn * (logn + loglogn - 1.0 + (loglogn - 2.0)
            / logn - ((loglogn - 6.0) * loglogn + 11.0) / (2.0
            * logn * logn)) + 3.5 * SQRT(nn) + 10;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- reimann #
FUNC DBL reimann(DBL nn):
   # approxmation of prime counting function
   DBL retvalu;
   DBL sum;
   DBL sum_prev;
   DBL ii;
   DBL lim;
   IF nn < 2:
      retvalu = 0;
   ELSE:
      sum = lix(nn);
      lim = 10 * Kw.lg(nn);
      AWAIT Kw.iseq(sum, sum_prev) COUNT ii FROM 2 TO lim:
         sum_prev = sum;
         sum += mobius(ii) * lix(POW(nn, 1.0 / ii)) / ii;
      AWAIT_END
      retvalu = sum;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- primenth #
FUNC INT primenth(INT nn):
   # Nth Prime
   INT ii;
   INT pp;
   DBL rmndr;
   INT inc;
   DBL prime_arr[30];
   # Nth prime
   IF nn < 5:
      IF nn < 1:
         pp = 0;
      ELSIF nn < 2:
         pp = 2;
      ELSIF nn < 3:
         pp = 3;
      ELSIF nn < 4:
         pp = 5;
      ELSE:
         pp = 7;
      IF_END
   ELSE:
      IF 1024 <= nn:
         ARRAY prime_arr[]:# 2**(n+10)th prime
            8161;
            # 2**10th prime
            17863;
            38873;
            84017;
            180503;
            386093;
            # 2**15th prime
            821641;
            1742537;
            3681131;
            7754077;
            16290047;
            # 2**20th prime
            34136029;
            71378569;
            148948139;
            310248241;
            645155197;
            # 2**25th prime
            1339484197;
            2777105129;
            5750079047;
            11891268401;
            24563311309;
            # 2**30th prime
            50685770167;
            104484802057;
         ARRAY_END
         ii = FLOORL(Kw.lg(nn + 1) - 10);
         IF ARRAYLAST(prime_arr[]) <= ii:
            ii = ARRAYLAST(prime_arr[]);
         IF_END
         pp = prime_arr[ii];
         ii = Kw.round(POW(2, ii + 10));
         rmndr = Kw.fmodu(pp, 6);
         IF Kw.iseq(rmndr, 5):
            inc = 2;
         ELSIF Kw.iseq(rmndr, 1):
            inc = 4;
         ELSE:
            DIE "PRIME_ISNT_PM_1_MOD_6";
         IF_END
      ELSE:
         pp = 11;
         ii = 5;
         # 11 is 5th prime
         inc = 2;
      IF_END
      IF nn < ii:
         PRINTSTR("II=");
         PRINTVAL(ii);
         PRINTSTR(" NN=");
         PRINTVAL(nn);
         DIE "PRIMENTH_failed";
      IF_END
      # Now PP is IIth prime number
      WHILE ii < nn:
         AWAIT Kw.isprime(pp):
            pp += inc;
            inc = 6 - inc;
         AWAIT_END
         ii += 1;
      WHILE_END
   IF_END
   RETURN pp;
FUNC_END
#   IIIIIIIIIInsert-End --------------------------- number.fwip #
#   IIIIIIIIIInsert-Begin ------------------------- bessel.fwip #
#    COPYRIGHT C 2017-2020 by Kevin D. Woerner
# 2020-08-17 kdw  bessel:macro syntax changed
# 2020-07-27 kdw  bessel:block syntax
# 2020-07-24 kdw  bessel:comment cleanup
# 2020-07-12 kdw  bessel:sqrttwo const
# 2020-07-10 kdw  bessel:polynomial refactor
# 2020-07-01 kdw  bessel:tests modified
# 2020-06-30 kdw  bessel:tests changed
# 2020-06-16 kdw  bessel:comments changed
# 2020-05-20 kdw  bessel:rmed unneeded parens
# 2020-05-11 kdw  bessel:reorder; blocks added
# 2020-05-06 kdw  bessel:rmed boolean vars
# 2020-04-28 kdw  bessel:tweaks here and there
# 2020-04-23 kdw  bessel:const format change
# 2020-04-13 kdw  bessel:numeric inequality work
# 2020-04-12 kdw  bessel:comment change
# 2020-04-08 kdw  bessel:preprocess sigil change
# 2020-03-25 kdw  bessel:tests
# 2020-03-23 kdw  bessel:comment changed
# 2020-03-22 kdw  bessel:bes[s]Y1__1 func
# 2020-03-21 kdw  bessel:reorg
# 2020-03-20 kdw  bessel:func renamd
# 2020-03-17 kdw  bessel:un-simplified; logic errors fixed
# 2020-03-13 kdw  bessel:simplified
# 2020-03-11 kdw  bessel:RE[P]LACE work
# 2020-03-09 kdw  bessel:LO[C]AL_.* keywords
# 2020-03-06 kdw  bessel:RE[P]LACE / IN[D]EX changes
# 2020-03-05 kdw  bessel:keywords TR[U]EVAL, FAL[S]EVAL changed
# 2020-03-04 kdw  bessel:refactor
# 2020-03-03 kdw  bessel:comment changed:odd chars
# 2020-03-02 kdw  bessel:rmed unused code
# 2020-03-01 kdw  bessel:.*_NE[X]T deprecated, et al.
# 2020-02-28 kdw  bessel:poly eval work
# 2020-02-26 kdw  bessel:simplified
# 2020-02-19 kdw  bessel:comment change
# 2020-02-15 kdw  bessel:array comment change
# 2020-02-14 kdw  bessel:improving attempt
# 2019-12-31 kdw  bessel:func renam
# 2019-12-26 kdw  bessel:module name addded to funcs
# 2019-11-17 kdw  bessel:include Macros file
# 2019-10-04 kdw  bessel:comment change
# 2019-08-18 kdw  bessel:L[O]G to L[N]
# 2019-08-11 kdw  bessel:comment cleanup
# 2019-08-06 kdw  bessel:rmed backslashes, macro arg renam
# 2019-05-29 kdw  bessel:comment changed
# 2019-05-22 kdw  bessel:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-05-01 kdw  bessel:consts explicit module name
# 2019-04-09 kdw  bessel:comment improvement
# 2019-03-19 kdw  bessel:re[t]_val to re[t]valu
# 2019-03-18 kdw  bessel:macro syntax changed
# 2019-03-11 kdw  bessel:comments to array dcls
# 2019-03-10 kdw  bessel:changed .*__1 funcs
# 2019-03-08 kdw  bessel:is[e]qual to is[e]q, et al.
# 2019-03-06 kdw  bessel:is.* funcs changed
# 2019-01-03 kdw  bessel:Await counter changed
# 2018-12-03 kdw  bessel:minor code reorg
# 2018-09-12 kdw  bessel:rmed unsed funcs
# 2018-07-20 kdw  bessel:funcs renam; refactor
# 2018-07-19 kdw  bessel:comments; array reformat
# 2018-07-14 kdw  bessel:float num format
# 2018-07-10 kdw  bessel:added "+" to exponents
# 2018-06-09 kdw  bessel:mved tests
# 2018-06-07 kdw  bessel:b[e]ssel_XX test more resolution
# 2018-06-06 kdw  bessel:b[e]ssel_y1 coeff fix
# 2018-05-17 kdw  bessel:ARR?AY.* and HOR[N]ER syntax
# 2018-05-16 kdw  bessel:AR?RAY syntax
# 2018-04-03 kdw  bessel:rm() from return
# 2018-04-02 kdw  bessel:Pro?totype, et al.
# 2017-11-26 kdw  bessel:FR[O]M and B[Y] keywords
# 2017-11-22 kdw  bessel:var renam
# 2017-11-21 kdw  bessel:FR[O]M
# 2017-10-23 kdw  bessel:array init syntax changed
# 2017-09-20 kdw  bessel:rmed useless trailing 0s
# 2017-08-31 kdw  bessel:REQ[U]IRES deletede
# 2017-05-03 kdw  bessel:PROT?OTYPE format changed
# 2017-04-28 kdw  bessel:b[e]ssel_[jy]v()
# 2017-04-26 kdw  bessel:backslashes
# 2017-04-24 kdw  bessel:y0, y02, y1, yn functions
# 2017-04-19 kdw  bessel:funciton keyword
# 2017-04-18 kdw  bessel:created
#   IIIIIIIIIInsert-Begin ------------------------- Macros.fwip #
#   IIIIIIIIIInsert-End --------------------------- Macros.fwip #
#   FFFFFFFFFFunction ---------------------------------- bessJv #
FUNC DBL bessJv(DBL vv
      , DBL xx):
   # Cylindrical Bessel function 1th kind Jv()
   # via power series
   DBL sum;
   DBL sum_prev;
   DBL term;
   DBL mm;
   DBL xxsqr_div_four;
   DBL avv;
   IF xx < 0.0:
      sum = 0.0;
   ELSE:
      avv = vv;
      IF Kw.isposint(-vv):
         avv = ABS(vv);
      IF_END
      xxsqr_div_four = (xx * xx / 4.0);
      term = POW(xx / 2.0, avv) / Kw.tgamma(avv + 1.0);
      sum = term;
      AWAIT Kw.iseq(sum, sum_prev) COUNT mm FROM 1:
         term *= - xxsqr_div_four / (mm * (avv + mm));
         sum_prev = sum;
         sum += term;
      AWAIT_END
      IF Kw.isposint(-vv) AND Kw.isodd(vv):
         sum = -sum;
      IF_END
   IF_END
   RETURN sum;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- bessYv #
FUNC DBL bessYv(DBL vv
      , DBL xx):
   # Cylindrical Bessel Function 2th kind Yv()
   DBL retvalu;
   DBL vvpi;
   IF Kw.isint(vv):
      retvalu = bessYn(vv, xx);
   ELSE:
      vvpi = Kw.PI * vv;
      retvalu = ((COS(vvpi) * bessJv(vv, xx) - bessJv(-vv, xx))
            / SIN(vvpi));
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- bessI0 #
FUNC DBL bessI0(DBL xx):
   # Hyperbolical Bessel function 1th kind of 0th order
   # via polynomial approximation
   DBL yy;
   DBL retvalu;
   # From Pavel Holoborodko
   #   https://www.advanpix.com/2015/11/11/
   #      rational-approximations-for-the-modified-bessel
   #      -function-of-the-first-kind-i0-computations
   #      -double-precision/
   IF xx < 7.75:
      yy = xx * xx / 4;
      retvalu
            = (((((((((((((((((1.1497640034400735733456400E-29)
            * yy + 2.0732014503197852176921968E-27) * yy
            + 5.9203280572170548134753422E-25) * yy
            + 1.3141332422663039834197910E-22) * yy
            + 2.5791926805873898803749321E-20) * yy
            + 4.3583591008893599099577755E-18) * yy
            + 6.2760839879536225394314453E-16) * yy
            + 7.5940582595094190098755663E-14) * yy
            + 7.5940584360755226536109511E-12) * yy
            + 6.1511873265092916275099070E-10) * yy
            + 3.9367598891475388547279760E-08) * yy
            + 1.9290123456788994104574754E-06) * yy
            + 6.9444444444444568581891535E-05) * yy
            + 1.7361111111111110294015271E-03) * yy
            + 2.7777777777777777805664954E-02) * yy
            + 2.4999999999999999999629693E-01) * yy
            + 1.0000000000000000000000801E+00) * yy + 1;
   ELSE:
      yy = 1.0 / xx;
      retvalu
            =
      (((((((((((((((((((((((1.6069467093441596329340754E+16)
         * yy - 2.1363029690365351606041265E+16) * yy
         + 1.3012646806421079076251950E+16) * yy
         - 4.8049082153027457378879746E+15) * yy
         + 1.1989242681178569338129044E+15) * yy
         - 2.1323049786724612220362154E+14) * yy
         + 2.7752144774934763122129261E+13) * yy
         - 2.6632742974569782078420204E+12) * yy
         + 1.8592340458074104721496236E+11) * yy
         - 8.9270060370015930749184222E+09) * yy
         + 2.3518420447411254516178388E+08) * yy
         + 2.6092888649549172879282592E+06) * yy
         - 5.9355022509673600842060002E+05) * yy
         + 3.1275740782277570164423916E+04) * yy
         - 1.0026890180180668595066918E+03) * yy
         + 2.2725199603010833194037016E+01) * yy
         - 1.0699095472110916094973951E-01) * yy
         + 9.4085204199017869159183831E-02) * yy
         + 4.4718622769244715693031735E-02) * yy
         + 2.9219501690198775910219311E-02) * yy
         + 2.8050628884163787533196746E-02) * yy
         + 4.9867785050353992900698488E-02) * yy
         + 3.9894228040143265335649948E-01);
      retvalu *= EXP(xx) / SQRT(xx);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- bessI1 #
FUNC DBL bessI1(DBL xx):
   # Hyperbolical Bessel function 1th kind of 1th order
   # via polynomial approximation
   DBL yy;
   DBL aa;
   DBL retvalu;
   IF xx < 7.75:
      yy = xx * xx / 4;
      aa = (((((((((((((1.332898928162290861E-23) * yy
            + 1.625212890947171108E-21) * yy
            + 3.410720494727771276E-19) * yy
            + 5.220157095351373194E-17) * yy
            + 6.904822652741917551E-15) * yy
            + 7.593969849687574339E-13) * yy
            + 6.834657311305621830E-11) * yy
            + 4.920949692800671435E-09) * yy
            + 2.755731926254790268E-07) * yy
            + 1.157407407354987232E-05) * yy
            + 3.472222222225921045E-04) * yy
            + 6.944444444444341983E-03) * yy
            + 8.333333333333333803E-02);
      retvalu = (((aa) * yy + 0.5) * yy + 1.0) * xx / 2.0;
   ELSIF xx < 500:
      yy = 1.0 / xx;
      retvalu
            = ((((((((((((((((((((((-2.213318202179221945E+15)
            * yy + 3.146401654361325073E+15) * yy
            - 2.067285045778906105E+15) * yy
            + 8.325554073334618015E+14) * yy
            - 2.298849639457172489E+14) * yy
            + 4.614040809616582764E+13) * yy
            - 6.967602516005787001E+12) * yy
            + 8.087824484994859552E+11) * yy
            - 7.313784438967834057E+10) * yy
            + 5.192386898222206474E+09) * yy
            - 2.903390398236656519E+08) * yy
            + 1.277677779341446497E+07) * yy
            - 4.404655582443487334E+05) * yy
            + 1.178785865993440669E+04) * yy
            - 2.426181371595021021E+02) * yy
            + 3.458284470977172076E+00) * yy
            - 1.528189554374492735E-01) * yy
            - 5.719036414430205390E-02) * yy
            - 4.090895951581637791E-02) * yy
            - 4.675104253598537322E-02) * yy
            - 1.496033551613111533E-01) * yy
            + 3.989422804014406054E-01) * EXP(xx) / SQRT(xx);
   ELSE:
      yy = 1.0 / xx;
      aa = EXP(xx / 2.0);
      retvalu = (((((-5.843630344778927582E-02) * yy
            - 4.090421597376992892E-02) * yy
            - 4.675105322571775911E-02) * yy
            - 1.496033551467584157E-01) * yy
            + 3.989422804014314820E-01) * aa / SQRT(xx);
      retvalu *= aa;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- bessK0 #
FUNC DBL bessK0(DBL arg):
   # Hyperbolical Bessel function 2th kind of 0th order
   # via polynomial approximation
   DBL retvalu;
   DBL sumf;
   DBL sumg;
   DBL sump;
   DBL sumq;
   DBL xx;
   DBL xz;
   xx = arg;
   IF xx <= 0.0:
      retvalu = DBLMAX;
   ELSIF xx < DBLEPS:
      retvalu = 0.11593151565841244858684731328185 - LN(xx);
   ELSIF xx <= 1.0:
      xz = xx * xx;
      sump = (((((5.8599221412826100000E-04) * xz
            + 1.3166052564989571850E-01) * xz
            + 1.1999463724910714109E+01) * xz
            + 4.6850901201934832188E+02) * xz
            + 5.9169059852270512312E+03) * xz
            + 2.4708152720399552679E+03;
      sumq = ((1.0000000000000000000E+00) * xz
            - 2.4994418972832303646E+02) * xz
            + 2.1312714303849120380E+04;
      sumf = (((-1.6414452837299064100E+00) * xz
            - 2.9601657892958843866E+02) * xz
            - 1.7733784684952985886E+04) * xz
            - 4.0320340761145482298E+05;
      sumg = ((1.0 * xz - 2.5064972445877992730E+02) * xz
            + 2.9865713163054025489E+04) * xz
            - 1.6128136304458193998E+06;
      retvalu = sump / sumq - LN(xx) * (xz * sumf / sumg + 1.0);
   ELSIF xx < DBLMAXLN:
      xz = 1.0 / xx;
      sump = (((((((((1.1394980557384778174E+02) * xz
            + 3.6832589957340267940E+03) * xz
            + 3.1075408980684392399E+04) * xz
            + 1.0577068948034021957E+05) * xz
            + 1.7398867902565686251E+05) * xz
            + 1.5097646353289914539E+05) * xz
            + 7.1557062783764037541E+04) * xz
            + 1.8321525870183537725E+04) * xz
            + 2.3444738764199315021E+03) * xz
            + 1.1600249425076035558E+02;
      sumq = ((((((((((1.0000000000000000000E+00) * xz
            + 2.0013443064949242491E+02) * xz
            + 4.4329628889746408858E+03) * xz
            + 3.1474655750295278825E+04) * xz
            + 9.7418829762268075784E+04) * xz
            + 1.5144644673520157801E+05) * xz
            + 1.2689839587977598727E+05) * xz
            + 5.8824616785857027752E+04) * xz
            + 1.4847228371802360957E+04) * xz
            + 1.8821890840982713696E+03) * xz
            + 9.2556599177304839811E+01;
      retvalu = sump / sumq / SQRT(xx) * EXP(-xx);
   ELSE:
      retvalu = 0.0;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- bessK1 #
FUNC DBL bessK1(DBL arg):
   # Hyperbolical Bessel function 2th kind of 1th order
   # via polynomial approximation
   DBL retvalu;
   DBL sumf;
   DBL sumg;
   DBL sump;
   DBL sumq;
   DBL xx;
   DBL xz;
   xx = arg;
   IF xx < DBLEPS:
      retvalu = DBLMAX;
   ELSIF xx < DBLEPS:
      retvalu = 1.0 / xx;
   ELSIF xx <= 1.0:
      xz = xx * xx;
      sump = (((((4.8127070456878442310E-1) * xz
            + 9.9991373567429309922E+1) * xz
            + 7.1885382604084798576E+3) * xz
            + 1.7733324035147015630E+5) * xz
            + 7.1938920065420586101E+5) * xz
            - 2.2149374878243304548E+6;
      sumq = (((1.0000000000000000000E+0) * xz
            - 2.8143915754538725829E+2) * xz
            + 3.7264298672067697862E+4) * xz
            - 2.2149374878243304548E+6;
      sumf = ((((-2.2795590826955002390E-1) * xz
            - 5.3103913335180275253E+1) * xz
            - 4.5051623763436087023E+3) * xz
            - 1.4758069205414222471E+5) * xz
            - 1.3531161492785421328E+6;
      sumg = (((1.0000000000000000000E+0) * xz
            - 3.0507151578787595807E+2) * xz
            + 4.3117653211351080007E+4) * xz
            - 2.7062322985570842656E+6;
      retvalu = (xz * LN(xx) * sumf / sumg + sump / sumq) / xx;
   ELSIF xx < DBLMAXLN:
      xz = 1.0 / xx;
      sump = ((((((((((6.4257745859173138767E-2) * xz
            + 7.5584584631176030810E+0) * xz
            + 1.3182609918569941308E+2) * xz
            + 8.1094256146537402173E+2) * xz
            + 2.3123742209168871550E+3) * xz
            + 3.4540675585544584407E+3) * xz
            + 2.8590657697910288226E+3) * xz
            + 1.3319486433183221990E+3) * xz
            + 3.4122953486801312910E+2) * xz
            + 4.4137176114230414036E+1) * xz
            + 2.2196792496874548962E+0;
      sumq = (((((((((1.0000000000000000000E+0) * xz
            + 3.6001069306861518855E+1) * xz
            + 3.3031020088765390854E+2) * xz
            + 1.2082692316002348638E+3) * xz
            + 2.1181000487171943810E+3) * xz
            + 1.9448440788918006154E+3) * xz
            + 9.6929165726802648634E+2) * xz
            + 2.5951223655579051357E+2) * xz
            + 3.4552228452758912848E+1) * xz
            + 1.7710478032601086579E+0;
      retvalu = sump / sumq / SQRT(xx);
      retvalu = retvalu * EXP(-xx);
   ELSE:
      retvalu = 0.0;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- bessJn_ps #
FUNC DBL bessJn_ps(INT nn
      , DBL xx):
   # Cylindrical Bessel function 1th kind of integer order
   # via power series
   DBL sum;
   DBL sum_prev;
   DBL term;
   DBL mm;
   DBL xxsqr_div_four;
   INT ann;
   IF nn < 0:
      ann = -nn;
   ELSE:
      ann = nn;
   IF_END
   term = POW(xx / 2.0, ann) / Kw.factorial(ann);
   xxsqr_div_four = -(xx * xx / 4.0);
   sum = term;
   AWAIT Kw.iseq(sum, sum_prev) COUNT mm FROM 1:
      term *= xxsqr_div_four / (mm * (ann + mm));
      sum_prev = sum;
      sum += term;
   AWAIT_END
   IF nn < 0 AND Kw.isodd(nn):
      sum = -sum;
   IF_END
   RETURN sum;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- bessIn_ps #
FUNC DBL bessIn_ps(INT nn
      , DBL xx):
   # Hyperbolical Bessel function 1th kind of integer order
   # via power series
   DBL sum;
   DBL sum_prev;
   DBL term;
   DBL mm;
   DBL xxsqr_div_four;
   INT ann;
   IF nn < 0:
      ann = -nn;
   ELSE:
      ann = nn;
   IF_END
   term = POW(xx / 2.0, ann) / Kw.factorial(ann);
   xxsqr_div_four = xx * xx / 4.0;
   sum = term;
   AWAIT Kw.iseq(sum, sum_prev) COUNT mm FROM 1:
      term *= xxsqr_div_four / (mm * (ann + mm));
      sum_prev = sum;
      sum += term;
   AWAIT_END
   RETURN sum;
FUNC_END
BLOCK:
      #   FFFFFFFFFFunction ---------------------
   #lf_besucjy0_xge5 #
   BLOCK_DEF FUNC DBL lf_besucjy0_xge5(DBL xx, INT jfunc):
      DBL ww;
      DBL pp;
      DBL qq;
      DBL zz;
      DBL xn;
      DBL denom;
      DBL numer;
      ww = 5.0 / xx;
      zz = 25.0 / (xx * xx);
      numer = (((((((7.96936729297347051624E-4) * zz
            + 8.28352392107440799803E-2) * zz
            + 1.23953371646414299388E0) * zz
            + 5.44725003058768775090E0) * zz
            + 8.74716500199817011941E0) * zz
            + 5.30324038235394892183E0) * zz
            + 9.99999999999999997821E-1);
      denom = (((((((9.24408810558863637013E-4) * zz
            + 8.56288474354474431428E-2) * zz
            + 1.25352743901058953537E0) * zz
            + 5.47097740330417105182E0) * zz
            + 8.76190883237069594232E0) * zz
            + 5.30605288235394617618E0) * zz
            + 1.00000000000000000218E0);
      pp = numer / denom;
      numer = ((((((((-1.13663838898469149931E-2) * zz
            - 1.28252718670509318512E0) * zz
            - 1.95539544257735972385E1) * zz
            - 9.32060152123768231369E1) * zz
            - 1.77681167980488050595E2) * zz
            - 1.47077505154951170175E2) * zz
            - 5.14105326766599330220E1) * zz
            - 6.05014350600728481186E0);
      denom = ((((((((1.00000000000000000000E0) * zz
            + 6.43178256118178023184E1) * zz
            + 8.56430025976980587198E2) * zz
            + 3.88240183605401609683E3) * zz
            + 7.24046774195652478189E3) * zz
            + 5.93072701187316984827E3) * zz
            + 2.06209331660327847417E3) * zz
            + 2.42005740240291393179E2);
      qq = numer / denom;
      xn = xx - Kw.PI / 4;
      IF jfunc < 1:
         pp = pp * COS(xn) - ww * qq * SIN(xn);
      ELSE:
         pp = pp * SIN(xn) + ww * qq * COS(xn);
      IF_END
      RETURN pp * Kw.SQRTTWO / SQRT(Kw.PI * xx);
   FUNC_END
   #   FFFFFFFFFFunction --------------------- lf_besucjy1_xge5 #
   BLOCK_DEF FUNC DBL lf_besucjy1_xge5(DBL xx, INT jfunc):
      DBL ww;
      DBL pp;
      DBL qq;
      DBL zz;
      DBL xn;
      DBL denom;
      DBL numer;
      ww = 5.0 / xx;
      zz = 25.0 / (xx * xx);
      numer = (((((((7.62125616208173112003E-4) * zz
            + 7.31397056940917570436E-2) * zz
            + 1.12719608129684925192E0) * zz
            + 5.11207951146807644818E0) * zz
            + 8.42404590141772420927E0) * zz
            + 5.21451598682361504063E0) * zz
            + 1.00000000000000000254E0);
      denom = (((((((5.71323128072548699714E-4) * zz
            + 6.88455908754495404082E-2) * zz
            + 1.10514232634061696926E0) * zz
            + 5.07386386128601488557E0) * zz
            + 8.39985554327604159757E0) * zz
            + 5.20982848682361821619E0) * zz
            + 9.99999999999999997461E-1);
      pp = numer / denom;
      numer = ((((((((5.10862594750176621635E-2) * zz
            + 4.98213872951233449420E0) * zz
            + 7.58238284132545283818E1) * zz
            + 3.66779609360150777800E2) * zz
            + 7.10856304998926107277E2) * zz
            + 5.97489612400613639965E2) * zz
            + 2.11688757100572135698E2) * zz
            + 2.52070205858023719784E1);
      denom = ((((((((1.00000000000000000000E0) * zz
            + 7.42373277035675149943E1) * zz
            + 1.05644886038262816351E3) * zz
            + 4.98641058337653607651E3) * zz
            + 9.56231892404756170795E3) * zz
            + 7.99704160447350683650E3) * zz
            + 2.82619278517639096600E3) * zz
            + 3.36093607810698293419E2);
      qq = numer / denom;
      xn = xx - 3 * Kw.PI / 4;
      IF jfunc < 1:
         pp = pp * COS(xn) - ww * qq * SIN(xn);
      ELSE:
         pp = pp * SIN(xn) + ww * qq * COS(xn);
      IF_END
      RETURN pp * Kw.SQRTTWO / SQRT(Kw.PI * xx);
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------- bessJ0 #
   FUNC DBL bessJ0(DBL xx):
      # Cylindrical Bessel function 1th kind of 0th order
      # via rational polynomial approximation
      DBL zz;
      DBL denom;
      DBL numer;
      DBL retvalu;
      IF xx < 0.0:
         xx = -xx;
      IF_END
      zz = xx * xx;
      IF xx < 1E-5:
         retvalu = 1.0 - zz / 4.0;
      ELSIF xx < 5.0:
         numer = ((((-4.79443220978201773821E9) * zz
               + 1.95617491946556577543E12) * zz
               - 2.49248344360967716204E14) * zz
               + 9.70862251047306323952E15);
         denom = (((((((((1.00000000000000000000E0) * zz
               + 4.99563147152651017219E2) * zz
               + 1.73785401676374683123E5) * zz
               + 4.84409658339962045305E7) * zz
               + 1.11855537045356834862E10) * zz
               + 2.11277520115489217587E12) * zz
               + 3.10518229857422583814E14) * zz
               + 3.18121955943204943306E16) * zz
               + 1.71086294081043136091E18);
         # these are the squares of the first two zeroes of J0
         retvalu = (zz - 5.783185962946784521175) * (zz
               - 30.4712623436620863991) * numer / denom;
      ELSE:
         retvalu = lf_besucjy0_xge5(xx, 0);
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------- bessJ1 #
   FUNC DBL bessJ1(DBL xx):
      # Cylindrical Bessel function 1th kind of 1th order
      # via rational polynomial approximation
      DBL ww;
      DBL zz;
      DBL denom;
      DBL numer;
      DBL retvalu;
      ww = xx;
      IF ww < 0.0:
         ww = -ww;
      IF_END
      IF ww < 5.0:
         zz = ww * ww;
         numer = ((((-8.99971225705559398224E8) * zz
               + 4.52228297998194034323E11) * zz
               - 7.27494245221818276015E13) * zz
               + 3.68295732863852883286E15);
         denom = (((((((((1.00000000000000000000E0) * zz
               + 6.20836478118054335476E2) * zz
               + 2.56987256757748830383E5) * zz
               + 8.35146791431949253037E7) * zz
               + 2.21511595479792499675E10) * zz
               + 4.74914122079991414898E12) * zz
               + 7.84369607876235854894E14) * zz
               + 8.95222336184627338078E16) * zz
               + 5.32278620332680085395E18);
         retvalu = numer / denom * xx * (zz
               - 14.6819706421238932572) * (zz
               - 49.2184563216946036703);
      ELSE:
         retvalu = lf_besucjy1_xge5(xx, 0);
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------- bessY0 #
   FUNC DBL bessY0(DBL xx):
      # Cylindrical Bessel function 2th kind of 0th order
      # via rational polynomial approximation
      DBL zz;
      DBL denom;
      DBL numer;
      DBL retvalu;
      IF xx <= 0.0:
         retvalu = Kw.DBLMAX;
      ELSE:
         zz = xx * xx;
         IF xx < 1E-5:
            retvalu = 1.0 - zz / 4.0;
         ELSIF xx < 5.0:
            numer = ((((((((1.55924367855235737965E4) * zz
                  - 1.46639295903971606143E7) * zz
                  + 5.43526477051876500413E9) * zz
                  - 9.82136065717911466409E11) * zz
                  + 8.75906394395366999549E13) * zz
                  - 3.46628303384729719441E15) * zz
                  + 4.42733268572569800351E16) * zz
                  - 1.84950800436986690637E16);
            denom = ((((((((1.00000000000000000000E0) * zz
                  + 1.04128353664259848412E3) * zz
                  + 6.26107330137134956842E5) * zz
                  + 2.68919633393814121987E8) * zz
                  + 8.64002487103935000337E10) * zz
                  + 2.02979612750105546709E13) * zz
                  + 3.17157752842975028269E15) * zz
                  + 2.50596256172653059228E17);
            retvalu = numer / denom + 2.0 * LN(xx) * bessJ0(xx)
                  / Kw.PI;
         ELSE:
            retvalu = lf_besucjy0_xge5(xx, 1);
         IF_END
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------- bessY1 #
   FUNC DBL bessY1(DBL xx):
      # Cylindrical Bessel function 2th kind of 1th order
      # via rational polynomial approximation
      DBL ww;
      DBL zz;
      DBL denom;
      DBL numer;
      DBL retvalu;
      ww = xx;
      IF xx <= 0.0:
         retvalu = -Kw.DBLMAX;
      ELSIF ww <= 5.0:
         zz = ww * ww;
         numer = ((((((1.2632047479017802640E9) * zz
               - 6.47355876379160291031E11) * zz
               + 1.14509511541823727583E14) * zz
               - 8.12770255501325109621E15) * zz
               + 2.02439475713594898196E17) * zz
               - 7.78877196265950026825E17);
         denom = (((((((((1.00000000000000000000E0) * zz
               + 5.94301592346128195359E2) * zz
               + 2.35564092943068577943E5) * zz
               + 7.34811944459721705660E7) * zz
               + 1.87601316108706159478E10) * zz
               + 3.88231277496238566008E12) * zz
               + 6.20557727146953693363E14) * zz
               + 6.87141087355300489866E16) * zz
               + 3.97270608116560655612E18);
         retvalu = xx * numer / denom + 2.0 * (bessJ1(xx)
               * LN(xx) - 1.0 / xx) / Kw.PI;
      ELSE:
         retvalu = lf_besucjy1_xge5(xx, 1);
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END
BLOCK:# define bessel ucrecur
   #   FFFFFFFFFFunction ---------------------- lf_bess_ucrecur #
   BLOCK_DEF FUNC DBL lf_bess_ucrecur(INT nn, DBL xx, DBL fzero
         , DBL fone):
      # Let Zn be either bessYn or bessJn
      # Zn(NN+1, XX) = 2*NN*Zn(NN, XX) / XX - Zn(NN-1, XX)
      DBL av;
      DBL bv;
      DBL cv;
      DBL tox;
      INT ii;
      IF nn <= 0:
         cv = fzero;
      ELSIF nn == 1:
         cv = fone;
      ELSE:
         tox = 2.0 / xx;
         av = fzero;
         bv = fone;
         FOR ii FROM 1 TO nn - 1:
            cv = tox * ii * bv - av;
            av = bv;
            bv = cv;
         FOR_END
      IF_END
      RETURN cv;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------ lf_limi #
   BLOCK_DEF FUNC INT lf_limi(INT nn):
      RETURN nn + FLOOR(SQRT(40.0 * nn));
   FUNC_END
   #   FFFFFFFFFFunction --------------------- lf_bess_ucrecur2 #
   BLOCK_DEF FUNC DBL lf_bess_ucrecur2(INT nn, DBL xx):
      DBL tox;
      DBL bzp;
      DBL bzc;
      DBL bzm;
      DBL sjm;
      INT jj;
      INT flipflop;
      INT limi;
      DBL retvalu;
      flipflop = 0;
      sjm = 0.0;
      tox = 2.0 / ABS(xx);
      retvalu = 0.0;
      bzp = 0.0;
      bzc = 1.0;
      limi = lf_limi(nn);
      IF Kw.isodd(limi):
         limi -= 1;
      IF_END
      FOR jj FROM limi TO 1 BY - 1:
         bzm = jj * tox * bzc - bzp;
         bzp = bzc;
         bzc = bzm;
         IF flipflop == 0:
            flipflop = 1;
         ELSE:
            sjm += bzc;
            flipflop = 0;
         IF_END
         IF jj == nn:
            retvalu = bzp;
         IF_END
      FOR_END
      sjm = 2.0 * sjm - bzc;
      retvalu /= sjm;
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------- bessIn #
   FUNC DBL bessIn(INT nn
         , DBL xx):
      # Hyperbolical Bessel function 1th kind of integer order
      INT jj;
      INT limi;
      DBL bzc;
      DBL bzm;
      DBL bzp;
      DBL tox;
      DBL retvalu;
      DBL axx;
      IF nn < 0 OR Kw.iszero(xx):
         retvalu = 0.0;
      ELSIF nn == 0:
         axx = ABS(xx);
         retvalu = bessI0(axx);
      ELSIF nn == 1:
         axx = ABS(xx);
         retvalu = bessI1(axx);
      ELSE:
         tox = 2.0 / ABS(xx);
         retvalu = 0.0;
         bzp = 0.0;
         bzc = 1.0;
         limi = 2 * lf_limi(nn);
         FOR jj FROM limi TO 1 BY - 1:
            bzm = bzp + jj * tox * bzc;
            bzp = bzc;
            bzc = bzm;
            IF jj == nn:
               retvalu = bzp;
            IF_END
         FOR_END
         retvalu *= bessI0(xx) / bzc;
      IF_END
      IF xx < 0.0 AND Kw.isodd(nn):
         retvalu = -retvalu;
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------- bessJn #
   FUNC DBL bessJn(INT nn
         , DBL xx):
      # Cylindrical Bessel function 1th kind of integer order
      DBL retvalu;
      IF nn == 0:
         retvalu = bessJ0(xx);
      ELSIF nn == 1:
         retvalu = bessJ1(xx);
      ELSIF nn < ABS(xx):
         retvalu = lf_bess_ucrecur(nn, xx, bessJ0(xx)
               , bessJ1(xx));
      ELSE:
         retvalu = lf_bess_ucrecur2(nn, xx);
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------- bessYn #
   FUNC DBL bessYn(INT nn
         , DBL xx):
      # Cylindrical Bessel function 2th kind of integer order
      DBL retvalu;
      IF nn == 0:
         retvalu = bessY0(xx);
      ELSIF nn == 1:
         retvalu = bessY1(xx);
      ELSE:
         retvalu = lf_bess_ucrecur(nn, xx, bessY0(xx)
               , bessY1(xx));
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------- bessKn #
   FUNC DBL bessKn(INT nn
         , DBL xx):
      # Hyperbolical Bessel function 2th kind of integer order
      DBL retvalu;
      IF nn < 0 OR Kw.iszero(xx):
         retvalu = 0.0;
      ELSIF nn == 0:
         retvalu = bessK0(xx);
      ELSIF nn == 1:
         retvalu = bessK1(xx);
      ELSE:
         retvalu = lf_bess_ucrecur(nn, xx, bessK0(xx)
               , bessK1(xx));
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ---------------------------- bessYn_ps #
   FUNC DBL bessYn_ps(INT nn
         , DBL xx):
      # Cylindrical Bessel function 2th kind of integer order
      # Based on the recurrrence relation
      #    Yn(N+1,XX) = 2N * Yn(N,XX) / XX - Yn(N-1,XX)
      DBL retvalu;
      DBL sum;
      DBL sum_prev;
      DBL term;
      DBL hn;
      DBL kk;
      DBL xxsqr_div_four;
      IF nn < 0 OR Kw.iszero(xx):
         retvalu = 0.0;
      ELSIF nn == 0:
         xxsqr_div_four = xx * xx / 4.0;
         sum = (LN(xx / 2.0) + Kw.EULER) * bessJn(0, xx);
         term = -1;
         hn = 0;
         AWAIT Kw.iseq(sum, sum_prev) COUNT kk FROM 1:
            hn += 1.0 / kk;
            term *= - xxsqr_div_four / (kk * kk);
            sum_prev = sum;
            sum += term * hn;
         AWAIT_END
         retvalu = 2.0 * sum / Kw.PI;
      ELSIF nn == 1:
         retvalu = bessY1(xx);
      ELSE:
         retvalu = lf_bess_ucrecur(nn, xx, bessY0(xx)
               , bessY1(xx));
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END# define bessel ucrecur
#   FFFFFFFFFFunction ------------------------------- bessY1__1 #
FUNC DBL bessY1__1(DBL xx):
   # Cylindrical Bessel Function 2th kind of 1th order
   # via rational polynomial approximationn
   DBL numer;
   DBL denom;
   DBL zz;
   DBL ww;
   DBL yy;
   DBL retvalu;
   IF Kw.iszero(xx):
      retvalu = -DBLMAX;
   ELSIF xx < 8.0:
      # Different rational polynomial approximations are used
      #   on the intervals(0,8) and[8,Inf)
      # REFERENCES:
      #   M. Abramowitz, I.A. Stegun
      #      Handbook Of Mathematical Functions, 1965.
      #   C.W. Clenshaw
      #      National Physical Laboratory Mathematical Tables
      #      VOL.5, 1962.
      yy = xx * xx;
      numer = ((((((8.511937935E+3) * yy - 4.237922726E+6) * yy
            + 7.349264551E+8) * yy - 5.153438139E+10) * yy
            + 1.275274390E+12) * yy - 4.900604943E+12);
      denom = (((((((1.0) * yy + 3.549632885E+2) * yy
            + 1.020426050E+5) * yy + 2.245904002E+7) * yy
            + 3.733650367E+9) * yy + 4.244419664E+11) * yy
            + 2.499580570E+13);
      retvalu = (xx * (numer / denom) + 2.0 * (bessJn(1, xx)
            * LN(xx) - 1.0 / xx) / Kw.PI);
   ELSE:
      zz = 8.0 / xx;
      yy = zz * zz;
      numer = (((((-2.403370190E-7) * yy + 2.457520174E-6) * yy
            - 3.516396496E-5) * yy + 1.831050000E-3) * yy
            + 1.000000000E+0);
      denom = (((((1.057874120E-7) * yy - 8.822898700E-7) * yy
            + 8.449199096E-6) * yy - 2.002690873E-4) * yy
            + 4.687499995E-2);
      ww = xx - 0.75 * Kw.PI;
      retvalu = Kw.SQRTTWO / SQRT(Kw.PI * xx) * (SIN(ww)
            * numer + zz * COS(ww) * denom);
   IF_END
   RETURN retvalu;
FUNC_END
BLOCK:# define bessel lcrecur
   #   FFFFFFFFFFunction ---------------------- lf_bess_lcrecur #
   BLOCK_DEF FUNC DBL lf_bess_lcrecur(INT nn, DBL xx, DBL fzero
         , DBL fone):
      # Let zn be either bess_jn or bess_yn
      # jn(NN+1, XX) = (2*NN+1) * jn(NN, XX) / XX  - jn(NN-1, XX)
      DBL av;
      DBL bv;
      DBL cv;
      INT ii;
      IF nn <= 0:
         cv = fzero;
      ELSIF nn == 1:
         cv = fone;
      ELSE:
         av = fzero;
         bv = fone;
         FOR ii FROM 1 TO nn - 1:
            cv = (2.0 * ii + 1.0) * bv / xx - av;
            av = bv;
            bv = cv;
         FOR_END
      IF_END
      RETURN cv;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------ bess_jn #
   FUNC DBL bess_jn(INT nn
         , DBL xx):
      # Spherical Bessel function 1th kind of integer order
      # Based on the recurrrence relation
      #    Jn(N+1,XX) = 2N * Jn(N,XX) / XX - Jn(N-1,XX)
      DBL retvalu;
      DBL jk_a;
      DBL jk_b;
      IF Kw.iszero(xx):
         IF nn == 0:
            retvalu = 1.0;
         ELSE:
            retvalu = 0.0;
         IF_END
      ELSE:
         jk_a = SIN(xx) / xx;
         # bess_j0(xx)
         jk_b = (SIN(xx) - xx * COS(xx)) / (xx * xx);
         # lcj1(xx)
         IF nn <= 0:
            retvalu = jk_a;
         ELSIF nn <= 1:
            retvalu = jk_b;
         ELSE:
            retvalu = lf_bess_lcrecur(nn, xx, jk_a, jk_b);
         IF_END
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------ bess_yn #
   FUNC DBL bess_yn(INT nn
         , DBL xx):
      # Spherical Bessel function 2th kind of integer order
      DBL retvalu;
      DBL yk_a;
      DBL yk_b;
      IF Kw.iszero(xx):
         IF nn == 0:
            retvalu = 1.0;
         ELSE:
            retvalu = 0.0;
         IF_END
      ELSE:
         yk_a = -COS(xx) / xx;
         # bess_y0(xx)
         yk_b = (-COS(xx) - xx * SIN(xx)) / (xx * xx);
         # lcy1(xx)
         IF nn <= 0:
            retvalu = yk_a;
         ELSIF nn <= 1:
            retvalu = yk_b;
         ELSE:
            retvalu = lf_bess_lcrecur(nn, xx, yk_a, yk_b);
         IF_END
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END# define bessel lcrecur
#TEST:bessJn(0,5)    ==-0.17759677131433830434739701307475871107;
#TEST:bessJn(1,5)    ==-0.32757913759146522203773432191016913276;
#TEST:bessJn(10,5)   ==0.00146780264731047413110753223260662702;
#TEST:bessJn(10,9)   ==0.12469409282831672203113667647612904039;
#TEST:bessJn(3,5)    ==0.36483123061366699446357694935872197913;
#TEST:bessJn(3,9)    ==-0.18093519033665684004269704611853713381;
#TEST:bessJn(7,5)    ==0.05337641015589071543068731454162964583;
#TEST:bessJn(7,9)    ==0.32746087924245292511589576597394823065;
#TEST:bessJv(10.2,10)==0.1893485360342877215129;
#TEST:bessYn(0,5)    ==-0.3085176252490337800737;
#TEST:bessYn(1,5)    ==0.1478631433912268448011;
#TEST:bessYn(10,5)   ==-25.12911009561009673738;
#TEST:bessYn(10,9)   ==-0.545464485725335449017;
#TEST:bessYv(10.2,10)==-0.38951921431588599144;
#TEST:bess_jn(10,10) ==0.0646051544925642642714;
#TEST:bess_yn(10,10) ==-0.1724536720880578488518;
#TEST:bess_jn(0,0.5) ==2*sin(0.5);
#TEST:bess_jn(0,1)   ==sin(1);
#TEST:bess_jn(1,1)   ==sin(1)-cos(1);
#TEST:bess_jn(1,2)   ==sin(2)/4-cos(2)/2;
#TEST:bess_yn(0,0.5) ==-2*cos(0.5);
#TEST:bess_yn(0,1)   ==-cos(1);
#TEST:bess_yn(1,1)   ==-sin(1)-cos(1);
#TEST:bess_yn(1,2)   ==-cos(2)/4-sin(2)/2;
#   IIIIIIIIIInsert-End --------------------------- bessel.fwip #
#   IIIIIIIIIInsert-Begin ---------------------- partition.fwip #
#    COPYRIGHT C 2017-2020 by Kevin D. Woerner
# 2020-07-27 kdw  partition:block syntax
# 2020-07-24 kdw  partition:comment cleanup
# 2020-06-22 kdw  partition:local-use mved before var decls
# 2020-06-03 kdw  partition:writeonly keyword
# 2020-05-11 kdw  partition:local-decl syntx change
# 2020-04-15 kdw  partition:funcs ret doubles
# 2020-04-14 kdw  partition:tests
# 2020-04-12 kdw  partition:comment change
# 2020-03-09 kdw  partition:LO[C]AL_.* keywords
# 2020-03-03 kdw  partition:comment changed:odd chars
# 2020-03-02 kdw  partition:s/_N[E]XT/_E[N]D/; indent block
# 2019-12-27 kdw  partition:eplicit K[w] module
# 2019-12-26 kdw  partition:module name added to funcs
# 2019-10-04 kdw  partition:comment change
# 2019-08-06 kdw  partition:rmed backslashes, macro arg renam
# 2019-05-28 kdw  partition:comment changed
# 2019-05-24 kdw  partition:local replaced private
# 2019-05-22 kdw  partition:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-03-19 kdw  partition:re[t]_val to re[t]valu
# 2018-05-14 kdw  partition:BLO?CK syntax change
# 2018-04-26 kdw  partition:comment change
# 2018-04-24 kdw  partition:func descriptions; BL?OCKs
# 2018-04-03 kdw  partition:rm() from return
# 2018-04-02 kdw  partition:Pro?totype, et al.
# 2017-07-03 kdw  partition:rmed useless comments
# 2017-05-03 kdw  partition:PROT?OTYPE format changed
# 2017-04-30 kdw  partition:func to function
# 2017-04-11 kdw  partition:created
BLOCK:# partition function
   BLOCK_DEF DBL lv_partitionr_arr[0];
   BLOCK_DEF INT lv_partitionr_end = 0;
   #   FFFFFFFFFFunction ---------------------------- partition #
   FUNC DBL partition(INT nn):
      # number of partitions of NN
      # E.g. partition(5) = 7 since 5 ==
      #    1+1+1+1+1, 1+1+1+2, 1+1+3, 1+4,
      #    1+2+2, 2+3, and 5
      # PARTITION(nn) = 0
      #      + PARTITION(NN -  1) + PARTITION(NN -  1 - 1)
      #      - PARTITION(NN -  5) - PARTITION(NN -  5 - 2)
      #      + PARTITION(NN - 12) + PARTITION(NN - 12 - 3)
      #      - PARTITION(NN - 22) - PARTITION(NN - 22 - 4)
      #      + PARTITION(NN - 35) + PARTITION(NN - 35 - 5)
      #      - PARTITION(NN - 51) - PARTITION(NN - 51 - 6) ...
      # where 1,5,12,22,35 comes from(3*kk*kk-kk) / 2
      #       1, 2, 5, 7, 12, 15, 22, 26, 35, 40, 51, 57
      #        +1 +3 +2 +5  +3  +7  +4  +9  +5  +11 +6
      BLOCK_USE lv_partitionr_arr[];
      BLOCK_USE lv_partitionr_end;
      DBL retvalu;
      INT jj;
      INT mm;
      INT kk;
      DBL sum;
      DBL ssign;
      IF nn < 0:
         retvalu = 0;
      ELSE:
         IF lv_partitionr_end <= 0:
            lv_partitionr_end = 6;
            REDIM lv_partitionr_arr[], lv_partitionr_end;
            lv_partitionr_arr[0] = 1;
            lv_partitionr_arr[1] = 1;
            lv_partitionr_arr[2] = 2;
            lv_partitionr_arr[3] = 3;
            lv_partitionr_arr[4] = 5;
            lv_partitionr_arr[5] = 7;
         IF_END
         IF lv_partitionr_end <= nn:
            mm = lv_partitionr_end;
            lv_partitionr_end = nn + 1;
            REDIM lv_partitionr_arr[], lv_partitionr_end;
            WHILE mm < lv_partitionr_end:
               sum = 0;
               ssign = 1;
               kk = 1;
               jj = mm - 1;
               WHILE 0 <= jj:
                  sum += ssign * lv_partitionr_arr[jj];
                  jj -= kk;
                  IF jj < 0:
                     WHILE_EXIT;
                  IF_END
                  sum += ssign * lv_partitionr_arr[jj];
                  ssign = -ssign;
                  kk += 1;
                  jj -= (2 * kk - 1);
               WHILE_END
               lv_partitionr_arr[mm] = sum;
               mm += 1;
            WHILE_END
         IF_END
         retvalu = lv_partitionr_arr[nn];
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END# partition function
#TEST:partition(30)-5604
BLOCK:# partitionq function
   BLOCK_DEF DBL lv_partitionq_arr[0];
   BLOCK_DEF INT lv_partitionq_end = 0;
   #   FFFFFFFFFFunction --------------------------- partitionq #
   FUNC DBL partitionq(INT nn):
      # number of partitions of NN into distinct parts
      # == number of partitions of NN into odd parts
      # E.G.: partitionq(8) = 6 since:
      #    one can partition 8 into distinct parts 6 ways:
      #       1+2+5, 1+3+4, 1+7, 2+6, 3+5, 8,
      #    and one can partition 8 into odd parts 6 ways:
      #       1+1+1+1+1+1+1+1, 1+1+1+1+1+3,
      #       1+1+3+3, 1+1+1+5, 1+7, 3+5
      BLOCK_USE lv_partitionq_arr[];
      BLOCK_USE lv_partitionq_end;
      DBL retvalu;
      INT jj;
      INT mm;
      INT kk;
      DBL sum;
      DBL ssign;
      INT ee;
      IF nn < 0:
         retvalu = 0;
      ELSE:
         IF lv_partitionq_end <= 0:
            lv_partitionq_end = 6;
            REDIM lv_partitionq_arr[], lv_partitionq_end;
            lv_partitionq_arr[0] = 1;
            lv_partitionq_arr[1] = 1;
            lv_partitionq_arr[2] = 1;
            lv_partitionq_arr[3] = 2;
            lv_partitionq_arr[4] = 2;
            lv_partitionq_arr[5] = 3;
         IF_END
         IF lv_partitionq_end <= nn:
            mm = lv_partitionq_end;
            lv_partitionq_end = nn + 1;
            REDIM lv_partitionq_arr[], lv_partitionq_end;
            WHILE mm < lv_partitionq_end:
               sum = 0;
               ssign = 1;
               kk = 1;
               jj = mm - 1;
               WHILE 0 <= jj:
                  sum += ssign * lv_partitionq_arr[jj];
                  jj -= kk;
                  IF jj < 0:
                     WHILE_EXIT;
                  IF_END
                  sum += ssign * lv_partitionq_arr[jj];
                  ssign = -ssign;
                  kk += 1;
                  jj -= (2 * kk - 1);
               WHILE_END
               ee = Kw.round(SQRT(1.0 + 12.0 * mm) / 6.0);
               IF mm == (3 * ee * ee - ee) OR mm == (3 * ee
                     * ee + ee):
                  IF Kw.isodd(ee):
                     sum -= 1;
                  ELSE:
                     sum += 1;
                  IF_END
               IF_END
               lv_partitionq_arr[mm] = sum;
               mm += 1;
            WHILE_END
         IF_END
         retvalu = lv_partitionq_arr[nn];
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END# partitionq function
#TEST:partitionq(30)-296
#   IIIIIIIIIInsert-End ------------------------ partition.fwip #
#   IIIIIIIIIInsert-Begin --------------------------- bits.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-20 kdw  bits:boolean checks changed
# 2020-08-17 kdw  bits:macro syntax changed
# 2020-07-25 kdw  bits:s/BITWISE/BIT/
# 2020-07-24 kdw  bits:comment cleanup
# 2020-06-17 kdw  bits:Modulo operator
# 2020-05-18 kdw  bits:while conditios redo
# 2020-05-13 kdw  bits:lang_.* vars
# 2020-05-12 kdw  bits:language syntax
# 2020-04-20 kdw  bits:language work
# 2020-04-14 kdw  bits:tests added
# 2020-04-12 kdw  bits:comment change
# 2020-04-09 kdw  bits:MO[D]E syntax change
# 2020-04-08 kdw  bits:preprocess sigil change
# 2020-03-06 kdw  bits:L[A]NG.* names
# 2020-03-03 kdw  bits:language simplified; comments changed
# 2020-03-02 kdw  bits:s/_N[E]XT/_E[N]D/
# 2020-01-21 kdw  bits:minor cleanup
# 2019-12-26 kdw  bits:module name addded to funcs
# 2019-10-08 kdw  bits:comment change
# 2019-10-04 kdw  bits:comment change
# 2019-09-10 kdw  bits:LAN[G]UAGE NOT to LAN[G]UAGE_N[O]T
# 2019-08-26 kdw  bits:PRI[N]TS to PR[I]NTSTR
# 2019-08-24 kdw  bits:BC: fixed
# 2019-08-19 kdw  bits:language work
# 2019-08-11 kdw  bits:language comments
# 2019-08-06 kdw  bits:rmed backshlashes, macro arg renam
# 2019-07-31 kdw  bits:bit to bitwise func nams
# 2019-06-02 kdw  bits:func desc added
# 2019-05-22 kdw  bits:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-03-19 kdw  bits:re[t]_val to re[t]valu
# 2019-03-08 kdw  bits:rmed ampersand
# 2018-06-09 kdw  bits:mved tests
# 2018-06-08 kdw  bits:tests
# 2018-05-18 kdw  bits:LAN[G]UAGE syntax change
# 2018-05-13 kdw  bits:MO?DE.* syntax change
# 2018-04-03 kdw  bits:rm() from return
# 2018-04-02 kdw  bits:Pro?totype, et al.
# 2018-04-01 kdw  bits:LAN[G]UAGE_E[N]D
# 2017-10-23 kdw  bits:lang is any fix
# 2017-10-21 kdw  bits:macros start with "at"
# 2017-10-20 kdw  bits:LAN[G]UAGE syntax changed
# 2017-06-29 kdw  bits:comment changed
# 2017-06-21 kdw  bits:LAN[G].* AND MASTER.* change
# 2017-05-03 kdw  bits:PROT?OTYPE format changed
# 2017-04-21 kdw  bits:func to function
# 2017-03-13 kdw  bits:forgotten ";" in bitor, binand
# 2017-03-10 kdw  bits:get Fw[i]p_Pa[r]se to work
# 2017-03-07 kdw  bits:INS?ERT etal
# 2017-03-06 kdw  bits:sigils rmed
# 2017-03-01 kdw  bits:var[y]log-a[d]d space messup
# 2017-02-28 kdw  bits:REQ[U]IRE function()
# 2017-02-24 kdw  bits:LAN[G]UAGE change
# 2017-02-14 kdw  bits:FWIP Loop syntax changed
# 2017-02-13 kdw  bits:FWIP language change
# 2017-02-12 kdw  bits:FWIP language change
# 2017-02-08 kdw  bits:"?"PRO?TOT?YPE
# 2017-02-07 kdw  bits:comment change
# 2017-01-19 kdw  bits:var name change
# 2017-01-06 kdw  bits:"?"LAN[G]UAGE_I[F] deprecated
# 2016-12-08 kdw  bits:comment change
# 2016-11-23 kdw  bits:comment cleanup
# 2016-11-21 kdw  bits:DE?F to FU?NC
# 2016-11-20 kdw  bits:language change
# 2016-11-15 kdw  bits:B?ITS*/MO?D change
# 2016-11-07 kdw  bits:__LA?NG* syntax change
# 2016-09-14 kdw  bits:lang change
# 2016-05-18 kdw  bits:comment change
# 2016-04-27 kdw  bits:comment cleanup
# 2015-12-30 kdw  bits:_?_DEC?LARE_?_
# 2015-12-21 kdw  bits:_[_]E[L]SE[_]_
# 2015-12-14 kdw  bits:long lines
# 2015-12-11 kdw  bits:_[_]EN[D]IF_[_] obsoleted
# 2015-12-07 kdw  bits:bits_[sg]et
# 2015-12-03 kdw  bits:rmed arcane functions
# 2015-12-02 kdw  bits:shortened function names
# 2015-11-18 kdw  bits:shortened long comments
# 2015-11-13 kdw  bits:long lines changed
# 2015-11-12 kdw  bits:rmed spurious comments
# 2015-10-01 kdw  bits:is* functions
# 2015-09-30 kdw  bits:rmed "**"
# 2015-09-25 kdw  bits:B[I]T* format change
# 2015-09-24 kdw  bits:bit ops changed
# 2015-09-22 kdw  bits:_[_]* format changed
# 2015-09-20 kdw  bits:created
LANGUAGE_NOT LANG_BC:# define bitwise functions
   #   FFFFFFFFFFunction --------------------------- bitwisenot #
   FUNC INT bitwisenot(INT xx):
      # bitwise logical Not of XX
      INT retvalu;
      MODE_INTEGER:
         retvalu = BITNOT(xx);
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- bitwiseand #
   FUNC INT bitwiseand(INT xx
         , INT yy):
      # bitwise logical And of XX and YY
      INT retvalu;
      MODE_INTEGER:
         retvalu = BITAND(xx, yy);
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ---------------------------- bitwiseor #
   FUNC INT bitwiseor(INT xx
         , INT yy):
      # bitwise logical Or of XX and YY
      INT retvalu;
      MODE_INTEGER:
         retvalu = BITOR(xx, yy);
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- bitwisexor #
   FUNC INT bitwisexor(INT xx
         , INT yy):
      # bitwise logical Xor of XX and YY
      INT retvalu;
      MODE_INTEGER:
         retvalu = BITXOR(xx, yy);
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END
LANGUAGE_END# define bitwise functions
LANGUAGE LANG_BC:# define bitwise functions
   #   FFFFFFFFFFunction --------------------------- bitwisenot #
   FUNC INT bitwisenot(INT xx):
      # bitwise logical Not of XX
      INT retvalu;
      MODE_INTEGER:
         retvalu = -1 - xx;
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- bitwiseand #
   FUNC INT bitwiseand(INT xx
         , INT yy):
      # bitwise logical And of XX and YY
      # bitwiseand calls bitwiseor, and visa versa
      INT retvalu;
      INT nn;
      INT tt;
      INT aa;
      INT bb;
      INT qxx;
      INT qyy;
      MODE_INTEGER:
         IF xx < 0 AND yy < 0:
            retvalu = (-1 - bitwiseor(-1 - xx, - 1 - yy));
         ELSE:
            nn = 0;
            xx /= 1;
            yy /= 1;
            IF xx < 0:
               xx = -1 - xx;
               nn = 1;
            IF_END
            IF yy < 0:
               tt = -1 - yy;
               yy = xx;
               xx = tt;
               nn = 1;
            IF_END
            retvalu = 0;
            tt = 1;
            WHILE 0 < xx OR 0 < yy:
               qxx = xx / 4;
               qyy = yy / 4;
               aa = xx - 4 * qxx;
               IF 0 < nn:
                  aa = 3 - aa;
               IF_END
               bb = yy - 4 * qyy;
               IF aa <> bb:
                  aa += bb - 3;
                  IF aa < 0:
                     aa = 0;
                  IF_END
               IF_END
               retvalu += tt * aa;
               # base 4 is faster
               tt *= 4;
               xx = qxx;
               yy = qyy;
            WHILE_END
         IF_END
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ---------------------------- bitwiseor #
   FUNC INT bitwiseor(INT xx
         , INT yy):
      # bitwise logical Or of XX and YY
      INT retvalu;
      INT tt;
      INT aa;
      INT bb;
      INT cc;
      INT qxx;
      INT qyy;
      MODE_INTEGER:
         IF xx < 0 OR yy < 0:
            retvalu = (-1 - bitwiseand(-1 - xx, - 1 - yy));
         ELSE:
            xx /= 1;
            yy /= 1;
            retvalu = 0;
            tt = 1;
            WHILE 0 < xx OR 0 < yy:
               qxx = xx / 4;
               qyy = yy / 4;
               aa = xx - 4 * qxx;
               bb = yy - 4 * qyy;
               IF aa <> bb:
                  aa += bb;
                  IF 3 < aa:
                     aa = 3;
                  IF_END
               IF_END
               retvalu += tt * aa;
               # base 4 is faster
               tt *= 4;
               xx = qxx;
               yy = qyy;
            WHILE_END
         IF_END
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- bitwisexor #
   FUNC INT bitwisexor(INT xx
         , INT yy):
      # bitwise logical Xor of XX and YY
      INT retvalu;
      INT nn;
      INT tt;
      INT aa;
      INT bb;
      INT cc;
      INT qxx;
      INT qyy;
      MODE_INTEGER:
         nn = 0;
         xx /= 1;
         yy /= 1;
         IF xx < 0:
            xx = -1 - xx;
            nn = 1 - nn;
         IF_END
         IF yy < 0:
            yy = -1 - yy;
            nn = 1 - nn;
         IF_END
         retvalu = 0;
         tt = 1;
         WHILE 0 < xx OR 0 < yy:
            qxx = xx / 4;
            qyy = yy / 4;
            aa = xx - 4 * qxx;
            bb = yy - 4 * qyy;
            cc = aa + bb;
            IF Kw.iseven(cc):
               cc = aa + 4 - bb;
            IF_END
            # base 4 is faster
            retvalu += tt * (cc % 4);
            tt *= 4;
            xx = qxx;
            yy = qyy;
         WHILE_END
         IF 0 < nn:
            retvalu = -1 - retvalu;
         IF_END
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END
LANGUAGE_END# define bitwise functions
#   FFFFFFFFFFunction ------------------------------- bitshiftl #
FUNC INT bitshiftl(INT hexnumber
      , INT shift_count):
   # shift HEXNUMBER left by SHIFT_COUNT bits
   INT retvalu;
   IF shift_count < 0:
      retvalu = BITSHIFTR(hexnumber, - shift_count);
   ELSIF 0 < shift_count:
      retvalu = BITSHIFTL(hexnumber, shift_count);
   ELSE:
      retvalu = hexnumber;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- bitshiftr #
FUNC INT bitshiftr(INT hexnumber
      , INT shift_count):
   # shift HEXNUMBER right by SHIFT_COUNT bits
   INT retvalu;
   IF shift_count < 0:
      retvalu = BITSHIFTL(hexnumber, - shift_count);
   ELSIF 0 < shift_count:
      retvalu = BITSHIFTR(hexnumber, shift_count);
   ELSE:
      retvalu = hexnumber;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ bits_count #
FUNC INT bits_count(INT hexnumber):
   # count the number of 1 bits in HEXNUMBER
   INT bit_counter;
   INT bitmask;
   bitmask = 1;
   bit_counter = 0;
   WHILE bitmask <= hexnumber:
      IF bitwiseand(bitmask, hexnumber) <> 0:
         bit_counter += 1;
      IF_END
      bitmask = BITSHIFTL(bitmask, 1);
   WHILE_END
   RETURN bit_counter;
FUNC_END
#TEST:bits_count(107717)-8;
#   FFFFFFFFFFunction ------------------------------- bits_ls1b #
FUNC INT bits_ls1b(INT orig):
   # bitmask of the least-signifigant non-zero bit in ORIG
   INT divisor;
   INT retvalu;
   IF orig == 0:
      retvalu = 0;
   ELSE:
      divisor = 1;
      WHILE 0 == BITAND(divisor, orig):
         divisor *= 2;
      WHILE_END
      retvalu = divisor;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:bits_ls1b(56)-8;
#   FFFFFFFFFFunction ------------------------------- bits_ms1b #
FUNC INT bits_ms1b(INT orig):
   # bitmask of the most-signifigant non-zero bit in ORIG
   # ASSUMES A TWOS-COMPLEMENT MACHINE
   INT divisor;
   INT retvalu;
   IF orig == 0:
      retvalu = 0;
   ELSE:
      divisor = -2;
      WHILE BITAND(divisor, orig) <> 0:
         divisor *= 2;
      WHILE_END
      retvalu = -divisor / 2;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- bits_ls1bpos #
FUNC INT bits_ls1bpos(INT orig):
   # location of the least-signifigant non-zero bit in ORIG
   #    == count of 0s on the right end of ORIG
   INT divisor;
   INT retvalu;
   INT bit_count;
   IF orig == 0:
      retvalu = -1;
   ELSE:
      divisor = 1;
      bit_count = 0;
      WHILE 0 == BITAND(divisor, orig):
         divisor *= 2;
         bit_count += 1;
      WHILE_END
      retvalu = bit_count;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:bits_ls1bpos(80)-4;
#   FFFFFFFFFFunction ---------------------------- bits_ms1bpos #
FUNC INT bits_ms1bpos(INT orig):
   # location of the most-signifigant non-zero bit in ORIG
   #    == (count of binary digits in ORIG) - 1
   # ASSUMES A TWOS-COMPLEMENT MACHINE
   INT divisor;
   INT retvalu;
   INT bit_count;
   IF orig == 0:
      retvalu = 0;
   ELSE:
      divisor = -2;
      bit_count = 0;
      WHILE BITAND(divisor, orig) <> 0:
         divisor *= 2;
         bit_count += 1;
      WHILE_END
      retvalu = bit_count;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------- bits_assign #
FUNC INT bits_assign(INT orig
      , INT value_to_set
      , INT which_mask):
   # assign VALUE_TO_SET to bits WHICH_MASK in ORIG
   INT divisor;
   INT retvalu;
   INT tempo;
   INT tempv;
   IF which_mask == 0:
      retvalu = orig;
   ELSE:
      divisor = bits_ls1bpos(which_mask);
      # first, clear target bits in ORIG:
      tempo = BITAND(orig, BITNOT(which_mask));
      # second, set the appropriate bit s in TEMPV
      tempv = BITSHIFTL(value_to_set, divisor);
      retvalu = BITOR(tempo, BITAND(tempv, which_mask));
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:bits_assign(170,5,112)-218;
#   FFFFFFFFFFunction -------------------------------- bits_get #
FUNC INT bits_get(INT vall
      , INT mask):
   # value of VALL And MASK right justified
   RETURN BITAND(vall, mask) / bits_ls1b(mask);
FUNC_END
#TEST:bits_get(436940,992)-22;
#   FFFFFFFFFFunction -------------------------------- bits_set #
FUNC INT bits_set(INT vall
      , INT mask):
   # value of VALL shifted left into MASK
   RETURN BITAND(vall * bits_ls1b(mask), mask);
FUNC_END
#TEST:bits_set(5,112)-80;
#   IIIIIIIIIInsert-End ----------------------------- bits.fwip #
#   IIIIIIIIIInsert-Begin ---------------------------- erf.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-17 kdw  erf:macro syntax changed
# 2020-07-27 kdw  erf:block syntax
# 2020-07-24 kdw  erf:comment cleanup
# 2020-07-20 kdw  erf:erf__3 tweak
# 2020-07-16 kdw  erf:erf_[_]4 work
# 2020-07-15 kdw  erf:erf__[34] work
# 2020-07-10 kdw  erf:polynomial refactor
# 2020-07-01 kdw  erf:tests modified
# 2020-06-30 kdw  erf:tests changed
# 2020-06-16 kdw  erf:comments changed
# 2020-06-09 kdw  erf:comments changed
# 2020-06-06 kdw  erf:comments added
# 2020-05-13 kdw  erf:comment trivially changed
# 2020-05-11 kdw  erf:block added
# 2020-05-06 kdw  erf:rmed boolean vars
# 2020-04-26 kdw  erf:block indentation
# 2020-04-12 kdw  erf:comment change
# 2020-04-08 kdw  erf:preprocess sigil change
# 2020-04-05 kdw  erf:py: lf_ca[l]erf work
# 2020-04-02 kdw  erf:erf rework
# 2020-03-25 kdw  erf:tests
# 2020-03-09 kdw  erf:LO[C]AL_.* keywords
# 2020-03-05 kdw  erf:s/TRU[E]VAL/TR[U]E/;s/FALS[E]VAL/FA[L]SE/
# 2020-03-03 kdw  erf:comment change
# 2020-03-01 kdw  erf:.*_NE[X]T deprecated, et al.
# 2020-02-28 kdw  erf:poly eval work
# 2020-02-26 kdw  erf:arr[a]y and hor[n]er work
# 2020-02-15 kdw  erf:array comment change
# 2019-12-26 kdw  erf:module name addded to funcs
# 2019-11-17 kdw  erf:include Macros file
# 2019-10-04 kdw  erf:comment change
# 2019-08-24 kdw  erf:for and count loops have from clause
# 2019-08-18 kdw  erf:B[O]OL to B[O]L
# 2019-08-11 kdw  erf:comment cleanup
# 2019-08-06 kdw  erf:rmed backslashes
# 2019-07-03 kdw  erf:rmed commented out code
# 2019-05-29 kdw  erf:comment changed
# 2019-05-24 kdw  erf:local replaced private
# 2019-05-22 kdw  erf:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-05-16 kdw  erf:loop limit def mved
# 2019-05-01 kdw  erf:consts explicit module name
# 2019-03-19 kdw  erf:re[t]_val to re[t]valu
# 2019-03-18 kdw  erf:macro syntax changed
# 2019-03-11 kdw  erf:comments to array dcls
# 2019-03-08 kdw  erf:is[e]qual to is[e]q, et al.
# 2019-03-06 kdw  erf:is.* funcs changed
# 2019-03-04 kdw  erf:loop-limit work
# 2019-01-03 kdw  erf:Await counter changed
# 2018-07-22 kdw  erf:erf refactor
# 2018-07-21 kdw  erf:comments
# 2018-07-19 kdw  erf:comments; array reformat
# 2018-07-18 kdw  erf:func renam
# 2018-07-17 kdw  erf:private lf_.* funcs
# 2018-07-13 kdw  erf:float number reformt
# 2018-07-11 kdw  erf:var nam change
# 2018-05-17 kdw  erf:ARR?AY.* and HOR[N]ER syntax
# 2018-05-16 kdw  erf:AR?RAY syntax
# 2018-04-03 kdw  erf:rm() from return
# 2018-03-26 kdw  erf:macro redef
# 2018-03-12 kdw  erf:made PP statements not need semicolon
# 2018-02-17 kdw  erf:bounded await loops
# 2018-02-15 kdw  erf:python debugging
# 2018-02-14 kdw  erf:P[I] changed
# 2017-11-26 kdw  erf:FR[O]M, B[Y] keywords; deprecate CO[U]NT
# 2017-10-24 kdw  erf:Underscored numbers
# 2017-10-23 kdw  erf:AR[R]AY syntax
# 2017-10-21 kdw  erf:macros start with "at""at"
# 2017-10-20 kdw  erf:COM[M]ENT format change
# 2017-09-20 kdw  erf:rmed useless trailing 0s
# 2017-08-30 kdw  erf:s/DBL_/DBL/;s/FLT_/FLT/
# 2017-04-26 kdw  erf:keyword COM[M]ENT.*
# 2017-04-21 kdw  erf:comment change
# 2017-04-20 kdw  erf:func to function
# 2017-03-10 kdw  erf:get Fw[i]p_Pa[r]se to work
# 2017-03-06 kdw  erf:sigils rmed
# 2017-02-26 kdw  erf:var renam
# 2017-02-24 kdw  erf:REP[L]ACE rework, et al
# 2017-02-20 kdw  erf:array var names
# 2017-02-14 kdw  erf:FWIP Loop syntax changed
# 2017-02-12 kdw  erf:FWIP language change
# 2017-02-07 kdw  erf:comment rearrangement
# 2017-01-06 kdw  erf:?[?]USE.* to ?[?].*_MODE; ?[?]DIGR.*
# 2016-11-23 kdw  erf:support of I?NT deprecated
# 2016-11-21 kdw  erf:DE?F to FU?NC
# 2016-11-20 kdw  erf:language change
# 2016-11-18 kdw  erf:_?_P?OD_?_
# 2016-11-14 kdw  erf:LA[N]G stuff
# 2016-11-11 kdw  erf:seca?nt algorithm refactor
# 2016-11-08 kdw  erf:bound loops
# 2016-10-31 kdw  erf:comment reorg; lang change
# 2016-09-13 kdw  erf:lang change
# 2016-07-02 kdw  erf:format tweak
# 2016-06-01 kdw  erf:comment change
# 2016-05-18 kdw  erf:comment change
# 2015-12-31 kdw  erf:bounded possible infinite loops
# 2015-12-28 kdw  erf:_?_I?F_X_?_ to _?_IF_NONE_?_
# 2015-12-25 kdw  erf:rmed unused functions
# 2015-12-15 kdw  erf:comment cleanup
# 2015-12-14 kdw  erf:erf[c]xinv refactor
# 2015-12-11 kdw  erf:s/LC_// from some consts
# 2015-11-26 kdw  erf:long lines
# 2015-11-18 kdw  erf:shortened comments
# 2015-11-17 kdw  erf:tweak
# 2015-11-16 kdw  erf:tweak
# 2015-11-13 kdw  erf:shorten lines
# 2015-10-27 kdw  erf:minor refactor of erf
# 2015-10-09 kdw  erf:renamed i[n]v functions
# 2015-10-01 kdw  erf:float equality checks to is.*
# 2015-09-30 kdw  erf:minor refactor of e[r]f
# 2015-09-20 kdw  erf:created
#   IIIIIIIIIInsert-Begin ------------------------- Macros.fwip #
#   IIIIIIIIIInsert-End --------------------------- Macros.fwip #
BLOCK:
      #   FFFFFFFFFFunction ----------------------------
   #lf_calerf #
   BLOCK_DEF FUNC DBL lf_calerf(DBL xx, INT jint):
      # Support function for erf funcs.
      # This routine was cannibalized from code written
      # by Peter John Acklam(email pjacklamonline.no),
      # and retrieved from http://cpansearch.perl.org/src/REID
      # /Games-Go-GoPair-1.001/Erf.pm
      # Coefficients from "Rational Chebyshev Approximations
      # for the Error Function" by W. J. Cody, Argonne National
      # Laboratory, 1969
      DBL result;
      DBL retvalu;
      DBL absx;
      DBL numer;
      DBL denom;
      DBL rsqrpi;
      DBL rxsq;
      DBL xsq;
      INT flag;
      absx = ABS(xx);
      xsq = xx * xx;
      flag = 0;
      IF absx <= 0.46875:
         numer = (((((1.85777706184603153E-1) * xsq
               + 3.16112374387056560E+0) * xsq
               + 1.13864154151050156E+2) * xsq
               + 3.77485237685302021E+2) * xsq
               + 3.20937758913846947E+3);
         denom = (((((1.00000000000000000E+0) * xsq
               + 2.36012909523441209E+1) * xsq
               + 2.44024637934444173E+2) * xsq
               + 1.28261652607737228E+3) * xsq
               + 2.84423683343917062E+3);
         # pickle
         retvalu = xx * numer / denom;
         IF jint == 1:
            retvalu = 1.0 - retvalu;
         ELSIF jint == 2:
            retvalu = EXP(xsq) * (1.0 - retvalu);
         IF_END
         flag = 1;
      ELSIF absx <= 4.0:
         # for 0.46875 < abs(x) <= 4.0
         numer = (((((((((2.15311535474403846E-8) * absx
               + 5.64188496988670089E-1) * absx
               + 8.88314979438837594E+0) * absx
               + 6.61191906371416295E+1) * absx
               + 2.98635138197400131E+2) * absx
               + 8.81952221241769090E+2) * absx
               + 1.71204761263407058E+3) * absx
               + 2.05107837782607147E+3) * absx
               + 1.23033935479799725E+3);
         denom = (((((((((1.00000000000000000E+0) * absx
               + 1.57449261107098347E+1) * absx
               + 1.17693950891312499E+2) * absx
               + 5.37181101862009858E+2) * absx
               + 1.62138957456669019E+3) * absx
               + 3.29079923573345963E+3) * absx
               + 4.36261909014324716E+3) * absx
               + 3.43936767414372164E+3) * absx
               + 1.23033935480374942E+3);
         result = numer / denom;
         # now result = EXP(xsq) * erfc(absx);
      ELSE:
         # for 4.0 < abs(x)
         rsqrpi = SQRT(1.0 / Kw.PI);
         IF jint <> 2 AND SQRT(LN(Kw.DBLMAX)) <= absx:
            result = 0.0;
         ELSIF jint == 2 AND 6.71E+7 <= absx:
            IF Kw.DBLMAX / 8.0 <= absx:
               result = 0.0;
            ELSE:
               result = rsqrpi / absx;
            IF_END
         ELSE:
            rxsq = 1.0 / (absx * absx);
            numer = ((((((-1.63153871373020978E+2) * rxsq
                  - 3.05326634961232344E+3) * rxsq
                  - 3.60344899949804439E+3) * rxsq
                  - 1.25781726111229246E+3) * rxsq
                  - 1.60837851487422766E+2) * rxsq
                  - 6.58749161529837803E+0);
            denom = ((((((1.00000000000000000E+4) * rxsq
                  + 2.56852019228982242E+4) * rxsq
                  + 1.87295284992346047E+4) * rxsq
                  + 5.27905102951428412E+3) * rxsq
                  + 6.05183413124413191E+2) * rxsq
                  + 2.33520497626869185E+1);
            result = (rsqrpi + rxsq * numer / denom) / absx;
            # now result = EXP(xsq) * erfc(absx);
         IF_END
      IF_END
      #  Fix up for negative argument, erf, etc.
      IF flag == 0:
         IF jint == 2:
            IF xx < - SQRT(LN(Kw.DBLMAX)):
               retvalu = Kw.DBLMAX;
            ELSIF xx < 0.0:
               retvalu = 2.0 * EXP(xsq) - result;
            ELSE:
               retvalu = result;
            IF_END
         ELSE:
            # now result = EXP(xsq) * erfc(absx);
            result *= EXP(-xsq);
            # now result == erfc(ABS(x))
            IF jint == 0:
               # done this way to prevent round off errors
               IF 0.0 <= xx:
                  retvalu = (0.5 - result) + 0.5;
               ELSE:
                  retvalu = -((0.5 - result) + 0.5);
               IF_END
               #now result=erf(x)
            ELSIF jint == 1:
               IF xx < 0.0:
                  retvalu = 2.0 - result;
               ELSE:
                  retvalu = result;
               IF_END
               # now retvalu=erfc(x)
            ELSE:
               retvalu = 0.0;
            IF_END
         IF_END
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ---------------------------------- erf #
   FUNC DBL erf(DBL xx):
      # The error function: domain = R; range = (-1,1)
      #        xx  EXP(-t*t)
      # INTEGRATE ---------- dt
      #       -xx  SQRT(PI)
      # via rational polynomial approximation
      RETURN lf_calerf(xx, 0);
   FUNC_END
   #   FFFFFFFFFFunction --------------------------------- erfc #
   FUNC DBL erfc(DBL xx):
      # One minus the error function: domain = R; range = (-1,1)
      RETURN lf_calerf(xx, 1);
   FUNC_END
   #   FFFFFFFFFFunction -------------------------------- erfcx #
   FUNC DBL erfcx(DBL xx):
      # EXP(x**2) * erfc(x)
      RETURN lf_calerf(xx, 2);
   FUNC_END
BLOCK_END
      #   FFFFFFFFFFunction ---------------------------------
   #erfcinv #
FUNC DBL erfcinv(DBL yy_orig):
   # inverse of erfc: domain = (0,2); range = R
   DBL retvalu;
   DBL xx;
   DBL yy;
   DBL xx_pr;
   DBL dx;
   DBL cc;
   DBL uu;
   INT ii;
   IF yy_orig <= 0.0:
      retvalu = Kw.DBLMAX / 2.0;
   ELSIF 2.0 <= yy_orig:
      retvalu = -(Kw.DBLMAX / 2.0);
   ELSIF Kw.iszero(yy_orig - 1.0):
      retvalu = 0.0;
   ELSE:
      # 0 < YY_ORIG < 1 OR 1 < YY_ORIG < 2
      IF 1.0 < yy_orig:
         yy = 2.0 - yy_orig;
      ELSE:
         yy = yy_orig;
      IF_END
      # now 0.0 < YY < 1.0
      dx = 1.0;
      xx = 0.0;
      cc = -SQRT(Kw.TAU / 8.0);
      AWAIT Kw.iseq(xx_pr, xx) COUNT ii FROM 0 TO 20:
         uu = cc * (erfcx(xx) - yy * EXP(xx * xx));
         dx = -uu / (1.0 + uu * xx);
         xx_pr = xx;
         xx += dx;
      AWAIT_END
      IF 1.0 < yy_orig:
         retvalu = -xx;
      ELSE:
         retvalu = xx;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- erfcxinv #
FUNC DBL erfcxinv(DBL yy):
   # inverse of erfcx
   DBL xx;
   DBL xx_pr;
   DBL dx;
   DBL cc;
   DBL ex;
   DBL df;
   DBL uu;
   INT ii;
   xx = 0.0;
   IF NOT Kw.iszero(yy - 1.0):
      dx = 1.0;
      cc = SQRT(8.0 / Kw.TAU);
      AWAIT Kw.iseq(xx_pr, xx) COUNT ii FROM 0 TO 20:
         ex = erfcx(xx);
         df = 2.0 * xx * ex - cc;
         uu = (ex - yy) / df;
         dx = -uu / (1.0 - uu * (xx + ex / df));
         xx_pr = xx;
         xx += dx;
      AWAIT_END
   IF_END
   RETURN xx;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- erfinv #
FUNC DBL erfinv(DBL yy):
   # inverse of erf: domain=(-1,1); range= R
   DBL retvalu;
   DBL xx;
   DBL xx_pr;
   DBL dx;
   DBL cc;
   DBL uu;
   INT ii;
   IF Kw.iszero(yy):
      retvalu = 0.0;
   ELSIF 0.5 < yy:
      retvalu = erfcinv(1.0 - yy);
   ELSIF yy < - 0.5:
      retvalu = -erfcinv(1.0 + yy);
   ELSE:
      dx = 1.0;
      xx = 0.0;
      cc = SQRT(Kw.TAU / 8.0);
      AWAIT Kw.iseq(xx_pr, xx) COUNT ii FROM 0 TO 20:
         uu = cc * (erf(xx) - yy) * EXP(xx * xx);
         dx = -uu / (1.0 + uu * xx);
         xx_pr = xx;
         xx += dx;
      AWAIT_END
      retvalu = xx;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- erf__1 #
FUNC DBL erf__1(DBL xx):
   # See Wikipedia::Error_Function::Numerical_approximation
   #::Approximation_with_elementary_functions
   DBL tt;
   DBL ans;
   DBL ply;
   tt = (1.0 / (1.0 + (0.5 * ABS(xx))));
   ply = ((((((((((1.70872770E-1) * tt - 8.22152230E-1) * tt
         + 1.48851587E+0) * tt - 1.13520398E+0) * tt
         + 2.78868070E-1) * tt - 1.86288060E-1) * tt
         + 9.67841800E-2) * tt + 3.74091960E-1) * tt
         + 1.00002368E+0) * tt - 1.26551223E+0);
   ans = 1.0 - tt * EXP((-xx * xx) + ply);
   IF xx < 0.0:
      ans = -ans;
   IF_END
   RETURN ans;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- erf__2 #
FUNC DBL erf__2(DBL xx):
   # See Wikipedia::Error_Function::Numerical_approximation
   #::Polynomial
   DBL tt;
   DBL ans;
   DBL ply;
   tt = 1.0 / (1.0 + 0.3275911 * ABS(xx));
   ply = ((((((1.061405429E+0) * tt - 1.453152027E+0) * tt
         + 1.421413741E+0) * tt - 2.844967360E-1) * tt
         + 2.548295920E-1) * tt + 0.000000000E+0);
   ans = 1.0 - EXP(-xx * xx) * ply;
   IF xx < 0.0:
      ans = -ans;
   IF_END
   RETURN ans;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- erf__3 #
FUNC DBL erf__3(DBL xx):
   #        xx  EXP(-t*t)
   # INTEGRATE  --------- dt
   #       -xx  SQRT(PI)
   # via Taylor series(for ABS(xx)<4.4) or asymptotic series
   # Range(-1, 1)  (includes endpoints due to rounding)
   DBL axx;
   DBL xxsq;
   DBL sum_curr;
   DBL factx;
   INT nn;
   DBL add_arr[80];
   INT kk;
   axx = ABS(xx);
   xxsq = xx * xx;
   IF axx < 4.4:
      factx = 1;
      # done this way to avoid catastrophic cancellation
      add_arr[0] = 1;
      AWAIT ABS(add_arr[nn]) < Kw.DBLEPS COUNT nn FROM 1 TO
            ARRAYLAST(add_arr[]):
         factx *= - xxsq / nn;
         add_arr[nn] = factx / (2.0 * nn + 1.0);
      AWAIT_END
      sum_curr = 0;
      FOR kk FROM nn TO 0 BY - 1:
         sum_curr += add_arr[kk];
      FOR_END
      sum_curr *= (2.0 * xx / SQRT(Kw.PI));
   ELSE:
      # this uses an asymptotic series for erf(x)
      factx = -EXP(-xxsq) / SQRT(Kw.PI);
      sum_curr = 0.0;
      kk = Kw.round(xxsq);
      FOR nn FROM 1 TO kk - 1:
         factx *= - (2.0 * nn - 1.0) / (2.0 * xxsq);
         sum_curr += factx;
      FOR_END
      sum_curr += 1.0 - EXP(-xxsq) / SQRT(Kw.PI) / axx;
      IF xx < 0:
         sum_curr = -sum_curr;
      IF_END
   IF_END
   RETURN sum_curr;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- erf__4 #
FUNC DBL erf__4(DBL xx):
   #        xx  EXP(-t*t)
   # INTEGRATE  --------- dt
   #       -xx  SQRT(PI)
   # via Taylor series(for ABS(xx)<4.4) or asymptotic series
   #  Range(-1, 1)  (includes endpoints due to rounding)
   DBL xxsq;
   DBL axx;
   DBL sum_prev;
   DBL sum_curr;
   INT nn;
   INT kk;
   INT twonnpone;
   DBL factx;
   DBL factz;
   DBL twoxxsq;
   DBL term;
   axx = ABS(xx);
   xxsq = xx * xx;
   twoxxsq = 2.0 * xxsq;
   sum_curr = 0.0;
   IF axx < 4.4:
      factz = (2.0 * xx / SQRT(Kw.PI));
      factx = factz;
      # adjacent terms combined to avoid cancellation
      AWAIT Kw.iseq(sum_prev, sum_curr) COUNT nn FROM 3 BY 2:
         twonnpone = 2 * nn + 1;
         factx *= xxsq * xxsq / ((nn - 1) * nn);
         term = (factx * (twonnpone * (nn - xxsq) + twoxxsq)
               / (4.0 * nn * nn - 1.0));
         sum_prev = sum_curr;
         sum_curr += term;
      AWAIT_END
      sum_curr += (1.0 - xxsq / 3.0) * factz;
   ELSE:
      # this uses an asymptotic series for erf(x)
      factx = -EXP(-xxsq) / (xx * SQRT(Kw.PI));
      # adjacent terms combined to avoid cancellation
      kk = Kw.round(xxsq);
      FOR nn FROM 1 TO kk - 5 BY 2:
         factx *= nn * (nn + 1) / (twoxxsq * twoxxsq);
         term = factx * (1.0 - (2.0 * nn + 1) / twoxxsq);
         sum_prev = sum_curr;
         sum_curr += term;
         IF Kw.iseq(sum_prev, sum_curr):
            FOR_EXIT;
         IF_END
      FOR_END
      sum_curr += 1.0 - EXP(-xxsq) / SQRT(Kw.PI) / axx;
      IF xx < 0.0:
         sum_curr = -sum_curr;
      IF_END
   IF_END
   RETURN sum_curr;
FUNC_END
#TEST:erfinv(erf(0.23))==0.23;
#TEST:erfc(0.5)  ==0.4795001221869534623172533461080354712635484;
#TEST:erf(0.5)   ==0.520499877813046537682746653891964528736;
#TEST:erf__3(0.5)==0.520499877813046537682746653891964528736;
#TEST:erf__4(0.5)==0.520499877813046537682746653891964528736;
#TEST:erf(1)     ==0.842700792949714869341220635082609259296067;
#TEST:erf__3(1)  ==0.842700792949714869341220635082609259296067;
#TEST:erf__4(1)  ==0.842700792949714869341220635082609259296067;
#TEST:erfc(1.5)  ==0.0338948535246892729330237383540521413185895;
#TEST:erf(1.5)   ==0.9661051464753107270669762616459478586814105;
#TEST:erf__3(1.5)==0.9661051464753107270669762616459478586814105;
#TEST:erf__4(1.5)==0.9661051464753107270669762616459478586814105;
#TEST:erf(5.0)   ==0.9999999999984625402055719651498116565146166;
#TEST:erf__4(5.0)==0.9999999999984625402055719651498116565146166;
#TEST:erf__3(5.0)==0.9999999999984625402055719651498116565146166;
#   IIIIIIIIIInsert-End ------------------------------ erf.fwip #
#   IIIIIIIIIInsert-Begin -------------------------- gamma.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-19 kdw  gamma:comment change
# 2020-08-17 kdw  gamma:macro syntax changed
# 2020-08-03 kdw  gamma:explicit module for pi and tau
# 2020-07-27 kdw  gamma:block syntax
# 2020-07-24 kdw  gamma:comment cleanup
# 2020-07-10 kdw  gamma:stirling tgamma work
# 2020-06-17 kdw  gamma:Modulo operator
# 2020-06-12 kdw  gamma:regularized ul-gamma function work
# 2020-06-08 kdw  gamma:integral function stuff
# 2020-06-06 kdw  gamma:comments added
# 2020-05-29 kdw  gamma:swapped lgamma and lgamma__1
# 2020-05-14 kdw  gamma:local funcs only in blocks
# 2020-05-11 kdw  gamma:BL[O]CK work
# 2020-04-26 kdw  gamma:block indentation
# 2020-04-13 kdw  gamma:numeric inequality work
# 2020-04-12 kdw  gamma:comment changed
# 2020-04-08 kdw  gamma:preprocess sigil change
# 2020-03-30 kdw  gamma:s/_cdfinv/_quantile/g
# 2020-03-29 kdw  gamma:regularize[lu]igamma
# 2020-03-29 kdw  gamma:tga[m]ma__[45] funcs
# 2020-03-26 kdw  gamma:hn__1; tests
# 2020-03-09 kdw  gamma:LO[C]AL_.* keywords
# 2020-03-03 kdw  gamma:comment changed:odd chars
# 2020-03-02 kdw  gamma:s/_NE[X]T/_E[N]D/g
# 2020-02-28 kdw  gamma:poly eval work
# 2020-02-26 kdw  gamma:arr[a]y and hor[n]er work
# 2020-02-16 kdw  gamma:array comments change
# 2020-02-14 kdw  gamma:incomplete beta work
# 2020-02-03 kdw  gamma:.*_LOOP changed
# 2020-01-31 kdw  gamma:func renam
# 2019-12-26 kdw  gamma:module name addded to funcs
# 2019-11-17 kdw  gamma:include Macros file
# 2019-09-17 kdw  gamma:rmed c[n]v_db[l]2i32
# 2019-08-24 kdw  gamma:for and count loops have from clause
# 2019-08-22 kdw  gamma:comment changed
# 2019-08-18 kdw  gamma:L[O]G to L[N]
# 2019-08-17 kdw  gamma:L[O]G to LN
# 2019-08-11 kdw  gamma:comment cleanup
# 2019-08-06 kdw  gamma:added "+" to array values
# 2019-06-02 kdw  gamma:func desc added
# 2019-05-31 kdw  gamma:NR_DO to RAPHSON_LOOP; et al
# 2019-05-29 kdw  gamma:comment changed
# 2019-05-24 kdw  gamma:local replaced private
# 2019-05-22 kdw  gamma:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-05-16 kdw  gamma:loop limit def mved
# 2019-05-01 kdw  gamma:consts explicit module name
# 2019-03-19 kdw  gamma:re[t]_val to re[t]valu
# 2019-03-18 kdw  gamma:macro syntax changed
# 2019-03-11 kdw  gamma:comments to array dcls
# 2019-03-08 kdw  gamma:is[e]qual to is[e]q, et al.
# 2019-03-04 kdw  gamma:loop-limit work
# 2019-01-23 kdw  gamma:lgamma--1 array back to exact
# 2019-01-13 kdw  gamma:var rena; reorg
# 2019-01-03 kdw  gamma:Await counter changed
# 2018-10-05 kdw  gamma:in digamm.*2 array size specd
# 2018-10-04 kdw  gamma:uppercased fwip trig funcs
# 2018-09-28 kdw  gamma:var renam
# 2018-07-22 kdw  gamma:digamma redef; private .*_sub
# 2018-07-18 kdw  gamma:digamma redef
# 2018-07-18 kdw  gamma:gamma work
# 2018-07-17 kdw  gamma:private lf_.* funcs
# 2018-07-13 kdw  gamma:float number reformt
# 2018-05-22 kdw  gamma:tga(m)ma2 description
# 2018-05-20 kdw  gamma:hnm()
# 2018-05-17 kdw  gamma:AR(R)AY.* and HOR[N]ER syntax
# 2018-05-16 kdw  gamma:A(R)RAY syntax
# 2018-04-03 kdw  gamma:rm() from return
# 2018-03-26 kdw  gamma:macro redef
# 2018-02-19 kdw  gamma:secant and macro refactor
# 2018-02-17 kdw  gamma:bounded await loops
# 2018-02-13 kdw  gamma:rmed T[A]N ref
# 2018-02-01 kdw  gamma:no net change
# 2018-01-26 kdw  gamma:comments
# 2018-01-16 kdw  gamma:birthdayx, lpermx
# 2018-01-03 kdw  gamma:combx, permx functions
# 2017-11-26 kdw  gamma:FR[O]M and B[Y] keywords
# 2017-11-22 kdw  gamma:var renam
# 2017-11-21 kdw  gamma:FR[O]M
# 2017-11-20 kdw  gamma:fixed tgamma
# 2017-11-19 kdw  gamma:double factorial tgamma2
# 2017-10-24 kdw  gamma:number underscore
# 2017-10-21 kdw  gamma:macros start with "at""at"
# 2017-10-20 kdw  gamma:var renam(no triple letters)
# 2017-09-20 kdw  gamma:rmed useless trailing 0s
# 2017-08-30 kdw  gamma:s/DBL_/DBL/;s/FLT_/FLT/
# 2017-08-24 kdw  gamma:vars renamd
# 2017-08-20 kdw  gamma:rmed/renamd .*_P[E]R_.* vars
# 2017-05-23 kdw  gamma:uigamma_sub fixed
# 2017-05-20 kdw  gamma:uigamma_sub functions
# 2017-05-19 kdw  gamma:[lu]igamma_sub functions
# 2017-05-18 kdw  gamma:lf_[lu]igamma_sub functions
# 2017-05-17 kdw  gamma:uigamma fixed; ligamma
# 2017-04-19 kdw  gamma:function hn
# 2017-03-30 kdw  gamma:comment cleanup
# 2017-03-21 kdw  gamma:lgammainv vs BC debugging
# 2017-03-19 kdw  gamma:comments
# 2017-03-12 kdw  gamma:shorten long comments
# 2017-03-10 kdw  gamma:get Fw[i]p_Pa[r]se to work
# 2017-03-07 kdw  gamma:IN(S)ERT etal
# 2017-03-06 kdw  gamma:sigils rmed
# 2017-03-01 kdw  gamma:var[y]log-a[d]d space messup
# 2017-02-28 kdw  gamma:REQ[U]IRE function()
# 2017-02-20 kdw  gamma:array var names
# 2017-02-14 kdw  gamma:FWIP Loop syntax changed
# 2017-02-13 kdw  gamma:FWIP language change
# 2017-02-12 kdw  gamma:FWIP language change
# 2017-02-09 kdw  gamma:lgammainv vs BC debugging
# 2017-02-08 kdw  gamma:SE[C]ANT syntax; syntax error in betainc
# 2017-02-07 kdw  gamma:comment rearrangement; SE[C]ANT stuff
# 2017-02-06 kdw  gamma:SE[C]ANT syntax
# 2017-02-05 kdw  gamma:SE[C]ANT stuff
# 2017-02-03 kdw  gamma:be(t)a(i)nc error return value
# 2017-02-01 kdw  gamma:be(t)a(i)nc work
# 2017-01-31 kdw  gamma:be(t)a(i)nc
# 2017-01-06 kdw  gamma:?[?]USE.* to ?[?].*_MODE; ?[?]DIGR.*
# 2016-12-25 kdw  gamma:rev to t
# 2016-12-02 kdw  gamma:BC debugging(dbl_epi* == 0)
# 2016-11-23 kdw  gamma:C(N)ST to R(E)AD(O)NLY
# 2016-11-21 kdw  gamma:D(E)F to F(U)NC
# 2016-11-20 kdw  gamma:language change
# 2016-11-18 kdw  gamma:tgamma refactor; __P(O)D(_)_
# 2016-11-17 kdw  gamma:tgamma problem w/ args < 0.5
# 2016-11-15 kdw  gamma:1 to 1.0 for python
# 2016-11-14 kdw  gamma:sec(a)nt algorithm refactor
# 2016-11-11 kdw  gamma:sec(a)nt algorithm refactor
# 2016-11-08 kdw  gamma:bound loops
# 2016-11-06 kdw  gamma:lng(a)mma1
# 2016-10-31 kdw  gamma:E(X)IT(L)OOP
# 2016-10-28 kdw  gamma:comment reorg
# 2016-09-15 kdw  gamma:lang change
# 2016-09-13 kdw  gamma:lang change
# 2016-05-18 kdw  gamma:comment change
# 2016-01-11 kdw  gamma:corrected comment; rmed ga(m)maln
# 2015-12-31 kdw  gamma:bounded possible infinite loops
# 2015-12-30 kdw  gamma:isd(b)le(q)ual to ise(q)ual
# 2015-12-28 kdw  gamma:.*2() functions exsized
# 2015-12-16 kdw  gamma:long comments
# 2015-12-14 kdw  gamma:bad sigils
# 2015-12-11 kdw  gamma:s/LC_// from some consts
# 2015-12-10 kdw  gamma:[] added to array
# 2015-12-03 kdw  gamma:long lines
# 2015-11-26 kdw  gamma:long lines
# 2015-11-17 kdw  gamma:comment change
# 2015-11-13 kdw  gamma:tg[a]mma tweak
# 2015-11-12 kdw  gamma:rmed tga[m]ma2; et al.
# 2015-10-19 kdw  gamma:ga[m]ma to tg[a]mma
# 2015-10-13 kdw  gamma:function rename
# 2015-10-12 kdw  gamma:ga(m)mai(n)v improved; l(g)amma(i)nv
# 2015-10-11 kdw  gamma:sec(a)nt algorithm changed
# 2015-10-10 kdw  gamma:fac(torial)?inv created
# 2015-10-09 kdw  gamma:di[g]ammai[n]v created
# 2015-10-01 kdw  gamma:float equality checks to is.*
# 2015-09-30 kdw  gamma:work on in[v]ga[m]ma
# 2015-09-29 kdw  gamma:work on in[v]ga[m]ma
# 2015-09-27 kdw  gamma:debugging; ga[m]mainv, digamma
# 2015-09-20 kdw  gamma:created
#   IIIIIIIIIInsert-Begin ------------------------- Macros.fwip #
#   IIIIIIIIIInsert-End --------------------------- Macros.fwip #
#   FFFFFFFFFFunction ------------------------------- lgamma__1 #
FUNC DBL lgamma__1(DBL xx):
   # compute LN(GAMMA(XX))
   DBL aa_arr[15];
   DBL sum;
   INT ii;
   DBL tt;
   DBL retvalu;
   DBL qq;
   IF xx <= 0.0 AND Kw.isint(xx):
      retvalu = LN(Kw.DBLMAX);
   ELSE:
      IF xx < 0:
         qq = 1 - xx;
      ELSE:
         qq = xx;
      IF_END
      # values for g=607/128, 15 terms
      ARRAY aa_arr[]:# lgamma(0<qq) pseudo-continued-fraction
         + 5.7156235665862923517E+1;
         - 5.9597960355475491248E+1;
         + 1.4136097974741747174E+1;
         - 4.9191381609762019978E-1;
         + 3.3994649984811888699E-5;
         + 4.6523628927048575665E-5;
         - 9.8374475304879564677E-5;
         + 1.5808870322491248884E-4;
         - 2.1026444172410488319E-4;
         + 2.1743961811521264320E-4;
         - 1.6431810653676389022E-4;
         + 8.4418223983852743293E-5;
         - 2.6190838401581408670E-5;
         + 3.6899182659531622704E-6;
      ARRAY_END
      sum = 0.99999999999999709182;
      FOR ii FROM 0 TO ARRAYLAST(aa_arr[]):
         sum += aa_arr[ii] / (qq + ii);
      FOR_END
      tt = qq + 607.0 / 128.0 - 0.5;
      qq = LN(Kw.TAU) / 2.0 + (qq - 0.5) * LN(tt) + LN(sum) - tt;
      IF xx < 0:
         retvalu = LN(Kw.PI / ABS(SIN(2.0 * Kw.TAU * xx))) - qq;
      ELSE:
         retvalu = qq;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- lgammainv #
FUNC DBL lgammainv(DBL yy):
   # XX such that YY = log(GAMMA(XX))
   DBL scvx_xp;
   DBL scvx_xx;
   DBL scvx_yp;
   DBL scvx_yy;
   DBL scvx_dx;
   DBL scvx_dy;
   INT scvx_ii;
   DBL yy_fixed;
   DBL xx_init;
   yy_fixed = yy / Kw.PI + LN(yy + 0.5);
   xx_init = yy_fixed + Kw.PI - 0.5;
   # return XX where
   #   yy - lgamma(scvx_xx)XX == 0
   # BEG Secant Calculation
   scvx_dx = 0.01;
   scvx_xx = xx_init;
   scvx_yy = yy - lgamma(scvx_xx);
   FOR scvx_ii FROM 0 TO 20:
      scvx_xp = scvx_xx;
      scvx_yp = scvx_yy;
      scvx_xx += scvx_dx;
      IF Kw.iseq(scvx_xp, scvx_xx):
         FOR_EXIT;
      IF_END
      scvx_yy = yy - lgamma(scvx_xx);
      scvx_dy = (scvx_yy - scvx_yp);
      IF Kw.iszero(scvx_dy):
         FOR_EXIT;
      IF_END
      scvx_dx *= - scvx_yy / scvx_dy;
   FOR_END
   # END Secant Calculation
   RETURN scvx_xx;
FUNC_END
BLOCK:
      #   FFFFFFFFFFunction --------------------
   #lf_lgamma_gt_zero #
   BLOCK_DEF FUNC DBL lf_lgamma_gt_zero(DBL xx):
      # compute LN(TGAMMA(XX))
      DBL retvalu;
      DBL zz;
      DBL pp;
      DBL uu;
      DBL denom;
      DBL numer;
      IF xx < 13.0:
         zz = 1.0;
         pp = 0.0;
         uu = xx;
         WHILE 3.0 <= uu:
            pp -= 1.0;
            uu = xx + pp;
            zz *= uu;
         WHILE_END
         WHILE uu < 2.0:
            zz /= uu;
            pp += 1.0;
            uu = xx + pp;
         WHILE_END
         IF zz < 0.0:
            zz = -zz;
         IF_END
         IF Kw.iseq(uu, 2.0):
            retvalu = LN(zz);
         ELSE:
            pp -= 2.0;
            xx += pp;
            numer = ((((((-1.37825152569120859100E+3) * xx
                  - 3.88016315134637840924E+4) * xx
                  - 3.31612992738871184744E+5) * xx
                  - 1.16237097492762307383E+6) * xx
                  - 1.72173700820839662146E+6) * xx
                  - 8.53555664245765465627E+5);
            denom = (((((((1.00000000000000000000E+0) * xx
                  - 3.51815701436523470549E+2) * xx
                  - 1.70642106651881159223E+4) * xx
                  - 2.20528590553854454839E+5) * xx
                  - 1.13933444367982507207E+6) * xx
                  - 2.53252307177582951285E+6) * xx
                  - 2.01889141433532773231E+6);
            retvalu = LN(zz) + xx * numer / denom;
         IF_END
      ELSE:
         uu = (xx - 0.5) * LN(xx) - xx + LN(SQRT(Kw.TAU));
         IF 1E+8 < xx:
            retvalu = uu;
         ELSE:
            pp = 1.0 / (xx * xx);
            IF 1000 < xx:
               # lgamma(1E+3<xx<1E+8)
               zz = (((7.9365079365079365079365E-4) * pp
                     - 2.7777777777777777777778E-3) * pp
                     + 8.3333333333333333333333E-2);
            ELSE:
               # lgamma(13<xx<1E+3)
               zz = (((((8.11614167470508450300E-4) * pp
                     - 5.95061904284301438324E-4) * pp
                     + 7.93650340457716943945E-4) * pp
                     - 2.77777777300996872050E-3) * pp
                     + 8.33333333333331927722E-2);
            IF_END
            retvalu = uu + zz / xx;
         IF_END
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------- lgamma #
   FUNC DBL lgamma(DBL zz):
      # compute LN(TGAMMA(zz))
      DBL retvalu;
      IF zz <= 0.0:
         IF Kw.isint(zz):
            retvalu = LN(Kw.DBLMAX);
         ELSE:
            retvalu = (LN(Kw.PI / ABS(SIN(2.0 * Kw.TAU * zz)))
                  - lf_lgamma_gt_zero(1.0 - zz));
         IF_END
      ELSE:
         retvalu = lf_lgamma_gt_zero(zz);
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END
BLOCK:
      #   FFFFFFFFFFunction -------------------------
   #lf_eval_cont #
   BLOCK_DEF FUNC DBL lf_eval_cont(DBL xx, INT deg
         , READONLY DBL coeff_arr_pc[]):
      # evaluate XX+C0/(XX+C1/(XX+C2/...+CN/XX)..)
      DBL sum;
      INT ii;
      sum = xx;
      FOR ii FROM deg TO 0 BY - 1:
         sum = xx + coeff_arr_pc[ii] / sum;
      FOR_END
      RETURN sum;
   FUNC_END
   #   FFFFFFFFFFunction ---------------------------- lgamma__2 #
   FUNC DBL lgamma__2(DBL zz):
      # compute LN(TGAMMA(ZZ))
      DBL retvalu;
      DBL aa_arr[10];
      DBL sum;
      IF zz <= 0.0:
         IF Kw.isint(zz):
            retvalu = LN(Kw.DBLMAX);
         ELSE:
            retvalu = (LN(Kw.PI / ABS(SIN(2.0 * Kw.TAU * zz)))
                  - lgamma(1.0 - zz));
         IF_END
      ELSE:
         # now 0 <= arg
         ARRAY aa_arr[]:# lgamma__2(0<zz) continued fraction
            + 1.0 / 12.0;
            + 1.0 / 30.0;
            + 53.0 / 210.0;
            + 195.0 / 371.0;
            + 229999.0 / 22737.0;
            + 29944523.0 / 19733142.0;
            + 109535241009.0 / 48264275462.0;
            + 29404527905795295658.0 / 9769214287853155785.0;
            + 455377030420113432210116914702.0
                  / 113084128923675014537885725485.0;
         ARRAY_END
         sum = 0.0;
         WHILE zz <= 6.0:
            # bounded by 6
            sum += LN(zz);
            zz += 1.0;
         WHILE_END
         sum -= lf_eval_cont(zz, ARRAYLAST(aa_arr[]), aa_arr[]);
         retvalu = (LN(Kw.TAU) / 2.0 + (zz - 0.5) * LN(zz)
               - 2.0 * zz - sum);
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END
      #   FFFFFFFFFFunction ----------------------------------
   #lpermx #
FUNC DBL lpermx(DBL nn
      , DBL rr):
   # Real valued extension of LN(perm(NN,RR))
   RETURN lgamma(nn + 1.0) - lgamma(nn - rr + 1.0);
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- permx #
FUNC DBL permx(DBL nn
      , DBL rr):
   # Real valued extension of perm
   RETURN EXP(lpermx(nn, rr));
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- lcombx #
FUNC DBL lcombx(DBL nn
      , DBL rr):
   # Real valued extension of LN(comb(NN,RR))
   RETURN lpermx(nn, rr) - lgamma(rr + 1.0);
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- combx #
FUNC DBL combx(DBL nn
      , DBL rr):
   # Real valued extension of comb
   RETURN EXP(lcombx(nn, rr));
FUNC_END
#   FFFFFFFFFFunction ------------------------------- birthdayx #
FUNC DBL birthdayx(DBL nn
      , DBL rr):
   # probability that RR things randomly placed in
   # NN boxes with no box having >1 object
   RETURN EXP(lpermx(nn, rr) - LN(nn) * rr);
FUNC_END
#   FFFFFFFFFFunction ------------------------------- tgamma__1 #
FUNC DBL tgamma__1(DBL xx):
   # compute GAMMA(XX)
   DBL zz;
   DBL rslt;
   DBL denom;
   DBL numer;
   IF Kw.isposint(1 - xx):
      rslt = Kw.DBLMAX;
   ELSE:
      zz = 1.0;
      WHILE 3.0 <= xx:
         xx -= 1;
         zz *= xx;
      WHILE_END
      WHILE xx < 2.0:
         IF ABS(xx) < 1E-9:
            WHILE_EXIT;
         IF_END
         zz /= xx;
         xx += 1.0;
      WHILE_END
      # Now 2 <= x < 3
      IF Kw.iseq(xx, 0.0):
         rslt = Kw.DBLMAX;
      ELSIF xx < 2.0:
         rslt = zz / ((1 + Kw.EULER * xx) * xx);
      ELSIF Kw.iseq(xx, 2.0):
         rslt = zz;
      ELSE:
         xx -= 2.0;
         # 0 < xx < 1
         numer = (((((((1.60119522476751861407E-04) * xx
               + 1.19135147006586384913E-03) * xx
               + 1.04213797561761569935E-02) * xx
               + 4.76367800457137231464E-02) * xx
               + 2.07448227648435975150E-01) * xx
               + 4.94214826801497100753E-01) * xx
               + 9.99999999999999996796E-01);
         denom = ((((((((-2.31581873324120129819E-05) * xx
               + 5.39605580493303397842E-04) * xx
               - 4.45641913851797240494E-03) * xx
               + 1.18139785222060435552E-02) * xx
               + 3.58236398605498653373E-02) * xx
               - 2.34591795718243348568E-01) * xx
               + 7.14304917030273074085E-02) * xx
               + 1.00000000000000000320E+00);
         rslt = zz * numer / denom;
      IF_END
   IF_END
   RETURN rslt;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- tgamma #
FUNC DBL tgamma(DBL xx):
   # value of gamma function via lgamma == EXP(LGAMMA(XX))
   #       INF
   # INTEGRATE  t**(xx - 1) EXP(-t) dt
   #         0
   DBL retvalu;
   DBL tmp;
   IF xx < 0.0:
      IF Kw.isint(xx):
         retvalu = Kw.DBLMAX;
      ELSE:
         tmp = EXP(lgamma(1.0 - xx));
         retvalu = Kw.PI / (SIN(Kw.PI * xx) * tmp);
      IF_END
   ELSE:
      retvalu = EXP(lgamma(xx));
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- tgammainv #
FUNC DBL tgammainv(DBL yy):
   # XX such that GAMMA(XX) == YY
   DBL scvx_xp;
   DBL scvx_xx;
   DBL scvx_yp;
   DBL scvx_yy;
   DBL scvx_dx;
   DBL scvx_dy;
   INT scvx_ii;
   DBL kk;
   DBL cc;
   DBL pp;
   DBL xx_init;
   kk = 1.46163214496836234126265954;
   # zero of digamma
   cc = SQRT(Kw.TAU) / Kw.E - tgamma(kk);
   # 0.0365338144849
   pp = LN((yy + cc) / SQRT(Kw.TAU));
   xx_init = pp / wp(pp / Kw.E) + 0.5;
   # return XX where
   #   yy - tgamma(scvx_xx)XX == 0
   # BEG Secant Calculation
   scvx_dx = 0.01;
   scvx_xx = xx_init;
   scvx_yy = yy - tgamma(scvx_xx);
   FOR scvx_ii FROM 0 TO 20:
      scvx_xp = scvx_xx;
      scvx_yp = scvx_yy;
      scvx_xx += scvx_dx;
      IF Kw.iseq(scvx_xp, scvx_xx):
         FOR_EXIT;
      IF_END
      scvx_yy = yy - tgamma(scvx_xx);
      scvx_dy = (scvx_yy - scvx_yp);
      IF Kw.iszero(scvx_dy):
         FOR_EXIT;
      IF_END
      scvx_dx *= - scvx_yy / scvx_dy;
   FOR_END
   # END Secant Calculation
   RETURN scvx_xx;
FUNC_END
BLOCK:
      #   FFFFFFFFFFunction -----------------------
   #lf_gamma_shift #
   BLOCK_DEF FUNC DBL lf_gamma_shift(DBL xx, DBL yy):
      # use this property of gamma function
      # to calculate values outside of[1,2)
      #    tgamma_2(x + 1) = x * tgamma_2(x);
      DBL prod;
      IF Kw.isposint(1 - yy):
         prod = Kw.DBLMAX;
      ELSE:
         prod = 1.0;
         WHILE yy < xx - 0.0001:
            # bounded by xx - 1
            prod *= yy;
            yy += 1.0;
         WHILE_END
         WHILE xx + 0.0001 < yy:
            # bounded by 1 - xx
            yy -= 1.0;
            prod /= yy;
         WHILE_END
         # Now xx - 0.1 <= yy <= xx + 0.1
      IF_END
      RETURN prod;
   FUNC_END
   #   FFFFFFFFFFunction -------------------- lf_tgamma_gt_half #
   BLOCK_DEF FUNC DBL lf_tgamma_gt_half(DBL xx):
      # compute GAMMA(XX) for 0.5 < XX
      # https://rosettacode.org/wiki/Gamma_function
      INT ii;
      DBL sum;
      DBL yy;
      DBL pp_arr[11];
      yy = xx - FLOOR(xx) + 1.0;
      # now 1 <= yy < 2
      ARRAY pp_arr[]:# tgamma(1<=xx<2)
         + 5.716400188274341379136E+3;
         - 1.481530426768413909044E+4;
         + 1.429149277657478554025E+4;
         - 6.348160217641458813289E+3;
         + 1.301608286058321874105E+3;
         - 1.081767053514369634679E+2;
         + 2.605696505611755827729E+0;
         - 7.423452510201416151527E-3;
         + 5.384136432509564062961E-8;
         - 4.023533141268236372067E-9;
      ARRAY_END
      sum = 1.000000000000000174663;
      FOR ii FROM 0 TO ARRAYLAST(pp_arr[]):
         sum += pp_arr[ii] / (yy + ii);
      FOR_END
      # very good approximation in[1,2]
      RETURN (SQRT(Kw.TAU) * sum * EXP(LN(yy + 8.5) * (yy
            - 0.5) - yy - 8.5) * lf_gamma_shift(xx, yy));
   FUNC_END
   #   FFFFFFFFFFunction ---------------------------- tgamma__2 #
   FUNC DBL tgamma__2(DBL xx):
      # compute GAMMA(XX)
      INT ii;
      DBL sum;
      DBL pp_arr[10];
      DBL yy;
      DBL rslt;
      IF Kw.isposint(1 - xx):
         rslt = Kw.DBLMAX;
      ELSE:
         yy = xx - FLOOR(xx) + 2.0;
         # now 2 <= yy < 3
         ARRAY pp_arr[]:# tgamma(2<=yy<3)
            + 7.61800917294715E+1;
            - 8.65053203294168E+1;
            + 2.40140982408309E+1;
            - 1.23173957245015E+0;
            + 1.20865097386618E-3;
            - 5.395239384953E-6;
         ARRAY_END
         sum = 1.00000000019001E+0;
         FOR ii FROM 0 TO ARRAYLAST(pp_arr[]):
            sum += pp_arr[ii] / (yy + ii);
         FOR_END
         # very good approximation in[1,2]
         rslt = (SQRT(Kw.TAU) * sum * EXP(LN(yy + 4.5) * (yy
               - 0.5) - yy - 4.5) * lf_gamma_shift(xx, yy));
      IF_END
      RETURN rslt;
   FUNC_END
   #   FFFFFFFFFFunction ---------------------------- tgamma__3 #
   FUNC DBL tgamma__3(DBL xx):
      # value of gamma function
      DBL retvalu;
      IF Kw.isposint(1 - xx):
         retvalu = Kw.DBLMAX;
      ELSIF xx < 0.5:
         retvalu = (Kw.PI / SIN(Kw.PI * xx)
               / lf_tgamma_gt_half(1.0 - xx));
      ELSE:
         retvalu = lf_tgamma_gt_half(xx);
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END
      #   FFFFFFFFFFunction ------------------------
   #tgamma__stirling #
FUNC DBL tgamma__stirling(DBL xx):
   # Stirlings approximation
   DBL yy;
   DBL ryy;
   DBL sc;
   DBL ply;
   sc = 1.0;
   WHILE xx < 10.0:
      sc /= xx;
      xx += 1;
   WHILE_END
   yy = xx - 1.0;
   ryy = 1.0 / yy;
   ply = (((((((-5246819.0 / 75246796800.0) * ryy + 163879.0
         / 209018880.0) * ryy - 571.0 / 2488320.0) * ryy
         - 139.0 / 51840) * ryy + 1.0 / 288.0) * ryy + 1.0
         / 12.0) * ryy + 1.0);
   RETURN sc * POW(yy / Kw.E, yy) * SQRT(Kw.TAU * yy) * ply;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- tgammadouble #
FUNC DBL tgammadouble(DBL xx):
   # double factorial extended to reals
   DBL xxh;
   xxh = (xx - 1.0) / 2.0;
   RETURN POW(2.0, xxh) * POW(2.0 / Kw.PI, (1.0 - COS(Kw.TAU
         * xxh)) / 4.0) * tgamma(xxh + 1.0);
FUNC_END
BLOCK:
      #   FFFFFFFFFFunction --------------------
   #lf_ligamma_xxleaa #
   BLOCK_DEF FUNC DBL lf_ligamma_xxleaa(DBL aa, DBL xx):
      # Lower Incomplete Gamma function
      # useful if XX <= MAX(1.1, AA)
      # ONLY CALL THIS WITH 0.0 < XX
      INT kk;
      DBL rr;
      DBL sum_curr;
      DBL sum_prev;
      sum_curr = EXP(aa * LN(xx) - xx) / aa;
      rr = sum_curr;
      FOR kk FROM 1 TO 5 * 20:
         rr *= xx / (aa + kk);
         sum_prev = sum_curr;
         sum_curr += rr;
         IF Kw.iseq(sum_prev, sum_curr):
            FOR_EXIT;
         IF_END
      FOR_END
      RETURN sum_curr;
   FUNC_END
   #   FFFFFFFFFFunction -------------------- lf_uigamma_aalexx #
   BLOCK_DEF FUNC DBL lf_uigamma_aalexx(DBL aa, DBL xx):
      # Upper Incomplete Gamma function
      # useful if MAX(1.1, AA) <= XX
      # ONLY CALL THIS WITH 0.75 < XX
      INT jj;
      DBL pp;
      INT ipp;
      DBL sum_curr;
      DBL tt;
      sum_curr = 0.0;
      pp = 47.0 / SQRT(xx - 0.75);
      ipp = FLOOR(pp);
      FOR jj FROM ipp TO 1 BY - 1:
         tt = xx + sum_curr;
         sum_curr = (jj - aa) * tt / (tt + jj);
      FOR_END
      RETURN EXP(aa * LN(xx) - xx) / (xx + sum_curr);
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------ ligamma #
   FUNC DBL ligamma(DBL aa
         , DBL xx):
      # ligamma(AA,XX) = lower incomplete gamma function
      #        xx
      # INTEGRATE  t**(aa - 1) EXP(-t) dt
      #         0
      DBL retvalu;
      IF xx <= 0.0:
         retvalu = 0.0;
      ELSIF aa <= 0.0:
         retvalu = DBLMAX;
      ELSIF xx <= 1.1 OR xx <= aa:
         retvalu = lf_ligamma_xxleaa(aa, xx);
      ELSE:
         # 0 < XX <= 1.1 AND AA < XX
         retvalu = tgamma(aa) - lf_uigamma_aalexx(aa, xx);
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------ uigamma #
   FUNC DBL uigamma(DBL aa
         , DBL xx):
      # uigamma(AA,XX) = upper incomplete gamma
      #       INF
      # INTEGRATE  t**(aa - 1) EXP(-t) dt
      #        xx
      DBL retvalu;
      IF aa <= 0.0:
         retvalu = DBLMAX;
      ELSIF xx <= 0.0:
         retvalu = tgamma(aa);
      ELSIF xx <= 1.1 OR xx <= aa:
         retvalu = tgamma(aa) - lf_ligamma_xxleaa(aa, xx);
      ELSE:
         # 0 < XX <= 1.1 AND AA < XX
         retvalu = lf_uigamma_aalexx(aa, xx);
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END
      #   FFFFFFFFFFunction --------------------------------
   #rligamma #
FUNC DBL rligamma(DBL aa
      , DBL xx):
   # rligamma(AA,XX) = regularized lower incomplete gamma
   #    == ligamma(AA,XX) / tgamma(AA)
   DBL retvalu;
   IF xx <= 0.0:
      retvalu = 0.0;
   ELSIF aa <= 0.0:
      retvalu = DBLMAX;
   ELSE:
      retvalu = ligamma(aa, xx) / tgamma(aa);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- ruigamma #
FUNC DBL ruigamma(DBL aa
      , DBL xx):
   # ruigamma(AA,XX) = regularized upper incomplete gamma
   #    == uigamma(AA,XX) / tgamma(AA)
   DBL retvalu;
   IF aa <= 0.0:
      retvalu = DBLMAX;
   ELSIF xx <= 0.0:
      retvalu = 1;
   ELSE:
      retvalu = uigamma(aa, xx) / tgamma(aa);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ uigamma__1 #
FUNC DBL uigamma__1(DBL aa
      , DBL xx):
   DBL ans;
   DBL ax;
   DBL cc;
   DBL yc;
   DBL rr;
   DBL tt;
   DBL yy;
   DBL zz;
   DBL pk;
   DBL pkma;
   DBL pkmb;
   DBL qk;
   DBL qkma;
   DBL qkmb;
   DBL retvalu;
   IF xx <= 0.0 OR aa <= 0.0:
      retvalu = 1.0;
   ELSE:
      ax = aa * LN(xx) - xx - lgamma(aa);
      IF ax < - DBLMAXLN:
         retvalu = 0.0;
      ELSE:
         ax = EXP(ax);
         IF xx < 1.0 OR xx < aa:
            # power series
            rr = aa;
            cc = 1.0;
            ans = 1.0;
            AWAIT cc / ans < DBLEPS:
               rr += 1;
               cc *= xx / rr;
               ans += cc;
            AWAIT_END
            retvalu = 1.0 - ans * ax / aa;
         ELSE:
            # continued fraction
            yy = 1.0 - aa;
            zz = xx + yy + 1.0;
            cc = 0.0;
            pkmb = 1.0;
            qkmb = xx;
            pkma = xx + 1.0;
            qkma = zz * xx;
            ans = pkma / qkma;
            AWAIT tt <= DBLEPS:
               cc += 1.0;
               yy += 1.0;
               zz += 2.0;
               yc = yy * cc;
               pk = pkma * zz - pkmb * yc;
               qk = qkma * zz - qkmb * yc;
               IF NOT Kw.iszero(qk):
                  rr = pk / qk;
                  tt = ABS((ans - rr) / rr);
                  ans = rr;
               ELSE:
                  tt = 1.0;
               IF_END
               pkmb = pkma;
               pkma = pk;
               qkmb = qkma;
               qkma = qk;
               IF 1 / DBLEPS < ABS(pk):
                  pkmb *= DBLEPS;
                  pkma *= DBLEPS;
                  qkmb *= DBLEPS;
                  qkma *= DBLEPS;
               IF_END
            AWAIT_END
            retvalu = ans * ax;
         IF_END
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ uigammainv #
FUNC DBL uigammainv(DBL aa
      , DBL yy):
   DBL dd;
   DBL tt;
   DBL xx;
   DBL scvx_xp;
   DBL scvx_xx;
   DBL scvx_yp;
   DBL scvx_yy;
   DBL scvx_dx;
   DBL scvx_dy;
   INT scvx_ii;
   dd = 1.0 / (9.0 * aa);
   tt = 1 - dd - gau_quantile(yy) * SQRT(dd);
   xx = aa * POW(tt, 3);
   # return XX where
   #   yy - uigamma(aa, scvx_xx)XX == 0
   # BEG Secant Calculation
   scvx_dx = 0.1;
   scvx_xx = xx;
   scvx_yy = yy - uigamma(aa, scvx_xx);
   FOR scvx_ii FROM 0 TO 20:
      scvx_xp = scvx_xx;
      scvx_yp = scvx_yy;
      scvx_xx += scvx_dx;
      IF Kw.iseq(scvx_xp, scvx_xx):
         FOR_EXIT;
      IF_END
      scvx_yy = yy - uigamma(aa, scvx_xx);
      scvx_dy = (scvx_yy - scvx_yp);
      IF Kw.iszero(scvx_dy):
         FOR_EXIT;
      IF_END
      scvx_dx *= - scvx_yy / scvx_dy;
   FOR_END
   # END Secant Calculation
   RETURN scvx_xx;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ ligammainv #
FUNC DBL ligammainv(DBL aa
      , DBL yy):
   RETURN uigammainv(aa, 1 - yy);
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- lbeta #
FUNC DBL lbeta(DBL aa
      , DBL bb):
   # LBETA(XX) = LGAMMA(AA) + LGAMMA(BB) - LGAMMA(AA + BB)
   RETURN lgamma(aa) + lgamma(bb) - lgamma(aa + bb);
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ beta #
FUNC DBL beta(DBL aa
      , DBL bb):
   # BETA(XX) = GAMMA(AA) * GAMMA(BB) / GAMMA(AA + BB)
   #         1
   # INTEGRATE  t**(aa - 1) (1 - t)**(bb - 1) dt
   #         0
   DBL retvalu;
   DBL lbe;
   lbe = lbeta(aa, bb);
   IF DBLMAXLN < lbe:
      retvalu = DBLMAX;
   ELSIF - DBLMAXLN < lbe:
      retvalu = EXP(lbe);
   ELSE:
      retvalu = -DBLMAX;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- betainc #
FUNC DBL betainc(DBL aa
      , DBL bb
      , DBL xx):
   # Incomplete Beta Function
   #        xx
   # INTEGRATE  t**(aa - 1) (1 - t)**(bb - 1) dt
   #         0
   DBL sum_curr;
   DBL sum_prev;
   DBL psq;
   DBL compx;
   DBL new_xx;
   DBL pp;
   DBL qq;
   DBL term;
   DBL ai;
   DBL rx;
   DBL temp;
   DBL log_beta;
   DBL retvalu;
   INT indx;
   INT ns;
   # Parameters:
   #    argument XX in(0,1)
   #    parameters AA, BB in(0,+Inf)
   IF aa <= 0.0 OR bb <= 0.0 OR 1.0 <= xx:
      retvalu = 1.0;
   ELSIF xx <= 0.0:
      retvalu = 0.0;
   ELSE:
      # Reference: KL Majumder, GP Bhattacharjee:
      #    Algorithm AS 63: "The incomplete Beta Integral",
      #    "Applied Statistics", Volume 22, Number 3, 1973
      #    pages 409-411.
      #  Change tail if necessary and determine S.
      psq = aa + bb;
      IF aa < psq * xx:
         new_xx = 1.0 - xx;
         compx = xx;
         pp = bb;
         qq = aa;
         indx = 0;
      ELSE:
         new_xx = xx;
         compx = 1.0 - xx;
         pp = aa;
         qq = bb;
         indx = 1;
      IF_END
      term = 1.0;
      sum_curr = 1.0;
      ai = 1.0;
      ns = FLOOR(qq + compx * psq);
      rx = new_xx / compx;
      #  Soper reduction.
      temp = qq - ai;
      IF ns == 0:
         rx = new_xx;
      IF_END
      AWAIT Kw.iseq(sum_curr, sum_prev):
         term *= temp * rx / (pp + ai);
         ai += 1.0;
         ns -= 1;
         IF 0 <= ns:
            temp = qq - ai;
            IF ns == 0:
               rx = new_xx;
            IF_END
         ELSE:
            temp = psq;
            psq += 1.0;
         IF_END
         sum_prev = sum_curr;
         sum_curr += term;
      AWAIT_END
      log_beta = lgamma(aa) + lgamma(bb) - lgamma(aa + bb);
      retvalu = sum_curr * EXP(pp * LN(new_xx) + (qq - 1.0)
            * LN(compx) - log_beta) / pp;
      IF indx == 0:
         retvalu = 1.0 - retvalu;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ betainc__1 #
FUNC DBL betainc__1(DBL aa
      , DBL bb
      , DBL xx):
   # Incomplete Beta Function
   DBL retvalu;
   DBL lbeta_ab;
   DBL front;
   DBL ff;
   DBL cc;
   DBL dd;
   INT ii;
   INT jj;
   INT mm;
   DBL numerator;
   DBL cd;
   IF xx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= xx:
      retvalu = 1.0;
   ELSIF(aa + 1.0) / (aa + bb + 2.0) < xx:
      # Use BETAINC(AA, BB, XX) == BETAINC(BB, AA, 1 - XX)
      retvalu = (1.0 - betainc__1(bb, aa, 1.0 - xx));
   ELSE:
      lbeta_ab = lbeta(aa, bb);
      front = EXP(LN(xx) * aa + LN(1.0 - xx) * bb - lbeta_ab)
            / aa;
      ff = 1.0;
      cc = 1.0;
      dd = 0.0;
      jj = 0;
      AWAIT ABS(1.0 - cd) < DBLEPS COUNT ii FROM 0 TO 200:
         IF ii == 0:
            numerator = 1.0;
         ELSIF jj == 0:
            # Even
            mm = ii / 2;
            numerator = (mm * (bb - mm) * xx) / ((aa + 2.0 * mm
                  - 1.0) * (aa + 2.0 * mm));
         ELSE:
            # Odd
            mm = (ii - 1) / 2;
            numerator = -((aa + mm) * (aa + bb + mm) * xx)
                  / ((aa + 2.0 * mm) * (aa + 2.0 * mm + 1));
         IF_END
         # Do 1 iteration of Lentz algorithm.
         dd = 1.0 + numerator * dd;
         IF ABS(dd) < DBLEPS * DBLEPS:
            dd = DBLEPS * DBLEPS;
         IF_END
         dd = 1.0 / dd;
         cc = 1.0 + numerator / cc;
         IF ABS(cc) < DBLEPS * DBLEPS:
            cc = DBLEPS * DBLEPS;
         IF_END
         cd = cc * dd;
         ff *= cd;
         jj = 1 - ii;
      AWAIT_END
      retvalu = front * (ff - 1.0);
   IF_END
   RETURN retvalu;
FUNC_END
BLOCK:
      #   FFFFFFFFFFunction -------------------
   #lf_digamma_gt_zero #
   BLOCK_DEF FUNC DBL lf_digamma_gt_zero(DBL xx):
      # derivative of LN(TGAMMA(XX)) for 0 < XX ONLY
      DBL rec_xx_sqr;
      DBL shift;
      DBL sxx;
      INT ii;
      DBL sumy;
      shift = 0.0;
      sxx = xx;
      WHILE sxx < 8.0:
         # bounded by 8
         shift -= 1.0 / sxx;
         sxx += 1.0;
      WHILE_END
      rec_xx_sqr = 1.0 / (sxx * sxx);
      sumy = 0.0;
      FOR ii FROM 14 TO 2 BY - 2:
         sumy *= rec_xx_sqr;
         sumy += - bernoulli(ii) / ii;
      FOR_END
      RETURN (shift + LN(sxx) - 1.0 / (2.0 * sxx) + rec_xx_sqr
            * sumy);
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------ digamma #
   FUNC DBL digamma(DBL xx):
      # derivative of LN(GAMMA(XX))
      #    digamma(xx) == dtgamma(xx) / tgamma(x)
      #    digamma(xx + 1) == digamma(xx) + 1.0 / xx
      #    digamma(nn) == hn(nn - 1) - Kw.EULER, nn posint
      DBL sxx;
      DBL retvalu;
      IF xx <= 0.0:
         IF Kw.isint(xx):
            retvalu = Kw.DBLMAX;
         ELSE:
            sxx = 2.0 * xx;
            retvalu = (lf_digamma_gt_zero(1.0 - xx) - Kw.PI
                  * COS(sxx) / SIN(sxx));
         IF_END
      ELSE:
         retvalu = lf_digamma_gt_zero(xx);
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END
      #   FFFFFFFFFFunction ------------------------------
   #digammainv #
FUNC DBL digammainv(DBL yy):
   # compute XX such that DIGAMMA(XX) == YY
   DBL scvx_xp;
   DBL scvx_xx;
   DBL scvx_yp;
   DBL scvx_yy;
   DBL scvx_dx;
   DBL scvx_dy;
   INT scvx_ii;
   # return XX where
   #   yy - digamma(scvx_xx)XX == 0
   # BEG Secant Calculation
   scvx_dx = 0.1;
   scvx_xx = EXP(yy);
   scvx_yy = yy - digamma(scvx_xx);
   FOR scvx_ii FROM 0 TO 20:
      scvx_xp = scvx_xx;
      scvx_yp = scvx_yy;
      scvx_xx += scvx_dx;
      IF Kw.iseq(scvx_xp, scvx_xx):
         FOR_EXIT;
      IF_END
      scvx_yy = yy - digamma(scvx_xx);
      scvx_dy = (scvx_yy - scvx_yp);
      IF Kw.iszero(scvx_dy):
         FOR_EXIT;
      IF_END
      scvx_dx *= - scvx_yy / scvx_dy;
   FOR_END
   # END Secant Calculation
   RETURN scvx_xx;
FUNC_END
BLOCK:
      #   FFFFFFFFFFunction ----------------
   #lf_digamma_gt_zero__1 #
   BLOCK_DEF FUNC DBL lf_digamma_gt_zero__1(DBL xx):
      DBL gg;
      DBL aa_arr[10];
      DBL sxx;
      DBL term;
      DBL lnarg;
      DBL numer;
      DBL denom;
      INT ii;
      gg = 9.6565781537733158945718737389;
      ARRAY aa_arr[]:# digamma(xx < 0)
         + 1.144005294538510956673085217E+4;
         - 3.239880201523183350535979104E+4;
         + 3.505145235055716665660834611E+4;
         - 1.816413095412607026106469185E+4;
         + 4.632329905366668184091382704E+3;
         - 5.369767777033567805557478696E+2;
         + 2.287544733951810076451548089E+1;
         - 2.179257487388651155600822204E-1;
         + 1.083148362725893688606893534E-4;
      ARRAY_END
      numer = 0.0;
      denom = 1.0;
      FOR ii FROM ARRAYLAST(aa_arr[]) TO 0 BY - 1:
         sxx = xx + ii;
         term = aa_arr[ii] / sxx;
         denom += term;
         numer += term / sxx;
      FOR_END
      lnarg = (gg + xx - 0.5);
      RETURN LN(lnarg) - (gg / lnarg) - numer / denom;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- digamma__1 #
   FUNC DBL digamma__1(DBL xx):
      # derivative of LN(TGAMMA(XX))
      DBL sxx;
      DBL retvalu;
      IF xx <= 0.0:
         IF Kw.isint(xx):
            retvalu = Kw.DBLMAX;
         ELSE:
            sxx = 2.0 * xx;
            retvalu = (lf_digamma_gt_zero__1(1.0 - xx) - Kw.PI
                  * COS(sxx) / SIN(sxx));
         IF_END
      ELSE:
         retvalu = lf_digamma_gt_zero__1(xx);
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END
      #   FFFFFFFFFFunction ----------------------------
   #factorialinv #
FUNC DBL factorialinv(DBL yy):
   # inverse of factorial function
   RETURN tgammainv(yy) - 1.0;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- facinv #
FUNC DBL facinv(DBL yy):
   # inverse of factorial function
   RETURN tgammainv(yy) - 1.0;
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- hn #
FUNC DBL hn(DBL xx):
   # sum of 1 / NN over positive integers <= XX
   DBL sum;
   DBL kk;
   DBL fxx;
   IF 0.0 < xx:
      fxx = FLOOR(xx);
      sum = 0.0;
      FOR kk FROM fxx TO 1 BY - 1:
         sum += 1.0 / kk;
      FOR_END
   ELSE:
      sum = 0.0;
   IF_END
   RETURN sum;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- hn__1 #
FUNC DBL hn__1(DBL xx):
   # use asymptotic series approximation of hn(XX)
   DBL yy;
   DBL retvalu;
   IF 0.0 < xx:
      yy = 1.0 / (xx * xx);
      retvalu = ((((((-5.0 / (66.0 * 10.0)) * yy + 1.0 / (30.0
            * 8.0)) * yy - 1.0 / (42.0 * 6.0)) * yy + 1.0
            / (30.0 * 4.0)) * yy - 1.0 / (6.0 * 2.0)) * yy
            + Kw.EULER) + LN(xx) + 0.5 / xx;
   ELSE:
      retvalu = 0.0;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- hnm #
FUNC DBL hnm(DBL xx
      , DBL mm):
   # sum of 1 / NN**MM over positive integers <= XX
   DBL sum;
   DBL kk;
   DBL fxx;
   fxx = FLOOR(xx);
   sum = 0.0;
   FOR kk FROM fxx TO 1 BY - 1:
      sum += 1.0 / POW(kk, mm);
   FOR_END
   RETURN sum;
FUNC_END
#TEST:tgammainv(tgamma(5.3))-5.3;
#TEST:1 - ruigamma(5.3,4)  - rligamma(5.3,4);
#TEST:1 - ruigamma(E,PI)   - rligamma(E,PI);
#TEST:1 - ruigamma(TAU,40) - rligamma(TAU,40);
#TEST:tgamma(1.5)  -sqrt(PI)/2;
#TEST:tgamma(PI)-2.28803779534003241795958890906023392288968815;
#TEST:hn(4.5) - 25.0 / 12.0;
#   IIIIIIIIIInsert-End ---------------------------- gamma.fwip #
#   IIIIIIIIIInsert-Begin ------------------------- combin.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-20 kdw  combin:boolean checks changed
# 2020-08-17 kdw  combin:comment change
# 2020-08-05 kdw  combin:pcoh[h]ammer func
# 2020-08-02 kdw  combin:var renam g?d
# 2020-07-27 kdw  combin:block syntax
# 2020-07-24 kdw  combin:s/LO[C]AL_/BL[O]CK_/
# 2020-07-12 kdw  combin:sqrttwo const
# 2020-06-22 kdw  combin:local-use mved before var decls
# 2020-06-19 kdw  combin:comments added
# 2020-06-17 kdw  combin:Modulo operator
# 2020-06-09 kdw  combin:comment changed
# 2020-06-03 kdw  combin:writeonly keyword
# 2020-05-13 kdw  combin:comment trivially changed
# 2020-05-12 kdw  combin:nul rets changed
# 2020-05-11 kdw  combin:local-decl syntx change
# 2020-05-05 kdw  combin:magic check func changed
# 2020-04-20 kdw  combin:co[m]b default value changed
# 2020-04-17 kdw  combin:fact[o]rialt rmed; stirling rework
# 2020-04-15 kdw  combin:refactor
# 2020-04-14 kdw  combin:tests added
# 2020-04-12 kdw  combin:comment change
# 2020-04-11 kdw  combin:comment change; minor rearrange
# 2020-04-10 kdw  combin:comment change
# 2020-04-09 kdw  combin:MO[D]E syntax change
# 2020-04-08 kdw  combin:d2(lt)_d1, d2(ur)_d1 funcs fixed
# 2020-04-07 kdw  combin:more d1.*_d2 funcs
# 2020-04-04 kdw  combin:d2h[y]pot_d11
# 2020-04-02 kdw  combin:re[t]urn rework
# 2020-04-01 kdw  combin:l[a-z][2]ii rnamd to d2[a-z]+_d1
# 2020-03-31 kdw  combin:ls[2]ii
# 2020-03-29 kdw  combin:fac[t]oriald[o]uble renam
# 2020-03-09 kdw  combin:LO[C]AL_.* keywords
# 2020-03-06 kdw  combin:RE[P]LACE / IN[D]EX changes
# 2020-03-03 kdw  combin:comment change
# 2020-03-02 kdw  combin:s/_NE[X]T/_E[N]D/g
# 2020-02-26 kdw  combin:comment change
# 2020-01-28 kdw  combin:work on funcs w/ array args
# 2020-01-26 kdw  combin:n2perm and n2comb work
# 2019-12-27 kdw  combin:eplicit K[w] module
# 2019-12-26 kdw  combin:module name addded to funcs
# 2019-10-29 kdw  combin:[OE]GF comments
# 2019-10-28 kdw  combin:eulerx refactor; zigzag; GF comments
# 2019-10-23 kdw  combin:lntwo const
# 2019-10-22 kdw  combin:localized lf_n2combr
# 2019-10-04 kdw  combin:comment change
# 2019-10-02 kdw  combin:tweak
# 2019-09-17 kdw  combin:rmed c[n]v_db[l]2i32
# 2019-09-10 kdw  combin:LAN[G]UAGE NOT to LAN[G]UAGE_N[O]T
# 2019-08-26 kdw  combin:PRI[N]TS to PR[I]NTSTR
# 2019-08-24 kdw  combin:for and count loops have from clause
# 2019-08-22 kdw  combin:comment changed
# 2019-08-18 kdw  combin:L[O]G to L[N]
# 2019-08-15 kdw  combin:array passing issues
# 2019-08-11 kdw  combin:language comments
# 2019-08-07 kdw  combin:language comments
# 2019-08-06 kdw  combin:rmed backslashes;macro arg renam
# 2019-07-03 kdw  combin:var renam "s/ind/_ind/;s/__ind/_ind/"
# 2019-06-02 kdw  combin:func desc added
# 2019-05-24 kdw  combin:local replaced private
# 2019-05-22 kdw  combin:fubini work
# 2019-05-01 kdw  combin:consts explicit module name
# 2019-03-19 kdw  combin:re[t]_val to re[t]valu
# 2019-03-18 kdw  combin:language tweak
# 2019-03-08 kdw  combin:is[e]qual to is[e]q; et al.
# 2019-03-06 kdw  combin:is.* funcs changed
# 2018-10-08 kdw  combin:vbdotnet stuff
# 2018-07-17 kdw  combin:private lf_.* funcs
# 2018-05-22 kdw  combin:comment change
# 2018-05-18 kdw  combin:LAN[G]UAGE syntax change
# 2018-05-17 kdw  combin:ARR?AY.* and HOR[N]ER syntax
# 2018-05-14 kdw  combin:var ranam
# 2018-05-13 kdw  combin:MO?DE.* syntax change
# 2018-05-06 kdw  combin:comment change
# 2018-05-01 kdw  combin:eulerian/binomial/stirling refactor
# 2018-04-29 kdw  combin:eulerian()
# 2018-04-03 kdw  combin:rm() from return
# 2018-04-02 kdw  combin:Pro?totype, et al.
# 2018-04-01 kdw  combin:LAN[G]UAGE_E[N]D
# 2018-03-27 kdw  combin:simpified
# 2018-03-20 kdw  combin:replaced index w/ "at"replace
# 2018-01-16 kdw  combin:birthday(inv)? work
# 2018-01-03 kdw  combin:combination, permutation
# 2017-12-31 kdw  combin:rmed lobb; ballot[s]? rework
# 2017-12-26 kdw  combin:ballot numbers
# 2017-12-25 kdw  combin:lobb numbers
# 2017-12-23 kdw  combin:fubini numbers
# 2017-12-22 kdw  combin:bell number experiment
# 2017-11-26 kdw  combin:FR[O]M and B[Y] keywords
# 2017-11-23 kdw  combin:rm digits from var names
# 2017-11-22 kdw  combin:var renam
# 2017-11-19 kdw  combin:double factorial factorial2
# 2017-10-21 kdw  combin:LA[N]G[U]AGE.* syntax changed
# 2017-10-20 kdw  combin:LA[N]G[U]AGE.* syntax changed
# 2017-08-20 kdw  combin:rmed/renamd .*_P[E]R_.* vars
# 2017-06-23 kdw  combin:REPL?ACE redo
# 2017-06-21 kdw  combin:LA[N]G.* AND MASTER.* change
# 2017-06-20 kdw  combin:comments changed
# 2017-06-13 kdw  combin:C now handles return arrays
# 2017-06-03 kdw  combin:PRI?NT.* changed
# 2017-05-31 kdw  combin:var renam
# 2017-05-17 kdw  combin:printtab converted to prints
# 2017-04-21 kdw  combin:func to function
# 2017-03-28 kdw  combin:comment cleanup
# 2017-03-27 kdw  combin:comment cleanup
# 2017-03-17 kdw  combin:space after comma
# 2017-03-13 kdw  combin:continue not supported
# 2017-03-12 kdw  combin:shorten long comments
# 2017-03-10 kdw  combin:get Fw[i]p_Pa[r]se to work
# 2017-03-06 kdw  combin:sigils rmed
# 2017-02-27 kdw  combin:PA?SS deprecated
# 2017-02-24 kdw  combin:array var names
# 2017-02-22 kdw  combin:array var names
# 2017-02-21 kdw  combin:array var names
# 2017-02-20 kdw  combin:array var names
# 2017-02-14 kdw  combin:FWIP Loop syntax changed
# 2017-02-13 kdw  combin:FWIP language change
# 2017-02-12 kdw  combin:FWIP language change
# 2017-02-07 kdw  combin:comment rearrangement; SE[C]ANT stuff
# 2017-01-06 kdw  combin:?[?]LAN[G]UAGE_ change
# 2016-12-07 kdw  combin:comment change
# 2016-12-06 kdw  combin:comb, n2* rework
# 2016-12-03 kdw  combin:comment change
# 2016-11-24 kdw  combin:LAN[G]UAGE_N[O]T to LAN[G]UAGE_IFN[O]T
# 2016-11-23 kdw  combin:comment change
# 2016-11-22 kdw  combin:PRI?NTLN to PRI?NTLINE
# 2016-11-21 kdw  combin:DE?F to FU?NC
# 2016-11-20 kdw  combin:language change
# 2016-11-15 kdw  combin:B?ITS*/MO?D change
# 2016-11-14 kdw  combin:LA[N]G stuff
# 2016-11-13 kdw  combin:bino?mialx
# 2016-11-12 kdw  combin:bel?lx
# 2016-09-15 kdw  combin:comment change
# 2016-09-14 kdw  combin:lang change
# 2016-05-24 kdw  combin:longlines
# 2016-05-04 kdw  combin:deprecating PRI?NT
# 2016-05-03 kdw  combin:figured out how to spell weird
# 2016-04-27 kdw  combin:_[_]BL?OCK* change
# 2016-01-11 kdw  combin:printing long array change
# 2015-12-21 kdw  combin:define local functions before use
# 2015-12-14 kdw  combin:rmed sigils; long lines
# 2015-12-11 kdw  combin:_[_]EN[D]IF_[_] obsoleted
# 2015-12-09 kdw  combin:lead space error fixed(BC code)
# 2015-12-03 kdw  combin:shortened function names
# 2015-12-02 kdw  combin:function renamed
# 2015-12-01 kdw  combin:variable renamed
# 2015-11-26 kdw  combin:long lines
# 2015-11-19 kdw  combin:long lines
# 2015-11-17 kdw  combin:F[O]R format changed
# 2015-11-17 kdw  combin:block comments
# 2015-11-16 kdw  combin:tweak
# 2015-11-13 kdw  combin:shortened comment; tweak ca[t]alan
# 2015-11-12 kdw  combin:shortened comment
# 2015-10-05 kdw  combin:is* functions
# 2015-10-02 kdw  combin:debugging n[2]pe[r]m
# 2015-09-30 kdw  combin:_[_]IF_[N]OT_.*
# 2015-09-29 kdw  combin:layout tweak
# 2015-09-25 kdw  combin:B[I]T* format change
# 2015-09-24 kdw  combin:bit ops changed
# 2015-09-22 kdw  combin:_[_]* format changed
# 2015-09-21 kdw  combin:fixed int division problem in comb
# 2015-09-20 kdw  combin:created
BLOCK:# factorial
   BLOCK_DEF DBL lv_factorial_arr[0];
   BLOCK_DEF INT lv_factorial_end = 0;
   #   FFFFFFFFFFunction ---------------------------- factorial #
   FUNC DBL factorial(INT nn):
      # factorial(NN) = 1*2*3*...*NN
      # EGF(factorial();x) = 1 / (1 - x)
      BLOCK_USE lv_factorial_end;
      BLOCK_USE lv_factorial_arr[];
      INT mm;
      DBL retvalu;
      IF nn < 0:
         retvalu = 0;
      ELSE:
         IF lv_factorial_end <= 0:
            lv_factorial_end = 6;
            REDIM lv_factorial_arr[], lv_factorial_end;
            ARRAY lv_factorial_arr[]:
               1;
               1;
               2;
               6;
               24;
               120;
            ARRAY_END
         IF_END
         IF lv_factorial_end <= nn:
            mm = lv_factorial_end;
            lv_factorial_end = nn + 1;
            REDIM lv_factorial_arr[], lv_factorial_end;
            WHILE mm < lv_factorial_end:
               lv_factorial_arr[mm] = (mm * lv_factorial_arr[mm
                     - 1]);
               mm += 1;
            WHILE_END
         IF_END
         retvalu = lv_factorial_arr[nn];
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END#TEST:factorial(7)-5040;
BLOCK:# factorialdouble
   BLOCK_DEF DBL lv_factorial_b_arr[0];
   BLOCK_DEF INT lv_factorial_b_end = 0;
   #   FFFFFFFFFFunction ---------------------- factorialdouble #
   FUNC DBL factorialdouble(INT nn):
      # The double factorial
      # If NN = 2*kk then
      #    2**kk * factorial(kk) = 2*4*6*8...*NN
      # if NN = 2*kk-1 then
      #    factorial(2*kk) / (2**kk * factorial(kk)) = 1*3*...*NN
      BLOCK_USE lv_factorial_b_end;
      BLOCK_USE lv_factorial_b_arr[];
      DBL retvalu;
      INT mm;
      IF nn < 0:
         retvalu = 0;
      ELSE:
         IF lv_factorial_b_end <= 0:
            lv_factorial_b_end = 6;
            REDIM lv_factorial_b_arr[], lv_factorial_b_end;
            ARRAY lv_factorial_b_arr[]:
               1;
               1;
               2;
               3;
               8;
               15;
            ARRAY_END
         IF_END
         IF lv_factorial_b_end <= nn:
            mm = lv_factorial_b_end;
            lv_factorial_b_end = nn + 1;
            REDIM lv_factorial_b_arr[], lv_factorial_b_end;
            WHILE mm < lv_factorial_b_end:
               lv_factorial_b_arr[mm] = mm
                     * lv_factorial_b_arr[mm - 2];
               mm += 1;
            WHILE_END
         IF_END
         retvalu = lv_factorial_b_arr[nn];
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END#TEST:factorialdouble(10)-3840;
#TEST:factorialdouble(11)-10395;
#   FFFFFFFFFFunction ------------------------------------- fac #
FUNC DBL fac(INT nn):
   # alias for factorial
   RETURN Kw.factorial(nn);
FUNC_END
#   FFFFFFFFFFunction ------------------------------ factorialt #
FUNC DBL factorialt(INT n_things
      , INT r_each):
   # factorial(N) / factorial(R)
   INT ii;
   DBL retvalu;
   retvalu = 1.0;
   FOR ii FROM r_each + 1 TO n_things:
      retvalu *= ii;
   FOR_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ comb #
FUNC DBL comb(INT n_things
      , INT r_each):
   # number of sets of R_EACH things selected
   #    from N_THINGS things
   # factorial(N) / (factorial(N - R) * factorial(R))
   INT ii;
   DBL retvalu;
   IF r_each < 0 OR n_things < r_each:
      retvalu = 0.0;
   ELSE:
      IF 2 * r_each < n_things:
         r_each = n_things - r_each;
      IF_END
      # now N_THINGS / 2 <= R_EACH
      retvalu = 1.0;
      FOR ii FROM r_each + 1 TO n_things:
         retvalu *= ii;
         retvalu /= (ii - r_each);
      FOR_END
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:comb(10,4)-210;
#   FFFFFFFFFFunction ------------------------------------ perm #
FUNC DBL perm(INT n_things
      , INT r_each):
   # number of ways to choose R_EACH things from N_THINGS things
   # factorial(N) / factorial(N - R)
   RETURN factorialt(n_things, n_things - r_each);
FUNC_END
#TEST:perm(10,4)-5040;
#   FFFFFFFFFFunction ----------------------------- combination #
FUNC DBL combination(INT n_things
      , INT r_each):
   # number of sets of R_EACH things selected
   #    from N_THINGS things
   RETURN Kw.comb(n_things, r_each);
FUNC_END
#   FFFFFFFFFFunction ----------------------------- permutation #
FUNC DBL permutation(INT n_things
      , INT r_each):
   # number of ways to choose R_EACH things from N_THINGS things
   RETURN Kw.perm(n_things, r_each);
FUNC_END
BLOCK:# Catalan numbers
   BLOCK_DEF DBL lv_catalan_arr[0];
   BLOCK_DEF INT lv_catalan_end = 0;
   #   FFFFFFFFFFunction ------------------------------ catalan #
   FUNC DBL catalan(INT nn):
      # factorial(2 * NN) / (factorial(NN + 1) * factorial(NN))
      #   *) # of properly nested NN pairs of parenthesises
      #   *) # binary trees with NN leaves
      #   *) # of triangulations of a(NN+2)-gon
      #   *) # of ways to tile a stairsep shape of height NN
      #            with NN rectangles
      # OGF(catalan();x) = (1 - SQRT(1 - 4 * x)) / (2 * x)
      BLOCK_USE lv_catalan_end;
      BLOCK_USE lv_catalan_arr[];
      INT kk;
      DBL retvalu;
      IF nn < 0:
         retvalu = 0;
      ELSE:
         IF lv_catalan_end <= 0:
            lv_catalan_end = 1;
            REDIM lv_catalan_arr[], lv_catalan_end;
            lv_catalan_arr[0] = 1;
         IF_END
         IF lv_catalan_end <= nn:
            kk = lv_catalan_end;
            lv_catalan_end = nn + 1;
            REDIM lv_catalan_arr[], lv_catalan_end;
            WHILE kk < lv_catalan_end:
               lv_catalan_arr[kk] = (2 * (2.0 * kk - 1)
                     * lv_catalan_arr[kk - 1] / (kk + 1.0));
               kk += 1;
            WHILE_END
         IF_END
         retvalu = lv_catalan_arr[nn];
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END
BLOCK:# Supercatalan numbers
   BLOCK_DEF DBL lv_supercatalan_arr[0];
   BLOCK_DEF INT lv_supercatalan_end = 0;
   #   FFFFFFFFFFunction ------------------------- supercatalan #
   FUNC DBL supercatalan(INT nn):
      # factorial(2 * NN) / (factorial(NN + 1) * factorial(NN))
      #   *) # of lattice paths with diagonal steps from
      #         (NN,NN) to(0,0) which do not touch the
      #         diagonal line x = y
      #   *) # of non-trivial bracketings of NN symbols.
      #      E.G. If NN=4
      #        abcd
      #        abcd   a(bc)d   ab(cd)
      #        abcd   a(bcd)
      #        (abc)d(a(bc))d a(bcd) a(b(cd))
      #        ab(cd)
      #        Hence supercatalan(4) = 11
      BLOCK_USE lv_supercatalan_end;
      BLOCK_USE lv_supercatalan_arr[];
      INT kk;
      DBL retvalu;
      IF nn < 0:
         retvalu = 0;
      ELSE:
         IF lv_supercatalan_end <= 0:
            lv_supercatalan_end = 3;
            REDIM lv_supercatalan_arr[], lv_supercatalan_end;
            lv_supercatalan_arr[0] = 1;
            lv_supercatalan_arr[1] = 1;
            lv_supercatalan_arr[2] = 1;
         IF_END
         IF lv_supercatalan_end <= nn:
            kk = lv_supercatalan_end;
            lv_supercatalan_end = nn + 1;
            REDIM lv_supercatalan_arr[], lv_supercatalan_end;
            WHILE kk < lv_supercatalan_end:
               lv_supercatalan_arr[kk] = (((6 * kk - 9)
                     * lv_supercatalan_arr[kk - 1] - (kk - 3)
                     * lv_supercatalan_arr[kk - 2]) / kk);
               kk += 1;
            WHILE_END
         IF_END
         retvalu = lv_supercatalan_arr[nn];
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END#TEST:supercatalan(10)-103049
BLOCK:# Bell numbers
   BLOCK_DEF DBL lv_bell_arr[0];
   BLOCK_DEF DBL lv_bell_x_arr[0];
   BLOCK_DEF INT lv_bell_end = 0;
   #   FFFFFFFFFFunction --------------------------------- bell #
   FUNC DBL bell(INT nn):
      # bell(NN) equals the number of
      #   1) possible rhyming schemes for NN lines.
      #   2) partitions of a set of NN elements
      #   3) ways NN distinct balls can be placed in NN boxes
      # EGF(bell();x) = EXP(EXP(x) - 1)
      BLOCK_USE lv_bell_end;
      BLOCK_USE lv_bell_arr[];
      BLOCK_USE lv_bell_x_arr[];
      INT jj;
      INT kk;
      DBL retvalu;
      # THIS IMPLEMENTATION HAS LV_BELL_X_ARR
      # REVERSED FROM NORMAL(I.E. THE BELL NUMBERS FIRST
      # APPEARS ON THE LEFT END(INDEX 0) OF THE ROW)
      #     0  1  2  3  4
      # 0)  1
      # 1)  2  1
      # 2)  5  3  2
      # 3) 15 10  7  5
      # 4) 52 37 27 20 15
      # ARR[n,n] = ARR[n-1,0]
      # ARR[n,m] = ARR[n-1,m] + ARR[n,m+1] for m < n
      IF nn < 0:
         retvalu = 0;
      ELSE:
         IF lv_bell_end <= 0:
            lv_bell_end = 3;
            REDIM lv_bell_arr[], lv_bell_end;
            REDIM lv_bell_x_arr[], lv_bell_end - 1;
            lv_bell_arr[0] = 1;
            lv_bell_arr[1] = 1;
            lv_bell_arr[2] = 2;
            lv_bell_x_arr[0] = 2;
            lv_bell_x_arr[1] = 1;
         IF_END
         IF lv_bell_end <= nn:
            kk = lv_bell_end;
            lv_bell_end = nn + 1;
            REDIM lv_bell_arr[], lv_bell_end;
            REDIM lv_bell_x_arr[], lv_bell_end - 1;
            WHILE kk < lv_bell_end:
               lv_bell_x_arr[kk - 1] = lv_bell_x_arr[0];
               FOR jj FROM kk - 2 TO 0 BY - 1:
                  lv_bell_x_arr[jj] += lv_bell_x_arr[jj + 1];
               FOR_END
               lv_bell_arr[kk] = lv_bell_x_arr[0];
               kk += 1;
            WHILE_END
         IF_END
         retvalu = lv_bell_arr[nn];
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END#TEST:bell(14)-190899322;
#   FFFFFFFFFFunction ----------------------------------- bellx #
FUNC DBL bellx(DBL xxn):
   # a real valued extension of the Bell numbers 1 <= XXn
   # using Dobinskis formula
   DBL sum;
   INT kk;
   DBL sum_prev;
   DBL den;
   kk = 0;
   sum = 0.0;
   den = 1.0;
   AWAIT Kw.iseq(sum_prev, sum):
      kk += 1;
      den *= kk;
      sum_prev = sum;
      sum += POW(kk, xxn) / den;
   AWAIT_END
   RETURN sum / Kw.E;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- fubini #
FUNC DBL fubini(INT nn):
   # The number of ways NN numbers can be ordered
   #  E.G. fubini(3)=13 since
   #   A=B<C A<B=C A<B<C A=B=C
   #   A=C<B       A<C<B
   #         B<A=C B<A<C
   #   B=C<A       B<C<A
   #         C<A=B C<A<B
   #               C<B<A
   # Approximately factorial(NN) / (2*log(2)**(NN+1))
   # Also known as the ordered Bell numbers
   # EGF(fubini();x) = 1 / (2 - EXP(x))
   INT mm;
   DBL sum;
   DBL retvalu;
   IF nn < 0:
      retvalu = 0;
   ELSIF nn == 0:
      retvalu = 1;
   ELSE:
      sum = 1.0 / (2.0 * Kw.LNTWO * Kw.LNTWO);
      FOR mm FROM 2 TO nn:
         sum *= mm / Kw.LNTWO;
      FOR_END
      retvalu = Kw.round(sum);
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:fubini(10)-102247563;
#   FFFFFFFFFFunction --------------------------------- d2lt_d1 #
FUNC INT d2lt_d1(INT xx
      , INT yy):
   # Convert a 2D triangular coordinates into 1D coordinate
   # If YY < 0 OR XX < YY: return -1
   # r/c   -1  0  1  2  3  4  5 ...
   #   --------------------------
   #   .    .  .  .  .  .  .  . ...
   #   5   -1 -1 -1 -1 -1 -1 20 ...
   #   4   -1 -1 -1 -1 -1 14 19 ...
   #   3   -1 -1 -1 -1  9 13 18 ...
   #   2   -1 -1 -1  5  8 12 17 ...
   #   1   -1 -1  2  4  7 11 16 ...
   #   0   -1  0  1  3  6 10 15
   #  -1   -1 -1 -1 -1 -1 -1 -1 ...
   INT retvalu;
   IF 0 <= yy AND yy <= xx:
      retvalu = yy + (xx * (xx + 1)) / 2;
   ELSE:
      retvalu = -1;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- d1lt_d2 #
FUNC INT d1lt_d2(INT nn
      , WRITEONLY INT ret_arr_p[]):
   # Convert a 1D triangular coordinates into 2D coordinate
   # If YY < 0 OR XX < YY: return -1
   # r/c   -1  0  1  2  3  4  5 ...
   #   --------------------------
   #   .    .  .  .  .  .  .  . ...
   #   5   -1 -1 -1 -1 -1 -1 20 ...
   #   4   -1 -1 -1 -1 -1 14 19 ...
   #   3   -1 -1 -1 -1  9 13 18 ...
   #   2   -1 -1 -1  5  8 12 17 ...
   #   1   -1 -1  2  4  7 11 16 ...
   #   0   -1  0  1  3  6 10 15
   #  -1   -1 -1 -1 -1 -1 -1 -1 ...
   INT basee;
   IF nn <= 0:
      ret_arr_p[0] = 0;
      ret_arr_p[1] = 0;
   ELSE:
      basee = FLOORL((SQRT(1 + 8.0 * nn) - 1) / 2);
      ret_arr_p[1] = nn - basee * (basee + 1) / 2;
      # tri(basee)
      ret_arr_p[0] = basee;
   IF_END
   RETURN ret_arr_p[0];
FUNC_END
#   FFFFFFFFFFunction --------------------------------- d2ur_d1 #
FUNC INT d2ur_d1(INT xx
      , INT yy):
   # Convert a 2D square coordinates into 1D coordinate
   # r/c   -1  0  1  2  3  4  5  6 ...
   #   --------------------------
   #   .   -1  .  .  .  .  .  .  . ...
   #   5   -1 20 26 33 41 50 60 71 ...
   #   4   -1 14 19 25 32 40 49 59 ...
   #   3   -1  9 13 18 24 31 39 48 ...
   #   2   -1  5  8 12 17 23 30 38 ...
   #   1   -1  2  4  7 11 16 22 29 ...
   #   0   -1  0  1  3  6 10 15 21 ...
   #  -1   -1 -1 -1 -1 -1 -1 -1 -1 ...
   INT retvalu;
   INT suma;
   IF 0 <= xx AND 0 <= yy:
      suma = (yy + xx);
      retvalu = suma * (suma + 1) / 2 + yy;
   ELSE:
      retvalu = -1;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- d1ur_d2 #
FUNC INT d1ur_d2(INT nn
      , WRITEONLY INT ret_arr_p[]):
   # Convert a 1D square coordinates into 2D coordinate
   # r/c   -1  0  1  2  3  4  5  6 ...
   #   --------------------------
   #   .   -1  .  .  .  .  .  .  . ...
   #   5   -1 20 26 33 41 50 60 71 ...
   #   4   -1 14 19 25 32 40 49 59 ...
   #   3   -1  9 13 18 24 31 39 48 ...
   #   2   -1  5  8 12 17 23 30 38 ...
   #   1   -1  2  4  7 11 16 22 29 ...
   #   0   -1  0  1  3  6 10 15 21 ...
   #  -1   -1 -1 -1 -1 -1 -1 -1 -1 ...
   INT basee;
   INT y_coord;
   IF nn <= 0:
      ret_arr_p[0] = 0;
      ret_arr_p[1] = 0;
   ELSE:
      basee = FLOORL((SQRT(1 + 8.0 * nn) - 1) / 2);
      # triinv(nn)
      y_coord = nn - basee * (basee + 1) / 2;
      # tri(basee)
      ret_arr_p[1] = y_coord;
      ret_arr_p[0] = basee - y_coord;
   IF_END
   RETURN ret_arr_p[0];
FUNC_END
#   FFFFFFFFFFunction ---------------------------- d2diamond_d1 #
FUNC INT d2diamond_d1(INT xx
      , INT yy):
   # Convert a 2D square coordinates into 1D coordinate
   # r/c   ... -3 -2 -1  0  1  2  3 ...
   #   --------------------------------
   #   .   ...  .  .  .  .  .  .  . ...
   #   3   ... 75 52 33 18 31 48 69 ...
   #   2   ... 53 34 19 8  17 30 47 ...
   #   1   ... 35 20 9  2  7  16 29 ...
   #   0   ... 21 10 3  0  1  6  15 ...
   #  -1   ... 37 22 11 4  5  14 27 ...
   #  -2   ... 57 38 23 12 13 26 43 ...
   #  -3   ... 81 58 39 24 25 42 63 ...
   #   .   ...  .  .  .  .  .  .  . ...
   INT ss;
   INT tt;
   INT retvalu;
   IF 0 == yy AND xx == 0:
      retvalu = 0;
   ELSE:
      ss = ABSL(xx) + ABSL(yy);
      tt = 2 * ss * (ss - 1) + 1;
      IF 0 < xx:
         # EAST half-plane
         retvalu = tt + ss + yy - 1;
      ELSE:
         # WEST half-plane
         retvalu = tt + 3 * ss - yy - 1;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- d1diamond_d2 #
FUNC INT d1diamond_d2(INT nn
      , WRITEONLY INT ret_arr_p[]):
   # Convert a 1D diamond coordinates into 2D coordinate
   # r/c   ... -3 -2 -1  0  1  2  3 ...
   #   --------------------------------
   #   .   ...  .  .  .  .  .  .  . ...
   #   3   ... 75 52 33 18 31 48 69 ...
   #   2   ... 53 34 19 8  17 30 47 ...
   #   1   ... 35 20 9  2  7  16 29 ...
   #   0   ... 21 10 3  0  1  6  15 ...
   #  -1   ... 37 22 11 4  5  14 27 ...
   #  -2   ... 57 38 23 12 13 26 43 ...
   #  -3   ... 81 58 39 24 25 42 63 ...
   #   .   ...  .  .  .  .  .  .  . ...
   INT ss;
   INT ssq;
   INT x_coord;
   IF nn <= 0:
      x_coord = 0;
      ret_arr_p[1] = 0;
   ELSE:
      ss = FLOORL(SQRT(nn) / Kw.SQRTTWO);
      ssq = 2 * ss * ss;
      # now ssq <= nn
      IF nn <= ssq + 2 * ss:
         ret_arr_p[1] = ssq - nn + ss;
         x_coord = ssq - nn;
         IF ss < - x_coord:
            x_coord = -x_coord - 2 * ss;
         IF_END
      ELSE:
         ret_arr_p[1] = nn - ssq - 3 * ss - 1;
         x_coord = nn - ssq - 2 * ss;
         IF ss < x_coord:
            x_coord = -x_coord + 2 * ss + 2;
         IF_END
      IF_END
   IF_END
   ret_arr_p[0] = x_coord;
   RETURN x_coord;
FUNC_END
#   FFFFFFFFFFunction ----------------------------- d2spiral_d1 #
FUNC INT d2spiral_d1(INT xx
      , INT yy):
   # Convert a 2D square coordinates into 1D coordinate
   # r/c   ... -3 -2 -1  0  1  2  3 ...
   #   --------------------------------
   #   .   ...  .  .  .  .  .  .  . ...
   #   3   ... 36 35 34 33 32 31 30 ...
   #   2   ... 37 16 15 14 13 12 29 ...
   #   1   ... 38 17  4  3  2 11 28 ...
   #   0   ... 39 18  5  0  1 10 27 ...
   #  -1   ... 40 19  6  7  8  9 26 ...
   #  -2   ... 41 20 21 22 23 24 25 ...
   #  -3   ... 42 43 44 45 46 47 48 ...
   #   .   ...  .  .  .  .  .  .  . ...
   INT retvalu;
   IF xx == 0 AND yy == 0:
      retvalu = 0;
   ELSIF ABSL(xx) <= ABSL(yy):
      # NORTH and SOUTH quarter planes
      retvalu = (4 * yy - 1) * yy - xx;
      IF yy < 0:
         #SOUTH quarter plane
         retvalu -= 2 * (yy - xx);
      IF_END
   ELSE:
      # EAST and WEST quarter planes
      retvalu = (4 * xx - 1) * xx - yy;
      IF 0 < xx:
         # EAST quarter planes
         retvalu -= 2 * (xx - yy);
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------- d1spiral_d2 #
FUNC INT d1spiral_d2(INT nn
      , WRITEONLY INT ret_arr_p[]):
   # Find where NN is
   # r/c   ... -3 -2 -1  0  1  2  3 ...
   #   --------------------------------
   #   .   ...  .  .  .  .  .  .  . ...
   #   3   ... 36 35 34 33 32 31 30 ...
   #   2   ... 37 16 15 14 13 12 29 ...
   #   1   ... 38 17  4  3  2 11 28 ...
   #   0   ... 39 18  5  0  1 10 27 ...
   #  -1   ... 40 19  6  7  8  9 26 ...
   #  -2   ... 41 20 21 22 23 24 25 ...
   #  -3   ... 42 43 44 45 46 47 48 ...
   #   .   ...  .  .  .  .  .  .  . ...
   INT sqrtnn;
   INT newdd;
   INT fxd;
   IF nn <= 0:
      ret_arr_p[0] = 0;
      ret_arr_p[1] = 0;
   ELSE:
      sqrtnn = FLOORL(SQRT(nn));
      IF Kw.iseven(sqrtnn):
         fxd = -sqrtnn / 2;
      ELSE:
         fxd = (sqrtnn + 1) / 2;
      IF_END
      newdd = nn - sqrtnn * sqrtnn;
      IF newdd <= sqrtnn:
         ret_arr_p[0] = fxd;
         IF fxd < 0:
            ret_arr_p[1] = -fxd - newdd;
         ELSE:
            ret_arr_p[1] = -fxd + newdd + 1;
         IF_END
      ELSE:
         ret_arr_p[1] = fxd;
         newdd -= sqrtnn;
         IF fxd < 0:
            ret_arr_p[0] = fxd + newdd;
         ELSE:
            ret_arr_p[0] = fxd - newdd;
         IF_END
      IF_END
   IF_END
   RETURN ret_arr_p[0];
FUNC_END
#   FFFFFFFFFFunction ------------------------------ d2hypot_d1 #
FUNC INT d2hypot_d1(INT xx
      , INT yy):
   # Convert a 2D triangular coordinates into 1D coordinate
   # If YY < 0 OR XX < YY: return -1
   # == number of lattice points(a,b) such that
   #      1) 0 <= b <= a
   #      2) a*a+b*b < XX*XX+YY*YY OR
   #         (a*a+b*b == XX*XX+YY*YY AND XX < aa)
   # d2hypot_d1(4,3) < d2hypot_d1(5,0)
   # r/c   -1  0  1  2  3  4  5 ...
   #   --------------------------
   #   .    .  .  .  .  .  .  . ...
   #   5   -1 -1 -1 -1 -1 -1 25 ...
   #   4   -1 -1 -1 -1 -1 17 22 ...
   #   3   -1 -1 -1 -1 11 13 18 ...
   #   2   -1 -1 -1  5  8 12 16 ...
   #   1   -1 -1  2  4  7 10 15 ...
   #   0   -1  0  1  3  6  9 14 ...
   #  -1   -1 -1 -1 -1 -1 -1 -1 ...
   INT retvalu;
   INT xlim;
   DBL dist;
   INT distsq;
   INT count;
   INT ixx;
   INT nyy;
   INT nyysq;
   INT xmax;
   IF 0 <= yy AND yy <= xx:
      distsq = xx * xx + yy * yy;
      dist = SQRT(distsq);
      xlim = FLOORL(dist / Kw.SQRTTWO);
      xmax = FLOORL(dist);
      count = 0;
      FOR ixx FROM xlim TO xmax:
         nyysq = distsq - ixx * ixx;
         nyy = CEILL(SQRT(nyysq));
         IF ixx < nyy:
            count += ixx + 1;
         ELSE:
            count += nyy;
            IF ixx < xx AND nyy * nyy == nyysq:
               count += 1;
            IF_END
         IF_END
      FOR_END
      retvalu = count + xlim * (xlim + 1) / 2;
   ELSE:
      retvalu = -1;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- binomialx #
FUNC DBL binomialx(DBL xnn
      , DBL xkk):
   # TGAMMA(XNN + 1) / (TGAMMA(XKK + 1) * TGAMMA(XNN + 1 - XKK))
   # a real valued extension of BINOMIAL(XNN, XKK)
   RETURN Kw.tgamma(xnn + 1) / (Kw.tgamma(xkk + 1)
         * Kw.tgamma(xnn + 1 - xkk));
FUNC_END
BLOCK:# binomial numbers
   BLOCK_DEF DBL lv_binom_arr[0];
   BLOCK_DEF INT lv_binom_end = 0;
   BLOCK_DEF INT lv_binom_max = 0;
   #   FFFFFFFFFFunction ----------------------------- binomial #
   FUNC INT binomial(INT nn
         , INT kk):
      # factorial(NN) / (factorial(KK) * factorial(NN - KK))
      #   == Binomial(NN - 1, KK - 1) + Binomial(NN - 1, KK)
      BLOCK_USE lv_binom_arr[];
      BLOCK_USE lv_binom_end;
      BLOCK_USE lv_binom_max;
      INT rz_ind;
      INT lz_ind;
      INT rr;
      INT ul_ind;
      INT retvalu;
      IF nn < kk OR nn < 0 OR kk < 0:
         retvalu = 0;
      ELSE:
         IF lv_binom_end <= 0:
            lv_binom_max = 2;
            lv_binom_end = d2lt_d1(lv_binom_max, 0);
            REDIM lv_binom_arr[], lv_binom_end;
            lv_binom_arr[0] = 1;
            lv_binom_arr[1] = 1;
            lv_binom_arr[2] = 1;
         IF_END
         rr = lv_binom_max;
         IF rr < nn + 1:
            lv_binom_end = d2lt_d1(nn + 1, 0);
            REDIM lv_binom_arr[], lv_binom_end;
            WHILE rr <= nn:
               ul_ind = d2lt_d1(rr - 1, 0);
               lz_ind = ul_ind + rr;
               lv_binom_arr[lz_ind] = 1;
               rz_ind = lz_ind + rr;
               WHILE lz_ind < rz_ind:
                  lv_binom_arr[rz_ind] = lv_binom_arr[lz_ind];
                  rz_ind -= 1;
                  lz_ind += 1;
                  lv_binom_arr[lz_ind] = (lv_binom_arr[ul_ind]
                        + lv_binom_arr[ul_ind + 1]);
                  ul_ind += 1;
               WHILE_END
               rr += 1;
            WHILE_END
            lv_binom_max = rr;
         IF_END
         retvalu = lv_binom_arr[d2lt_d1(nn, kk)];
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END# binomial numbers
#TEST:binomial(9,4)-126;
#TEST:binomial(10,4)-210;
BLOCK:# eulerian numbers
   BLOCK_DEF DBL lv_euler_arr[0];
   BLOCK_DEF INT lv_euler_end = 0;
   BLOCK_DEF INT lv_euler_max = 0;
   #   FFFFFFFFFFunction ----------------------------- eulerian #
   FUNC DBL eulerian(INT nn
         , INT mm):
      # EULERIAN(NN, MM) == # of permutations of 0,1,2,...NN-1
      #       with exactly MM elements < next element
      # EULERIAN(NN, MM) == (NN - MM) * EULERIAN(NN - 1, MM - 1)
      #                   + (MM + 1)  * EULERIAN(NN - 1, MM)
      # eulerian(4,0) == 1
      #    ddd 3210
      # eulerian(4,1) == 11
      #    udd 0321,1320,2310
      #    dud 1032,2031,2130,3021,3120
      #    ddu 2103,3102,3021
      # eulerian(4,2) == 11
      #    uud 0132,0231,1230
      #    udu 0213,0312,1203,1302,2301
      #    duu 1023,2013,3012
      # eulerian(4,3) == 1
      #    uuu 0123
      BLOCK_USE lv_euler_arr[];
      BLOCK_USE lv_euler_end;
      BLOCK_USE lv_euler_max;
      INT cr;
      INT rr;
      INT lz_ind;
      INT rz_ind;
      INT ul_ind;
      DBL retvalu;
      IF nn < mm OR nn < 0 OR mm < 0:
         retvalu = 0;
      ELSE:
         IF lv_euler_end <= 0:
            lv_euler_max = 3;
            lv_euler_end = d2lt_d1(lv_euler_max, 0);
            REDIM lv_euler_arr[], lv_euler_end;
            lv_euler_arr[0] = 0;
            lv_euler_arr[1] = 1;
            lv_euler_arr[2] = 0;
            lv_euler_arr[3] = 1;
            lv_euler_arr[4] = 1;
            lv_euler_arr[5] = 0;
         IF_END
         rr = lv_euler_max;
         IF rr < nn + 1:
            lv_euler_end = d2lt_d1(nn + 1, 0);
            REDIM lv_euler_arr[], lv_euler_end;
            WHILE rr <= nn:
               lz_ind = d2lt_d1(rr, 0);
               lv_euler_arr[lz_ind] = 1;
               lv_euler_arr[lz_ind + rr] = 0;
               rz_ind = lz_ind + rr - 1;
               ul_ind = d2lt_d1(rr - 1, 0);
               cr = 1;
               WHILE lz_ind < rz_ind:
                  # take advantage of EULER(x,y) = EULER(x,x-y)
                  lv_euler_arr[rz_ind] = lv_euler_arr[lz_ind];
                  lz_ind += 1;
                  lv_euler_arr[lz_ind] = ((rr - cr)
                        * lv_euler_arr[ul_ind] + (cr + 1)
                        * lv_euler_arr[ul_ind + 1]);
                  ul_ind += 1;
                  rz_ind -= 1;
                  cr += 1;
               WHILE_END
               rr += 1;
               lv_euler_max = rr;
            WHILE_END
         IF_END
         retvalu = lv_euler_arr[d2lt_d1(nn, mm)];
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END# eulerian numbers
#TEST:eulerian(8,5)-4293;
#TEST:eulerian(9,5)-88234;
BLOCK:# Entringer numbers
   BLOCK_DEF DBL lv_entringer_arr[0];
   BLOCK_DEF INT lv_entringer_end = 0;
   BLOCK_DEF INT lv_entringer_max = 0;
   #   FFFFFFFFFFunction ---------------------------- entringer #
   FUNC DBL entringer(INT nn
         , INT kk):
      # Entringer number
      # == number of permutations of[0,NN],
      #   starting with KK, which, after initially falling,
      #   alternately rise then fall.
      # E.G. entringer(4,2): 21403 21304 20413 20314
      #      hence entringer(4,2) == 4
      # E.G. entringer(4,4): 42301 41203 41302 40312 40213
      #      hence entringer(4,4) == 5
      BLOCK_USE lv_entringer_arr[];
      BLOCK_USE lv_entringer_max;
      BLOCK_USE lv_entringer_end;
      INT cz;
      INT inda;
      INT rr;
      DBL retvalu;
      IF nn <= 0 OR kk < 0 OR nn < kk:
         retvalu = 0;
      ELSE:
         IF lv_entringer_end <= 0:
            lv_entringer_max = 1;
            lv_entringer_end = d2lt_d1(lv_entringer_max, 0);
            REDIM lv_entringer_arr[], lv_entringer_end;
            lv_entringer_arr[0] = 1;
         IF_END
         rr = lv_entringer_max;
         IF rr < nn + 1:
            lv_entringer_end = d2lt_d1(nn + 1, 0);
            REDIM lv_entringer_arr[], lv_entringer_end;
            WHILE rr <= nn:
               inda = d2lt_d1(rr, 0);
               lv_entringer_arr[inda] = 0;
               FOR cz FROM 1 TO rr:
                  lv_entringer_arr[inda + cz]
                        = lv_entringer_arr[inda + cz - 1]
                        + lv_entringer_arr[inda - cz];
               FOR_END
               rr += 1;
               lv_entringer_max = rr;
            WHILE_END
         IF_END
         retvalu = lv_entringer_arr[d2lt_d1(nn, kk)];
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END# Entringers numbers
#TEST:entringer(5,3)-14
#   FFFFFFFFFFunction ---------------------------------- zigzag #
FUNC DBL zigzag(INT nn):
   # Number of alternating permutations on[0..NN-1]
   #   starting with a rise
   #   == entringer(NN,NN)
   # E.G. if NN=4 the alternating permutations(starting with
   #      a rise) are 0312 0213 1203 1302 2301
   # So zigzag(4) == 5
   # EGF(zigzag();x) = sec(x) + tan(x)
   # zigzag(NN) is about 2 * (2 / PI)**(NN + 1) * factorial(NN)
   # bell(2 * NN) * (4**(2 * NN) - 2**(2 * NN)) =
   #      (-1)**(NN + 1)* 2 * NN * zigzag(2 * NN - 1)
   # sec(X) = SUM[II;0;Inf;2;zigzag(II)*XX**II/factorial(II)]
   # tan(X) = SUM[II;1;Inf;2;zigzag(II)*XX**II/factorial(II)]
   RETURN Kw.entringer(nn, nn);
FUNC_END
#TEST:zigzag(6)-61;
#TEST:zigzag(7)-272;
#TEST:zigzag(8)-1385;
#TEST:zigzag(9)-7936;
#TEST:zigzag(10)-50521;
#TEST:zigzag(12)-2702765;
#   FFFFFFFFFFunction ------------------------------------- zig #
FUNC DBL zig(INT nn):
   # Zig(or Secant) numbers
   # EGF(zig();x) = sec(SQRT(x));
   RETURN Kw.zigzag(2 * nn);
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- zag #
FUNC DBL zag(INT nn):
   # Zag(or Tangent) numbers
   # EGF(zag();x) = tan(SQRT(x)) / SQRT(x);
   RETURN Kw.zigzag(2 * nn - 1);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- eulerx #
FUNC DBL eulerx(INT nn):
   # Euler number
   # EGF(eulerx();x) = sec(x)
   DBL retvalu;
   IF nn <= 0 OR Kw.isodd(nn):
      retvalu = 0;
   ELSE:
      retvalu = Kw.entringer(nn, nn);
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:eulerx(12)-2702765;
#   FFFFFFFFFFunction ---------------------------------- ballot #
FUNC DBL ballot(DBL xmm
      , DBL xnn):
   # probability of counting
   #    NN votes for candidate 1 and
   #    MM votes for candidate 2
   # such that the winner is always strictly ahead of the loser
   RETURN ABS(xnn - xmm) / (xmm + xnn);
FUNC_END
#   FFFFFFFFFFunction --------------------------------- ballots #
FUNC DBL ballots(DBL xmm
      , DBL xnn):
   # probability of counting
   #    NN votes for candidate 1 and
   #    MM votes for candidate 2
   # such that the winner is never behind of the loser
   DBL retvalu;
   IF xmm < xnn:
      retvalu = (xnn - xmm + 1.0) / (xnn + 1.0);
   ELSE:
      retvalu = (xmm - xnn + 1.0) / (xmm + 1.0);
   IF_END
   RETURN retvalu;
FUNC_END
BLOCK:# Stirling numbers of the 1th kind
   BLOCK_DEF DBL lv_stir_a_arr[0];
   BLOCK_DEF INT lv_stir_a_end = 0;
   BLOCK_DEF INT lv_stir_a_max = 0;
   #   FFFFFFFFFFunction ---------------------------- stirling1 #
   FUNC DBL stirling1(INT nn
         , INT kk):
      # Stirling numbers of the 1th kind
      # The ABS(stirling1(NN, KK)) == # of permutations
      #    of NN objects with exactly KK cycles.
      # Let ff(x,n) == x(x-1)(x-2)(x-3)...(x-n+1).
      #    ff(x,n) = SUM k = 0 TO N OF stirling1(n,k) * x**k
      BLOCK_USE lv_stir_a_arr[];
      BLOCK_USE lv_stir_a_end;
      BLOCK_USE lv_stir_a_max;
      INT col_k;
      INT ul_ind;
      INT cz_ind;
      INT rr;
      DBL retvalu;
      IF nn < 0 OR kk < 0 OR nn < kk:
         retvalu = 0;
      ELSE:
         # STIRLING1(NN, KK) = -(NN - 1) * STIRLING1(NN - 1, KK)
         #         + STIRLING1(NN - 1, KK - 1);
         # with initial conditions
         #   A) STIRLING1(0,0) = 1 and
         #   B) STIRLING1(NN,0) = STIRLING1(0,NN) = 0 for 0 < NN
         IF lv_stir_a_max <= 0:
            lv_stir_a_max = 2;
            lv_stir_a_end = d2lt_d1(lv_stir_a_max, 0);
            REDIM lv_stir_a_arr[], lv_stir_a_end;
            lv_stir_a_arr[0] = 1;
            lv_stir_a_arr[1] = 0;
            lv_stir_a_arr[2] = 1;
         IF_END
         rr = lv_stir_a_max;
         IF rr < nn + 1:
            lv_stir_a_end = d2lt_d1(nn + 1, 0);
            REDIM lv_stir_a_arr[], lv_stir_a_end;
            WHILE rr <= nn:
               cz_ind = d2lt_d1(rr, 0);
               lv_stir_a_arr[cz_ind] = 0;
               cz_ind += 1;
               ul_ind = d2lt_d1(rr - 1, 0);
               FOR col_k FROM 1 TO rr - 1:
                  lv_stir_a_arr[cz_ind]
                        = (lv_stir_a_arr[ul_ind] - (rr - 1)
                        * lv_stir_a_arr[ul_ind + 1]);
                  ul_ind += 1;
                  cz_ind += 1;
               FOR_END
               lv_stir_a_arr[cz_ind] = 1;
               rr += 1;
               lv_stir_a_max = rr;
            WHILE_END
         IF_END
         retvalu = lv_stir_a_arr[d2lt_d1(nn, kk)];
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END#TEST:stirling1(9,6)+4536;
BLOCK:# Stirling numbers of the 2th kind
   BLOCK_DEF DBL lv_stir_b_arr[0];
   BLOCK_DEF INT lv_stir_b_end = 0;
   BLOCK_DEF INT lv_stir_b_max = 0;
   #   FFFFFFFFFFunction ---------------------------- stirling2 #
   FUNC DBL stirling2(INT nn
         , INT kk):
      # Stirling numbers of the 2th kind
      # # of possible rhyming schemes for NN lines using
      #       KK unique rhyming syllables.
      # Let ff(x,n) == x(x-1)(x-2)(x-3)...(x-n+1).
      #    x**n = SUM k = 0 TO NN OF stirling2(n,k) * ff(x,n)
      # E. G. for a poem of 4 lines, there are:
      # bell(N) = SUM[k = 0 to N](stirling2(N, k))
      BLOCK_USE lv_stir_b_arr[];
      BLOCK_USE lv_stir_b_end;
      BLOCK_USE lv_stir_b_max;
      INT col_k;
      INT ul_ind;
      INT cz_ind;
      INT rr;
      DBL retvalu;
      IF nn < kk OR nn < 0 OR kk < 0:
         retvalu = 0;
      ELSE:
         # STIRLING2(NN, KK) = KK * STIRLING2(NN - 1,KK)
         #                       + STIRLING2(NN - 1,KK - 1)
         # with initial conditions
         #   A) STIRLING2(0,0) = 1 and
         #   B) STIRLING2(NN,0) = STIRLING2(0,NN) = 0 for 0 < NN
         IF lv_stir_b_end <= 0:
            lv_stir_b_max = 2;
            lv_stir_b_end = d2lt_d1(lv_stir_b_max, 0);
            REDIM lv_stir_b_arr[], lv_stir_b_end;
            lv_stir_b_arr[0] = 1;
            lv_stir_b_arr[1] = 0;
            lv_stir_b_arr[2] = 1;
         IF_END
         rr = lv_stir_b_max;
         IF rr < nn + 1:
            lv_stir_b_end = d2lt_d1(nn + 1, 0);
            REDIM lv_stir_b_arr[], lv_stir_b_end;
            WHILE rr <= nn:
               cz_ind = d2lt_d1(rr, 0);
               lv_stir_b_arr[cz_ind] = 0;
               cz_ind += 1;
               ul_ind = d2lt_d1(rr - 1, 0);
               FOR col_k FROM 1 TO rr - 1:
                  lv_stir_b_arr[cz_ind]
                        = (lv_stir_b_arr[ul_ind] + col_k
                        * lv_stir_b_arr[ul_ind + 1]);
                  ul_ind += 1;
                  cz_ind += 1;
               FOR_END
               lv_stir_b_arr[cz_ind] = 1;
               rr += 1;
               lv_stir_b_max = rr;
            WHILE_END
         IF_END
         retvalu = lv_stir_b_arr[d2lt_d1(nn, kk)];
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END#TEST:stirling2(9,6)-2646;
BLOCK:# Bernoullis numbers
   BLOCK_DEF DBL lv_bern_n_arr[0];
   BLOCK_DEF DBL lv_bern_d_arr[0];
   BLOCK_DEF INT lv_bern_end = 0;
   #   FFFFFFFFFFunction ---------------------------- bernoulli #
   FUNC DBL bernoulli(INT nn):
      # the NNth Bernoulli number
      # if 1 < NN is odd, then bernoulli(NN) = 0
      # EGF(bernoulli();x) = x / (EXP(x) - 1)
      BLOCK_USE lv_bern_n_arr[];
      BLOCK_USE lv_bern_d_arr[];
      BLOCK_USE lv_bern_end;
      DBL retvalu;
      INT sz_ind;
      DBL coeff;
      DBL sumn;
      DBL sumd;
      INT jj;
      INT mm;
      DBL gdn;
      DBL nsumn;
      DBL nsumd;
      DBL xkk;
      INT nnhalf;
      IF nn == 1:
         # the first bernoulli number is weird
         retvalu = -0.5;
      ELSIF nn < 0 OR Kw.isodd(nn):
         retvalu = 0.0;
      ELSE:
         IF lv_bern_end <= 0:
            lv_bern_end = 3;
            REDIM lv_bern_n_arr[], lv_bern_end;
            REDIM lv_bern_d_arr[], lv_bern_end;
            lv_bern_n_arr[0] = 1;
            lv_bern_n_arr[1] = 1;
            lv_bern_n_arr[2] = -1;
            lv_bern_d_arr[0] = 1;
            lv_bern_d_arr[1] = 6;
            lv_bern_d_arr[2] = 30;
         IF_END
         nnhalf = FLOORL(nn / 2);
         IF lv_bern_end <= nnhalf:
            mm = lv_bern_end;
            lv_bern_end = nnhalf + 1;
            REDIM lv_bern_n_arr[], lv_bern_end;
            REDIM lv_bern_d_arr[], lv_bern_end;
            WHILE mm < lv_bern_end:
               sz_ind = 2 * mm;
               # coeff is always an integer
               coeff = ((sz_ind + 1) * sz_ind) / 2;
               sumn = 1.0 - sz_ind;
               sumd = 2.0;
               FOR jj FROM 1 TO mm - 1:
                  # compute the numerator and denominator
                  nsumn = Kw.round(sumn * lv_bern_d_arr[jj]
                        + sumd * coeff * lv_bern_n_arr[jj]);
                  nsumd = Kw.round(sumd * lv_bern_d_arr[jj]);
                  gdn = gcd(nsumn, nsumd);
                  sumn = nsumn / gdn;
                  sumd = nsumd / gdn;
                  xkk = 2 * jj;
                  coeff *= (sz_ind - xkk + 1.0) / (xkk + 1.0);
                  coeff *= (sz_ind - xkk) / (xkk + 2.0);
                  coeff = Kw.round(coeff);
               FOR_END
               sumd *= (sz_ind + 1);
               gdn = Kw.gcd(sumn, sumd);
               lv_bern_n_arr[mm] = -sumn / gdn;
               lv_bern_d_arr[mm] = sumd / gdn;
               mm += 1;
            WHILE_END
         IF_END
         retvalu = lv_bern_n_arr[nnhalf] / lv_bern_d_arr[nnhalf];
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- bernoullin #
   FUNC INT bernoullin(INT nn):
      # the numerator of the NNth bernoulli number
      BLOCK_USE lv_bern_n_arr[];
      BLOCK_USE lv_bern_d_arr[];
      INT retvalu;
      IF nn == 1:
         # the first Bernoulli number is weird
         retvalu = -1;
      ELSIF Kw.isodd(nn) OR nn < 0:
         retvalu = 0;
      ELSE:
         retvalu = Kw.bernoulli(nn);
         retvalu = lv_bern_n_arr[nn / 2];
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- bernoullid #
   FUNC INT bernoullid(INT nn):
      # the denominator of the NNth Bernoulli number
      BLOCK_USE lv_bern_n_arr[];
      BLOCK_USE lv_bern_d_arr[];
      INT retvalu;
      IF nn == 1:
         # the first Bernoulli number is weird
         retvalu = 2;
      ELSIF Kw.isodd(nn) OR nn < 0:
         retvalu = 1;
      ELSE:
         retvalu = Kw.bernoulli(nn);
         retvalu = lv_bern_d_arr[nn / 2];
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END#TEST:bernoulli(12)*2730+691;
#   FFFFFFFFFFunction -------------------------------- birthday #
FUNC DBL birthday(DBL xnn
      , DBL xrr):
   # the probability that every pigeon has a hole to itself
   # if RR pigeons are placed in NN pigeon holes.
   DBL prob;
   INT ii;
   prob = 1.0;
   FOR ii FROM 1 TO xrr - 1:
      prob *= (xnn - ii) / xnn;
   FOR_END
   RETURN prob;
FUNC_END
#   FFFFFFFFFFunction ----------------------------- birthdayinv #
FUNC DBL birthdayinv(DBL xnn
      , DBL xprob):
   # XRR such that PROB = BIRTHDAY(XRR, XNN)
   # the number, RR, of pigeons such that the probability
   # of placing RR pigeons in NN holes with each pigeons
   # having its own holes is PROB
   DBL xrr;
   DBL cprob;
   cprob = 1.0;
   xrr = 1.0;
   WHILE xprob < cprob:
      cprob *= (xnn - xrr) / xnn;
      xrr += 1;
   WHILE_END
   RETURN xrr;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- n2perm #
FUNC INT n2perm(INT mm
      , INT nn
      , WRITEONLY INT ret_perm_arr_p[]):
   # n2perm(M, N) == Mth permutation of N things
   # e.g. n2perm(0, N)=(0, 1, 2, 3, ..., (N-1))
   # e.g. n2perm(factorial(N)-1, N)=((N-1), ..., 3, 2, 1, 0)
   INT ii;
   INT pat_arr[];
   INT source_arr[];
   INT jj;
   INT kk;
   INT sz_ind;
   MODE_INTEGER:
      REDIM pat_arr[], nn;
      REDIM source_arr[], nn;
      kk = mm;
      FOR ii FROM 1 TO nn:
         pat_arr[nn - ii] = kk % ii;
         kk = FLOOR(kk / ii);
         source_arr[ii - 1] = ii - 1;
      FOR_END
      FOR ii FROM 0 TO nn - 1:
         sz_ind = pat_arr[ii];
         ret_perm_arr_p[ii] = source_arr[sz_ind];
         # splice out source_arr[sz_ind]
         FOR jj FROM sz_ind TO nn - ii - 2:
            source_arr[jj] = source_arr[jj + 1];
         FOR_END
      FOR_END
   MODE_INTEGER_END
   REDIM pat_arr[];
   REDIM source_arr[];
   RETURN mm;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- n2comb #
FUNC INT n2comb(INT mm
      , INT nn
      , INT rr
      , WRITEONLY INT ret_comb_arr_p[]):
   # n2comb(M, N, R) = Mth combination of N things taken
   # R at a time
   # e.g. n2comb(0, N, R) = ((N-R), (N-R+1), .., N-1).
   # No error checking done.
   INT kk;
   INT cc;
   INT qq;
   INT ss;
   INT pp;
   MODE_INTEGER:
      kk = Kw.comb(nn, rr) - mm;
      FOR ss FROM 0 TO rr - 1:
         pp = rr - ss;
         cc = 1;
         qq = 1;
         WHILE cc < kk:
            kk -= cc;
            # cc should always be an integer
            cc = (cc * pp) / qq;
            qq += 1;
            pp += 1;
         WHILE_END
         ret_comb_arr_p[ss] = nn - pp;
      FOR_END
   MODE_INTEGER_END
   RETURN mm;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ pochhammer #
FUNC DBL pochhammer(INT nn
      , DBL xx):
   # if 0 < nn:
   #    The rising Pochhammer symbol
   #    XX * (XX + 1) * ... * (XX + NN)
   # else
   #    The falling Pochhammer symbol
   #    XX * (XX - 1) * ... * (XX - (-NN))
   DBL retvalu;
   INT ii;
   IF 0 < nn:
      retvalu = xx;
      FOR ii FROM 1 TO nn:
         retvalu *= (xx + ii);
      FOR_END
   ELSIF nn < 0:
      retvalu = xx;
      FOR ii FROM - 1 TO nn BY - 1:
         retvalu *= (xx + ii);
      FOR_END
   ELSE:
      retvalu = 1.0;
   IF_END
   RETURN retvalu;
FUNC_END
#   IIIIIIIIIInsert-End --------------------------- combin.fwip #
#   IIIIIIIIIInsert-Begin ------------------------- julian.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-20 kdw  julian:boolean checks changed
# 2020-08-19 kdw  julian:comment change
# 2020-08-17 kdw  julian:comment change
# 2020-07-29 kdw  julian:block-def work
# 2020-07-27 kdw  julian:block syntax
# 2020-07-24 kdw  julian:comment cleanup
# 2020-06-29 kdw  julian:halaqim def local
# 2020-06-22 kdw  julian:local-use mved before var decls
# 2020-06-17 kdw  julian:modulo parens
# 2020-05-30 kdw  julian:CONST syntax change
# 2020-05-20 kdw  julian:module for tau made explicit
# 2020-05-18 kdw  julian:minor cleanup
# 2020-05-13 kdw  julian:.*_LA[S]T changed to .*_COU[N]T
# 2020-05-11 kdw  julian:REPL[A]CE replaced with LO[C]AL_CO[N]ST
# 2020-05-07 kdw  julian:more boolean variable work
# 2020-05-06 kdw  julian:boolean variable work
# 2020-04-28 kdw  julian:tweaks here and there
# 2020-04-26 kdw  julian:BL[O]CK indentation work
# 2020-04-24 kdw  julian:sec[2]dhms
# 2020-04-23 kdw  julian:const format change
# 2020-04-17 kdw  julian:comments changed; minor rearrange
# 2020-04-14 kdw  julian:tests added
# 2020-04-13 kdw  julian:numeric inequality work
# 2020-04-12 kdw  julian:comment change
# 2020-04-08 kdw  julian:preprocess sigil change
# 2020-03-17 kdw  julian:isl[e]apyear renam
# 2020-03-10 kdw  julian:LO[C]AL_USE more consistent
# 2020-03-09 kdw  julian:LO[C]AL_.* keywords
# 2020-03-06 kdw  julian:RE[P]LACE / IN[D]EX changes
# 2020-03-03 kdw  julian:comment change
# 2020-03-02 kdw  julian:s/_N[E]XT/_E[N]D/
# 2020-02-24 kdw  julian:function comments
# 2020-01-22 kdw  julian:print_j[d]264
# 2020-01-21 kdw  julian:j[d]264 func
# 2019-12-31 kdw  julian:clock.*() funcs
# 2019-12-27 kdw  julian:eplicit K[w] module
# 2019-12-26 kdw  julian:module name addded to funcs
# 2019-11-08 kdw  julian:mved consts to constants
# 2019-10-17 kdw  julian:halaqin work
# 2019-10-14 kdw  julian:jewish work
# 2019-10-04 kdw  julian:comment change
# 2019-10-02 kdw  julian:comment change
# 2019-09-27 kdw  julian:replace word JD with JD[A]Y
# 2019-09-22 kdw  julian:s/J[D]_AT_/JDSEC_AT_/g
# 2019-09-21 kdw  julian:several const renamd
# 2019-09-18 kdw  julian:comment change
# 2019-09-17 kdw  julian:rmed c[n]v_db[l]2i32
# 2019-09-11 kdw  julian:tweak in RH func
# 2019-08-20 kdw  julian:jew[i]shy[m]d2jd func
# 2019-08-18 kdw  julian:B[O]OL to B[O]L
# 2019-08-11 kdw  julian:comment cleanup
# 2019-08-06 kdw  julian:rmed backslashes; macro arg name change
# 2019-07-20 kdw  julian:func descriptions
# 2019-05-29 kdw  julian:comment changed
# 2019-05-24 kdw  julian:local replaced private
# 2019-05-23 kdw  julian:replace renam
# 2019-05-21 kdw  julian:je[w]ish2j[d]x refactor / fix
# 2019-04-30 kdw  julian:rework of jd2ymdhms, j2k2ymdhms funcs
# 2019-03-19 kdw  julian:re[t]_val to re[t]valu
# 2019-03-08 kdw  julian:is[e]qual to is[e]q, et al.
# 2019-03-01 kdw  julian:ymd[h]ms2j2k created
# 2019-02-28 kdw  julian:REP[L]ACE/DE[F]INE work
# 2019-02-03 kdw  julian:day2hms.* funcs
# 2019-01-31 kdw  julian:conversion func rework
# 2018-12-08 kdw  julian:comment change
# 2018-10-08 kdw  julian:vbdotnet stuff
# 2018-09-28 kdw  julian:var renam
# 2018-09-17 kdw  julian:comment change
# 2018-09-16 kdw  julian:func renam
# 2018-07-19 kdw  julian:comments; array reformat
# 2018-06-14 kdw  julian:const changed
# 2018-05-22 kdw  julian:comment change
# 2018-05-14 kdw  julian:BL(O)CK syntax change
# 2018-05-06 kdw  julian:comment change
# 2018-04-16 kdw  julian:.*_diff work
# 2018-04-15 kdw  julian:kwt work
# 2018-04-14 kdw  julian:ep(o)chx renamd to kwt
# 2018-04-10 kdw  julian:reorder conversion funcs
# 2018-04-03 kdw  julian:rm() from return
# 2018-03-20 kdw  julian:replaced index w/ "at"replace
# 2018-03-19 kdw  julian:var nam change
# 2018-03-16 kdw  julian:format of constant and index change
# 2018-03-12 kdw  julian:made PP statements not need semicolon
# 2018-02-15 kdw  julian:var nam change for VB6 VBDOTNET
# 2018-02-14 kdw  julian:IN[D]EX stuff
# 2018-02-01 kdw  julian:tweak
# 2018-01-29 kdw  julian:julian consts renamd
# 2018-01-28 kdw  julian:time const name change
# 2018-01-22 kdw  julian:*_elapsed_* funcs renamd; parenthesis
# 2017-12-08 kdw  julian:ym[d]2jd refactor
# 2017-12-05 kdw  julian:doo[m]sday comments
# 2017-11-26 kdw  julian:FR[O]M and B[Y] keywords
# 2017-11-23 kdw  julian:rm digits from var names
# 2017-11-22 kdw  julian:var renam
# 2017-10-25 kdw  julian:h2[h]ms.*
# 2017-10-21 kdw  julian:macros start with "at"
# 2017-10-20 kdw  julian:REP[L]ACE syntax changed
# 2017-09-27 kdw  julian:var nam changed
# 2017-09-26 kdw  julian:jewish elapsed days work
# 2017-09-22 kdw  julian:jd2y(m)dhms rework
# 2017-09-20 kdw  julian:nasty bug in jd2y(m)dhms; rmed ym(d)2j2k
# 2017-09-18 kdw  julian:ymd(h)ms2jd work
# 2017-09-17 kdw  julian:ymd(h)ms2jd
# 2017-09-14 kdw  julian:units work
# 2017-09-12 kdw  julian:day2h[m]s function
# 2017-09-11 kdw  julian:consts renamed, refactor ym(d)2j2k
# 2017-09-06 kdw  julian:UNITS support
# 2017-08-25 kdw  julian:d(a)y2hms bug
# 2017-08-20 kdw  julian:rmed/renamd .*_P[E]R_.* vars
# 2017-07-12 kdw  julian:m(o)dulo to M(O)D
# 2017-06-23 kdw  julian:REP(L)ACE redo
# 2017-04-21 kdw  julian:func to function
# 2017-03-19 kdw  julian:comments
# 2017-03-17 kdw  julian:python stuff in jd2ym.*
# 2017-03-12 kdw  julian:shorten long comments
# 2017-03-10 kdw  julian:get Fw[i]p_Pa[r]se to work
# 2017-03-06 kdw  julian:sigils rmed
# 2017-03-01 kdw  julian:var[y]log-a[d]d space messup
# 2017-02-28 kdw  julian:REQ[U]IRE function()
# 2017-02-24 kdw  julian:REP[L]ACE rework, et al
# 2017-02-23 kdw  julian:var renam
# 2017-02-20 kdw  julian:var renam
# 2017-02-14 kdw  julian:FWIP Loop syntax changed
# 2017-02-12 kdw  julian:FWIP language change
# 2017-02-07 kdw  julian:comment rearrangement
# 2017-01-31 kdw  julian:long lines
# 2016-12-18 kdw  julian:jewish_* refactor
# 2016-12-16 kdw  julian:jewish_* refactor
# 2016-12-12 kdw  julian:var name change; comment changed
# 2016-12-05 kdw  julian:comment change
# 2016-12-04 kdw  julian:comment reorg
# 2016-12-02 kdw  julian:rmed unused hour-per-degree
# 2016-11-28 kdw  julian:file suffix changed
# 2016-11-21 kdw  julian:D(E)F to F(U)NC
# 2016-11-20 kdw  julian:language change
# 2016-11-19 kdw  julian:is leap tyear refactor
# 2016-11-18 kdw  julian:__(P)OD(_)_
# 2016-11-16 kdw  julian:function renam
# 2016-11-15 kdw  julian:function descriptions
# 2016-11-14 kdw  julian:ho(l)id.fwip consolidation
# 2016-11-11 kdw  julian:var name change
# 2016-09-14 kdw  julian:lang change
# 2016-08-08 kdw  julian:corrected comment
# 2016-08-05 kdw  julian:moved stuff to const
# 2016-08-02 kdw  julian:tweak
# 2016-08-01 kdw  julian:ymd2j* refactor
# 2016-07-30 kdw  julian:ymd2j* refactor
# 2016-07-29 kdw  julian:ymd2j* refactor
# 2016-07-28 kdw  julian:ymd2j* refactor
# 2016-07-27 kdw  julian:unix funcs
# 2016-07-26 kdw  julian:ymdhms functions
# 2016-07-19 kdw  julian:renamed / refactor things
# 2016-07-18 kdw  julian:.*d(o)w functions
# 2016-07-14 kdw  julian:const name changed
# 2016-07-13 kdw  julian:ymd2j(2)000 epoch correction
# 2016-04-11 kdw  julian:variables renamed
# 2015-12-14 kdw  julian:long line
# 2015-11-18 kdw  julian:long line changed
# 2015-11-12 kdw  julian:ym[d]2doy change
# 2015-10-26 kdw  julian:j[d]2000 to j[2]000
# 2015-10-20 kdw  julian:changed to epoch J2000
# 2015-10-19 kdw  julian:corrected julian day of 2000-01-01
# 2015-10-16 kdw  julian:hms2day
# 2015-10-15 kdw  julian:created
#   FFFFFFFFFFunction --------------------------- days_in_month #
FUNC INT days_in_month(INT g_year
      , INT g_month):
   # number of days in the given month
   INT retvalu;
   MODE_INTEGER:
      IF g_month == 2:
         IF Kw.isleapyear(g_year):
            retvalu = 29;
         ELSE:
            retvalu = 28;
         IF_END
      ELSIF(6 * g_month + 1) % 11 < 5:
         retvalu = 30;
      ELSE:
         retvalu = 31;
      IF_END
   MODE_INTEGER_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- sec2dhms #
FUNC DBL sec2dhms(DBL seconds):
   # convert seconds to DD.HHMMSS
   DBL dy;
   DBL hr;
   DBL mn;
   DBL tm;
   DBL sg;
   IF seconds < 0.0:
      sg = -1.0;
   ELSE:
      sg = 1.0;
   IF_END
   dy = FLOOR(seconds * Kw.SECOND / Kw.DAY);
   tm = (seconds * Kw.SECOND / Kw.DAY - dy) * Kw.DAY / Kw.HOUR;
   hr = FLOOR(tm);
   tm = (tm - hr) * Kw.HOUR / Kw.MINUTE;
   mn = FLOOR(tm);
   tm = (tm - mn) * Kw.MINUTE / Kw.SECOND;
   RETURN dy + sg * (hr + (mn + tm / 100.0) / 100.0) / 100.0;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- day2dhms #
FUNC DBL day2dhms(DBL dayfrac):
   # convert fractional days to DD.HHMMSS
   DBL dy;
   DBL hr;
   DBL mn;
   DBL tm;
   DBL sg;
   IF dayfrac < 0.0:
      sg = -1.0;
   ELSE:
      sg = 1.0;
   IF_END
   dy = FLOOR(dayfrac);
   tm = (dayfrac - dy) * Kw.DAY / Kw.HOUR;
   hr = FLOOR(tm);
   tm = (tm - hr) * Kw.HOUR / Kw.MINUTE;
   mn = FLOOR(tm);
   tm = (tm - mn) * Kw.MINUTE / Kw.SECOND;
   RETURN dy + sg * (hr + (mn + tm / 100.0) / 100.0) / 100.0;
FUNC_END
#   FFFFFFFFFFunction ----------------------------- day2dhmsinv #
FUNC DBL day2dhmsinv(DBL xx_hms):
   # convert DD.HHMMSSss... to fractional days
   # (undo day2hms)
   DBL dy;
   DBL hr;
   DBL mn;
   DBL tm;
   dy = FLOOR(xx_hms);
   tm = (xx_hms - dy) * 100.0;
   hr = FLOOR(tm);
   tm = (tm - hr) * 100.0;
   mn = FLOOR(tm);
   tm = (tm - mn) * 100.0;
   RETURN dy + (hr * Kw.HOUR + mn * Kw.MINUTE + tm * Kw.SECOND)
         / Kw.DAY;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- hms2day #
FUNC DBL hms2day(DBL hourx
      , DBL minutex
      , DBL secondx):
   # convert hour-minute-second into fractional days
   RETURN (secondx * Kw.SECOND + minutex * Kw.MINUTE + hourx
         * Kw.HOUR) / Kw.DAY;
FUNC_END
#TEST:hms2day(5,39,24.48)-0.2357;
#   FFFFFFFFFFunction -------------------------------- hour2day #
FUNC DBL hour2day(DBL hourx):
   # convert hours into fractional days
   RETURN hourx * Kw.HOUR / Kw.DAY;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- day2hour #
FUNC DBL day2hour(DBL dayx):
   # convert days into hours
   RETURN dayx * Kw.DAY / Kw.HOUR;
FUNC_END
##    JDAY Conversion-functions ---- ----- ----- ----- ----- ----
#   FFFFFFFFFFunction ---------------------------------- jd2kwt #
FUNC DBL jd2kwt(DBL jjdtime):
   # convert a Julian date to a KWT epoch
   RETURN (jjdtime * Kw.JDAY - Kw.JDSEC_AT_0KWT) / Kw.KWT;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- jd2j2k #
FUNC DBL jd2j2k(DBL jjdtime):
   # convert a Julian date to a J2000 date
   RETURN (jjdtime * Kw.JDAY - Kw.JDSEC_AT_0J2K) / Kw.J2KDAY;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- jd2uet #
FUNC DBL jd2uet(DBL jjdtime):
   # convert a Julian date to a UET epoch
   RETURN (jjdtime * Kw.JDAY - Kw.JDSEC_AT_0UET) / Kw.UET;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- kwt2jd #
FUNC DBL kwt2jd(DBL kwttime):
   # convert a KWT epoch to a Julian date
   RETURN (kwttime * Kw.KWT + Kw.JDSEC_AT_0KWT) / Kw.JDAY;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- uet2jd #
FUNC DBL uet2jd(DBL uettime):
   # convert a UET to a Julian date
   RETURN (uettime * Kw.UET + Kw.JDSEC_AT_0UET) / Kw.JDAY;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- j2k2jd #
FUNC DBL j2k2jd(DBL jtwoktm):
   # convert a J2000 date to a Julian date
   RETURN (jtwoktm * Kw.J2KDAY + Kw.JDSEC_AT_0J2K) / Kw.JDAY;
FUNC_END
##    JDAY Conversion-functions derived ----- ----- ----- ---- --
#   FFFFFFFFFFunction --------------------------------- j2k2kwt #
FUNC DBL j2k2kwt(DBL jtwoktm):
   # convert a J2000 to a KWT epoch
   RETURN jd2kwt(j2k2jd(jtwoktm));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- j2k2uet #
FUNC DBL j2k2uet(DBL jtwoktm):
   # convert a J2000 to a UET epoch
   RETURN jd2uet(j2k2jd(jtwoktm));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- kwt2j2k #
FUNC DBL kwt2j2k(DBL kwttime):
   # convert a KWT to a J2000 date
   RETURN jd2j2k(kwt2jd(kwttime));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- kwt2uet #
FUNC DBL kwt2uet(DBL kwttime):
   # convert a KWT to a Julian date
   RETURN jd2uet(kwt2jd(kwttime));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- uet2kwt #
FUNC DBL uet2kwt(DBL uettime):
   # convert a UET to a KWT date
   RETURN jd2kwt(uet2jd(uettime));
FUNC_END
#   FFFFFFFFFFunction --------------------------------- uet2j2k #
FUNC DBL uet2j2k(DBL uettime):
   # convert a UET to a J2000 date
   RETURN jd2j2k(uet2jd(uettime));
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- jd2dow #
FUNC INT jd2dow(DBL jjd):
   # day of week of the given Julian date
   INT jjtemp;
   jjtemp = FLOOR(jjd + 1.5);
   RETURN jjtemp % 7;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- j2k2dow #
FUNC INT j2k2dow(DBL jtwok):
   # day of week of the given J2000 date
   INT jjtemp;
   jjtemp = FLOOR(jtwok + 6.5);
   RETURN jjtemp % 7;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- ymd2doy #
FUNC DBL ymd2doy(INT g_year
      , INT g_month
      , DBL g_daymon):
   # convert year-month-day to day of year
   DBL delta;
   WHILE g_month < 1:
      g_month += Kw.MONTHS_IN_YEAR;
      g_year -= 1;
   WHILE_END
   WHILE Kw.MONTHS_IN_YEAR < g_month:
      g_month -= Kw.MONTHS_IN_YEAR;
      g_year += 1;
   WHILE_END
   delta = 0;
   IF 2 < g_month:
      IF Kw.isleapyear(g_year):
         delta = 1;
      IF_END
      delta += FLOOR(30.6001 * g_month - 0.3) - 32.0;
      # 2<mon
   ELSIF g_month == 2:
      delta = 31;
   IF_END
   RETURN delta + g_daymon;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- ymd2j2k #
FUNC DBL ymd2j2k(DBL g_year
      , DBL g_month
      , DBL g_day):
   # convert a YEAR, MONTH, DAY into a J2000 date
   DBL yr;
   DBL mn;
   DBL jtwok;
   DBL jcen;
   DBL dayoffset;
   g_year -= 2000;
   # with normal use(i.e. 1 <= month <= Kw.MONTHS_IN_YEAR),
   #    the following loops are trivial
   WHILE g_month < 1:
      g_month += Kw.MONTHS_IN_YEAR;
      g_year -= 1;
   WHILE_END
   WHILE Kw.MONTHS_IN_YEAR < g_month:
      g_month -= Kw.MONTHS_IN_YEAR;
      g_year += 1;
   WHILE_END
   mn = g_month + 1;
   yr = g_year;
   IF g_month < 3:
      # Jan and Feb need special treatment
      mn += Kw.MONTHS_IN_YEAR;
      yr -= 1;
   IF_END
   jcen = FLOOR(yr / 100);
   # The first 2 terms give the number of missing leap days
   #    due to the " == 0 mod 100 and <> 0 mod 400" rule.
   # March 0 is the 60th day of the year 0000.
   # The month formula(g_month == 3) gives 122.4004 to 122.
   # Hence we need to offset by 62 to get the correct DOY.
   dayoffset = jcen - FLOOR(jcen / 4.0) + 62;
   jtwok = (FLOOR(yr * Kw.JYEAR / Kw.DAY) + FLOOR(30.6001 * mn
         - dayoffset) + g_day - 1.5);
   RETURN jtwok;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- ymd2jd #
FUNC DBL ymd2jd(DBL g_year
      , DBL g_month
      , DBL g_day):
   # convert a YEAR, MONTH, DAY into a Julian date
   RETURN j2k2jd(ymd2j2k(g_year, g_month, g_day));
FUNC_END
#TEST:ymd2jd(1960,11,2.16125)-2437240.66125;
#TEST:ymd2jd(2017,9,3.5)-2458000;
#   FFFFFFFFFFunction --------------------------------- ymd2dow #
FUNC INT ymd2dow(INT g_year
      , INT g_month
      , DBL g_daymon):
   # day of week of the given year-month-day
   RETURN jd2dow(ymd2jd(g_year, g_month, g_daymon));
FUNC_END
#   FFFFFFFFFFunction -------------------------------- doomsday #
FUNC INT doomsday(INT g_year):
   # The Doomsday of a given G_YEAR is the day of the week of
   #    the last day of February.
   # 04-04, 06-06, 08-08, 10-10, and 12-12 are Doomsdays.
   # "I work 9 to 5 at the 7-11":
   #    09-05, 05-09, 07-11 and 11-07 are all Doomsdays.
   # For January:
   #    01-03 is a Doomsday in non-leap years;
   #    01-04 is a Doomsday in leap years.
   #       (01-03 is a Doomsday 3 out of 4 years).
   #    Year Doomsday
   #    1700 0 Sunday
   #    1800 5 Friday
   #    1900 3 Wednesday
   #    2000 2 Tuesday
   #    2100 0 Sunday
   #    2200 5 Friday
   # Doomsday(CCYY) = Doomsday(CC00) + YY + floor(YY / 4)
   # The following days are Doomsdays:
   #    03-00 The Zeroth of March
   #    03-14 Pi day
   #    07-04 The Fourth of July
   #    09-19 Talk Like A Pirate day
   #    10-31 Halloween
   #    11-00 The Zeroth of November
   #    12-26 Boxing Day
   INT cc;
   INT yy;
   INT lps;
   INT anchor;
   INT retvalu;
   MODE_INTEGER:
      cc = FLOOR(g_year / 100);
      anchor = (cc % 4) * 5 + 2;
      yy = g_year % 100;
      lps = FLOOR(yy / 4);
      # Determine the Doomsday for the year in question
      retvalu = (anchor + yy + lps) % 7;
   MODE_INTEGER_END
   RETURN retvalu;
FUNC_END
#TEST:doomsday(2018)-3;
BLOCK:# Julian specific defines
   BLOCK_DEF CONST LC_GD_YEAR 0;
   BLOCK_DEF CONST LC_GD_MONTH 1;
   BLOCK_DEF CONST LC_GD_DAY 2;
   BLOCK_DEF CONST LC_GD_HOUR 3;
   BLOCK_DEF CONST LC_GD_MIN 4;
   BLOCK_DEF CONST LC_GD_SEC 5;
   BLOCK_DEF CONST LC_GD_DOW 6;
   BLOCK_DEF CONST LC_GD_NUM 7;
   BLOCK_DEF CONST LC_GD_JD 8;
   BLOCK_DEF CONST LC_GD_COUNT 9;
   BLOCK_DEF DBL lv_ymdhms_arr[20];
   #   FFFFFFFFFFunction ---------------------------- jd2ymdhms #
   FUNC DBL jd2ymdhms(DBL jjulid):
      # convert a julian date to a
      # year-mon-day-hour-min-sec array
      # use in conjunction with ymdhms_get()
      # returns a number YYYYMMDD.hhmmss
      BLOCK_USE lv_ymdhms_arr[];
      INT jcent;
      INT bbdays;
      INT bdiff;
      INT g_years;
      INT month_next;
      DBL ftime_frac;
      DBL dtime_rem;
      INT ijulian;
      lv_ymdhms_arr[LC_GD_JD] = jjulid;
      ftime_frac = Kw.frac(jjulid + 0.5);
      ijulian = FLOOR(jjulid + 0.5);
      # rounded
      # 60.5 = (days in January) + (days in leap February)
      #      + 0.5 for good luck
      jcent = FLOOR(((ijulian - 60.5) * Kw.JDAY
            - Kw.JDSEC_AT_0GREGORIAN) / (100.0 * Kw.GYEAR));
      bbdays = ijulian + jcent - FLOOR(jcent / 4.0);
      g_years = FLOOR((bbdays + 1399.9) * Kw.DAY / Kw.JYEAR);
      bdiff = bbdays - FLOOR(g_years * Kw.JYEAR / Kw.DAY) + 1522;
      month_next = FLOOR(bdiff / 30.6001);
      # time(in days) remaining in month
      dtime_rem = bdiff - FLOOR(30.6001 * month_next)
            + ftime_frac;
      lv_ymdhms_arr[LC_GD_YEAR] = g_years - 4716.0;
      IF 13 < month_next:
         lv_ymdhms_arr[LC_GD_MONTH] = month_next - 13;
      ELSE:
         lv_ymdhms_arr[LC_GD_MONTH] = month_next - 1;
      IF_END
      IF lv_ymdhms_arr[LC_GD_MONTH] < 3:
         lv_ymdhms_arr[LC_GD_YEAR] += 1;
      IF_END
      lv_ymdhms_arr[LC_GD_DAY] = FLOOR(dtime_rem);
      dtime_rem = Kw.DAY / Kw.HOUR * Kw.frac(dtime_rem);
      lv_ymdhms_arr[LC_GD_HOUR] = FLOOR(dtime_rem);
      dtime_rem = Kw.HOUR / Kw.MINUTE * Kw.frac(dtime_rem);
      lv_ymdhms_arr[LC_GD_MIN] = FLOOR(dtime_rem);
      dtime_rem = Kw.MINUTE / Kw.SECOND * Kw.frac(dtime_rem);
      lv_ymdhms_arr[LC_GD_SEC] = dtime_rem;
      lv_ymdhms_arr[LC_GD_DOW] = FLOOR(Kw.fmod(ijulian + 1.0
            , 7.0));
      # reuse FTIME_FRAC, DTIME_REM
      dtime_rem = (lv_ymdhms_arr[LC_GD_MONTH] * 100.0
            + lv_ymdhms_arr[LC_GD_DAY]
            + lv_ymdhms_arr[LC_GD_HOUR] / 100.0
            + lv_ymdhms_arr[LC_GD_MIN] / 10000.0
            + lv_ymdhms_arr[LC_GD_SEC] / 1000000.0);
      ftime_frac = lv_ymdhms_arr[LC_GD_YEAR] * 10000.0;
      IF ftime_frac < 0.0:
         lv_ymdhms_arr[LC_GD_NUM] = ftime_frac - dtime_rem;
      ELSE:
         lv_ymdhms_arr[LC_GD_NUM] = ftime_frac + dtime_rem;
      IF_END
      RETURN lv_ymdhms_arr[LC_GD_NUM];
   FUNC_END
   #TEST:jd2ymdhms(2437240.66125)-19601102.035212;
   #   FFFFFFFFFFunction --------------------------- j2k2ymdhms #
   FUNC DBL j2k2ymdhms(DBL jtwokd):
      # convert a j2k date to a
      # year-mon-day-hour-min-sec array
      # use in conjunction with ymdhms_get()
      # returns a number YYYYMMDD.hhmmss
      RETURN jd2ymdhms(j2k2jd(jtwokd));
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- ymdhms_get #
   FUNC DBL ymdhms_get(INT indexp):
      # retrieve the INDEXPth result from the last
      # .*2ymdhms conversion
      # year-mon-day-hour-min-sec array
      # INDEXP  RETURNS
      #    0    year
      #    1    month
      #    2    day
      #    3    hour
      #    4    minute
      #    5    second
      #    6    day-of-week
      #    7    YYYMMDD.hhmmss
      #    8    Julian day
      BLOCK_USE lv_ymdhms_arr[];
      DBL retvalu;
      IF LC_GD_YEAR <= indexp AND indexp < LC_GD_COUNT:
         retvalu = lv_ymdhms_arr[indexp];
      ELSE:
         retvalu = -1;
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------- jd2ymdhmsinv #
   FUNC DBL jd2ymdhmsinv(NUL):
      # given previously fillled
      # year-mon-day-hour-min-sec array
      # return the Julian day
      BLOCK_USE lv_ymdhms_arr[];
      RETURN ymd2jd(lv_ymdhms_arr[LC_GD_YEAR]
            , lv_ymdhms_arr[LC_GD_MONTH]
            , lv_ymdhms_arr[LC_GD_DAY])
            + hms2day(lv_ymdhms_arr[LC_GD_HOUR]
            , lv_ymdhms_arr[LC_GD_MIN]
            , lv_ymdhms_arr[LC_GD_SEC]) * Kw.DAY / Kw.JDAY;
   FUNC_END
BLOCK_END
      #   FFFFFFFFFFunction -----------------------------
   #print_jd264 #
FUNC DBL print_jd264(DBL jjulid):
   # print out gregorian day in tthe format
   #   YYMDhms as a base-64 string for the date
   # corresponding to Julian day JJULID
   CALL jd2ymdhms(jjulid);
   CALL print_base_out(ymdhms_get(LC_GD_YEAR), 64);
   CALL print_base_out(ymdhms_get(LC_GD_MONTH), 64);
   CALL print_base_out(ymdhms_get(LC_GD_DAY), 64);
   CALL print_base_out(ymdhms_get(LC_GD_HOUR), 64);
   CALL print_base_out(ymdhms_get(LC_GD_MIN), 64);
   CALL print_base_outf(ymdhms_get(LC_GD_SEC), 64);
   RETURN jjulid;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- ymdhms2jd #
FUNC DBL ymdhms2jd(DBL ymdhmsx):
   # given a number YYYYMMDD.hmmss, return the Julian day
   DBL xx_arr[LC_GD_COUNT];
   DBL ys;
   ys = ymdhmsx * (1.0 + Kw.DBLEPS);
   # facilitate rounding
   xx_arr[LC_GD_YEAR] = FLOOR(ys / 10000.0);
   IF ys < 0:
      ys = -ys;
   IF_END
   xx_arr[LC_GD_MONTH] = Kw.fmodu(FLOOR(ys / 100.0), 100.0);
   xx_arr[LC_GD_DAY] = Kw.fmodu(FLOOR(ys), 100.0);
   xx_arr[LC_GD_HOUR] = Kw.fmodu(FLOOR(ys * 100.0), 100.0);
   xx_arr[LC_GD_MIN] = Kw.fmodu(FLOOR(ys * 10000.0), 100.0);
   xx_arr[LC_GD_SEC] = Kw.frac(ys * 10000.0) * 100.0;
   RETURN ymd2jd(xx_arr[LC_GD_YEAR], xx_arr[LC_GD_MONTH]
         , xx_arr[LC_GD_DAY]) + hms2day(xx_arr[LC_GD_HOUR]
         , xx_arr[LC_GD_MIN], xx_arr[LC_GD_SEC]) * Kw.DAY
         / Kw.JDAY;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ ymdhms2j2k #
FUNC DBL ymdhms2j2k(DBL ymdhmsx):
   # convert a YYYYMMDD.hhmmss into a J2000 date
   RETURN jd2j2k(ymdhms2jd(ymdhmsx));
FUNC_END
#   FFFFFFFFFFunction -------------------------------- clocksec #
FUNC DBL clocksec(DBL secnds):
   # The radian angular position from the 12:00:00 postion
   # of the second hand of a clock at SECNDS past midnight
   RETURN Kw.frac(secnds / Kw.MINUTE) * Kw.TAU;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- clockmin #
FUNC DBL clockmin(DBL secnds):
   # The radian angular position from the 12:00:00 postion
   # of the minute hand of a clock at SECNDS past midnight
   RETURN Kw.frac(secnds / Kw.HOUR) * Kw.TAU;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- clockhour #
FUNC DBL clockhour(DBL secnds):
   # The radian angular position from the 12:00:00 postion
   # of the hour hand of a clock at SECNDS past midnight
   RETURN Kw.frac(secnds / (Kw.DAY / 2)) * Kw.TAU;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- clocksum #
FUNC DBL clocksum(DBL secnds):
   # The sum of the radian angular position differences
   # of the hands of a clock at SECNDS past midnight
   DBL sc;
   DBL mn;
   DBL hr;
   sc = clocksec(secnds);
   mn = clockmin(secnds);
   hr = clockhour(secnds);
   RETURN Kw.dist(sc - mn, Kw.TAU) + Kw.dist(hr - mn, Kw.TAU)
         + Kw.dist(sc - hr, Kw.TAU);
FUNC_END
#   FFFFFFFFFFunction ------------------------------ clockstdev #
FUNC DBL clockstdev(DBL secnds):
   # compute the standard deivation of the angular differences
   # between the hour, minute and second hands of a clock at
   # time SECNDS after midnight
   DBL sc;
   DBL mn;
   DBL hr;
   DBL da;
   DBL db;
   DBL dc;
   sc = clocksec(secnds);
   mn = clockmin(secnds);
   hr = clockhour(secnds);
   da = Kw.dist(sc - mn, Kw.TAU);
   db = Kw.dist(hr - mn, Kw.TAU);
   dc = Kw.dist(sc - hr, Kw.TAU);
   RETURN SQRT((da * da + db * db + dc * dc - Kw.square(da + db
         + dc) / 3) / 2);
FUNC_END
#   FFFFFFFFFFunction ----------------------------- date_easter #
FUNC INT date_easter(INT g_year):
   # what day of *March* is easter in Gregorian year G_YEAR
   # The algorithm is due to J.-M. Oudin 1940 and is
   # reprinted in the Explanatory Supplement to the
   # Astronomical Almanac, ed. P. K. Seidelmann 1992.
   # See Chapter 12, "Calendars", by L. E. Doggett.
   INT cc;
   INT nn;
   INT kk;
   INT ff;
   INT ii;
   INT jj;
   INT mm;
   INT lps;
   MODE_INTEGER:
      cc = FLOOR(g_year / 100);
      nn = g_year % 19;
      lps = FLOOR(g_year / 4);
      kk = FLOOR((cc + 8) / 25 - 1);
      ff = FLOOR((cc - kk) / 3);
      mm = cc - FLOOR(cc / 4);
      ii = (mm - ff + 19 * nn + 15) % 30;
      IF 28 < ii OR (ii == 28 AND 10 < nn):
         ii -= 1;
      IF_END
      jj = (g_year + lps + ii + 2 - mm) % 7;
   MODE_INTEGER_END
   RETURN ii - jj + 28;
FUNC_END
BLOCK:# Halaqim
   BLOCK_DEF CONST HALAQIM_PER_HOUR 1080;
   #T
   BLOCK_DEF CONST HALAQIM Kw.HOUR / HALAQIM_PER_HOUR;
   #T
   #   BLOCK_DEF INT lv_hqphr = 2;
   #   FFFFFFFFFFunction ----------------------------- lf_hqphr #
   #   BLOCK_DEF FUNC INT lf_hqphr(NUL):
   #      RETURN HALAQIM_PER_HOUR;
   #   FUNC_END
   #   FFFFFFFFFFunction ------------------- date_rosh_hashanah #
   FUNC DBL date_rosh_hashanah(INT g_year):
      # which day of *September* is Rosh HaShanah in
      #   the *GREGORIAN* year G_YEAR
      INT aa;
      DBL dos;
      INT day_of_september;
      DBL parts;
      INT doww;
      MODE_INTEGER:
         aa = (12 * g_year + 12) % 19;
         # 11<aa iff jewish leap year
         # 1 hour = 1080 parts("halaqim") = 3.333333 seconds
         # Synodic period of the moon = 29.530587981 days
         #                           = 29 d + 12 h + 44 m + 2.8 s
         #                           = 29 d + 12 h + 792.84 parts
         #                            = 765432.84046752 halaqim
         #                       about round(MOONMONTH / HALAQIM)
         dos = (FLOOR(g_year / 100) - FLOOR(g_year / 400) - 2
               + (g_year % 4) / 4.0 + (round(Kw.MOONMONTH
               / Kw.HALAQIM) * aa - 1565.0 * g_year - 445405)
               / (19.0 * Kw.DAY / HALAQIM));
         day_of_september = FLOOR(dos);
         parts = Kw.frac(dos) * Kw.DAY / HALAQIM;
         # delay rules
         doww = ymd2dow(g_year, 9, day_of_september);
         # R-H cant be next to Shabbat
         #      (i.e. cant be Friday or Sunday),
         # and it cant be Wednesday(or Friday), as that
         # would make Yom Kippur(== RH + 9) be next to Shabbat.
         IF doww == 0 OR doww == 3 OR doww == 5:
            day_of_september += 1;
            # Adu
         ELSIF doww == 1 AND 11 < aa AND 23269 <= parts:
            # Monday, leap year, and time after 21:32:43.3333333
            day_of_september += 1;
            # Batu Thakpad
         ELSIF doww == 2 AND 6 < aa AND 16404 <= parts:
            # Tuesday, common year, and time after 15:11:20
            day_of_september += 2;
            # Gatarad
         IF_END
      MODE_INTEGER_END
      RETURN day_of_september - 0.25;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- jewish2jdx #
   FUNC DBL jewish2jdx(INT hebyear):
      # Julian day of Rosh Hashanah in Jewish year HEBYEAR
      INT hebyear_mone;
      INT months_el;
      INT halaqims_el;
      INT hour_el;
      INT hq_left;
      INT days_left;
      INT alt_days;
      INT alt_dow;
      MODE_INTEGER:
         # 19 Julian Years = 235.002093574 Moon Months
         hebyear_mone = hebyear - 1;
         months_el = (235 * FLOOR(hebyear_mone / 19) + 12
               * (hebyear_mone % 19) + FLOOR((7
               * (hebyear_mone % 19) + 1) / 19));
         # MOONMONTH = 29 * DAY + 12 * HOUR
            #+ 792.84046752 HALAQIM
         halaqims_el = 204 + (793
               * (months_el % HALAQIM_PER_HOUR));
         hour_el = (5 + (12 * months_el) + 793
               * FLOOR(months_el / HALAQIM_PER_HOUR)
               + FLOOR(halaqims_el / HALAQIM_PER_HOUR));
         days_left = 1 + 29 * months_el + FLOOR(hour_el
               / (Kw.DAY / Kw.HOUR));
         # 347996.25 = Julian day of the zeroth day of the
         #    seventh month in Jewish year 1
         #    = Gregorian date -3760-09-06
         alt_days = days_left + 347996;
         alt_dow = (alt_days % Kw.iround(Kw.WEEK / Kw.DAY));
         hq_left = (halaqims_el % HALAQIM_PER_HOUR);
      MODE_INTEGER_END
      hq_left += Kw.DAY * Kw.frac(hour_el * Kw.HOUR / Kw.DAY)
            / Kw.HALAQIM;
      IF 19440 <= hq_left:
         IF 0 == alt_dow OR 2 == alt_dow OR 4 == alt_dow:
            alt_days += 2;
         ELSE:
            alt_days += 1;
         IF_END
      ELSIF 0 == alt_dow:
         IF 9924 <= hq_left AND (NOT isjewishleap(hebyear)):
            alt_days += 2;
         IF_END
      ELSIF 6 == alt_dow:
         IF 16789 <= hq_left AND isjewishleap(hebyear - 1):
            alt_days += 1;
         IF_END
      ELSIF 1 == alt_dow OR 3 == alt_dow OR 5 == alt_dow:
         alt_days += 1;
      IF_END
      RETURN alt_days + 0.25;
   FUNC_END
BLOCK_END# Halaqim
#TEST:jewish2jdx(5776)-2457279.25;
#TEST:jewish2jdx(1)-347997.25;
#   FFFFFFFFFFunction ----------------------------- date_pesach #
FUNC DBL date_pesach(INT g_year):
   # Pesach occurs exactly 163 days before Rosh HaShanah
   # If Rosh Hashanah is Sept M(where Sept 30+N == Oct N),
   # then Pesach(in that *Gregorian* year) is March 21 + M
   DBL rh;
   rh = date_rosh_hashanah(g_year);
   RETURN rh + 21;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- g2jewish #
FUNC INT g2jewish(INT g_year):
   # What Jewish year starts in Gregorian year G_YEAR?
   RETURN g_year + 3761;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- jewish2g #
FUNC INT jewish2g(INT hebyear):
   # What Gregorian year starts in Jewish year HEBYEAR?
   RETURN hebyear - 3760;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- isjewishleap #
FUNC BOL isjewishleap(INT hebyear):
   # Is the Jewish year HEBYEAR a leap year?
   # True iff(HEBYEAR mod 19 == 0,3,6,8,11,14,17)
   RETURN (7 * hebyear + 1) % 19 < 7;
FUNC_END
#   FFFFFFFFFFunction ------------------- jewish_months_in_year #
FUNC INT jewish_months_in_year(INT hebyear):
   # number of months in Jewish year HEBYEAR
   INT miy;
   IF isjewishleap(hebyear):
      miy = 13;
   ELSE:
      miy = 12;
   IF_END
   RETURN miy;
FUNC_END
#   FFFFFFFFFFunction ----------------------- jewish_yearlength #
FUNC INT jewish_yearlength(INT hebyear):
   # number of days in Jewish year HEBYEAR
   INT g_year;
   INT retvalu;
   # Is there an easier way?
   g_year = jewish2g(hebyear - 1);
   retvalu = (FLOOR(Kw.JYEAR / Kw.DAY)
         + (date_rosh_hashanah(g_year + 1)
         - date_rosh_hashanah(g_year)));
   IF Kw.isleapyear(g_year + 1):
      retvalu += 1;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- jewish2jd #
FUNC DBL jewish2jd(INT hebyear):
   # Julian day of Rosh Hashanah in Jewish year HEBYEAR
   INT gyear;
   gyear = jewish2g(hebyear - 1);
   RETURN ymd2jd(gyear, 9, date_rosh_hashanah(gyear));
FUNC_END
#   FFFFFFFFFFunction -------------------------- isjewish8short #
FUNC BOL isjewish8short(INT hebyear):
   # Is there an easier way to tell if Month 8 is long?
   # Month 8 is long iff the Hebrew year is multiple of 5
   #   days long
   INT remten;
   MODE_INTEGER:
      remten = jewish_yearlength(hebyear) % 10;
   MODE_INTEGER_END
   RETURN remten <> 5;
FUNC_END
#   FFFFFFFFFFunction -------------------------- isjewish9short #
FUNC BOL isjewish9short(INT hebyear):
   # Is there an easier way to tell if Month 9 is short?
   # Month 9 is short iff the Hebrew year is 3 mod 10
   #   days long
   INT remten;
   MODE_INTEGER:
      remten = jewish_yearlength(hebyear) % 10;
   MODE_INTEGER_END
   RETURN remten == 3;
FUNC_END
#   FFFFFFFFFFunction ---------------------- jewish_monthlength #
FUNC INT jewish_monthlength(INT hebyear
      , INT hebmonth):
   # Number of days in Jewish month HEBMONTH
   #    in Jewish year HEBYEAR
   INT retvalu;
   retvalu = 30;
   IF hebmonth < 1 OR 13 < hebmonth:
      retvalu = 0;
   ELSIF hebmonth < 8:
      IF Kw.iseven(hebmonth):
         retvalu = 29;
      IF_END
   ELSIF hebmonth == 10:
      retvalu = 29;
   ELSIF hebmonth == 11:
      retvalu = 30;
   ELSIF hebmonth == 8:
      IF isjewish8short(hebyear):
         retvalu = 29;
      IF_END
   ELSIF hebmonth == 9:
      IF isjewish9short(hebyear):
         retvalu = 29;
      IF_END
   ELSIF hebmonth == 12:
      IF NOT isjewishleap(hebyear):
         retvalu = 29;
      IF_END
   ELSIF hebmonth == 13 AND isjewishleap(hebyear):
      retvalu = 29;
   ELSE:
      retvalu = 0;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------- jewish_monthbegin #
FUNC INT jewish_monthbegin(INT hebyear
      , INT hmonth):
   # What day of(Gregorian month HMONTH + 2) is
   # the Jewish date HEBYEAR-HMONTH-01
   INT g_year;
   INT g_month;
   INT hm;
   DBL gdate;
   g_year = jewish2g(hebyear - 1);
   g_month = 9;
   IF hmonth < Kw.JEWISH_FIRST_MONTH:
      g_year += 1;
      gdate = date_rosh_hashanah(g_year);
      FOR hm FROM Kw.JEWISH_FIRST_MONTH - 1 TO hmonth BY - 1:
         g_month -= 1;
         gdate += (days_in_month(g_year, g_month)
               - jewish_monthlength(hebyear, hm));
      FOR_END
   ELSIF Kw.JEWISH_FIRST_MONTH <= hmonth:
      gdate = date_rosh_hashanah(g_year);
      FOR hm FROM Kw.JEWISH_FIRST_MONTH TO hmonth - 1:
         gdate -= (days_in_month(g_year, g_month)
               - jewish_monthlength(hebyear, hm));
         g_month += 1;
         IF Kw.MONTHS_IN_YEAR < g_month:
            g_month = 1;
            g_year += 1;
         IF_END
      FOR_END
   IF_END
   RETURN gdate;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- jewishymd2jd #
FUNC DBL jewishymd2jd(INT hebyear
      , INT hebmonth
      , DBL hebday):
   # The Julian day of the Jewish date HEBYEAR-HEBMONTH-HEBDAY
   DBL jds;
   INT hmon;
   INT moninyear;
   moninyear = jewish_months_in_year(hebyear);
   IF 1 <= hebmonth AND hebmonth <= moninyear:
      jds = jewish2jd(hebyear);
      hmon = Kw.JEWISH_FIRST_MONTH;
      WHILE hmon <> hebmonth:
         jds += jewish_monthlength(hebyear, hmon);
         hmon += 1;
         IF moninyear < hmon:
            hmon = 1;
         ELSIF hmon == Kw.JEWISH_FIRST_MONTH:
            hebyear += 1;
            moninyear = jewish_months_in_year(hebyear);
         IF_END
      WHILE_END
   ELSE:
      jds = 0;
   IF_END
   RETURN jds + hebday - 1.0;
FUNC_END
#   IIIIIIIIIInsert-End --------------------------- julian.fwip #
#   IIIIIIIIIInsert-Begin --------------------------- mean.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-17 kdw  mean:macro syntax changed
# 2020-08-11 kdw  mean:agc[m]ean added
# 2020-07-07 kdw  mean:attempt to extend agmean to < 0
# 2020-07-06 kdw  mean:p[m]ean works w/ pp == 0
# 2020-07-04 kdw  mean:ag[h]mean
# 2020-04-26 kdw  mean:block indentation
# 2020-04-14 kdw  mean:tests added
# 2020-04-12 kdw  mean:comment change
# 2020-04-11 kdw  mean:macro arg format
# 2020-04-08 kdw  mean:allow 0 in some means
# 2020-03-03 kdw  mean:comment changed:odd chars
# 2020-03-02 kdw  mean:s/_N[E]XT/_E[N]D/
# 2020-02-28 kdw  mean:poly eval work
# 2020-02-26 kdw  mean:arr[a]y and hor[n]er work
# 2020-02-24 kdw  mean:r[m]s comment
# 2020-02-23 kdw  mean:r[m]s func
# 2020-02-08 kdw  mean:refactor iterated means
# 2020-02-03 kdw  mean:.*_LOOP changed
# 2019-12-27 kdw  mean:eplicit K[w] module
# 2019-12-26 kdw  mean:module name addded to funcs
# 2019-11-17 kdw  mean:include Macros file
# 2019-10-04 kdw  mean:comment change
# 2019-10-02 kdw  mean:macro arg format change
# 2019-09-07 kdw  mean:lo[g]1p to ln[1]p
# 2019-08-24 kdw  mean:for and count loops have from clause
# 2019-08-18 kdw  mean:L[O]G to L[N]
# 2019-08-11 kdw  mean:comment cleanup
# 2019-08-06 kdw  mean:rmed backslashes, macro arg renam
# 2019-07-16 kdw  mean:comment change
# 2019-07-02 kdw  mean:macro renam
# 2019-05-31 kdw  mean:NR_DO to RAPHSON_LOOP; et al
# 2019-05-29 kdw  mean:comment changed
# 2019-05-21 kdw  mean:macro redef
# 2019-05-16 kdw  mean:loop limit def mved
# 2019-05-01 kdw  mean:consts explicit module name
# 2019-03-19 kdw  mean:re[t]_val to re[t]valu
# 2019-03-18 kdw  mean:macro syntax changed
# 2019-03-11 kdw  mean:comments to array dcls
# 2019-03-09 kdw  mean:.*mean() func renam
# 2019-03-08 kdw  mean:is[e]qual to is[e]q, et al.
# 2019-03-04 kdw  mean:loop-limit work
# 2019-01-03 kdw  mean:Await counter changed
# 2018-07-20 kdw  mean:ag?m1i?nv work
# 2018-07-13 kdw  mean:float number reformt
# 2018-05-17 kdw  mean:ARR?AY.* and HOR[N]ER syntax
# 2018-05-16 kdw  mean:AR?RAY syntax
# 2018-04-03 kdw  mean:rm() from return
# 2018-03-26 kdw  mean:macro redef
# 2018-02-19 kdw  mean:secant and macro refactor
# 2018-02-16 kdw  mean:await loops
# 2017-11-26 kdw  mean:FR[O]M and B[Y] keywords
# 2017-11-24 kdw  mean:AR[R]AY_E[N]D
# 2017-10-21 kdw  mean:macros start with "at""at"
# 2017-10-20 kdw  mean:SEC[A]NT syntax change
# 2017-08-30 kdw  mean:s/DBL_/DBL/;s/FLT_/FLT/
# 2017-08-20 kdw  mean:rmed/renamd .*_P[E]R_.* vars
# 2017-04-21 kdw  mean:func to function
# 2017-03-12 kdw  mean:shorten long comments
# 2017-03-10 kdw  mean:get Fw[i]p_Pa[r]se to work
# 2017-03-07 kdw  mean:INS?ERT etal
# 2017-03-06 kdw  mean:sigils rmed
# 2017-02-23 kdw  mean:array var names
# 2017-02-20 kdw  mean:array var names
# 2017-02-14 kdw  mean:FWIP Loop syntax changed
# 2017-02-13 kdw  mean:FWIP language change
# 2017-02-12 kdw  mean:FWIP language change
# 2017-02-08 kdw  mean:SE[C]ANT syntax
# 2017-02-07 kdw  mean:comment rearrangement; SE[C]ANT stuff
# 2017-02-06 kdw  mean:SE[C]ANT syntax
# 2017-02-05 kdw  mean:SE[C]ANT stuff
# 2017-02-03 kdw  mean:SE[C]ANT stuff
# 2016-11-23 kdw  mean:CN?ST to REA?DON?LY
# 2016-11-21 kdw  mean:DE?F to FU?NC
# 2016-11-20 kdw  mean:language change
# 2016-11-14 kdw  mean:seca?nt algorithm refactor
# 2016-11-11 kdw  mean:seca?nt algorithm refactor
# 2016-11-08 kdw  mean:AW?AIT.*COU?NT syntax
# 2016-11-07 kdw  mean:loops refactored
# 2016-11-06 kdw  mean:isz?ero to ise?qual
# 2016-10-31 kdw  mean:EX?ITL?OOP
# 2016-10-27 kdw  mean:whitespace issues
# 2016-10-14 kdw  mean:_p added to several vars
# 2016-09-15 kdw  mean:lang change
# 2016-09-13 kdw  mean:lang change
# 2016-09-08 kdw  mean:contraharmonic, heronian
# 2015-12-31 kdw  mean:bounded possible infinite loops
# 2015-12-30 kdw  mean:define ghm1 before use
# 2015-12-14 kdw  mean:minor refactor
# 2015-12-10 kdw  mean:agm loop refactor
# 2015-12-09 kdw  mean:infinite loop in agm sometimes
# 2015-12-08 kdw  mean:a[g]m
# 2015-11-17 kdw  mean:comment changed
# 2015-11-12 kdw  mean:minor refactor
# 2015-10-11 kdw  mean:seca?nt algorithm changed
# 2015-10-10 kdw  mean:created
#   IIIIIIIIIInsert-Begin ------------------------- Macros.fwip #
#   IIIIIIIIIInsert-End --------------------------- Macros.fwip #
#   FFFFFFFFFFunction ----------------------------------- amean #
FUNC DBL amean(DBL xa
      , DBL xb):
   # The arithmetic mean
   RETURN (xa + xb) / 2.0;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- amean1 #
FUNC DBL amean1(DBL xa):
   # The arithmetic mean of 1.0 and XA
   RETURN (xa + 1.0) / 2.0;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- lmean #
FUNC DBL lmean(DBL xa
      , DBL xb):
   # The logarithmic mean: (XA - XB) / log(XA / XB)
   DBL retvalu;
   DBL diffy;
   IF xa <= 0 OR xb <= 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSE:
      diffy = xa - xb;
      IF 0.0001 < ABS(diffy):
         retvalu = diffy / LN(xa / xb);
      ELSE:
         retvalu = diffy / Kw.ln1p(diffy / xb);
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- lmean1 #
FUNC DBL lmean1(DBL xa):
   # The logarithmic mean of 1 and XA
   RETURN lmean(1.0, xa);
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- pmean #
FUNC DBL pmean(DBL pp
      , DBL xa
      , DBL xb):
   # The power mean
   # pmean(-1,...)  harmonic
   # pmean(0,...)   geometric
   #   actually limit as p to 0 of pmean(p,...)
   # pmean(1,...)   arithmetic
   # pmean(2,...)   quadratic
   DBL retvalu;
   IF xa <= 0 OR xb <= 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSIF Kw.iszero(pp):
      retvalu = SQRT(xa * xb);
   ELSE:
      retvalu = POW((POW(xa, pp) + POW(xb, pp)) / 2.0, 1.0 / pp);
   IF_END
   RETURN retvalu;
FUNC_END
# for x in(0,+INF): AH(1,x) == G(1,x)
# for x in(1,+INF):
# H < GH < HL < G=AH < GL < L,HQ < AG < AL < GQ < A,LQ < AQ < Q
# for x in(0,1) or(1,+INF):
# H < GH < HL < G=AH < GL < L,HQ < AG < AL < GQ < A,LQ < AQ < Q
# lm1(x) < hqm1(x) in(0.07228214847860485, 13.83467455032826)
# am1(x) < lqm1(x) in(0.07565734259951488, 13.21748776312862)
#   FFFFFFFFFFunction ----------------------------------- gmean #
FUNC DBL gmean(DBL xa
      , DBL xb):
   # The geometric mean
   DBL retvalu;
   IF xa < 0 OR xb < 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSE:
      retvalu = SQRT(xa * xb);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- gmean1 #
FUNC DBL gmean1(DBL xa):
   # The geometric mean of 1.0 and XA
   RETURN gmean(1.0, xa);
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- hmean #
FUNC DBL hmean(DBL xa
      , DBL xb):
   # The harmonic mean
   DBL retvalu;
   IF xa < 0 OR xb < 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSE:
      retvalu = 2.0 * xa * xb / (xa + xb);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- hmean1 #
FUNC DBL hmean1(DBL xa):
   # The harmonic mean of 1.0 and XA
   RETURN hmean(1.0, xa);
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- qmean #
FUNC DBL qmean(DBL xa
      , DBL xb):
   # The quadratic mean
   DBL retvalu;
   IF xa < 0 OR xb < 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSE:
      retvalu = SQRT((xa * xa + xb * xb) / 2.0);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- qmean1 #
FUNC DBL qmean1(DBL xa):
   # The quadratic mean of 1.0 and XA
   RETURN qmean(1.0, xa);
FUNC_END
#   FFFFFFFFFFunction ---------------------------- heronianmean #
FUNC DBL heronianmean(DBL xa
      , DBL xb):
   # The heronian mean
   DBL retvalu;
   IF xa < 0 OR xb < 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSE:
      retvalu = (xa + xb + SQRT(xa * xb)) / 3.0;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------- heronianmean1 #
FUNC DBL heronianmean1(DBL xa):
   # The heronian mean of 1.0 and XA
   RETURN heronianmean(1.0, xa);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- agmean #
FUNC DBL agmean(DBL xa
      , DBL xb):
   # The arithmetic-geometric mean
   INT ii;
   DBL retvalu;
   DBL xtmp;
   DBL pdifff;
   DBL cdifff;
   IF xa <= 0 OR xb <= 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSE:
      cdifff = ABS(xa - xb);
      AWAIT Kw.iswithin(xa, xb, 10 * DBLEPS)
            OR pdifff < cdifff COUNT ii FROM 0 TO 20:
         pdifff = cdifff;
         xtmp = SQRT(xa * xb);
         xa = (xa + xb) / 2.0;
         xb = xtmp;
         cdifff = xa - xb;
      AWAIT_END
      retvalu = xtmp;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- agmean1 #
FUNC DBL agmean1(DBL xa):
   # The arithmetic-geometric of 1.0 and XA
   RETURN agmean(1.0, xa);
FUNC_END
#TEST:agmean(1,2)-1.4567910310469068691864323832650819749738639;
#   FFFFFFFFFFunction ---------------------------------- ahmean #
FUNC DBL ahmean(DBL xa
      , DBL xb):
   # The arithmetic-harmonic mean
   INT ii;
   DBL retvalu;
   DBL xtmp;
   DBL pdifff;
   DBL cdifff;
   IF xa <= 0 OR xb <= 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSE:
      cdifff = ABS(xa - xb);
      AWAIT Kw.iswithin(xa, xb, 10 * DBLEPS)
            OR pdifff < cdifff COUNT ii FROM 0 TO 20:
         pdifff = cdifff;
         xtmp = 2.0 * xa * xb / (xa + xb);
         xa = (xa + xb) / 2.0;
         xb = xtmp;
         cdifff = xa - xb;
      AWAIT_END
      retvalu = xtmp;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- ahmean1 #
FUNC DBL ahmean1(DBL xa):
   # The arithmetic-harmonic of 1.0 and XA
   RETURN ahmean(1.0, xa);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- almean #
FUNC DBL almean(DBL xa
      , DBL xb):
   # The arithmetic-logarithmic mean
   INT ii;
   DBL retvalu;
   DBL xtmp;
   DBL pdifff;
   DBL cdifff;
   IF xa <= 0 OR xb <= 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSE:
      cdifff = ABS(xa - xb);
      AWAIT Kw.iswithin(xa, xb, 10 * DBLEPS)
            OR pdifff < cdifff COUNT ii FROM 0 TO 20:
         pdifff = cdifff;
         xtmp = lmean(xa, xb);
         xa = (xa + xb) / 2.0;
         xb = xtmp;
         cdifff = xa - xb;
      AWAIT_END
      retvalu = xtmp;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- almean1 #
FUNC DBL almean1(DBL xa):
   # The arithmetic-logarithmic of 1.0 and XA
   RETURN almean(1.0, xa);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- aqmean #
FUNC DBL aqmean(DBL xa
      , DBL xb):
   # The arithmetic-quadratic mean
   INT ii;
   DBL retvalu;
   DBL xtmp;
   DBL pdifff;
   DBL cdifff;
   IF xa <= 0 OR xb <= 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSE:
      cdifff = ABS(xa - xb);
      AWAIT Kw.iswithin(xa, xb, 10 * DBLEPS)
            OR pdifff < cdifff COUNT ii FROM 0 TO 20:
         pdifff = cdifff;
         xtmp = (xa + xb) / 2.0;
         xa = qmean(xa, xb);
         xb = xtmp;
         cdifff = xa - xb;
      AWAIT_END
      retvalu = xtmp;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- aqmean1 #
FUNC DBL aqmean1(DBL xa):
   # The arithmetic-quadratic of 1.0 and XA
   RETURN aqmean(1.0, xa);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- ghmean #
FUNC DBL ghmean(DBL xa
      , DBL xb):
   # The geometric-harmonic mean
   INT ii;
   DBL retvalu;
   DBL xtmp;
   DBL pdifff;
   DBL cdifff;
   IF xa <= 0 OR xb <= 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSE:
      cdifff = ABS(xa - xb);
      AWAIT Kw.iswithin(xa, xb, 10 * DBLEPS)
            OR pdifff < cdifff COUNT ii FROM 0 TO 20:
         pdifff = cdifff;
         xtmp = 2.0 * xa * xb / (xa + xb);
         xa = SQRT(xa * xb);
         xb = xtmp;
         cdifff = xa - xb;
      AWAIT_END
      retvalu = xtmp;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- ghmean1 #
FUNC DBL ghmean1(DBL xa):
   # The geometric-harmonic of 1.0 and XA
   RETURN ghmean(1.0, xa);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- glmean #
FUNC DBL glmean(DBL xa
      , DBL xb):
   # The geometric-logarithm mean
   INT ii;
   DBL retvalu;
   DBL xtmp;
   DBL pdifff;
   DBL cdifff;
   IF xa <= 0 OR xb <= 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSE:
      cdifff = ABS(xa - xb);
      AWAIT Kw.iswithin(xa, xb, 10 * DBLEPS)
            OR pdifff < cdifff COUNT ii FROM 0 TO 20:
         pdifff = cdifff;
         xtmp = SQRT(xa * xb);
         xa = lmean(xa, xb);
         xb = xtmp;
         cdifff = xa - xb;
      AWAIT_END
      retvalu = xtmp;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- glmean1 #
FUNC DBL glmean1(DBL xa):
   # The geometric-logarithm of 1.0 and XA
   RETURN glmean(1.0, xa);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- gqmean #
FUNC DBL gqmean(DBL xa
      , DBL xb):
   # The geometric-quadratic mean
   INT ii;
   DBL retvalu;
   DBL xtmp;
   DBL pdifff;
   DBL cdifff;
   IF xa <= 0 OR xb <= 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSE:
      cdifff = ABS(xa - xb);
      AWAIT Kw.iswithin(xa, xb, 10 * DBLEPS)
            OR pdifff < cdifff COUNT ii FROM 0 TO 20:
         pdifff = cdifff;
         xtmp = SQRT(xa * xb);
         xa = qmean(xa, xb);
         xb = xtmp;
         cdifff = xa - xb;
      AWAIT_END
      retvalu = xtmp;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- gqmean1 #
FUNC DBL gqmean1(DBL xa):
   # The geometric-quadratic of 1.0 and XA
   RETURN gqmean(1.0, xa);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- hlmean #
FUNC DBL hlmean(DBL xa
      , DBL xb):
   # The harmonic-logarithmic mean
   INT ii;
   DBL retvalu;
   DBL xtmp;
   DBL pdifff;
   DBL cdifff;
   IF xa <= 0 OR xb <= 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSE:
      cdifff = ABS(xa - xb);
      AWAIT Kw.iswithin(xa, xb, 10 * DBLEPS)
            OR pdifff < cdifff COUNT ii FROM 0 TO 20:
         pdifff = cdifff;
         xtmp = 2.0 * xa * xb / (xa + xb);
         xa = lmean(xa, xb);
         xb = xtmp;
         cdifff = xa - xb;
      AWAIT_END
      retvalu = xtmp;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- hlmean1 #
FUNC DBL hlmean1(DBL xa):
   # The harmonic-logarithmic of 1.0 and XA
   RETURN hlmean(1.0, xa);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- hqmean #
FUNC DBL hqmean(DBL xa
      , DBL xb):
   # The harmonic-quadratic mean
   INT ii;
   DBL retvalu;
   DBL xtmp;
   DBL pdifff;
   DBL cdifff;
   IF xa <= 0 OR xb <= 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSE:
      cdifff = ABS(xa - xb);
      AWAIT Kw.iswithin(xa, xb, 10 * DBLEPS)
            OR pdifff < cdifff COUNT ii FROM 0 TO 20:
         pdifff = cdifff;
         xtmp = 2.0 * xa * xb / (xa + xb);
         xa = qmean(xa, xb);
         xb = xtmp;
         cdifff = xa - xb;
      AWAIT_END
      retvalu = xtmp;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- hqmean1 #
FUNC DBL hqmean1(DBL xa):
   # The harmonic-quadratic of 1.0 and XA
   RETURN hqmean(1.0, xa);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- lqmean #
FUNC DBL lqmean(DBL xa
      , DBL xb):
   # The logarithmic-quadratic mean
   INT ii;
   DBL retvalu;
   DBL xtmp;
   DBL pdifff;
   DBL cdifff;
   IF xa <= 0 OR xb <= 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb):
      retvalu = xa;
   ELSE:
      cdifff = ABS(xa - xb);
      AWAIT Kw.iswithin(xa, xb, 10 * DBLEPS)
            OR pdifff < cdifff COUNT ii FROM 0 TO 20:
         pdifff = cdifff;
         xtmp = lmean(xa, xb);
         xa = qmean(xa, xb);
         xb = xtmp;
         cdifff = xa - xb;
      AWAIT_END
      retvalu = xtmp;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- lqmean1 #
FUNC DBL lqmean1(DBL xa):
   # The logarithmic-quadratic of 1.0 and XA
   RETURN lqmean(1.0, xa);
FUNC_END
#   FFFFFFFFFFunction ------------------------------- agmean__1 #
FUNC DBL agmean__1(DBL xa
      , DBL xb):
   # The arithmetic-geometric mean extended to negative numbers
   INT ii;
   DBL retvalu;
   DBL xtmp;
   DBL xsgn;
   xsgn = 1;
   AWAIT Kw.iswithin(xa, xb, 10 * DBLEPS) COUNT ii FROM 0 TO 20:
      xtmp = xa;
      xa = (xa + xb) / 2.0;
      xb = SQRT(ABS(xtmp * xb)) * Kw.sign(xa);
      #      IF NOT Kw.isss(xa * xb, xa + xb):
      #         xsgn = -xsgn;
      #      IF_END
   AWAIT_END
   retvalu = xsgn * xtmp;
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- agcmean #
FUNC DBL agcmean(READONLY DBL xa_arr_pc[]
      , READONLY DBL xb_arr_pc[]
      , WRITEONLY DBL ret_arr_p[]):
   # Complex AGM; return magnitude
   DBL gg_arr[2];
   DBL aa_arr[2];
   DBL tt_arr[2];
   DBL pr_arr[2];
   DBL pr_len;
   DBL pr_theta;
   gg_arr[0] = xa_arr_pc[0];
   gg_arr[1] = xa_arr_pc[1];
   aa_arr[0] = xb_arr_pc[0];
   aa_arr[1] = xb_arr_pc[1];
   AWAIT Kw.iseq(gg_arr[0], aa_arr[0]) AND Kw.iseq(gg_arr[1]
         , aa_arr[1]):
      tt_arr[0] = (aa_arr[0] + gg_arr[0]) / 2;
      tt_arr[1] = (aa_arr[1] + gg_arr[1]) / 2;
      pr_arr[0] = aa_arr[0] * gg_arr[0] - aa_arr[1] * gg_arr[1];
      pr_arr[1] = aa_arr[1] * gg_arr[0] + aa_arr[0] * gg_arr[1];
      pr_len = SQRT(Kw.hypot(pr_arr[0], pr_arr[1]));
      pr_theta = ATAN2(pr_arr[1], pr_arr[0]) / 2.0;
      gg_arr[0] = pr_len * COS(pr_theta);
      gg_arr[1] = pr_len * SIN(pr_theta);
      aa_arr[0] = tt_arr[0];
      aa_arr[1] = tt_arr[1];
      IF aa_arr[0] * gg_arr[0] + aa_arr[1] * gg_arr[1] < 0:
         gg_arr[0] = -gg_arr[0];
         gg_arr[1] = -gg_arr[1];
      IF_END
   AWAIT_END
   ret_arr_p[0] = gg_arr[0];
   ret_arr_p[1] = gg_arr[1];
   RETURN Kw.hypot(gg_arr[0], gg_arr[1]);
FUNC_END
#   FFFFFFFFFFunction --------------------------------- aghmean #
FUNC DBL aghmean(DBL xa
      , DBL xb
      , DBL xc):
   # The rithmetic-geometric-harmonic mean
   INT ii;
   DBL ta;
   DBL tb;
   DBL tc;
   DBL retvalu;
   IF xa <= 0 OR xb <= 0 OR xc <= 0:
      retvalu = 0;
   ELSIF Kw.iseq(xa, xb) AND Kw.iseq(xa, xc):
      retvalu = xa;
   ELSE:
      AWAIT Kw.iswithin(xa, xc, 10
            * DBLEPS) COUNT ii FROM 0 TO 20:
         ta = xa;
         tb = xb;
         tc = xc;
         xa = (ta + tb + tc) / 3.0;
         xb = Kw.cuberoot(ta * tb * tc);
         xc = 3.0 / (1.0 / ta + 1.0 / tb + 1.0 / tc);
      AWAIT_END
      retvalu = xb;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- rms #
FUNC DBL rms(DBL xa
      , DBL xb):
   # RMS value of XA and XB
   # same as qmean
   RETURN SQRT((xa * xa + xb * xb) / 2.0);
FUNC_END
#   FFFFFFFFFFunction ------------------------------ agmean1inv #
FUNC DBL agmean1inv(DBL yy):
   # The inverse arithmetic-geometric mean
   DBL scvx_xp;
   DBL scvx_xx;
   DBL scvx_yp;
   DBL scvx_yy;
   DBL scvx_dx;
   DBL scvx_dy;
   INT scvx_ii;
   DBL x_init;
   DBL dx;
   DBL cc;
   IF yy <= 0.0:
      scvx_xx = 0.0;
   ELSIF yy < 0.0022:
      scvx_xx = 1.0 / Kw.DBLMAX;
   ELSE:
      # Get an approximation of agmean1inv(yy)
      IF yy <= 0.5:
         x_init = 4.0 * EXP(Kw.PI / (-2.0 * yy));
      ELSIF yy < 2.1:
         cc = yy - 1.0;
         x_init = ((((((((-0.09765625) * cc + 0.12890625) * cc
               + 0.18750000) * cc + 0.18750000) * cc
               - 0.25000000) * cc + 0.50000000) * cc
               + 2.00000000) * cc + 1.00000000);
      ELSE:
         cc = -(Kw.PI / 2.0);
         x_init = yy * Kw.wm(cc / (4.0 * yy)) / cc;
      IF_END
      IF yy < 0.06:
         dx = x_init * 0.1;
      ELSE:
         dx = x_init * 0.5;
      IF_END
      # return XX where
      #   yy - agmean1(scvx_xx)XX == 0
      # BEG Secant Calculation
      scvx_dx = dx;
      scvx_xx = x_init;
      scvx_yy = yy - agmean1(scvx_xx);
      FOR scvx_ii FROM 0 TO 20:
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         IF Kw.iseq(scvx_xp, scvx_xx):
            FOR_EXIT;
         IF_END
         scvx_yy = yy - agmean1(scvx_xx);
         scvx_dy = (scvx_yy - scvx_yp);
         IF Kw.iszero(scvx_dy):
            FOR_EXIT;
         IF_END
         scvx_dx *= - scvx_yy / scvx_dy;
      FOR_END
      # END Secant Calculation
   IF_END
   RETURN scvx_xx;
FUNC_END
#TEST:agmean1inv(agmean1(2.7))-2.7;
#TEST:agmean1(agmean1inv(2.2))-2.2;
#   FFFFFFFFFFunction ------------------------------ ghmean1inv #
FUNC DBL ghmean1inv(DBL yy):
   # The inverse geometric harmonic mean
   DBL scvx_xp;
   DBL scvx_xx;
   DBL scvx_yp;
   DBL scvx_yy;
   DBL scvx_dx;
   DBL scvx_dy;
   INT scvx_ii;
   DBL x_init;
   IF yy <= 0.0:
      scvx_xx = 0.0;
   ELSE:
      x_init = EXP(Kw.PI * yy / 2.0 - 1.385) - 0.22;
      # return XX where
      #   yy - ghmean1(scvx_xx)XX == 0
      # BEG Secant Calculation
      scvx_dx = 0.2;
      scvx_xx = x_init;
      scvx_yy = yy - ghmean1(scvx_xx);
      FOR scvx_ii FROM 0 TO 20:
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         IF Kw.iseq(scvx_xp, scvx_xx):
            FOR_EXIT;
         IF_END
         scvx_yy = yy - ghmean1(scvx_xx);
         scvx_dy = (scvx_yy - scvx_yp);
         IF Kw.iszero(scvx_dy):
            FOR_EXIT;
         IF_END
         scvx_dx *= - scvx_yy / scvx_dy;
      FOR_END
      # END Secant Calculation
   IF_END
   RETURN scvx_xx;
FUNC_END
#   FFFFFFFFFFunction -------------------------- contraharmonic #
FUNC DBL contraharmonic(INT nn
      , READONLY DBL val_arr_pc[]):
   # The Contraharmonic mean
   DBL denom;
   DBL numer;
   INT ii;
   numer = 0.0;
   denom = 0.0;
   FOR ii FROM 0 TO nn - 1:
      denom += val_arr_pc[ii] * val_arr_pc[ii];
      numer += val_arr_pc[ii];
   FOR_END
   RETURN denom / numer;
FUNC_END
#   IIIIIIIIIInsert-End ----------------------------- mean.fwip #
#   IIIIIIIIIInsert-Begin ------------------------- random.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-17 kdw  random:comment change
# 2020-07-27 kdw  random:block syntax
# 2020-07-25 kdw  random:s/BITWISE/BIT/
# 2020-07-24 kdw  random:comment cleanup
# 2020-06-22 kdw  random:local-use mved befroe var decls
# 2020-06-17 kdw  random:mode integer added to several funcs
# 2020-05-30 kdw  random:CONST syntax change
# 2020-05-14 kdw  random:local funcs only in blocks
# 2020-05-13 kdw  random:.*_LA[S]T changed to .*_COU[N]T
# 2020-05-12 kdw  random:nul rets changed
# 2020-05-11 kdw  random:REPL[A]CE replaced with LO[C]AL_CO[N]ST
# 2020-05-05 kdw  random:magic check func changed
# 2020-04-28 kdw  random:tweaks here and there
# 2020-04-26 kdw  random:BL[O]CK indentation work
# 2020-04-23 kdw  random:const format change
# 2020-04-14 kdw  random:minor tweak to init array
# 2020-04-12 kdw  random:comment change
# 2020-04-09 kdw  random:MO[D]E syntax change
# 2020-04-08 kdw  random:preprocess sigil change
# 2020-03-11 kdw  random:comment change
# 2020-03-09 kdw  random:LO[C]AL_.* keywords
# 2020-03-06 kdw  random:RE[P]LACE / IN[D]EX changes
# 2020-03-03 kdw  random:comment changed:odd chars
# 2020-03-02 kdw  random:s/_N[E]XT/_[E]ND/
# 2019-12-27 kdw  random:explicit K[w] module
# 2019-12-26 kdw  random:module name addded to funcs
# 2019-10-04 kdw  random:comment change
# 2019-09-17 kdw  random:rmed c[n]v_db[l]2i32
# 2019-09-05 kdw  random:refactor
# 2019-08-25 kdw  random:loop rework
# 2019-08-24 kdw  random:for and count loops have from clause
# 2019-08-11 kdw  random:comment cleanup
# 2019-08-06 kdw  random:rmed backslashes, macro arg renam
# 2019-08-01 kdw  random:rand-cycle refactor
# 2019-07-31 kdw  random:bit to bitwise func nams
# 2019-07-03 kdw  random:var renam: "s/ind/_ind/;s/__ind/_ind/"
# 2019-05-29 kdw  random:comment changed
# 2019-05-24 kdw  random:local replaced private
# 2019-05-22 kdw  random:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-05-17 kdw  random:explicit module for intmax
# 2019-03-08 kdw  random:is[e]qual to is[e]q, et al.
# 2019-02-28 kdw  random:REP[L]ACE/DE[F]INE work
# 2018-07-17 kdw  random:private lf_.* funcs
# 2018-06-19 kdw  random:die keyword
# 2018-05-15 kdw  random:DIE.* change
# 2018-05-14 kdw  random:BL[O]CK syntax
# 2018-05-13 kdw  random:MO?DE.* syntax change
# 2018-04-03 kdw  random:rm() from return
# 2018-04-02 kdw  random:Pro?totype, et al.
# 2018-03-20 kdw  random:replaced index w/ "at"replace
# 2018-03-16 kdw  random:format of constant and index change
# 2018-02-14 kdw  random:IN[D]EX stuff
# 2017-11-26 kdw  random:FR[O]M and B[Y] keywords
# 2017-11-21 kdw  random:FR[O]M
# 2017-10-21 kdw  random:macros start with "at"
# 2017-10-20 kdw  random:RE[P]LACE syntax changed
# 2017-08-30 kdw  random:INT_* to INT* consts; Req?uires rmed
# 2017-08-24 kdw  random:var renam
# 2017-06-23 kdw  random:REPL?ACE redo
# 2017-06-08 kdw  random:magic constants now hidden
# 2017-04-30 kdw  random:func to function
# 2017-04-04 kdw  random:comments deleted
# 2017-03-12 kdw  random:shorten long comments
# 2017-03-10 kdw  random:get Fw[i]p_Pa[r]se to work
# 2017-03-06 kdw  random:sigils rmed
# 2017-03-01 kdw  random:var[y]log-a[d]d space messup
# 2017-02-28 kdw  random:REQ[U]IRE function()
# 2017-02-24 kdw  random:REP[L]ACE rework, et al
# 2017-02-21 kdw  random:var renam
# 2017-02-20 kdw  random:array var names
# 2017-02-14 kdw  random:FWIP Loop syntax changed
# 2017-02-13 kdw  random:FWIP language change
# 2017-02-12 kdw  random:FWIP language change
# 2017-01-06 kdw  random:?[?]USE.* to ?[?].*_MODE; ?[?]DIGR.*
# 2016-12-28 kdw  random:comment change
# 2016-12-07 kdw  random:comment change
# 2016-11-24 kdw  random:while loops changed to await loops
# 2016-11-23 kdw  random:CN?ST to REA?DON?LY
# 2016-11-21 kdw  random:DE?F to FU?NC
# 2016-11-20 kdw  random:language change
# 2016-11-16 kdw  random:r?and_ini?t_arrays; comments
# 2016-11-15 kdw  random:M?OD/B?IT* syntax change
# 2016-10-30 kdw  random:reorg
# 2016-10-29 kdw  random:reorg
# 2016-10-28 kdw  random:comment reorg; moved several func
# 2016-10-14 kdw  random:_p added to several vars
# 2016-09-19 kdw  random:magic vars declred as doubles
# 2016-09-18 kdw  random:debugging; yfs number change
# 2016-09-13 kdw  random:lang change
# 2016-09-14 kdw  random:lang change
# 2016-08-16 kdw  random:randint refactor; comments
# 2016-07-02 kdw  random:randgam refactor
# 2016-05-23 kdw  random:long lines
# 2016-05-18 kdw  random:comment change
# 2016-04-27 kdw  random:PYTHON: randpoi(int vs dbl div)
# 2016-01-22 kdw  random:long lines
# 2016-01-18 kdw  random:long lines
# 2015-12-30 kdw  random:ra?nd_se?ed to ra?nd_in?it, et al.
# 2015-12-25 kdw  random:default seed is time
# 2015-12-21 kdw  random:define local functions before use
# 2015-12-14 kdw  random:minor refactor; rmed sigils
# 2015-12-11 kdw  random:s/LC_// from some consts
# 2015-12-03 kdw  random:long lines
# 2015-12-02 kdw  random:rearranged
# 2015-11-26 kdw  random:long lines
# 2015-11-19 kdw  random:long lines
# 2015-11-17 kdw  random:F[O]R format changed
# 2015-11-17 kdw  random:block comments
# 2015-11-15 kdw  random:m[a]gic stuff
# 2015-11-13 kdw  random:comment shortened
# 2015-11-12 kdw  random:comment shortened
# 2015-10-27 kdw  random:variable rename
# 2015-10-13 kdw  random:_[_]DEFI[N]E_[_]
# 2015-10-08 kdw  random:refactor KNUTH stuff
# 2015-10-07 kdw  random:l[f]_ra[n]_init_.*_array has 2 args
# 2015-10-05 kdw  random:var rename; ra?nd_se?ed returns arg
# 2015-10-01 kdw  random:float equality checks to is.*;magic
# 2015-09-30 kdw  random:rmed unused variables
# 2015-09-25 kdw  random:reworked for VB anmd BC
# 2015-09-24 kdw  random:bit ops changed
# 2015-09-22 kdw  random:_[_]* format changed
# 2015-09-20 kdw  random:created
BLOCK:# Random numbers
   BLOCK_DEF CONST LC_KNUTH_MAX 1073741823;
   # 2**30-1 MUST BE ODD
   BLOCK_DEF CONST LC_KNUTH_QUALITY_COUNT 1009;
   BLOCK_DEF CONST LC_KNUTH_KK_COUNT 100;
   BLOCK_DEF CONST LC_KNUTH_LL 37;
   BLOCK_DEF CONST LC_KNUTH_TT 70;
   # array size must be greater than LC_KNUTH_QUALITY_COUNT
   #  AND greater than 2 * LC_KNUTH_KK_COUNT - 1
   BLOCK_DEF CONST LC_KNUTH_ARRAY_COUNT 1100;
   BLOCK_DEF INT lv_ranz_ind = -3;
   BLOCK_DEF DBL lv_ranz_magic = 0.0;
   BLOCK_DEF INT lv_ranz_arr[LC_KNUTH_QUALITY_COUNT];
   BLOCK_DEF INT lv_ran_a_arr[LC_KNUTH_ARRAY_COUNT];
   # generator state
   BLOCK_DEF INT lv_ran_x_arr[LC_KNUTH_KK_COUNT];
   # cannabalized from D. E. Knuth: "The Art of
   # Computer Programming" Vol 2, Ed 3, pg 186
   ## Random Number Generation
   #   FFFFFFFFFFunction ------------------------- lf_ran_cycle #
   BLOCK_DEF FUNC INT lf_ran_cycle(INT nn):
      BLOCK_USE lv_ran_x_arr[];
      BLOCK_USE lv_ran_a_arr[];
      INT aa;
      INT bb;
      INT cc;
      INT mody;
      MODE_INTEGER:
         # must have LC_KNUTH_KK_COUNT < nn
         aa = 0;
         WHILE aa < LC_KNUTH_KK_COUNT:
            lv_ran_a_arr[aa] = lv_ran_x_arr[aa];
            aa += 1;
            #[0..KK)
         WHILE_END
         bb = 0;
         cc = (LC_KNUTH_KK_COUNT - LC_KNUTH_LL);
         # Before each loop:
         #   aa - bb == LC_KNUTH_KK_COUNT mod nn
         #   aa - cc == LC_KNUTH_LL       mod nn
         WHILE aa < nn:
            mody = lv_ran_a_arr[bb] - lv_ran_a_arr[cc];
            lv_ran_a_arr[aa] = BITAND(LC_KNUTH_MAX, mody);
            aa += 1;
            #[KK   ..nn)
            bb += 1;
            #[0    ..nn-KK)
            cc += 1;
            #[KK-LL..nn-LL)
         WHILE_END
         aa = 0;
         WHILE aa < LC_KNUTH_LL:
            mody = lv_ran_a_arr[bb] - lv_ran_a_arr[cc];
            lv_ran_x_arr[aa] = BITAND(LC_KNUTH_MAX, mody);
            aa += 1;
            #[0    ..LL)
            bb += 1;
            #[nn-KK..nn-KK+LL)
            cc += 1;
            #[nn-LL..nn)
         WHILE_END
         cc = 0;
         WHILE aa < LC_KNUTH_KK_COUNT:
            mody = lv_ran_a_arr[bb] - lv_ran_x_arr[cc];
            lv_ran_x_arr[aa] = BITAND(LC_KNUTH_MAX, mody);
            aa += 1;
            #[LL      ..KK)
            bb += 1;
            #[nn-KK+LL..nn)
            cc += 1;
            #[0       ..KK-LL)
         WHILE_END
      MODE_INTEGER_END
      RETURN bb;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------- lf_fill_ranz #
   BLOCK_DEF FUNC INT lf_fill_ranz(NUL):
      BLOCK_USE lv_ranz_magic;
      BLOCK_USE lv_ranz_ind;
      BLOCK_USE lv_ranz_arr[];
      BLOCK_USE lv_ran_a_arr[];
      INT jj;
      CALL lf_ran_cycle(LC_KNUTH_QUALITY_COUNT);
      FOR jj FROM 0 TO LC_KNUTH_QUALITY_COUNT - 1:
         lv_ranz_arr[jj] = lv_ran_a_arr[jj];
      FOR_END
      lv_ranz_arr[LC_KNUTH_KK_COUNT] = -1;
      lv_ranz_ind = 0;
      lv_ranz_magic = Kw.magicset();
      RETURN lv_ranz_arr[0];
   FUNC_END
   #   FFFFFFFFFFunction ------------------------- lf_next_ranz #
   BLOCK_DEF FUNC INT lf_next_ranz(NUL):
      BLOCK_USE lv_ranz_magic;
      BLOCK_USE lv_ranz_ind;
      BLOCK_USE lv_ranz_arr[];
      # if not initialized: initialize;
      # else if buffer empty: create more
      IF NOT Kw.ismagic(lv_ranz_magic):
         CALL rand_init(Kw.timee());
      ELSIF lv_ranz_arr[lv_ranz_ind] < 0:
         CALL lf_fill_ranz();
      IF_END
      lv_ranz_ind += 1;
      RETURN lv_ranz_arr[lv_ranz_ind - 1];
   FUNC_END
   #   FFFFFFFFFFunction ---------------------- rand_init_array #
   FUNC DBL rand_init_array(INT seed_size
         , READONLY INT seed_arr_pc[]):
      # Initialize Random Number generator
      # with an array of SEED_SIZE longs
      # (at most LC_KNUTH_KK_COUNT are used)
      BLOCK_USE lv_ran_x_arr[];
      INT tt;
      INT jj;
      INT kk;
      INT dd;
      INT rnd_arr[2 * LC_KNUTH_KK_COUNT];
      INT rndss;
      INT rndx;
      INT rndff;
      INT seed_ind;
      INT bitmask;
      MODE_INTEGER:
         rndss = BITAND((seed_arr_pc[0] + 2), (LC_KNUTH_MAX
               - 1));
         # rndss is now even
         FOR jj FROM 0 TO LC_KNUTH_KK_COUNT - 1:
            rnd_arr[jj] = rndss;
            rndss = BITSHIFTL(rndss, 1);
            IF LC_KNUTH_MAX < rndss:
               rndss -= (LC_KNUTH_MAX - 1);
            IF_END
            # rndss is still even
         FOR_END
         rndff = 0;
         seed_ind = 0;
         bitmask = 0;
         FOR jj FROM 0 TO LC_KNUTH_KK_COUNT - 1:
            IF bitmask <= 1:
               seed_ind += 1;
               IF seed_size <= seed_ind:
                  FOR_EXIT;
               IF_END
               rndff = seed_arr_pc[seed_ind];
               bitmask = BITSHIFTL(1, 30);
            IF_END
            IF BITAND(rndff, bitmask) <> 0:
               # bitmask, rnd_arr[ii] are even, hence so is xor
               rnd_arr[jj] = BITXOR(bitmask, rnd_arr[jj]);
            IF_END
            bitmask = BITSHIFTR(bitmask, 1);
         FOR_END
         # Back to Knuths code
         # All numbers in rnd_arr[] are even
         rnd_arr[1] += 1;
         # All numbers rnd_arr[] are even EXCEPT rnd_arr[1]
         rndss = BITAND(seed_arr_pc[0], LC_KNUTH_MAX);
         tt = LC_KNUTH_TT - 1;
         WHILE 0 < tt:
            FOR jj FROM LC_KNUTH_KK_COUNT - 1 TO 1 BY - 1:
               rnd_arr[jj + jj] = rnd_arr[jj];
               rnd_arr[jj + jj - 1] = 0;
            FOR_END
            jj = LC_KNUTH_KK_COUNT + LC_KNUTH_KK_COUNT - 2;
            dd = LC_KNUTH_KK_COUNT + LC_KNUTH_LL - 2;
            kk = LC_KNUTH_KK_COUNT - 2;
            WHILE 0 <= kk:
               rndx = rnd_arr[dd] - rnd_arr[jj];
               rnd_arr[dd] = BITAND(rndx, LC_KNUTH_MAX);
               rndx = rnd_arr[kk] - rnd_arr[jj];
               rnd_arr[kk] = BITAND(rndx, LC_KNUTH_MAX);
               dd -= 1;
               kk -= 1;
               jj -= 1;
            WHILE_END
            IF Kw.isodd(rndss):
               FOR jj FROM LC_KNUTH_KK_COUNT TO 1 BY - 1:
                  rnd_arr[jj] = rnd_arr[jj - 1];
               FOR_END
               rnd_arr[0] = rnd_arr[LC_KNUTH_KK_COUNT];
               jj = rnd_arr[LC_KNUTH_LL] - rnd_arr[0];
               rnd_arr[LC_KNUTH_LL] = BITAND(LC_KNUTH_MAX, jj);
               rndss = BITSHIFTR(rndss, 1);
            ELSIF rndss == 0:
               tt -= 1;
            ELSE:
               rndss = BITSHIFTR(rndss, 1);
            IF_END
         WHILE_END
         kk = (LC_KNUTH_KK_COUNT - LC_KNUTH_LL);
         jj = 0;
         # Before each loop:
         #   jj - kk = LC_KNUTH_LL mod LC_KNUTH_KK_COUNT
         WHILE jj < LC_KNUTH_LL:
            lv_ran_x_arr[kk] = rnd_arr[jj];
            kk += 1;
            jj += 1;
         WHILE_END
         # jj == LC_KNUTH_LL; kk == LC_KNUTH_KK_COUNT
         kk = 0;
         WHILE jj < LC_KNUTH_KK_COUNT:
            lv_ran_x_arr[kk] = rnd_arr[jj];
            kk += 1;
            jj += 1;
         WHILE_END
         FOR jj FROM 0 TO 9:
            CALL lf_ran_cycle(2 * LC_KNUTH_KK_COUNT - 1);
         FOR_END
      MODE_INTEGER_END
      CALL lf_fill_ranz();
      RETURN 0;
   FUNC_END
   #   FFFFFFFFFFunction ---------------------------- rand_init #
   FUNC DBL rand_init(DBL seed):
      # Initialize Random Number generator
      # with a single double SEED
      INT sd_arr[2];
      sd_arr[0] = FLOOR(seed);
      sd_arr[1] = FLOOR(frac(seed) * Kw.INTMAX);
      CALL rand_init_array(2, sd_arr[]);
      RETURN seed;
   FUNC_END
   #   FFFFFFFFFFunction -------------------------------- randl #
   FUNC INT randl(INT nn):
      # Return a uniformly distributed integer in[0,NN)
      INT max_allowed;
      INT rndm;
      INT retvalu;
      MODE_INTEGER:
         max_allowed = LC_KNUTH_MAX - (LC_KNUTH_MAX % nn);
         # Now MAX_ALLOWED is a multiple of NN
         AWAIT rndm < max_allowed:
            rndm = lf_next_ranz();
         AWAIT_END
         retvalu = rndm % nn;
      MODE_INTEGER_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction -------------------------------- randd #
   FUNC DBL randd(NUL):
      # Return a uniformly distributed number in[0.0,1.0)
      RETURN (lf_next_ranz() + lf_next_ranz() / (LC_KNUTH_MAX
            + 1.0)) / (LC_KNUTH_MAX + 1.0);
   FUNC_END
BLOCK_END# Random numbers
#   IIIIIIIIIInsert-End --------------------------- random.fwip #
#   IIIIIIIIIInsert-Begin ----------------------- randdist.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-24 kdw  randdist:var renam
# 2020-08-20 kdw  randdist:boolean checks changed
# 2020-08-19 kdw  randdist:comment change
# 2020-08-17 kdw  randdist:macro syntax changed
# 2020-07-27 kdw  randdist:block syntax
# 2020-07-24 kdw  randdist:s/LO[C]AL_/BL[O]CK_/
# 2020-07-14 kdw  randdist:s/px/pbrx/g
# 2020-07-12 kdw  randdist:sqrttwo const
# 2020-07-10 kdw  randdist:normal cdf approx func
# 2020-07-01 kdw  randdist:tests modified
# 2020-06-30 kdw  randdist:tests changed
# 2020-06-22 kdw  randdist:local-use mved before var decls
# 2020-06-08 kdw  randdist:integral function stuff
# 2020-06-06 kdw  randdist:Gompertz distribution
# 2020-05-14 kdw  randdist:local funcs only in blocks
# 2020-05-11 kdw  randdist:BL[O]CK work
# 2020-05-06 kdw  randdist:rmed boolean vars
# 2020-05-05 kdw  randdist:magic check func changed
# 2020-04-30 kdw  randdist:trap[_]rand rework
# 2020-04-24 kdw  randdist:comments; const renam
# 2020-04-14 kdw  randdist:tests added
# 2020-04-12 kdw  randdist:comment change
# 2020-04-10 kdw  randdist:comment change
# 2020-04-08 kdw  randdist:preprocess sigil change
# 2020-04-07 kdw  randdist:comment; dup func rmed
# 2020-04-02 kdw  randdist:tweak here and there
# 2020-04-01 kdw  randdist:t quantile work
# 2020-03-30 kdw  randdist:s/_cdfinv/_quantile/g
# 2020-03-30 kdw  randdist:comment change
# 2020-03-29 kdw  randdist:func renam
# 2020-03-27 kdw  randdist:nbd and polya work
# 2020-03-26 kdw  randdist:_cdf trap inv func
# 2020-03-25 kdw  randdist:tri and trap simplified
# 2020-03-20 kdw  randdist:tri and trap work
# 2020-03-10 kdw  randdist:fixed pd[f]bb
# 2020-03-09 kdw  randdist:LO[C]AL_.* keywords
# 2020-03-05 kdw
   #randdist:s/TRU[E]VAL/TR[U]E/;s/FALS[E]VAL/FA[L]SE/
# 2020-03-03 kdw  randdist:comment change
# 2020-03-02 kdw  randdist:s/_NE[X]T/_E[N]D/g;
# 2020-02-28 kdw  randdist:poly eval work
# 2020-02-27 kdw  randdist:comment change
# 2020-02-26 kdw  randdist:arr[a]y and hor[n]er work
# 2020-02-16 kdw  randdist:array comments change
# 2020-02-14 kdw  randdist:incomplete beta work
# 2020-02-06 kdw  randdist:ks debugging II
# 2020-02-04 kdw  randdist:ks debugging
# 2020-02-03 kdw  randdist:more funcs have single return
# 2020-01-15 kdw  randdist:more arg checks in[cp]dfgeo()
# 2020-01-08 kdw  randdist:added several rand.* funcs
# 2019-12-31 kdw  randdist:maxwell-juttner distribution
# 2019-12-27 kdw  randdist:comments changed
# 2019-12-26 kdw  randdist:module name addded to funcs
# 2019-12-20 kdw  randdist:_pdf[mb]b long names
# 2019-11-20 kdw  randdist:black-body work II
# 2019-11-18 kdw  randdist:black-body work
# 2019-11-17 kdw  randdist:include Macros file
# 2019-10-23 kdw  randdist:lntwo const
# 2019-10-14 kdw  randdist:comment change
# 2019-10-04 kdw  randdist:comment change
# 2019-08-24 kdw  randdist:for and count loops have from clause
# 2019-08-22 kdw  randdist:comment changed
# 2019-08-18 kdw  randdist:B[O]OL to B[O]L
# 2019-08-17 kdw  randdist:L[O]G to LN
# 2019-08-11 kdw  randdist:comment cleanup
# 2019-08-06 kdw  randdist:rmed backslashes;macro arg renam
# 2019-07-22 kdw  randdist:func comments
# 2019-05-31 kdw  randdist:NR_DO to RAPHSON_LOOP; et al
# 2019-05-29 kdw  randdist:comment changed
# 2019-05-24 kdw  randdist:local replaced private
# 2019-05-20 kdw  randdist:rm unneeded comments; s/function/func/
# 2019-05-01 kdw  randdist:consts explicit module name
# 2019-03-19 kdw  randdist:re[t]_val to re[t]valu
# 2019-03-18 kdw  randdist:macro syntax changed
# 2019-03-16 kdw  randdist:tweak
# 2019-03-11 kdw  randdist:comments to array dcls
# 2019-03-08 kdw  randdist:is[e]qual to is[e]q, et al.
# 2019-03-06 kdw  randdist:is.* funcs changed
# 2019-01-03 kdw  randdist:Await counter changed
# 2018-11-29 kdw  randdist:upper cased fwip defined funcs
# 2018-10-05 kdw  randdist:l[o]g to L[O]G
# 2018-09-17 kdw  randdist:zipf and zeta dists
# 2018-09-13 kdw  randdist:cdf[t]inv2 fix
# 2018-07-25 kdw  randdist:cdf[k]s_a
# 2018-07-22 kdw  randdist:lf_cdftinv_gt_half
# 2018-07-19 kdw  randdist:comments; array reformat
# 2018-07-17 kdw  randdist:private lf_.* funcs
# 2018-07-14 kdw  randdist:float num format
# 2018-07-11 kdw  randdist:var nam change
# 2018-06-09 kdw  randdist:mved tests
# 2018-06-08 kdw  randdist:tests
# 2018-05-17 kdw  randdist:AR[R]AY.* and HOR[N]ER syntax
# 2018-05-16 kdw  randdist:AR[R]AY syntax
# 2018-04-19 kdw  randdist:comments added
# 2018-04-03 kdw  randdist:rm() from return
# 2018-03-26 kdw  randdist:macro redef
# 2018-03-12 kdw  randdist:made PP statements not need semicolon
# 2018-02-19 kdw  randdist:secant and macro refactor
# 2018-02-14 kdw  randdist:comment change
# 2017-11-26 kdw  randdist:FR[O]M and B[Y] keywords
# 2017-11-22 kdw  randdist:var renam
# 2017-10-21 kdw  randdist:macros start with "at""at"
# 2017-10-20 kdw  randdist:COM[M]ENMT format changed
# 2017-10-03 kdw  randdist:dont die for bad args
# 2017-08-31 kdw  randdist:[pc]dftri,[pc]dfgeo,[pc]dfpoi added
# 2017-08-30 kdw  randdist:s/DBL_/DBL/;s/FLT_/FLT/
# 2017-08-20 kdw  randdist:rmed/renamd .*_P[E]R_.* vars
# 2017-06-21 kdw  randdist:added ";" to COM[M]ENT lines
# 2017-05-25 kdw  randdist:line wrap problem wrt python
# 2017-05-16 kdw  randdist:chisqr work
# 2017-04-26 kdw  randdist:keyword COMMENT.*
# 2017-04-24 kdw  randdist:extra parens added
# 2017-04-21 kdw  randdist:var renam
# 2017-04-20 kdw  randdist:func to function
# 2017-03-12 kdw  randdist:shorten long comments
# 2017-03-10 kdw  randdist:get Fw[i]p_Pa[r]se to work
# 2017-03-07 kdw  randdist:INS[E]RT etal
# 2017-03-06 kdw  randdist:sigils rmed
# 2017-03-01 kdw  randdist:RE[T]URN syntax more finicky
# 2017-02-28 kdw  randdist:REQ[U]IRE function()
# 2017-02-24 kdw  randdist:REP[L]ACE rework, et al
# 2017-02-20 kdw  randdist:made die more uniform
# 2017-02-14 kdw  randdist:FWIP Loop syntax changed
# 2017-02-13 kdw  randdist:FWIP language change
# 2017-02-12 kdw  randdist:FWIP language change
# 2017-02-08 kdw  randdist:SE[C]ANT syntax
# 2017-02-07 kdw  randdist:var renam
# 2017-02-06 kdw  randdist:SE[C]ANT syntax
# 2017-02-03 kdw  randdist:cdfb[e]tainv
# 2017-01-31 kdw  randdist:beta dist
# 2017-01-06 kdw  randdist:..USE.* to ...*_MODE; ..DIGR.*
# 2017-01-03 kdw  randdist:var renam
# 2017-01-02 kdw  randdist:Pareto
# 2016-12-23 kdw  randdist:die change
# 2016-12-03 kdw  randdist:comment change
# 2016-11-27 kdw  randdist:long lines
# 2016-11-24 kdw  randdist:reformatting of await loops
# 2016-11-22 kdw  randdist:moved cdfno[r]mal2 to ap[p]rox and
   #renam
# 2016-11-21 kdw  randdist:D[E]F to FU[N]C
# 2016-11-20 kdw  randdist:language change
# 2016-11-18 kdw  randdist:__POD__
# 2016-11-16 kdw  randdist:comments
# 2016-11-15 kdw  randdist:MOD/BIT* syntax change
# 2016-11-14 kdw  randdist:sec[a]nt algorithm refactor
# 2016-11-11 kdw  randdist:sec[a]nt algorithm refactor
# 2016-11-06 kdw  randdist:while loop replaced with await
# 2016-11-01 kdw  randdist:debugging t-distribution
# 2016-10-31 kdw  randdist:EX[I]TL[O]OP
# 2016-10-30 kdw  randdist:lang change
# 2016-09-15 kdw  randdist:lang change
# 2016-09-13 kdw  randdist:lang change
# 2016-08-15 kdw  randdist:layout error
# 2016-07-19 kdw  randdist:float numbers(added ".0")
# 2016-05-18 kdw  randdist:comment change
# 2015-12-28 kdw  randdist:.*2() functions rmed
# 2015-12-28 kdw  randdist:__IF_X__ to __IF_NONE_ _
# 2015-12-26 kdw  randdist:commented out _cdf[k]s_1
# 2015-12-16 kdw  randdist:long comments
# 2015-12-14 kdw  randdist:long lines
# 2015-12-11 kdw  randdist:s/LC_// from some consts
# 2015-12-03 kdw  randdist:long lines changed
# 2015-12-02 kdw  randdist:*student* to *t*
# 2015-11-26 kdw  randdist:long lines changed
# 2015-11-19 kdw  randdist:long lines changed
# 2015-11-17 kdw  randdist:variable rename
# 2015-11-13 kdw  randdist:minor refactor; long lines changed
# 2015-11-12 kdw  randdist:rmed useless function
# 2015-10-27 kdw  randdist:variable rename
# 2015-10-19 kdw  randdist:ga[m]ma to tga[m]ma
# 2015-10-09 kdw  randdist:renamed i[n]v functions
# 2015-10-01 kdw  randdist:float equality checks to is.*
# 2015-09-30 kdw  randdist:use p[o]w function
# 2015-09-27 kdw  randdist:tweak
# 2015-09-25 kdw  randdist:use isodd, iseven instead of[M]OD
# 2015-09-20 kdw  randdist:created
# http://www2.econ.osaka-u.ac.jp/tildetanizaki/cv/books
#      /cmse/cmse.pdf
#   IIIIIIIIIInsert-Begin ------------------------- Macros.fwip #
#   IIIIIIIIIInsert-End --------------------------- Macros.fwip #
#   FFFFFFFFFFunction --------------------------------- int_pdf #
FUNC DBL int_pdf(DBL nn
      , DBL xx):
   # PDF Uniform Integer
   # Support: 0..NN-1
   DBL retvalu;
   DBL mm;
   IF xx < 0.0 OR nn < xx OR (NOT Kw.isint(xx)):
      retvalu = 0.0;
   ELSE:
      # XX is an integer in[0,NN)
      mm = FLOOR(nn);
      IF Kw.isint(nn):
         IF xx < nn:
            retvalu = 1.0 / nn;
         ELSE:
            retvalu = 0;
         IF_END
      ELSE:
         IF xx < mm:
            retvalu = 1.0 / nn;
         ELSE:
            retvalu = 1.0 - mm / nn;
         IF_END
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- int_cdf #
FUNC DBL int_cdf(DBL nn
      , DBL xx):
   # CDF Uniform Integer[0,NN)
   # Support: 0..NN-1
   DBL retvalu;
   DBL mm;
   IF xx <= 0.0:
      retvalu = 0.0;
   ELSIF nn <= xx:
      retvalu = 1.0;
   ELSE:
      mm = FLOOR(nn);
      IF xx < mm:
         retvalu = (FLOOR(xx) + 1) / nn;
      ELSE:
         retvalu = 1;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- int_quantile #
FUNC DBL int_quantile(DBL nn
      , DBL prbx):
   # Quantile Uniformly Integer[0,NN)
   # Support: 0..NN-1
   DBL retvalu;
   IF prbx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 - frac(nn) / nn <= prbx:
      retvalu = CEIL(nn - 1);
   ELSE:
      retvalu = FLOOR(nn * prbx + 1);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- int_rand #
FUNC INT int_rand(DBL nn):
   # Random Uniform Integer Variable[0,NN)
   # Support: 0..NN-1
   # Average = FLOOR(NN)*(FLOOR(NN-1)/2+FRAC(NN))/NN
   #    If NN is an integer, average=(NN-1)/2
   INT retvalu;
   IF nn <= 1:
      retvalu = 0;
   ELSE:
      retvalu = FLOORL(randd() * nn);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ normal_pdf #
FUNC DBL normal_pdf(DBL xx):
   # PDF(0,1) gaussian distribution
   # Support: (-Inf,Inf)
   # (-Inf,0,+Inf) to(0,1/SQRT(Kw.TAU),0)
   RETURN EXP(-xx * xx / 2.0) / (SQRT(Kw.TAU));
FUNC_END
#   FFFFFFFFFFunction ------------------------------ normal_cdf #
FUNC DBL normal_cdf(DBL xx):
   # CDF(0,1) gaussian distribution
   # Support: (-Inf,Inf)
   RETURN Kw.erf(xx / Kw.SQRTTWO) / 2.0 + 0.5;
FUNC_END
#   FFFFFFFFFFunction --------------------------- normal_cdf__1 #
FUNC DBL normal_cdf__1(DBL xx):
   # approximate the CDF of the normal distribution
   DBL retvalu;
   DBL sum_curr;
   DBL sum_prev;
   DBL bb;
   DBL xx_sqr;
   DBL ii;
   IF xx <= - 10.0:
      retvalu = 0.0;
   ELSIF 10.0 <= xx:
      retvalu = 1.0;
   ELSIF Kw.iszero(xx):
      retvalu = 0.5;
   ELSE:
      sum_curr = 0.0;
      bb = 1.0 / xx;
      xx_sqr = xx * xx;
      AWAIT Kw.iseq(sum_prev, sum_curr) COUNT ii FROM 0:
         bb *= xx_sqr / (2.0 * ii + 1.0);
         sum_prev = sum_curr;
         sum_curr += bb;
      AWAIT_END
      retvalu = (sum_curr * EXP(-0.5 * (xx_sqr + LN(Kw.TAU)))
            + 0.5);
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:normal_cdf__1(1)==0.84134474606854294858523254563203792;
#   FFFFFFFFFFunction ------------------------- normal_quantile #
FUNC DBL normal_quantile(DBL prbx):
   # Quantile normal distribution(0,1) to(-Inf,+Inf)
   RETURN Kw.SQRTTWO * Kw.erfinv(2.0 * prbx - 1.0);
FUNC_END
BLOCK:# normal distributed nunmbers
   BLOCK_DEF DBL lv_rand_gau_magic = 0.0;
   BLOCK_DEF DBL lv_rand_gau_prev = 0.0;
   #   FFFFFFFFFFunction -------------------------- normal_rand #
   FUNC DBL normal_rand(NUL):
      # Random Normal Variable
      BLOCK_USE lv_rand_gau_magic;
      BLOCK_USE lv_rand_gau_prev;
      DBL retvalu;
      DBL uua;
      DBL uub;
      DBL ww;
      IF Kw.ismagic(lv_rand_gau_magic):
         lv_rand_gau_magic = Kw.magicnot();
         retvalu = lv_rand_gau_prev;
      ELSE:
         AWAIT Kw.isbetweenx(ww, 0.0, 0.25):
            uua = randd() - 0.5;
            uub = randd() - 0.5;
            ww = uua * uua + uub * uub;
         AWAIT_END
         ww = SQRT(-2.0 * LN(4.0 * ww) / ww);
         lv_rand_gau_prev = uub * ww;
         lv_rand_gau_magic = Kw.magicset();
         retvalu = uua * ww;
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END# normal distributed nunmbers
#   FFFFFFFFFFunction --------------------------------- gau_pdf #
FUNC DBL gau_pdf(DBL xx):
   # PDF gaussian distribution
   # (-Inf,0,+Inf) to(0,1/SQRT(Kw.TAU),0)
   RETURN normal_pdf(xx);
FUNC_END
#   FFFFFFFFFFunction --------------------------------- gau_cdf #
FUNC DBL gau_cdf(DBL xx):
   # CDF(0,1) gaussian distribution
   # Support: (-Inf,Inf)
   RETURN normal_cdf(xx);
FUNC_END
#   FFFFFFFFFFunction ---------------------------- gau_quantile #
FUNC DBL gau_quantile(DBL prbx):
   # Quantile normal ditribution(0,1) to(-Inf,+Inf)
   RETURN normal_quantile(prbx);
FUNC_END
#   FFFFFFFFFFunction -------------------------------- gau_rand #
FUNC DBL gau_rand(NUL):
   # Random Normal Variable
   RETURN normal_rand();
FUNC_END
#   FFFFFFFFFFunction ---------------------- normal_quantile__1 #
FUNC DBL normal_quantile__1(DBL prbx):
   # Quantile normal ditribution(0,1) to(-Inf,+Inf)
   DBL retvalu;
   DBL p_low;
   DBL qq;
   DBL rr;
   DBL denom;
   DBL numer;
   #Define work variables
   #Define break-point
   p_low = 0.02425;
   IF prbx <= 0.0:
      retvalu = -(Kw.DBLMAX);
   ELSIF 1.0 <= prbx:
      retvalu = Kw.DBLMAX;
   ELSIF p_low <= prbx AND prbx <= 1.0 - p_low:
      # mid region
      qq = prbx - 0.5;
      rr = qq * qq;
      numer = ((((((-3.96968302866538E+1) * rr
            + 2.20946098424521E+2) * rr - 2.75928510446969E+2)
            * rr + 1.38357751867269E+2) * rr
            - 3.06647980661472E+1) * rr + 2.50662827745924E+0);
      denom = ((((((-5.44760987982241E+1) * rr
            + 1.61585836858041E+2) * rr - 1.55698979859887E+2)
            * rr + 6.68013118877197E+1) * rr
            - 1.32806815528857E+1) * rr + 1.00000000000000E+0);
      retvalu = (qq * numer / denom);
   ELSE:
      IF prbx < p_low:
         # lower region
         rr = SQRT(-2.0 * LN(prbx));
         qq = 1.0;
      ELSE:
         # not lower region
         rr = SQRT(-2.0 * LN(1 - prbx));
         qq = -1.0;
      IF_END
      numer = ((((((-7.78489400243029E-3) * rr
            - 3.22396458041136E-1) * rr - 2.40075827716184E+0)
            * rr - 2.54973253934373E+0) * rr
            + 4.37466414146497E+0) * rr + 2.93816398269878E+0);
      denom = (((((7.78469570904146E-3) * rr
            + 3.22467129070040E-1) * rr + 2.44513413714300E+0)
            * rr + 3.75440866190742E+0) * rr
            + 1.00000000000000E+0);
      retvalu = qq * numer / denom;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- uni_pdf #
FUNC DBL uni_pdf(DBL max_x
      , DBL xx):
   # PDF uniform distribution on[0,MAX_X)
   # MEAN       MAX_X / 2
   # VARIANCE   MAX_X / 12
   # MODE[0,MAX_X)
   # MEDIAN     MAX_ / 2
   DBL retvalu;
   IF max_x <= 0.0 OR xx <= 0.0 OR max_x <= xx:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 / max_x;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- uni_cdf #
FUNC DBL uni_cdf(DBL max_x
      , DBL xx):
   # CDF uniform distribution on[0,MAX_X)
   # Support:[0,MAX_X)
   # MEAN       MAX_X / 2
   # VARIANCE   MAX_X / 12
   # MODE[0,MAX_X)
   # MEDIAN     MAX_X / 2
   DBL retvalu;
   IF max_x <= 0.0 OR xx < 0.0:
      retvalu = 0.0;
   ELSIF max_x < xx:
      retvalu = 1.0;
   ELSE:
      retvalu = xx / max_x;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- uni_quantile #
FUNC DBL uni_quantile(DBL max_x
      , DBL prbx):
   # Quantile uniform distribution on[0,MAX_X)
   # Support:[0,MAX_X)
   DBL retvalu;
   IF prbx < 0.0 OR max_x <= 0.0:
      retvalu = 0.0;
   ELSIF max_x < prbx:
      retvalu = 1.0;
   ELSE:
      retvalu = prbx * max_x;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- uni_rand #
FUNC DBL uni_rand(DBL max_x):
   # Random uniform variable on[0,MAX_X)
   # Support:[0,MAX_X)
   RETURN uni_quantile(max_x, randd());
FUNC_END
#TEST:rand_init(1.987)==1.987;
#TEST:uni_rand(1.0)-0.2159134211342970495126070140656793228118;
#TEST:uni_rand(1.0)-0.9505410465129708504072869601486672763713;
#TEST:uni_rand(1.0)-0.6972580030927504803756056261931917106267;
#   FFFFFFFFFFunction --------------------------------- exp_pdf #
FUNC DBL exp_pdf(DBL scal
      , DBL xx):
   # PDF exponential distribution on w/ scaling 0 < SCAL
   # Support:[0,Inf)
   # == SCAL * EXP(-SCAL * XX)
   # MEAN       1 / SCAL
   # VARIANCE   1 / SCAL**2
   # MODE       0
   # MEDIAN     LN(2) / SCAL
   DBL retvalu;
   IF xx < 0.0 OR scal <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = scal * EXP(-scal * xx);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- exp_cdf #
FUNC DBL exp_cdf(DBL scal
      , DBL xx):
   # CDF exponential distribution w/ scaling 0 < SCAL
   # Support:[0,Inf)
   # == 1 - EXP(-SCAL * XX)
   # MEAN       1 / SCAL
   # VARIANCE   1 / SCAL**2
   # MODE       0
   # MEDIAN     LN(2) / SCAL
   DBL retvalu;
   IF xx < 0.0 OR scal <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 - EXP(-scal * xx);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- exp_quantile #
FUNC DBL exp_quantile(DBL scal
      , DBL prbx):
   # Quantile exponential ditribution[0,+Inf] to[0,1]
   # == -LN(1 - PRBX) / SCAL
   DBL retvalu;
   IF prbx <= 0.0 OR scal <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= prbx:
      retvalu = Kw.DBLMAX;
   ELSE:
      retvalu = -LN(1.0 - prbx) / scal;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- exp_rand #
FUNC DBL exp_rand(DBL scal):
   # Random Exponential Variable
   RETURN - LN(randd()) / scal;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- poi_pdf #
FUNC DBL poi_pdf(DBL meanx
      , DBL xx):
   # PDF poisson distribution
   # Support:[0,+Inf)
   # MEAN      MEANX
   # VARIANCE  MEANX
   # MODE      MEANX - 1
   DBL kk;
   DBL retvalu;
   IF xx < 0.0 OR meanx <= 0.0:
      retvalu = 0.0;
   ELSE:
      kk = FLOOR(xx);
      retvalu = POW(meanx, kk) * EXP(-meanx) / factorial(kk);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- poi_cdf #
FUNC DBL poi_cdf(DBL meanx
      , DBL xx):
   # CDF poisson distribution
   # Support:[0,+Inf)
   # MEAN      MEANX
   # VARIANCE  MEANX
   # MODE      MEANX - 1
   INT ii;
   INT kk;
   DBL sum;
   DBL term;
   DBL retvalu;
   IF xx <= 0.0 OR meanx <= 0.0:
      retvalu = 0.0;
   ELSIF 1000 < xx / meanx:
      retvalu = 1;
      #Kw.uigamma(xx, meanx);
   ELSE:
      term = EXP(-meanx);
      sum = term;
      kk = FLOORL(xx);
      FOR ii FROM 1 TO kk:
         term *= meanx / ii;
         sum += term;
      FOR_END
      retvalu = sum;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- poi_quantile #
FUNC DBL poi_quantile(DBL meanx
      , DBL prbx):
   # Quantile poisson distribution
   # MEAN      MEANX
   # VARIANCE  MEANX
   # MODE      MEANX - 1
   INT ii;
   DBL sum;
   DBL prevsum;
   DBL term;
   DBL retvalu;
   IF prbx <= 0.0 OR meanx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= prbx:
      retvalu = DBLMAX;
   ELSE:
      prevsum = 0.0;
      term = EXP(-meanx);
      sum = term;
      ii = 0;
      WHILE sum <= prbx:
         ii += 1;
         term *= meanx / ii;
         prevsum = sum;
         sum += term;
      WHILE_END
      IF sum - prbx < prbx - prevsum:
         retvalu = ii;
      ELSE:
         retvalu = ii - 1;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- poi_rand #
FUNC INT poi_rand(DBL meanx):
   # Random Poisson variable w/ mean MEANX
   # Support  NN = 0,1,2,3,...
   #   PDFPOI(NN)=MEANX**NN*EXP(-NN)/factorial(NN)
   DBL prob;
   DBL poi;
   DBL sum;
   INT nn;
   prob = randd();
   poi = EXP(-meanx);
   sum = poi;
   nn = 0;
   WHILE sum < prob:
      nn += 1;
      poi *= 1.0 * meanx / nn;
      sum += poi;
   WHILE_END
   RETURN nn;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- geo_pdf #
FUNC DBL geo_pdf(DBL prob
      , DBL kk):
   # PDF geometric distribution
   # Support: 0..Inf
   # MEAN(1 - PROB) / PROB
   # VARIANCE(1 - PROB) / PROB**2
   # MODE      0
   DBL retvalu;
   IF kk < 0 OR prob < 0.0 OR 1.0 <= prob:
      retvalu = 0.0;
   ELSE:
      retvalu = POW(1.0 - prob, kk) * prob;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- geo_cdf #
FUNC DBL geo_cdf(DBL prob
      , DBL kk):
   # CDF geometric distribution
   # Support: 0..Inf
   # MEAN(1 - PROB) / PROB
   # VARIANCE(1 - PROB) / PROB**2
   # MODE      0
   DBL retvalu;
   IF kk <= - 1 OR prob < 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= prob:
      retvalu = 1.0;
   ELSE:
      retvalu = 1.0 - POW(1.0 - prob, kk + 1);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- geo_quantile #
FUNC DBL geo_quantile(DBL prob
      , DBL prbx):
   # Quantile Geometric Distribution
   DBL retvalu;
   IF prbx <= 0.0 OR 1.0 <= prbx OR prob <= 0.0 OR 1.0 <= prob:
      retvalu = 0.0;
   ELSE:
      retvalu = LN(1.0 - prbx) / LN(1.0 - prob) - 1.0;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- geo_rand #
FUNC INT geo_rand(DBL prob):
   # Random Geometric Variable
   # Support  0,1,2,3,...
   # THIS IMPLEMENTATION HAS SUPPORT STARTING AT 0
   RETURN FLOORL(LN(randd()) / LN(1.0 - prob));
FUNC_END
#   FFFFFFFFFFunction ------------------------------ cauchy_pdf #
FUNC DBL cauchy_pdf(DBL scal
      , DBL xx):
   # PDF Cauchy distribution w/ scaling 0 < SCAL
   # Support: (-Inf,0,+Inf) to(0,1/Kw.PI,0)
   # MEAN      NAN(0 principle value)
   # VARIANCE  NAN
   # MODE      0
   # cauchy_pdf(1,x) == t_pdf(1,x)
   RETURN 1.0 / (Kw.PI * scal * (1 + (Kw.square(xx / scal))));
FUNC_END
#   FFFFFFFFFFunction ------------------------------ cauchy_cdf #
FUNC DBL cauchy_cdf(DBL scal
      , DBL xx):
   # CDF Cauchy distribution
   # Support: (-Inf,0,+Inf)
   RETURN taninv(xx / scal) / Kw.PI + 0.5;
FUNC_END
#   FFFFFFFFFFunction ------------------------- cauchy_quantile #
FUNC DBL cauchy_quantile(DBL scal
      , DBL prbx):
   # Quantile Cauchy distribution
   #      (0,1) to(-Inf,+Inf)
   RETURN scal * TAN((prbx - 0.5) * Kw.PI);
FUNC_END
#   FFFFFFFFFFunction ----------------------------- cauchy_rand #
FUNC DBL cauchy_rand(DBL scal):
   # Random Cauchy Variable
   RETURN cauchy_quantile(scal, randd());
FUNC_END
#   FFFFFFFFFFunction ---------------------------- logistic_pdf #
FUNC DBL logistic_pdf(DBL ss
      , DBL xx):
   # PDF logistic distribution w/ scaling SS
   # Support: (-Inf,+Inf)
   DBL exs;
   DBL retvalu;
   IF ss <= 0.0:
      retvalu = 0.0;
   ELSE:
      exs = EXP(-xx / ss);
      retvalu = exs / (ss * POW(1.0 + exs, 2.0));
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- logistic_cdf #
FUNC DBL logistic_cdf(DBL ss
      , DBL xx):
   # CDF logistic distribution w/ scaling SS
   # Support: (-Inf,+Inf)
   DBL retvalu;
   IF ss <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 / (1.0 + EXP(-xx / ss));
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------- logistic_quantile #
FUNC DBL logistic_quantile(DBL ss
      , DBL prbx):
   # Quantile logistic distribution w/ scaling SS
   DBL retvalu;
   IF prbx <= 0.0 OR ss <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= prbx:
      retvalu = 1.0;
   ELSE:
      retvalu = -ss * LN(1.0 / prbx - 1.0);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------- logistic_rand #
FUNC DBL logistic_rand(DBL ss):
   # Random Logistic Variable w/ scaling SS
   RETURN - ss * LN(1.0 / randd() - 1.0);
FUNC_END
#   FFFFFFFFFFunction --------------------------------- tri_pdf #
FUNC DBL tri_pdf(DBL pp
      , DBL xx):
   # PDF Triangular distribution w/ 0 <= PP <= 1
   # PDF* is triangle defined by(0,0) (1,0) (pp,2)
   # Support:[0,1]
   DBL retvalu;
   IF pp < 0.0 OR 1.0 < pp:
      retvalu = 0;
   ELSE:
      IF xx < 0.0 OR 1.0 < xx:
         retvalu = 0.0;
      ELSIF xx < pp:
         retvalu = Kw.divi(2.0 * xx, pp, 2.0);
      ELSE:
         retvalu = Kw.divi(2.0 * (1.0 - xx), 1.0 - pp, 2.0);
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- tri_cdf #
FUNC DBL tri_cdf(DBL pp
      , DBL xx):
   # CDF Triangular distribution
   # Support:[0,1]
   DBL retvalu;
   IF pp < 0.0 OR 1.0 < pp:
      retvalu = 0;
   ELSE:
      IF xx <= 0:
         retvalu = 0;
      ELSIF xx < pp:
         retvalu = xx * xx / pp;
      ELSIF xx < 1.0:
         retvalu = 1.0 - Kw.square(1.0 - xx) / (1.0 - pp);
      ELSE:
         retvalu = 1.0;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- tri_quantile #
FUNC DBL tri_quantile(DBL pp
      , DBL prbx):
   # Quantile Triangular Variable
   DBL retvalu;
   IF pp < 0.0 OR 1.0 < pp:
      retvalu = 0;
   ELSE:
      IF prbx <= 0:
         retvalu = 0;
      ELSIF prbx < pp:
         retvalu = SQRT(prbx * pp);
      ELSIF prbx < 1.0:
         retvalu = 1.0 - SQRT((1.0 - prbx) * (1.0 - pp));
      ELSE:
         retvalu = 1.0;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- tri_rand #
FUNC DBL tri_rand(DBL pp):
   # Random Triangular Variable
   # Valid only if 0 <= PP <= 1
   # PDF is triangle(0,0) (1,0) and(PP,2)
   DBL xx;
   DBL yy;
   xx = randd();
   yy = randd();
   IF xx < pp:
      IF 2 * xx < pp * yy:
         xx = pp - xx;
      IF_END
   ELSE:
      IF (pp - 1.0) * yy < 2.0 * (xx - 1.0):
         xx = (pp + 1.0) - xx;
      IF_END
   IF_END
   RETURN xx;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- trap_pdf #
FUNC DBL trap_pdf(DBL para
      , DBL parb
      , DBL xx):
   # PDF Trapezoidal Variable
   # Support:[0,1]
   # Must have 0 <= PARA <= PARB  <= 1.0
   # PDF is bounded by(0,0) (1,0), (PARA,HH) and(PARB,HH)
   #   where HH = 2 / (1 + PARB - PARA)
   # Support[0,1]
   # trap_pdf(A,A,) = tri_pdf(A,)
   DBL retvalu;
   IF xx < 0.0 OR 1.0 < xx OR para < 0.0 OR parb < para
         OR 1.0 < parb:
      retvalu = 0.0;
   ELSE:
      IF xx < para:
         retvalu = xx / para;
      ELSIF xx <= parb:
         retvalu = 1.0;
      ELSE:
         retvalu = (1.0 - xx) / (1.0 - parb);
      IF_END
   IF_END
   # scale to force area under PDF == 1.0
   RETURN retvalu * 2.0 / (1.0 + parb - para);
FUNC_END
#   FFFFFFFFFFunction -------------------------------- trap_cdf #
FUNC DBL trap_cdf(DBL para
      , DBL parb
      , DBL xx):
   # CDF Trapezoidal Variable
   # Support:[0,1]
   # Must have 0 <= PARA <= PARB <= 1.0
   # PDF is bounded by(0,0) (1,0), (PARA,HH) and(PARB,HH)
   #   where HH = 2 / (1 + PARB - PARA)
   # Support[0,1]
   DBL mm;
   DBL retvalu;
   IF para < 0.0 OR parb < para OR 1.0 < parb:
      retvalu = 0.0;
   ELSIF xx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= xx:
      retvalu = 1.0;
   ELSE:
      mm = 2.0 / (1.0 + parb - para);
      IF xx < para:
         retvalu = mm * xx * xx / (2.0 * para);
      ELSIF xx < parb:
         retvalu = mm * (xx - para / 2.0);
      ELSE:
         retvalu = 1.0 - mm * Kw.square(1.0 - xx) / (2.0 * (1.0
               - parb));
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------- trap_quantile #
FUNC DBL trap_quantile(DBL para
      , DBL parb
      , DBL prbx):
   # Quantile Trapezoidal Variable
   # Must have 0 <= PARA <= PARB <= 1.0
   # PDF is bounded by(0,0) (1,0), (PARA,HH) and(PARB,HH)
   #    where HH = 2 / (1 + PARB - PARA)
   # Support[0,1]
   DBL mm;
   DBL retvalu;
   IF para < 0.0 OR parb < para OR 1.0 < parb:
      retvalu = 0.0;
   ELSIF prbx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= prbx:
      retvalu = 1.0;
   ELSE:
      mm = 2.0 / (1.0 + parb - para);
      IF prbx < para * mm / 2.0:
         retvalu = SQRT((2.0 * para * prbx) / mm);
      ELSIF prbx < 1.0 - mm * (1.0 - parb) / 2.0:
         retvalu = prbx / mm + para / 2.0;
      ELSE:
         retvalu = 1.0 - Kw.SQRTTWO * SQRT((1.0 - parb) * (1.0
               - prbx) / mm);
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- trap_rand #
FUNC DBL trap_rand(DBL para
      , DBL parb):
   # Random Trapezoidal Variable
   # Support[0,1]
   DBL xx;
   DBL retvalu;
   retvalu = -1;
   AWAIT 0.0 <= retvalu:
      xx = randd();
      IF xx < para:
         IF randd() * para < xx:
            retvalu = xx;
         IF_END
      ELSIF xx <= parb:
         retvalu = xx;
      ELSE:
         IF randd() * (1.0 - parb) < (1.0 - xx):
            retvalu = xx;
         IF_END
      IF_END
   AWAIT_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ pareto_pdf #
FUNC DBL pareto_pdf(DBL shap
      , DBL scal
      , DBL xx):
   # PDF Pareto distribution with shape 0 < SHAP
   # and scale 0 < SCAL.
   # Support:[0,Inf)
   # == SHAP * (SCAL / XX) ** SHAP / XX
   # MEAN       IF SHAP <= 1, INF
   #            ELSE, SHAP * SCAL / (SHAP - 1)
   # VARIANCE   IF SHAP <= 2, INF
   #         ELSE, SHAP**2 * SCAL / ((SHAP - 1)**2 * (SHAP - 2))
   # MODE       SCAL
   # MEDIAN     SCAL * POW(2, 1 / SHAP)
   RETURN shap * POW(scal / xx, shap) / xx;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ pareto_cdf #
FUNC DBL pareto_cdf(DBL shap
      , DBL scal
      , DBL xx):
   # CDF Pareto distribution with shape 0 < SHAP
   # and scale 0 < SCAL.
   # Support:[0,Inf)
   # == 1 - (SCAL / XX) ** SHAP
   # MEAN       IF SHAP <= 1, INF
   #            ELSE, SHAP * SCAL / (SHAP - 1)
   # VARIANCE   IF SHAP <= 2, INF
   #         ELSE, SHAP**2 * SCAL / ((SHAP - 1)**2 * (SHAP - 2))
   # MODE       SCAL
   # MEDIAN     SCAL * POW(2, 1 / SHAP)
   RETURN 1.0 - POW(scal / xx, shap);
FUNC_END
#   FFFFFFFFFFunction ------------------------- pareto_quantile #
FUNC DBL pareto_quantile(DBL shap
      , DBL scal
      , DBL prbx):
   # Quantile Pareto distribution with shape 0 < SHAP
   # and scale 0 < SCAL.
   RETURN scal / POW(1.0 - prbx, 1.0 / shap);
FUNC_END
#TEST:pareto_quantile(1.3,2.4,pareto_cdf(1.3,2.4, 3.5))==3.5;
#   FFFFFFFFFFunction ----------------------------- pareto_rand #
FUNC DBL pareto_rand(DBL shap
      , DBL scal):
   # Random Pareto Variable with shape 0 < SHAP
   # and scale 0 < SCAL.
   RETURN scal / POW(randd(), 1.0 / shap);
FUNC_END
#   FFFFFFFFFFunction ---------------------------- gompertz_pdf #
FUNC DBL gompertz_pdf(DBL shap
      , DBL scal
      , DBL xx):
   # PDF Gompertz distribution with shape 0 < SHAP
   # and scale 0 < SCAL.
   # Support:[0,Inf)
   # MEAN       EXP(SHAP) * Kw.Ei(-SHAP) / SCAL
   # MODE       IF SHAP < 1: -LN(SHAP) / SCAL
   #            ELSE: 0
   # MEDIAN     LN(LN(0.5) / SHAP + 1) / SCAL
   RETURN scal * shap * EXP(shap + scal * xx - shap * EXP(scal
         * xx));
FUNC_END
#   FFFFFFFFFFunction ---------------------------- gompertz_cdf #
FUNC DBL gompertz_cdf(DBL shap
      , DBL scal
      , DBL xx):
   # CDF gompertz distribution with shape 0 < SHAP
   # and scale 0 < SCAL.
   # Support:[0,Inf)
   RETURN 1.0 - EXP(-shap * (EXP(scal * xx) - 1));
FUNC_END
#   FFFFFFFFFFunction ----------------------- gompertz_quantile #
FUNC DBL gompertz_quantile(DBL shap
      , DBL scal
      , DBL prbx):
   # Quantile Gompertz distribution with shape 0 < SHAP
   # and scale 0 < SCAL.
   RETURN LN(1 - LN(1.0 - prbx) / shap) / scal;
FUNC_END
#TEST:gompertz_quantile(1.3,2.4,gompertz_cdf(1.3,2.4,0.7))==0.7;
#   FFFFFFFFFFunction --------------------------- gompertz_rand #
FUNC DBL gompertz_rand(DBL shap
      , DBL scal):
   # Random Gompertz Variable with shape 0 < SHAP
   # and scale 0 < SCAL.
   RETURN gompertz_quantile(shap, scal, randd());
FUNC_END
#   FFFFFFFFFFunction -------------------------------- zipf_pdf #
FUNC DBL zipf_pdf(DBL ss
      , INT max_kk
      , INT kk):
   # PDF zipf distribution w/ parameter SS over 1..MAX_KK
   DBL retvalu;
   IF kk <= 0.0 OR max_kk < kk:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 / (POW(kk, ss) * Kw.hnm(max_kk, ss));
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- zipf_cdf #
FUNC DBL zipf_cdf(DBL ss
      , INT max_kk
      , INT kk):
   # CDF zipf distribution w/ parameter SS over 0..MAX_KK
   DBL retvalu;
   IF kk <= 0.0:
      retvalu = 0.0;
   ELSIF max_kk < kk:
      retvalu = 1.0;
   ELSE:
      retvalu = Kw.hnm(kk, ss) / Kw.hnm(max_kk, ss);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------- zipf_quantile #
FUNC INT zipf_quantile(DBL ss
      , INT max_kk
      , DBL prbx):
   # Inverse Zipf distribution w/ parameter SS
   #    over integers KK in[1,MAX_KK]
   INT ii;
   DBL summ;
   DBL target;
   target = prbx * Kw.hnm(max_kk, ss);
   summ = 0;
   AWAIT target <= summ COUNT ii FROM 1:
      summ += 1.0 / POW(ii, ss);
   AWAIT_END
   RETURN ii;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- zipf_rand #
FUNC INT zipf_rand(DBL ss
      , INT max_kk):
   # Random Zipf Variable w/ parameter SS
   #    over integers in[1,MAX_KK]
   RETURN zipf_quantile(ss, max_kk, randd());
FUNC_END
#   FFFFFFFFFFunction -------------------------------- beta_pdf #
FUNC DBL beta_pdf(DBL shap_a
      , DBL shap_b
      , DBL xx):
   # PDF Beta distribution w/ shape 0 < SHAP_A,SHAP_B
   # Support: (-Inf,Inf)
   RETURN POW(xx, shap_a - 1.0) * POW((1.0 - xx), shap_b - 1.0)
         / beta(shap_a, shap_b);
FUNC_END
#   FFFFFFFFFFunction -------------------------------- beta_cdf #
FUNC DBL beta_cdf(DBL shap_a
      , DBL shap_b
      , DBL xx):
   # CDF Beta distribution with shape parameters
   #    0 < SHAP_A and 0 < SHAP_B
   RETURN betainc(shap_a, shap_b, xx);
FUNC_END
#   FFFFFFFFFFunction --------------------------- beta_quantile #
FUNC DBL beta_quantile(DBL shap_a
      , DBL shap_b
      , DBL prbx):
   # Quantile Beta distribution with shape parameters
   #    0 < SHAP_A and 0 < SHAP_B
   DBL retvalu;
   DBL scvx_xp;
   DBL scvx_xx;
   DBL scvx_yp;
   DBL scvx_yy;
   DBL scvx_dx;
   DBL scvx_dy;
   INT scvx_ii;
   IF prbx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= prbx:
      retvalu = 1.0;
   ELSE:
      # return XX where
      #   prbx - beta_cdf(shap_a, shap_b, scvx_xx)XX == 0
      # BEG Secant Calculation
      scvx_dx = 0.50;
      scvx_xx = 0.25;
      scvx_yy = prbx - beta_cdf(shap_a, shap_b, scvx_xx);
      FOR scvx_ii FROM 0 TO 20:
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         IF Kw.iseq(scvx_xp, scvx_xx):
            FOR_EXIT;
         IF_END
         scvx_yy = prbx - beta_cdf(shap_a, shap_b, scvx_xx);
         scvx_dy = (scvx_yy - scvx_yp);
         IF Kw.iszero(scvx_dy):
            FOR_EXIT;
         IF_END
         scvx_dx *= - scvx_yy / scvx_dy;
      FOR_END
      # END Secant Calculation
      retvalu = scvx_xx;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- beta_rand #
FUNC DBL beta_rand(DBL shap_a
      , DBL shap_b):
   # Random Beta Variable w/ shape 0 < SHAP_A,SHAP_B
   RETURN beta_quantile(shap_a, shap_b, randd());
FUNC_END
#   FFFFFFFFFFunction ------------------------------- gamma_pdf #
FUNC DBL gamma_pdf(DBL shap
      , DBL xx):
   # PDF gamma distribution w/ shape SHAP
   # Support: (0,Inf)
   # MEAN       SHAP
   # VARIANCE   SHAP
   # MODE       SHAP - 1 for 1 <= SHAP
   # MEDIAN     ?
   DBL retvalu;
   IF xx <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = EXP(LN(xx) * (shap - 1.0) - xx)
            / Kw.tgamma(shap);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- gamma_cdf #
FUNC DBL gamma_cdf(DBL shap
      , DBL xx):
   # CDF gamma distribution w/ shape SHAP
   # Support: (0,Inf)
   # MEAN       SHAP
   # VARIANCE   SHAP
   # MODE       SHAP - 1 for 1 <= SHAP
   # MEDIAN     ?
   DBL retvalu;
   DBL rr;
   INT ii;
   DBL sum;
   IF xx <= 0.0 OR shap <= 0.0:
      retvalu = 0.0;
   ELSIF Kw.isint(shap):
      sum = 1.0;
      rr = 1.0;
      FOR ii FROM 1 TO shap - 1:
         rr *= xx / ii;
         sum += rr;
      FOR_END
      retvalu = 1.0 - EXP(-xx) * sum;
   ELSE:
      retvalu = Kw.rligamma(shap, xx);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ gamma_rand #
FUNC DBL gamma_rand(DBL shap):
   # Random Gamma Variable w/ shape SHAP
   DBL i_shape;
   DBL f_shape;
   DBL rval;
   DBL jj;
   DBL ee;
   DBL gg;
   DBL yy;
   DBL ff;
   DBL xx;
   DBL vv;
   DBL qq;
   DBL pp;
   i_shape = FLOOR(shap);
   rval = 1.0;
   IF shap < 5:
      FOR jj FROM 1 TO i_shape:
         rval *= randd();
      FOR_END
      rval = -LN(rval);
      f_shape = shap - i_shape;
      IF 0.00001 < f_shape:
         # from "The Art of Computer Programming"
         # Volume 2 1997 by Donald Knuth, Page 587
         pp = Kw.E / (f_shape + Kw.E);
         AWAIT randd() < qq:
            vv = LN(randd());
            IF randd() < pp:
               xx = EXP(vv / f_shape);
               qq = EXP(-xx);
            ELSE:
               xx = 1.0 - vv;
               qq = EXP(LN(xx) * (f_shape - 1));
            IF_END
         AWAIT_END
         rval += xx;
      IF_END
   ELSE:
      # from "The Art of Computer Programming"
      # Volume 2 1997 by Donald Knuth, Page 134
      ee = shap - 1.0;
      gg = SQRT(shap + ee);
      yy = 0.0;
      ff = 0.0;
      WHILE rval <= 0.0 OR (1.0 + yy * yy) * EXP(ee * LN(rval
            / ee) - ff) < randd():
         xx = Kw.PI * randd();
         yy = SIN(xx) / COS(xx);
         ff = gg * yy;
         rval = ff + ee;
      WHILE_END
   IF_END
   RETURN rval;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ chisqr_pdf #
FUNC DBL chisqr_pdf(DBL df
      , DBL xx):
   # PDF Chi-square distribution
   # Support: (0,Inf)
   # MEAN       DF
   # VARIANCE   2 * DF
   # MODE       MAX(DF - 2, 0)
   # MEDIAN     about DF * (1 - 2 / (9 * DF**2))
   DBL retvalu;
   IF xx <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = (EXP((LN(xx / 2.0) * df - xx) / 2.0) / (xx
            * Kw.tgamma(df / 2.0)));
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ chisqr_cdf #
FUNC DBL chisqr_cdf(DBL df
      , DBL xx):
   # CDF Chi-square distribution
   # Support: (0,Inf)
   # MEAN       DF
   # VARIANCE   2 * DF
   # MODE       MAX(DF - 2, 0)
   # MEDIAN     about DF * (1 - 2 / (9 * DF**2))
   DBL retvalu;
   IF xx <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = (1.0 - Kw.ruigamma(df / 2.0, xx / 2.0));
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------- chisqr_rand #
FUNC DBL chisqr_rand(DBL df):
   # Random Chi-squared Variable w/ DF
   DBL sum;
   DBL vv;
   DBL jj;
   sum = 0;
   FOR jj FROM 1 TO df:
      vv = gau_rand();
      sum += vv * vv;
   FOR_END
   IF NOT Kw.isint(df):
      sum += gamma_rand(frac(df) / 2.0) * 2.0;
   IF_END
   RETURN sum;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- binomial_pdf #
FUNC DBL binomial_pdf(DBL prob
      , INT success
      , INT trial):
   # PDF binomial distribution
   # Support: 0..SUCCESS
   DBL retvalu;
   IF success < 0 OR trial < success:
      retvalu = 0.0;
   ELSE:
      retvalu = comb(trial, success) * POW(prob, success)
            * POW(1.0 - prob, trial - success);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- binomial_cdf #
FUNC DBL binomial_cdf(DBL prob
      , INT success
      , INT trial):
   # CDF binomial distribution
   # Support: 0..SUCCESS
   # Must have  0 <= PROB <= 1; SUCCESS <= TRIAL
   #  == betainc(TRIAL - SUCCESS, SUCCESS + 1.0, 1.0 - PROB)
   DBL lsum;
   DBL sfactor;
   INT ss;
   DBL mu;
   DBL kk;
   IF prob <= 0.0 OR success < 0:
      lsum = 0.0;
   ELSIF 1.0 <= prob OR trial <= success:
      lsum = 1.0;
   ELSE:
      # Use binomial_cdf(PR,K,N) = binomial_cdf(1-PR,N-K-1,N)
      IF trial <= 2 * success:
         ss = trial - success - 1;
         prob = 1.0 - prob;
      ELSE:
         ss = success;
      IF_END
      sfactor = POW(1.0 - prob, trial);
      mu = prob / (1.0 - prob);
      lsum = 0.0;
      FOR kk FROM 0 TO ss:
         lsum += sfactor;
         sfactor *= (mu * (trial - kk)) / (kk + 1.0);
      FOR_END
      IF ss <> success:
         lsum = 1.0 - lsum;
      IF_END
   IF_END
   RETURN lsum;
FUNC_END
#   FFFFFFFFFFunction --------------------------- binomial_rand #
FUNC DBL binomial_rand(DBL prob
      , DBL rr):
   # Random Binomial Variable
   # count of successes with probability PROB in RR trials
   DBL successes;
   successes = 0;
   WHILE 0 < rr:
      IF randd() < prob:
         successes += 1;
      IF_END
      rr -= 1;
   WHILE_END
   RETURN successes;
FUNC_END
#   FFFFFFFFFFunction ----------------------------- benford_pdf #
FUNC DBL benford_pdf(INT max_kk
      , INT kk):
   # PDF Benford distribution aka "First-digit law"
   # Support: 1..MAX_KK-1
   # == LN(1 + 1 / KK) / LN(MAX_KK)
   DBL retvalu;
   IF kk <= 0.0 OR max_kk <= kk:
      retvalu = 0.0;
   ELSE:
      retvalu = LN(1.0 + 1.0 / kk) / LN(max_kk);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------- benford_cdf #
FUNC DBL benford_cdf(INT max_kk
      , INT kk):
   # CDF Benford distribution aka "First-digit law"
   # Support: 1..MAX_KK-1
   # == LN(KK + 1) / LN(MAX_KK)
   DBL retvalu;
   IF kk <= 0.0:
      retvalu = 0.0;
   ELSIF max_kk <= kk:
      retvalu = 1.0;
   ELSE:
      retvalu = LN(kk + 1.0) / LN(max_kk);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- benford_rand #
FUNC INT benford_rand(INT max_kk):
   # Random Benford Variable over[1,MAX_KK)
   # aka "First-digit law"
   INT ii;
   DBL summ;
   DBL target;
   target = randd();
   summ = 0;
   AWAIT target <= summ COUNT ii FROM 1:
      summ += LN(1.0 + 1.0 / ii) / LN(max_kk);
   AWAIT_END
   RETURN ii;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- nbd_pdf #
FUNC DBL nbd_pdf(DBL prob
      , INT rsuccesses
      , INT kfailures):
   # PDF Negative Binomial Distribution with
   #    success probability PROB, RSUCCESSES successes,
   #    and KFAILURES failures.
   # Support: 0..Inf
   # return probability that the RSUCCESESth success
   #    is on the(KFAILURES + RSUCCESSES)th trial
   #    given probability of success == PROB
   RETURN comb(rsuccesses + kfailures - 1, kfailures) * POW(1.0
         - prob, kfailures) * POW(prob, rsuccesses);
FUNC_END
#   FFFFFFFFFFunction --------------------------------- nbd_cdf #
FUNC DBL nbd_cdf(DBL prob
      , INT rsuccesses
      , INT kfailures):
   # CDF Negative Binomial Distribution with
   #    success probability PROB, RSUCCESSES successes,
   #    and KFAILURES failures.
   # Support: 0..Inf
   # return probability that the RSUCCESESth success
   #    occurs before the(KFAILURES + RSUCCESSES + 1)th trial
   #    given probability of success == PROB
   RETURN 1.0 - betainc(kfailures + 1, rsuccesses, 1.0 - prob);
FUNC_END
#   FFFFFFFFFFunction -------------------------------- nbd_rand #
FUNC INT nbd_rand(DBL prob
      , INT rsuccesses):
   # Random Negative Binomial Variable
   # Return number of failures before the RSUCCESSESth
   #     success given probability of success == PROB
   # support is integers in[0,+Inf)
   INT failures;
   INT rr;
   rr = rsuccesses;
   failures = 0;
   WHILE 0 < rr:
      IF randd() <= prob:
         rr -= 1;
         # success
      ELSE:
         failures += 1;
         # failure
      IF_END
   WHILE_END
   RETURN failures;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- polya_pdf #
FUNC DBL polya_pdf(DBL prob
      , DBL rsuccesses
      , DBL kfailures):
   RETURN combx(rsuccesses + kfailures - 1, kfailures)
         * POW(1.0 - prob, kfailures) * POW(prob, rsuccesses);
FUNC_END
#   FFFFFFFFFFunction ------------------------------- polya_cdf #
FUNC DBL polya_cdf(DBL prob
      , DBL rsuccesses
      , DBL kfailures):
   RETURN 1.0 - betainc(kfailures + 1, rsuccesses, 1.0 - prob);
FUNC_END
#   FFFFFFFFFFunction ------------------------------ polya_rand #
FUNC DBL polya_rand(DBL tt
      , DBL prob):
   # Random Polya Variable
   # a real extension of negative binomial distribution
   DBL nn;
   DBL mm;
   DBL rr;
   INT uu;
   DBL qq;
   nn = 0;
   mm = tt - 1;
   qq = EXP(tt * LN(prob));
   rr = qq;
   uu = randd();
   WHILE rr <= uu:
      nn += 1;
      mm += 1;
      qq *= (1.0 - prob) * mm / nn;
      rr += qq;
   WHILE_END
   RETURN nn;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- zeta_pdf #
FUNC DBL zeta_pdf(DBL ss
      , INT xx):
   # PDF zeta distribution w/ parameter SS
   # Support: 0..Inf
   DBL retvalu;
   IF xx <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 / (Kw.zeta(ss) * POW(xx, ss));
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- zeta_cdf #
FUNC DBL zeta_cdf(DBL ss
      , INT xx):
   # CDF zeta distribution w/ parameter SS
   # Support: 1..Inf
   DBL retvalu;
   IF xx <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = Kw.hnm(xx, ss) / Kw.zeta(ss);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- ks_cdf #
FUNC DBL ks_cdf(INT nn
      , DBL xx):
   # CDF Kolmogorov-Smirnov distribution
   # from "The Art of Computer Programming" by D. E. Knuth
   # Volume 2 3ed. Pg 58 and 561
   DBL retvalu;
   DBL two_tt_sqr;
   INT kk;
   DBL sum;
   DBL tt;
   IF nn <= 0 OR xx <= 0.0:
      retvalu = 0.0;
   ELSE:
      IF 30 < nn:
         tt = xx;
         two_tt_sqr = 2.0 * tt * tt;
         retvalu = 1.0 - EXP(-two_tt_sqr) * (1.0 - 2.0 * tt
               / (3.0 * SQRT(nn)) - two_tt_sqr * (two_tt_sqr
               / 9.0 - 1.0 / 3.0) / nn);
      ELSE:
         tt = xx * SQRT(nn);
         sum = 0.0;
         kk = nn;
         WHILE tt < kk:
            sum += Kw.comb(nn, kk) * POW(kk - tt, kk) * POW(tt
                  + nn - kk, nn - kk - 1);
            kk -= 1;
         WHILE_END
         retvalu = 1.0 - sum * tt / POW(nn, nn);
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- ks_a_cdf #
FUNC DBL ks_a_cdf(DBL xx):
   # from https://en.wikipedia.org/wiki/ Kolmogorov-Smirnov_test
   #      Pr(K <= XX) = ks_a_cdf(XX)
   # where K is a Kolmogorov Distribution
   DBL sum;
   DBL sum_prev;
   DBL vv;
   INT kk;
   DBL retvalu;
   IF xx < 0.0001:
      retvalu = 0.0;
   ELSE:
      sum = 0.0;
      vv = -Kw.square(Kw.PI / xx) / 8.0;
      AWAIT Kw.iseq(sum, sum_prev) COUNT kk FROM 1 BY 2:
         sum_prev = sum;
         sum += EXP(vv * kk * kk);
      AWAIT_END
      retvalu = sum * SQRT(Kw.TAU) / xx;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- ks_b_cdf #
FUNC DBL ks_b_cdf(INT nn
      , DBL xx):
   # from https://en.wikipedia.org/wiki/ Kolmogorov-Smirnov_test
   # Thin wrapper around ks_a_cdf where XX is replaced with
   #   XX + 1 / (6 * sqrt(NN)) + (XX - 1) / (4 * NN)
   DBL retvalu;
   DBL nxx;
   IF xx < 0.0001 OR nn <= 0:
      retvalu = 0.0;
   ELSE:
      nxx = xx + (2.0 * SQRT(nn) + 3.0 * xx - 3.0) / (12.0 * nn);
      retvalu = ks_a_cdf(nxx);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------- ks_quantile #
FUNC DBL ks_quantile(DBL nn
      , DBL prbx):
   # Quantile Kolmogorov-Smirnov distribution
   DBL scvx_xp;
   DBL scvx_xx;
   DBL scvx_yp;
   DBL scvx_yy;
   DBL scvx_dx;
   DBL scvx_dy;
   INT scvx_ii;
   IF NOT Kw.isbetween(prbx, 0.0, 1.0):
      scvx_xx = 0.0;
   ELSE:
      # return XX where
      #   prbx - ks_cdf(nn, scvx_xx)XX == 0
      # BEG Secant Calculation
      scvx_dx = 0.5;
      scvx_xx = 0.25;
      scvx_yy = prbx - ks_cdf(nn, scvx_xx);
      FOR scvx_ii FROM 0 TO 20:
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         IF Kw.iseq(scvx_xp, scvx_xx):
            FOR_EXIT;
         IF_END
         scvx_yy = prbx - ks_cdf(nn, scvx_xx);
         scvx_dy = (scvx_yy - scvx_yp);
         IF Kw.iszero(scvx_dy):
            FOR_EXIT;
         IF_END
         scvx_dx *= - scvx_yy / scvx_dy;
      FOR_END
      # END Secant Calculation
   IF_END
   RETURN scvx_xx;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- t_pdf #
FUNC DBL t_pdf(DBL dfn
      , DBL xx):
   # PDF Students T Distribution
   RETURN Kw.tgamma((dfn + 1.0) / 2.0) * POW((1.0
         + Kw.square(xx) / dfn), (-(dfn + 1.0) / 2.0))
         / (SQRT(dfn * Kw.PI) * Kw.tgamma(dfn / 2.0));
FUNC_END
BLOCK:# define t_cdf
   #   FFFFFFFFFFunction -------------------------- lf_subtprob #
   BLOCK_DEF FUNC DBL lf_subtprob(DBL nnx, DBL xx):
      DBL aa;
      DBL bb;
      DBL ww;
      DBL zz;
      DBL yy;
      DBL ii;
      INT nn;
      DBL retvalu;
      nn = FLOORL(ABS(nnx));
      ww = ATAN2(xx, SQRT(nn));
      zz = Kw.square(COS(ww));
      yy = 1.0;
      ii = nn - 2.0;
      WHILE 2.0 <= ii:
         yy = 1.0 + (ii - 1.0) / ii * zz * yy;
         ii -= 2.0;
      WHILE_END
      IF Kw.iseven(nn):
         aa = SIN(ww) / 2.0;
         bb = 0.5;
      ELSE:
         IF nn == 1:
            aa = 0;
         ELSE:
            aa = SIN(ww) * COS(ww) / Kw.PI;
         IF_END
         bb = 0.5 + ww / Kw.PI;
      IF_END
      retvalu = bb + aa * yy;
      IF 1.0 < retvalu:
         retvalu = 1.0;
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction -------------------------------- t_cdf #
   FUNC DBL t_cdf(DBL dfx
         , DBL xx):
      # CDF Students T distribution
      RETURN lf_subtprob(dfx, xx);
   FUNC_END
BLOCK_END# define t_cdf
BLOCK:
      #   FFFFFFFFFFunction ------------------------
   #lf_t_quantile #
   BLOCK_DEF FUNC DBL lf_t_quantile(INT ndfx, DBL prbx):
      # Quantile Students T distribution
      DBL ux;
      DBL uxsq;
      DBL aa_x;
      DBL bb_x;
      DBL cc_x;
      DBL dd_x;
      DBL ee_x;
      DBL retvalu;
      DBL delta;
      DBL pp_a;
      DBL nn_a;
      DBL out_sign;
      IF prbx < 0.5:
         prbx = 1.0 - prbx;
         out_sign = -1;
      ELSE:
         out_sign = 1;
      IF_END
      ux = normal_quantile(prbx);
      # 20121022 kdpw lf_subu(prbx);
      uxsq = Kw.square(ux);
      aa_x = ((1.0) * uxsq + 1.0) / 4.0;
      bb_x = (((5.0) * uxsq + 16.0) * uxsq + 3.0) / 96.0;
      cc_x = ((((3.0) * uxsq + 19.0) * uxsq + 17.0) * uxsq
            - 15.0) / 384.0;
      dd_x = (((((79.0) * uxsq + 776.0) * uxsq + 1482.0) * uxsq
            - 1920.0) * uxsq - 945.0) / 92160.0;
      ee_x = ((((((27.0) * uxsq + 339.0) * uxsq + 930.0) * uxsq
            - 1782.0) * uxsq - 765.0) * uxsq - 17955.0)
            / 368640.0;
      # 20200407 kdw  changed sign
      retvalu = ux * (1.0 + (aa_x + (bb_x + (cc_x + (dd_x
            + ee_x / ndfx) / ndfx) / ndfx) / ndfx) / ndfx);
      IF ndfx <= Kw.square(Kw.log10(prbx)) + 3.0:
         nn_a = ndfx + 1.0;
         AWAIT Kw.iszero(retvalu) OR aa_x < retvalu:
            pp_a = lf_subtprob(ndfx, retvalu);
            ee_x = (nn_a * LN(nn_a / (ndfx
                  + Kw.square(retvalu))) + LN(ndfx / nn_a
                  / Kw.TAU) - 1.0 + (1.0 / nn_a - 1.0 / ndfx)
                  / 6.0) / 2.0;
            IF 100 < ee_x:
               # prevent overflow in exp
               delta = 0;
            ELSE:
               delta = (pp_a - prbx) / EXP(ee_x);
            IF_END
            retvalu -= delta;
            # reuse aa_x
            aa_x = ABS(delta) * 10000.0;
         AWAIT_END
      IF_END
      RETURN out_sign * retvalu;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- t_quantile #
   FUNC DBL t_quantile(DBL dfx
         , DBL prbx):
      # Quantile Students T distribution
      INT ndfx;
      DBL retvalu;
      ndfx = FLOOR(ABS(dfx));
      IF Kw.iszero(prbx - 0.5):
         retvalu = 0.0;
      ELSIF prbx <= 0.0:
         retvalu = -Kw.DBLMAX;
      ELSIF 1.0 <= prbx:
         retvalu = Kw.DBLMAX;
      ELSE:
         retvalu = lf_t_quantile(ndfx, prbx);
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END# define t_quantile()
#   FFFFFFFFFFunction -------------------------------- t_cdf__1 #
FUNC DBL t_cdf__1(DBL dfx
      , DBL xx):
   # CDF Students T distribution
   DBL zz;
   DBL yy;
   yy = SQRT(dfx + xx * xx);
   zz = (xx + yy) / (2.0 * yy);
   RETURN Kw.betainc__1(dfx / 2.0, dfx / 2.0, zz);
FUNC_END
#   FFFFFFFFFFunction --------------------------- t_quantile__1 #
FUNC DBL t_quantile__1(DBL dfx
      , DBL prbx):
   # Quantile Students T distribution
   DBL scvx_xp;
   DBL scvx_xx;
   DBL scvx_yp;
   DBL scvx_yy;
   DBL scvx_dx;
   DBL scvx_dy;
   INT scvx_ii;
   IF NOT Kw.isbetween(prbx, 0.0, 1.0):
      scvx_xx = 0.0;
   ELSE:
      # return XX where
      #   prbx - t_cdf(dfx, scvx_xx)XX == 0
      # BEG Secant Calculation
      scvx_dx = 0.5;
      scvx_xx = 0.25;
      scvx_yy = prbx - t_cdf(dfx, scvx_xx);
      FOR scvx_ii FROM 0 TO 20:
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         IF Kw.iseq(scvx_xp, scvx_xx):
            FOR_EXIT;
         IF_END
         scvx_yy = prbx - t_cdf(dfx, scvx_xx);
         scvx_dy = (scvx_yy - scvx_yp);
         IF Kw.iszero(scvx_dy):
            FOR_EXIT;
         IF_END
         scvx_dx *= - scvx_yy / scvx_dy;
      FOR_END
      # END Secant Calculation
   IF_END
   RETURN scvx_xx;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- f_cdf #
FUNC DBL f_cdf(INT dfn_a
      , INT dfn_b
      , DBL xx):
   # CDF Fisher-Senecords Distribution
   DBL aa;
   DBL bb;
   DBL gg;
   aa = dfn_a / 2.0;
   bb = dfn_b / 2.0;
   gg = aa * xx;
   RETURN beta_cdf(aa, bb, gg / (bb + gg));
FUNC_END
BLOCK:
      #   FFFFFFFFFFunction --------------------------
   #lf_subfprob #
   BLOCK_DEF FUNC DBL lf_subfprob(INT dfn_a, INT dfn_b, DBL xx):
      DBL retvalu;
      DBL zx;
      DBL ax;
      DBL bx;
      DBL yx;
      DBL ix;
      DBL pp_a;
      IF xx <= 0.0:
         retvalu = 1.0;
      ELSIF Kw.iseven(dfn_b):
         zx = dfn_b / (dfn_b + dfn_a * xx);
         ax = 1.0;
         FOR ix FROM dfn_b - 2 TO 2 BY - 2:
            ax = 1.0 + (dfn_a + ix - 2.0) / ix * zx * ax;
         FOR_END
         retvalu = 1.0 - (POW(1.0 - zx, dfn_a / 2.0) * ax);
      ELSIF Kw.iseven(dfn_a):
         zx = dfn_a * xx / (dfn_b + dfn_a * xx);
         ax = 1.0;
         FOR ix FROM dfn_a - 2 TO 2 BY - 2:
            ax = 1.0 + (dfn_b + ix - 2.0) / ix * zx * ax;
         FOR_END
         retvalu = POW(1.0 - zx, dfn_b / 2.0) * ax;
      ELSE:
         yx = ATAN2(SQRT(dfn_a * xx / dfn_b), 1.0);
         zx = Kw.square(SIN(yx));
         IF dfn_a == 1:
            ax = 0.0;
         ELSE:
            ax = 1.0;
         IF_END
         FOR ix FROM dfn_a - 2 TO 3 BY - 2:
            ax = 1.0 + (dfn_b + ix - 2.0) / ix * zx * ax;
         FOR_END
         bx = Kw.PI;
         FOR ix FROM 2 TO dfn_b - 1 BY 2:
            bx *= (ix - 1.0) / ix;
         FOR_END
         pp_a = 2.0 / bx * SIN(yx) * POW(COS(yx), dfn_b) * ax;
         zx = Kw.square(COS(yx));
         IF dfn_b == 1:
            ax = 0.0;
         ELSE:
            ax = 1.0;
         IF_END
         FOR ix FROM dfn_b - 2 TO 3 BY - 2:
            ax = 1.0 + (ix - 1.0) / ix * zx * ax;
         FOR_END
         retvalu = (pp_a + 1.0 - (4.0 / Kw.TAU) * (yx + SIN(yx)
               * COS(yx) * ax));
         IF retvalu < 0.0:
            retvalu = 0.0;
         IF_END
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction -------------------------- lf_subf_two #
   BLOCK_DEF FUNC DBL lf_subf_two(DBL nx, DBL mm, DBL pp):
      DBL uu;
      DBL nx_sub_two;
      DBL xx_prev;
      DBL xx;
      DBL zz;
      uu = chisqr_cdf(nx, pp);
      nx_sub_two = nx - 2.0;
      xx = (uu / nx * (1.0 + ((uu - nx_sub_two) / 2.0 + (((4.0
            * uu - 11.0 * nx_sub_two) * uu + nx_sub_two * (7.0
            * nx - 10.0)) / 24.0 + (((2.0 * uu - 10.0
            * nx_sub_two) * uu + nx_sub_two * (17.0 * nx
            - 26.0)) * uu - nx_sub_two * nx_sub_two * (9.0 * nx
            - 6.0)) / 48.0 / mm) / mm) / mm));
      AWAIT Kw.iswithin(xx, xx_prev, 0.00001):
         IF xx <= 0.0:
            AWAIT_EXIT;
         IF_END
         zz = EXP(((nx + mm) * LN((nx + mm) / (nx * xx + mm))
               + (nx - 2.0) * LN(xx) + LN(nx * mm / (nx + mm))
               - Kw.LNTWO - LN(Kw.TAU) - (1.0 / nx + 1.0 / mm
               - 1.0 / (nx + mm)) / 6.0) / 2.0);
         xx_prev = xx;
         xx += (lf_subfprob(nx, mm, xx) - pp) / zz;
      AWAIT_END
      RETURN xx;
   FUNC_END
   #   FFFFFFFFFFunction ----------------------------- lf_subfx #
   BLOCK_DEF FUNC DBL lf_subfx(INT nx, INT mm, DBL pp):
      DBL retvalu;
      DBL uu;
      DBL aa;
      IF Kw.iseq(pp, 1.0):
         retvalu = 0.0;
      ELSIF mm == 0:
         retvalu = 1.0 / Kw.square(t_quantile(nx, 0.5 - pp
               / 2.0));
      ELSIF nx == 1:
         retvalu = Kw.square(t_quantile(mm, pp / 2.0));
      ELSIF mm == 2:
         uu = chisqr_cdf(mm, 1.0 - pp);
         aa = mm - 2.0;
         retvalu = 1.0 / (uu / mm * (1.0 + ((uu - aa) / 2.0
               + (((4.0 * uu - 11.0 * aa) * uu + aa * (7.0 * mm
               - 10.0)) / 24.0 + (((2.0 * uu - 10.0 * aa) * uu
               + aa * (17.0 * mm - 26.0)) * uu - aa * aa * (9.0
               * mm - 6.0)) / 48.0 / nx) / nx) / nx));
      ELSIF mm < nx:
         retvalu = 1.0 / lf_subf_two(mm, nx, 1.0 - pp);
      ELSE:
         retvalu = lf_subf_two(nx, mm, pp);
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- f_quantile #
   FUNC DBL f_quantile(INT dfn_a
         , INT dfn_b
         , DBL prbx):
      # Quantile Fisher-Senecords Distribution
      RETURN lf_subfx(dfn_a, dfn_b, 1.0 - prbx);
   FUNC_END
BLOCK_END
      #   FFFFFFFFFFunction ---------------------------
   #f_quantile__1 #
FUNC DBL f_quantile__1(INT dfn_a
      , INT dfn_b
      , DBL prbx):
   DBL retvalu;
   DBL scvx_xp;
   DBL scvx_xx;
   DBL scvx_yp;
   DBL scvx_yy;
   DBL scvx_dx;
   DBL scvx_dy;
   INT scvx_ii;
   IF prbx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= prbx:
      retvalu = 1.0;
   ELSE:
      # return XX where
      #   prbx - f_cdf(dfn_a, dfn_b, scvx_xx)XX == 0
      # BEG Secant Calculation
      scvx_dx = 0.50;
      scvx_xx = 0.25;
      scvx_yy = prbx - f_cdf(dfn_a, dfn_b, scvx_xx);
      FOR scvx_ii FROM 0 TO 20:
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         IF Kw.iseq(scvx_xp, scvx_xx):
            FOR_EXIT;
         IF_END
         scvx_yy = prbx - f_cdf(dfn_a, dfn_b, scvx_xx);
         scvx_dy = (scvx_yy - scvx_yp);
         IF Kw.iszero(scvx_dy):
            FOR_EXIT;
         IF_END
         scvx_dx *= - scvx_yy / scvx_dy;
      FOR_END
      # END Secant Calculation
      retvalu = scvx_xx;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- mb_pdf #
FUNC DBL mb_pdf(DBL aa
      , DBL xx):
   # PDF Maxwell-Boltzmann distribution
   # distribution of particle speeds in an idealized gas
   RETURN SQRT(4 / Kw.TAU) * xx * xx * EXP(-xx * xx / (2 * aa
         * aa)) / (aa * aa * aa);
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- mb_cdf #
FUNC DBL mb_cdf(DBL aa
      , DBL xx):
   # CDF Maxwell-Boltzmann distribution
   # MEAN = 2 * aa * SQRT(4 / TAU)
   # MODE = SQRT(2) * aa
   # VARIANCE = aa * aa * (3 - 16 / TAU)
   # Let aa = SQRT(BOLTZMANN * temperature / mass)
   # or     = SQRT(GAS * temperature / molar-mass)
   RETURN Kw.erf(xx / (Kw.SQRTTWO * aa)) - SQRT(4 / Kw.TAU)
         * xx * EXP(-xx * xx / (2 * aa * aa)) / aa;
FUNC_END
#   FFFFFFFFFFunction ------------------- maxwell_boltzmann_pdf #
FUNC DBL maxwell_boltzmann_pdf(DBL temperature
      , DBL molecular_mass
      , DBL velocity):
   # PDF Maxwell-Boltzmann distribution
   # distribution of particle speeds in an idealized gas
   DBL aa;
   aa = SQRT(Kw.BOLTZMANN * temperature / molecular_mass);
   RETURN mb_pdf(aa, velocity);
FUNC_END
#   FFFFFFFFFFunction ------------------- maxwell_boltzmann_cdf #
FUNC DBL maxwell_boltzmann_cdf(DBL temperature
      , DBL molecular_mass
      , DBL velocity):
   # CDF Maxwell-Boltzmann distribution
   # distribution of particle speeds in an idealized gas
   # Lat AA = sqrt(BOLTZMANN * TEMPERATURE / MASS)
   # MEAN     = 4 * AA / SQRT(TAU)
   # MODE     = AA * SQRT(2)
   # VARIANCE = AA**2 * (3 - 16 / TAU)
   DBL aa;
   aa = SQRT(Kw.BOLTZMANN * temperature / molecular_mass);
   RETURN mb_cdf(aa, velocity);
FUNC_END
#   FFFFFFFFFFunction --------------------- maxwell_juttner_pdf #
FUNC DBL maxwell_juttner_pdf(DBL temperature
      , DBL molecular_mass
      , DBL velocity):
   # PDF Maxwell-Juttner distribution
   # distribution of speeds of particles in a hypothetical
   #    gas of relativistic particles.
   DBL gmm;
   DBL bt;
   DBL rtht;
   DBL dn;
   DBL retvalu;
   IF temperature <= 0.0 OR velocity <= 0.0
         OR Kw.LIGHT <= velocity OR molecular_mass <= 0.0:
      retvalu = 0.0;
   ELSE:
      rtht = (molecular_mass * Kw.LIGHT * Kw.LIGHT)
            / (Kw.BOLTZMANN * temperature);
      bt = velocity / Kw.LIGHT;
      gmm = 1.0 / Kw.topyh1(bt);
      dn = Kw.bessKn(2, rtht);
      IF Kw.iszero(dn):
         retvalu = 0.0;
      ELSE:
         retvalu = gmm * gmm * bt * rtht * EXP(-gmm * rtht) / dn;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- bb_pdf #
FUNC DBL bb_pdf(DBL wavelen):
   # PDF black-body distribution over[0,Inf)
   # output is spectral radiance which has units of
   #    Power / Area / length
   # MODE   1 / (wp(-5 * exp(-5)) + 5) == 0.201405235272642
   DBL retvalu;
   IF wavelen <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 / (POW(wavelen, 5.0) * (EXP(1.0 / wavelen)
            - 1.0));
   IF_END
   RETURN retvalu * 15.0 / POW(Kw.PI, 4.0);
FUNC_END
#   FFFFFFFFFFunction --------------------------- blackbody_pdf #
FUNC DBL blackbody_pdf(DBL wavelen):
   # PDF black-body distribution over[0,Inf)
   # output is spectral radiance which has units of
   #    Power / Area / length
   RETURN bb_pdf(wavelen);
FUNC_END
#   FFFFFFFFFFunction ------------------------------- ints_rand #
FUNC INT ints_rand(INT nn
      , READONLY DBL prob_arr_pc[]):
   # random number in[0,NN) with
   #   p(MM) = PROB_ARR_PC[MM] / SUM(PROB_ARR_PC[])
   DBL sum;
   INT p_ind;
   DBL rndm;
   DBL hh;
   sum = 0;
   FOR p_ind FROM 0 TO nn - 1:
      sum += prob_arr_pc[p_ind];
   FOR_END
   rndm = randd();
   hh = 0;
   FOR p_ind FROM 0 TO nn - 1:
      hh += prob_arr_pc[p_ind] / sum;
      IF rndm < hh:
         FOR_EXIT;
      IF_END
   FOR_END
   RETURN p_ind;
FUNC_END
#TEST:normal_pdf(1)==0.2419707245191433497978;
#TEST:normal_cdf(0)==0.5;
#TEST:normal_cdf(1)==0.841344746068542948585232545632037922478;
#TEST:normal_cdf(2)==0.9772498680518207927997;
#TEST:normal_quantile(normal_cdf(1.34))==1.34;
#TEST:normal_quantile(0.5)-0.0;
#TEST:normal_quantile(0.8413447460685429485852)==1.0;
#TEST:normal_quantile(0.9772498680518207927997)==2.0;
#TEST:t_cdf(3,1)==0.8044988905221146790445;
#TEST:t_quantile(3,0.8044988905221146790445)==1;
#TEST:t_quantile__1(3,0.8044988905221146790445)==1;
#TEST:f_cdf(2,3,1.4)==0.6280026109165123031128;
#TEST:f_quantile(2,3,0.6280026109165123031128)==1.4;
#TEST:pareto_quantile(1.3,2.4,pareto_cdf(1.3,2.4,3.5))==3.5;
#TEST:geo_pdf(0.2,3)==0.1024;
#TEST:geo_cdf(0.2,7)==0.83222784;
#TEST:nbd_pdf(0.6,5,5)==0.1003290624;
#TEST:nbd_cdf(0.6,5,3)==0.5940864;
#   IIIIIIIIIInsert-End ------------------------- randdist.fwip #
#   IIIIIIIIIInsert-Begin --------------------------- stat.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-17 kdw  stat:comment change
# 2020-07-27 kdw  stat:block syntax
# 2020-07-24 kdw  stat:comment cleanup
# 2020-06-03 kdw  stat:writeonly keyword
# 2020-05-11 kdw  stat:local-func syntax changed
# 2020-04-26 kdw  stat:BL[O]CK indentation work
# 2020-04-12 kdw  stat:comment change
# 2020-03-09 kdw  stat:LO[C]AL_.* keywords
# 2020-03-03 kdw  stat:comment change
# 2020-03-02 kdw  stat:s/_N[E]XT/_E[N]D/
# 2020-01-28 kdw  stat:maxmin func rework
# 2019-12-26 kdw  stat:module name addded to funcs
# 2019-10-04 kdw  stat:comment change
# 2019-08-24 kdw  stat:for and count loops have from clause
# 2019-08-18 kdw  stat:L[O]G to L[N]
# 2019-08-11 kdw  stat:comment cleanup
# 2019-08-06 kdw  stat:rmed backshlashes, macro arg renam
# 2019-07-22 kdw  stat:minor cosmetic tweak
# 2019-05-24 kdw  stat:local replaced private
# 2019-05-22 kdw  stat:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-03-19 kdw  stat:re[t]_val to re[t]valu
# 2018-07-17 kdw  stat:private lf_.* funcs
# 2018-04-19 kdw  stat:consts rework
# 2018-04-03 kdw  stat:rm() from return
# 2018-01-13 kdw  stat:maxabs2, minabs2 funcs
# 2017-11-26 kdw  stat:FR[O]M and B[Y] keywords
# 2017-11-22 kdw  stat:var renam
# 2017-06-13 kdw  stat:C now handle return arrays
# 2017-04-30 kdw  stat:func to function
# 2017-03-10 kdw  stat:get Fw[i]p_Pa[r]se to work
# 2017-03-06 kdw  stat:sigils rmed
# 2017-03-01 kdw  stat:var[y]log-a[d]d space messup
# 2017-02-24 kdw  stat:LAN[G]UAGE change
# 2017-02-20 kdw  stat:array var names
# 2017-02-14 kdw  stat:FWIP Loop syntax changed
# 2017-02-12 kdw  stat:FWIP language change
# 2017-02-08 kdw  stat:min(abs(offset)?)?
# 2017-01-06 kdw  stat:LAN[G]UAGE_[I]F deprecated
# 2016-11-24 kdw  stat:LAN[G]UAGE_N[O]T to LAN[G]UAGE_IFN[O]T
# 2016-11-23 kdw  stat:CN?ST to RE?ADO?NLY
# 2016-11-21 kdw  stat:DE?F to FU?NC
# 2016-11-20 kdw  stat:language change
# 2016-11-11 kdw  stat:var name change
# 2016-10-14 kdw  stat:_p added to several vars
# 2016-09-15 kdw  stat:comment change
# 2016-09-14 kdw  stat:comment change
# 2016-09-13 kdw  stat:lang change
# 2016-04-27 kdw  stat:forced double division in places
# 2016-01-21 kdw  stat:lf_num2norm
# 2015-12-14 kdw  stat:array sigils; long comments
# 2015-12-11 kdw  stat:_[_]EN[D]IF_[_] obsoleted
# 2015-12-02 kdw  stat:ave[r]age to m[e]an; variable rename
# 2015-11-26 kdw  stat:long lines
# 2015-11-24 kdw  stat:variable rename
# 2015-11-17 kdw  stat:F[O]R format changed
# 2015-10-09 kdw  stat:added comment to st[d]ev2s[p]read
# 2015-10-01 kdw  stat:float equality checks to is.*
# 2015-09-30 kdw  stat:_[_]I[F]_N[O]T_.*(
# 2015-09-29 kdw  stat:C cant return an array
# 2015-09-24 kdw  stat:cosmetic change
# 2015-09-20 kdw  stat:created
BLOCK:# num to norm
   #   FFFFFFFFFFunction -------------------------- lf_num2norm #
   BLOCK_DEF FUNC DBL lf_num2norm(DBL numm):
      DBL retvalu;
      IF numm <= 1:
         retvalu = 0.0;
      ELSE:
         retvalu = (3.0 * SQRT(LN(numm)) - 1.4 - (0.5
               * LN(numm) - 0.39) / numm);
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------- stdev2spread #
   FUNC DBL stdev2spread(DBL numm
         , DBL stdevx):
      # return the expected spread given NUMM data
      # points with standard deviation STDEVX,
      # assuming an underlying normal distribution
      DBL retvalu;
      IF numm <= 1 OR Kw.iszero(stdevx):
         retvalu = 0.0;
      ELSE:
         retvalu = (stdevx * lf_num2norm(numm));
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------- spread2stdev #
   FUNC DBL spread2stdev(DBL numm
         , DBL spread):
      # return the expected standard deviation given
      # NUMM data points with SPREAD,
      # assuming an underlying normal distribution
      DBL retvalu;
      IF numm <= 1 OR Kw.iszero(spread):
         retvalu = 0.0;
      ELSE:
         retvalu = (spread / lf_num2norm(numm));
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END# num to norm
#   FFFFFFFFFFunction ---------------------------------- maxabs #
FUNC DBL maxabs(INT nn
      , READONLY DBL data_arr_pc[]):
   # return value in an array the farthest from 0
   INT ii;
   DBL maxaby;
   DBL amaxaby;
   DBL atemp;
   maxaby = data_arr_pc[0];
   amaxaby = ABS(maxaby);
   FOR ii FROM 1 TO nn - 1:
      atemp = ABS(data_arr_pc[ii]);
      IF amaxaby < atemp:
         maxaby = data_arr_pc[ii];
         amaxaby = atemp;
      IF_END
   FOR_END
   RETURN maxaby;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- minabs #
FUNC DBL minabs(INT nn
      , READONLY DBL data_arr_pc[]):
   # return value in an array the closest to 0
   INT ii;
   DBL minaby;
   DBL aminaby;
   DBL atemp;
   minaby = data_arr_pc[0];
   aminaby = ABS(minaby);
   FOR ii FROM 1 TO nn - 1:
      atemp = ABS(data_arr_pc[ii]);
      IF atemp < aminaby:
         minaby = data_arr_pc[ii];
         aminaby = atemp;
      IF_END
   FOR_END
   RETURN minaby;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- maxabsoffset #
FUNC DBL maxabsoffset(DBL offset
      , INT nn
      , READONLY DBL data_arr_pc[]):
   # return value in an array the farthest from OFFSET
   INT ii;
   DBL maxaby;
   DBL delta;
   maxaby = data_arr_pc[0] - offset;
   FOR ii FROM 1 TO nn - 1:
      delta = data_arr_pc[ii] - offset;
      IF ABS(maxaby) < ABS(delta):
         maxaby = delta;
      IF_END
   FOR_END
   RETURN maxaby + offset;
FUNC_END
#   FFFFFFFFFFunction ---------------------------- minabsoffset #
FUNC DBL minabsoffset(DBL offset
      , INT nn
      , READONLY DBL data_arr_pc[]):
   # return value in an array the closest to OFFSET
   INT ii;
   DBL minaby;
   DBL delta;
   minaby = data_arr_pc[0] - offset;
   FOR ii FROM 1 TO nn - 1:
      delta = data_arr_pc[ii] - offset;
      IF ABS(delta) < ABS(minaby):
         minaby = delta;
      IF_END
   FOR_END
   RETURN minaby + offset;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ mini #
FUNC DBL mini(INT num
      , READONLY DBL data_arr_pc[]):
   # return the minimum value in an array
   DBL curr;
   DBL tmp;
   INT ii;
   curr = data_arr_pc[0];
   FOR ii FROM 1 TO num - 1:
      tmp = data_arr_pc[ii];
      IF tmp < curr:
         curr = tmp;
      IF_END
   FOR_END
   RETURN curr;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ maxi #
FUNC DBL maxi(INT num
      , READONLY DBL data_arr_pc[]):
   # return the maximum value in an array
   DBL curr;
   DBL tmp;
   INT ii;
   curr = data_arr_pc[0];
   FOR ii FROM 1 TO num - 1:
      tmp = data_arr_pc[ii];
      IF curr < tmp:
         curr = tmp;
      IF_END
   FOR_END
   RETURN curr;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- maxmin #
FUNC DBL maxmin(INT num
      , READONLY DBL data_arr_pc[]
      , WRITEONLY DBL ret_maxmin_arr_p[]):
   # return the spread of the data
   #   RET_MAXMIN_ARR_p[0] = maximum
   #   RET_MAXMIN_ARR_p[1] = minimum
   DBL tmp;
   INT ii;
   DBL maxx;
   DBL minn;
   minn = data_arr_pc[0];
   maxx = data_arr_pc[0];
   FOR ii FROM 1 TO num - 1:
      tmp = data_arr_pc[ii];
      IF minn < tmp:
         minn = tmp;
      IF_END
      IF tmp < maxx:
         maxx = tmp;
      IF_END
   FOR_END
   ret_maxmin_arr_p[0] = maxx;
   ret_maxmin_arr_p[1] = minn;
   RETURN maxx - minn;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ min2 #
FUNC DBL min2(DBL value_a
      , DBL value_b):
   # return the minimum of VALUE_A and VALUE_B
   DBL retvalu;
   IF value_a < value_b:
      retvalu = value_a;
   ELSE:
      retvalu = value_b;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ max2 #
FUNC DBL max2(DBL value_a
      , DBL value_b):
   # return the maximum of VALUE_A and VALUE_B
   DBL retvalu;
   IF value_b < value_a:
      retvalu = value_a;
   ELSE:
      retvalu = value_b;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- minabs2 #
FUNC DBL minabs2(DBL value_a
      , DBL value_b):
   # return VALUE_A or VALUE_B closest to 0
   DBL retvalu;
   IF ABS(value_a) < ABS(value_b):
      retvalu = value_a;
   ELSE:
      retvalu = value_b;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- maxabs2 #
FUNC DBL maxabs2(DBL value_a
      , DBL value_b):
   # return VALUE_A or VALUE_B farthest from 0
   DBL retvalu;
   IF ABS(value_b) < ABS(value_a):
      retvalu = value_a;
   ELSE:
      retvalu = value_b;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- variance #
FUNC DBL variance(INT nn
      , READONLY DBL xx_arr_pc[]):
   # the variance of the data in an array
   INT ii;
   DBL delta;
   DBL meanx;
   DBL variancex;
   meanx = 0.0;
   variancex = 0.0;
   FOR ii FROM 0 TO nn - 1:
      delta = xx_arr_pc[ii] - meanx;
      meanx += delta / (ii + 1.0);
      variancex += delta * (xx_arr_pc[ii] - meanx);
   FOR_END
   IF 2 <= nn:
      variancex /= (nn - 1.0);
   ELSE:
      variancex = 0;
   IF_END
   RETURN variancex;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ mean #
FUNC DBL mean(INT nn
      , READONLY DBL xx_arr_pc[]):
   # the mean of the values in an array
   INT ii;
   DBL delta;
   DBL meanx;
   meanx = 0.0;
   FOR ii FROM 0 TO nn - 1:
      delta = xx_arr_pc[ii] - meanx;
      meanx += delta / (ii + 1.0);
   FOR_END
   RETURN meanx;
FUNC_END
#   IIIIIIIIIInsert-End ----------------------------- stat.fwip #
#   IIIIIIIIIInsert-Begin --------------------------- stts.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-29 kdw  stts:_a[r]r changed to _mt[r]x
# 2020-08-17 kdw  stts:macro syntax changed
# 2020-07-27 kdw  stts:block syntax
# 2020-07-24 kdw  stts:comment cleanup
# 2020-06-25 kdw  stts:var renam
# 2020-06-22 kdw  stts:local-use mved before var decls
# 2020-05-30 kdw  stts:CONST syntax change
# 2020-05-18 kdw  stts:boolean funcs have "is" in their name
# 2020-05-13 kdw  stts:.*_LA[S]T changed to .*_COU[N]T
# 2020-05-12 kdw  stts:nul rets changed
# 2020-05-11 kdw  stts:REPL[A]CE replaced with LO[C]AL_CO[N]ST
# 2020-05-08 kdw  stts:lf[_]stt[s]_init func
# 2020-05-06 kdw  stts:rmed boolean vars
# 2020-05-05 kdw  stts:magic check func changed
# 2020-04-26 kdw  stts:BL[O]CK indentation work
# 2020-04-23 kdw  stts:const format change
# 2020-04-12 kdw  stts:comment change
# 2020-04-11 kdw  stts:macro arg format
# 2020-04-08 kdw  stts:preprocess sigil change
# 2020-03-23 kdw  stts:all array var names m/_a[r]r/
# 2020-03-09 kdw  stts:LO[C]AL_.* keywords
# 2020-03-06 kdw  stts:RE[P]LACE / IN[D]EX changes
# 2020-03-05 kdw  stts:s/TRU[E]VAL/TR[U]E/;s/FALS[E]VAL/FA[L]SE/
# 2020-03-03 kdw  stts:comment changed:odd chars
# 2020-03-01 kdw  stts:die output changed
# 2019-12-27 kdw  stts:eplicit K[w] module
# 2019-12-26 kdw  stts:module name addded to funcs
# 2019-11-27 kdw  stts:rework
# 2019-11-23 kdw  stts:tracking down warning of undef vals
# 2019-11-08 kdw  stts:st[t]s_upda[t]ex
# 2019-10-04 kdw  stts:comment change
# 2019-10-02 kdw  stts:macro arg format change
# 2019-09-11 kdw  stts:macro arg name change
# 2019-08-24 kdw  stts:for and count loops have from clause
# 2019-08-18 kdw  stts:B[O]OL to B[O]L
# 2019-08-11 kdw  stts:comment cleanup
# 2019-08-07 kdw  stts:die message chaned
# 2019-08-06 kdw  stts:rmed backslashes, macro arg renam
# 2019-06-07 kdw  stts:die string typo
# 2019-06-04 kdw  stts:func comments
# 2019-05-29 kdw  stts:comment changed
# 2019-05-24 kdw  stts:local replaced private
# 2019-05-22 kdw  stts:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-03-19 kdw  stts:re[t]_val to re[t]valu
# 2019-03-18 kdw  stts:macro syntax changed
# 2019-03-08 kdw  stts:is[e]qual to is[e]q, et al.
# 2019-03-05 kdw  stts:comment on st[d]ev
# 2019-02-28 kdw  stts:REP[L]ACE/DE[F]INE work
# 2019-02-19 kdw  stts:macro syntax
# 2018-07-17 kdw  stts:private lf_.* funcs
# 2018-07-14 kdw  stts:float num format
# 2018-06-19 kdw  stts:die keyword
# 2018-05-15 kdw  stts:DIE.* change
# 2018-05-14 kdw  stts:BLO?CK syntax change
# 2018-04-03 kdw  stts:rmed "pass"
# 2018-04-02 kdw  stts:mai[g]icnot, ma[g]icset
# 2018-03-26 kdw  stts:macro redef
# 2018-03-20 kdw  stts:replaced index w/ "at"replace
# 2018-03-16 kdw  stts:format of constant and index change
# 2018-02-19 kdw  stts:secant and macro refactor
# 2018-02-17 kdw  stts:expandnow changed
# 2018-02-16 kdw  stts:lv_.* to lf_.* in function name
# 2018-02-14 kdw  stts:expand preprocess directive
# 2017-11-26 kdw  stts:FR[O]M and B[Y] keywords
# 2017-11-22 kdw  stts:var renam
# 2017-10-21 kdw  stts:macros start with "at"
# 2017-10-20 kdw  stts:REP[L]ACE syntax changed
# 2017-09-17 kdw  stts:function had name of /lv_.*/
# 2017-08-31 kdw  stts:REQ[U]IRES rmed
# 2017-07-23 kdw  stts:rmed unneeded parens#
# 2017-06-23 kdw  stts:REPL?ACE redo
# 2017-06-12 kdw  stts:rmd some explicit refers to LC_STTS_*
# 2017-06-08 kdw  stts:sttsm2, stts_reset, corrstderr
# 2017-06-01 kdw  stts:func to function
# 2017-04-20 kdw  stts:func to function
# 2017-03-27 kdw  stts:rm useless ";"
# 2017-03-12 kdw  stts:shorten long comments
# 2017-03-10 kdw  stts:get Fw[i]p_Pa[r]se to work
# 2017-03-06 kdw  stts:sigils rmed
# 2017-03-01 kdw  stts:var[y]log-a[d]d space messup
# 2017-02-28 kdw  stts:REQ[U]IRE function()
# 2017-02-24 kdw  stts:REP[L]ACE rework, et al
# 2017-02-20 kdw  stts:var renam
# 2017-02-14 kdw  stts:FWIP Loop syntax changed
# 2017-02-13 kdw  stts:FWIP language change
# 2017-02-12 kdw  stts:FWIP language change
# 2017-01-03 kdw  stts:bool const renam
# 2016-12-23 kdw  stts:die format change
# 2016-11-23 kdw  stts:comment cleanup
# 2016-11-21 kdw  stts:DE?F to FU?NC
# 2016-11-20 kdw  stts:language change
# 2016-11-19 kdw  stts:minor tweak
# 2016-11-16 kdw  stts:ma?gic stuff
# 2016-11-09 kdw  stts:string cleanup
# 2016-09-14 kdw  stts:added() to return statements
# 2016-09-13 kdw  stts:lang change
# 2016-05-26 kdw  stts:long lines
# 2016-05-24 kdw  stts:long lines
# 2016-05-18 kdw  stts:comment change
# 2016-04-27 kdw  stts:forced double division in places
# 2016-03-10 kdw  stts:comment tweak
# 2016-02-29 kdw  stts:comment tweak
# 2016-01-22 kdw  stts:tweak
# 2015-12-30 kdw  stts:co?rr_get_.* to co?rr_.*
# 2015-12-28 kdw  stts:st[t]s_get_.* to st[t]s_.*
# 2015-12-26 kdw  stts:requires stuff
# 2015-12-14 kdw  stts:minor refactor
# 2015-12-02 kdw  stts:*_ave[r]age deleted(use *_me[a]n)
# 2015-11-26 kdw  stts:long lines
# 2015-11-23 kdw  stts:st[t]s_c[o]rr_* to co[r]r_* renamed
# 2015-11-18 kdw  stts:st[t]s_corr_g[e]t_ha[n]dle
# 2015-11-17 kdw  stts:block comments
# 2015-11-15 kdw  stts:ma[g]ic stuff
# 2015-11-13 kdw  stts:function name shortened
# 2015-11-12 kdw  stts:comment shortened
# 2015-10-13 kdw  stts:_[_]DEFI[N]E_[_]
# 2015-10-05 kdw  stts:magic stuff
# 2015-10-01 kdw  stts:float equality checks to is.*;magic
# 2015-09-30 kdw  stts:rmed unused variables
# 2015-09-29 kdw  stts:layout tweak
# 2015-09-25 kdw  stts:B[I]T*, M[O]D format change
# 2015-09-22 kdw  stts:_[_]* format changed
# 2015-09-20 kdw  stts:created
BLOCK:# Statistics block
   BLOCK_DEF CONST LC_STTS_NUM 0;
   BLOCK_DEF CONST LC_STTS_MEAN 1;
   BLOCK_DEF CONST LC_STTS_MSQ 2;
   BLOCK_DEF CONST LC_STTS_MAX 3;
   BLOCK_DEF CONST LC_STTS_MIN 4;
   BLOCK_DEF CONST LC_STTS_MAGIC 5;
   BLOCK_DEF CONST LC_STTS_COUNT 6;
   BLOCK_DEF CONST LC_STTS_MAX_KEY 100;
   BLOCK_DEF DBL lv_sttx_mtrx[LC_STTS_MAX_KEY][LC_STTS_COUNT];
   #   FFFFFFFFFFunction -------------------- lf_stts_is_inited #
   BLOCK_DEF FUNC BOL lf_stts_is_inited(INT ix_hndl):
      BLOCK_USE lv_sttx_mtrx[];
      INT vll;
      INT ii;
      INT jj;
      BOL retvalu_bol;
      vll = lv_sttx_mtrx[0][LC_STTS_MAGIC];
      IF vll <> Kw.magicset() AND vll <> Kw.magicnot():
         FOR ii FROM 0 TO LC_STTS_MAX_KEY - 1:
            FOR jj FROM 0 TO LC_STTS_MAGIC - 1:
               lv_sttx_mtrx[ii][jj] = 0;
            FOR_END
            lv_sttx_mtrx[0][LC_STTS_MAGIC] = Kw.magicnot();
         FOR_END
      IF_END
      IF LC_STTS_MAX_KEY <= ix_hndl:
         retvalu_bol = FALSE;
      ELSE:
         vll = lv_sttx_mtrx[ix_hndl][LC_STTS_MAGIC];
         retvalu_bol = Kw.ismagic(vll);
      IF_END
      RETURN retvalu_bol;
   FUNC_END
   #   FFFFFFFFFFunction ------------------- lf_stts_find_empty #
   BLOCK_DEF FUNC INT lf_stts_find_empty(NUL):
      INT ix_hndl;
      ix_hndl = 0;
      WHILE lf_stts_is_inited(ix_hndl):
         ix_hndl += 1;
      WHILE_END
      IF LC_STTS_MAX_KEY <= ix_hndl:
         DIE "STTS-Bad-handle";
      IF_END
      RETURN ix_hndl;
   FUNC_END
   #   FFFFFFFFFFunction ---------------------------- stts_init #
   FUNC INT stts_init(INT ix_hndl
         , DBL n_count
         , DBL meanx
         , DBL var
         , DBL minim
         , DBL maxim):
      # init STTS LC_HNDL w/ given parameters; return handle
      BLOCK_USE lv_sttx_mtrx[];
      lv_sttx_mtrx[ix_hndl][LC_STTS_NUM] = n_count;
      lv_sttx_mtrx[ix_hndl][LC_STTS_MEAN] = meanx;
      lv_sttx_mtrx[ix_hndl][LC_STTS_MSQ] = var * (n_count - 1.0);
      lv_sttx_mtrx[ix_hndl][LC_STTS_MIN] = minim;
      lv_sttx_mtrx[ix_hndl][LC_STTS_MAX] = maxim;
      lv_sttx_mtrx[ix_hndl][LC_STTS_MAGIC] = Kw.magicset();
      RETURN ix_hndl;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- stts_initx #
   FUNC INT stts_initx(INT ix_hndl
         , DBL num_count
         , DBL meanx
         , DBL msq
         , DBL minim
         , DBL maxim):
      # init STTS LC_HNDL w/ given parameters; return handle
      BLOCK_USE lv_sttx_mtrx[];
      lv_sttx_mtrx[ix_hndl][LC_STTS_NUM] = num_count;
      lv_sttx_mtrx[ix_hndl][LC_STTS_MEAN] = meanx;
      lv_sttx_mtrx[ix_hndl][LC_STTS_MSQ] = msq;
      lv_sttx_mtrx[ix_hndl][LC_STTS_MIN] = minim;
      lv_sttx_mtrx[ix_hndl][LC_STTS_MAX] = maxim;
      lv_sttx_mtrx[ix_hndl][LC_STTS_MAGIC] = Kw.magicset();
      RETURN ix_hndl;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- stts_reset #
   FUNC INT stts_reset(INT ix_hndl):
      RETURN stts_init(ix_hndl, 0.0, 0.0, 0.0, 1.0, 0.0);
   FUNC_END
   #   FFFFFFFFFFunction ----------------------------- stts_new #
   FUNC INT stts_new(NUL):
      # init new STTS w/ default parameters; return handle
      INT ix_hndl;
      ix_hndl = lf_stts_find_empty();
      RETURN stts_reset(ix_hndl);
   FUNC_END
   #   FFFFFFFFFFunction -------------------------- stts_delete #
   FUNC INT stts_delete(INT ix_hndl):
      # delete STTS w/ given handle
      BLOCK_USE lv_sttx_mtrx[];
      lv_sttx_mtrx[ix_hndl][LC_STTS_MAGIC] = Kw.magicnot();
      RETURN ix_hndl;
   FUNC_END
   #   FFFFFFFFFFunction ---------------------------- sttscount #
   FUNC DBL sttscount(INT ix_hndl):
      # count of LC_HNDLth stts calc
      BLOCK_USE lv_sttx_mtrx[];
      RETURN lv_sttx_mtrx[ix_hndl][LC_STTS_NUM];
   FUNC_END
   #   FFFFFFFFFFunction ----------------------------- sttsmean #
   FUNC DBL sttsmean(INT ix_hndl):
      # mean of LC_HNDLth stts calc
      BLOCK_USE lv_sttx_mtrx[];
      RETURN lv_sttx_mtrx[ix_hndl][LC_STTS_MEAN];
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------ sttsmsq #
   FUNC DBL sttsmsq(INT ix_hndl):
      # msq of LC_HNDLth stts calc
      BLOCK_USE lv_sttx_mtrx[];
      RETURN lv_sttx_mtrx[ix_hndl][LC_STTS_MSQ];
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------ sttsmax #
   FUNC DBL sttsmax(INT ix_hndl):
      # max of LC_HNDLth stts calc
      BLOCK_USE lv_sttx_mtrx[];
      RETURN lv_sttx_mtrx[ix_hndl][LC_STTS_MAX];
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------ sttsmin #
   FUNC DBL sttsmin(INT ix_hndl):
      # min of LC_HNDLth stts calc
      BLOCK_USE lv_sttx_mtrx[];
      RETURN lv_sttx_mtrx[ix_hndl][LC_STTS_MIN];
   FUNC_END
   #   FFFFFFFFFFunction ---------------------------- sttsmagic #
   FUNC DBL sttsmagic(INT ix_hndl):
      # magic of LC_HNDLth stts calc
      BLOCK_USE lv_sttx_mtrx[];
      RETURN lv_sttx_mtrx[ix_hndl][LC_STTS_MAGIC];
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------ sttssum #
   FUNC DBL sttssum(INT ix_hndl):
      # sum of data points in STTS w/ given handle
      RETURN sttsmean(ix_hndl) * sttscount(ix_hndl);
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------ sttsvar #
   FUNC DBL sttsvar(INT ix_hndl):
      # variance of data points in STTS w/ given handle
      DBL retvalu;
      IF ABS(sttscount(ix_hndl)) <= 1.0:
         retvalu = 0.0;
      ELSE:
         retvalu = (sttsmsq(ix_hndl) / (ABS(sttscount(ix_hndl)
               - 1.0)));
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ---------------------------- sttsstdev #
   FUNC DBL sttsstdev(INT ix_hndl):
      # Unbiased Standard deviation w/ given handle
      DBL retvalu;
      IF sttscount(ix_hndl) <= 1.0:
         retvalu = 0.0;
      ELSE:
         retvalu = (SQRT(sttsmsq(ix_hndl) / (sttscount(ix_hndl)
               - 1.0)));
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------ sttsstdevmean #
   FUNC DBL sttsstdevmean(INT ix_hndl):
      # Unbiased Standard deviation of the mean w/ given handle
      DBL retvalu;
      IF sttscount(ix_hndl) <= 1.0 OR sttsmsq(ix_hndl) <= 0.0:
         retvalu = 0.0;
      ELSE:
         retvalu = (SQRT(sttsmsq(ix_hndl))
               / (sttscount(ix_hndl) - 1.0));
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- sttsspread #
   FUNC DBL sttsspread(INT ix_hndl):
      # spread of data points in STTS w/ given handle
      RETURN sttsmax(ix_hndl) - sttsmin(ix_hndl);
   FUNC_END
   #   FFFFFFFFFFunction -------------------------- stts_update #
   FUNC DBL stts_update(INT ix_hndl
         , DBL new_data):
      # add NEW_DATA to STTS w/ handle LC_HNDL
      # return difference between NEW_DATA and OLD mean
      BLOCK_USE lv_sttx_mtrx[];
      DBL delta;
      DBL numy;
      IF NOT lf_stts_is_inited(ix_hndl):
         DIE "STTS-Bad-handle";
      IF_END
      delta = new_data - lv_sttx_mtrx[ix_hndl][LC_STTS_MEAN];
      # update these AFTER doing the previous calculation
      lv_sttx_mtrx[ix_hndl][LC_STTS_NUM] += 1.0;
      numy = lv_sttx_mtrx[ix_hndl][LC_STTS_NUM];
      lv_sttx_mtrx[ix_hndl][LC_STTS_MEAN] += (delta / numy);
      lv_sttx_mtrx[ix_hndl][LC_STTS_MSQ] += (delta * (new_data
            - lv_sttx_mtrx[ix_hndl][LC_STTS_MEAN]));
      # update max / mins
      IF (numy < 2.0 OR sttsspread(ix_hndl) < 0.0):
         lv_sttx_mtrx[ix_hndl][LC_STTS_MIN] = new_data;
         lv_sttx_mtrx[ix_hndl][LC_STTS_MAX] = new_data;
      ELSE:
         IF new_data < lv_sttx_mtrx[ix_hndl][LC_STTS_MIN]:
            lv_sttx_mtrx[ix_hndl][LC_STTS_MIN] = new_data;
         IF_END
         IF lv_sttx_mtrx[ix_hndl][LC_STTS_MAX] < new_data:
            lv_sttx_mtrx[ix_hndl][LC_STTS_MAX] = new_data;
         IF_END
      IF_END
      RETURN delta;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------ stts_downdate #
   FUNC DBL stts_downdate(INT ix_hndl
         , DBL old_data):
      DBL delt;
      DBL men;
      IF NOT lf_stts_is_inited(ix_hndl):
         DIE "STTS-Bad-handle";
      IF_END
      men = lv_sttx_mtrx[ix_hndl][LC_STTS_MEAN];
      delt = old_data - men;
      IF 0 < lv_sttx_mtrx[ix_hndl][LC_STTS_NUM]:
         lv_sttx_mtrx[ix_hndl][LC_STTS_NUM] -= 1;
         IF 0 < lv_sttx_mtrx[ix_hndl][LC_STTS_NUM]:
            men -= delt / lv_sttx_mtrx[ix_hndl][LC_STTS_NUM];
            lv_sttx_mtrx[ix_hndl][LC_STTS_MEAN] = men;
            lv_sttx_mtrx[ix_hndl][LC_STTS_MSQ] -= delt
                  * (old_data - men);
            IF lv_sttx_mtrx[ix_hndl][LC_STTS_MSQ] < 0.0:
               lv_sttx_mtrx[ix_hndl][LC_STTS_MSQ] = 0.0;
            IF_END
         ELSE:
            lv_sttx_mtrx[ix_hndl][LC_STTS_MSQ] = 0.0;
            lv_sttx_mtrx[ix_hndl][LC_STTS_MEAN] = 0.0;
         IF_END
      IF_END
      RETURN delt;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------- stts_updatex #
   FUNC DBL stts_updatex(INT ix_hndl
         , INT nn
         , READONLY DBL data_arr_pc[]):
      # update STTS w/ handle LC_HNDL w/ data DATA_ARR_PC[]
      INT ii;
      DBL retvalu;
      retvalu = 0.0;
      FOR ii FROM 0 TO nn - 1:
         retvalu += stts_update(ix_hndl, data_arr_pc[ii]);
      FOR_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ---------------------------- stts_newx #
   FUNC INT stts_newx(INT nn
         , READONLY DBL data_arr_pc[]):
      # create a new STTS w/ data DATA_ARR_PC[]; return handle
      INT ihndl;
      INT ii;
      ihndl = stts_new();
      FOR ii FROM 0 TO nn - 1:
         CALL stts_update(ihndl, data_arr_pc[ii]);
      FOR_END
      RETURN ihndl;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- stts_shift #
   FUNC INT stts_shift(INT ix_hndl
         , DBL data_shift):
      # "shift" STTS w/ handle LC_HNDL by DATA_SHIFT
      BLOCK_USE lv_sttx_mtrx[];
      lv_sttx_mtrx[ix_hndl][LC_STTS_MAX] += data_shift;
      lv_sttx_mtrx[ix_hndl][LC_STTS_MIN] += data_shift;
      lv_sttx_mtrx[ix_hndl][LC_STTS_MEAN] += data_shift;
      RETURN ix_hndl;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- stts_scale #
   FUNC INT stts_scale(INT ix_hndl
         , DBL xfactor):
      # "scale" STTS w/ handle LC_HNDL by XFACTOR
      BLOCK_USE lv_sttx_mtrx[];
      DBL newmax;
      DBL newmin;
      IF 0 < xfactor:
         newmax = lv_sttx_mtrx[ix_hndl][LC_STTS_MAX] * xfactor;
         newmin = lv_sttx_mtrx[ix_hndl][LC_STTS_MIN] * xfactor;
      ELSE:
         newmax = lv_sttx_mtrx[ix_hndl][LC_STTS_MIN] * xfactor;
         newmin = lv_sttx_mtrx[ix_hndl][LC_STTS_MAX] * xfactor;
      IF_END
      lv_sttx_mtrx[ix_hndl][LC_STTS_MIN] = newmin;
      lv_sttx_mtrx[ix_hndl][LC_STTS_MAX] = newmax;
      lv_sttx_mtrx[ix_hndl][LC_STTS_MEAN] *= xfactor;
      lv_sttx_mtrx[ix_hndl][LC_STTS_MSQ] *= xfactor * xfactor;
      RETURN ix_hndl;
   FUNC_END
   #   FFFFFFFFFFunction ---------------------------- stts_copy #
   FUNC INT stts_copy(INT hto
         , INT hfrom):
      # copy STTS w/ handle HFROM to STTS w/ handle HTO
      BLOCK_USE lv_sttx_mtrx[];
      INT ii;
      FOR ii FROM 0 TO LC_STTS_COUNT - 1:
         lv_sttx_mtrx[hto][ii] = lv_sttx_mtrx[hfrom][ii];
      FOR_END
      RETURN hto;
   FUNC_END
   # update info in setA with data points from setB
   #   FFFFFFFFFFunction ------------------------- stts_update2 #
   FUNC INT stts_update2(INT ix_hnda
         , INT ix_hndb):
      # update STTS w/ handle LC_HNDA w/ STTS w/ handle LC_HNDB
      DBL delta;
      DBL ncount;
      DBL nmean;
      DBL nmsqr;
      DBL bmin;
      DBL bmax;
      DBL amin;
      DBL amax;
      IF NOT lf_stts_is_inited(ix_hndb):
         DIE "STTS-Bad-hndb";
      IF_END
      IF NOT Kw.iszero(sttscount(ix_hndb)):
         IF NOT lf_stts_is_inited(ix_hnda):
            DIE "STTS-Bad-hnda";
         IF_END
         IF Kw.iszero(sttscount(ix_hnda)):
            CALL stts_copy(ix_hnda, ix_hndb);
         ELSE:
            delta = sttsmean(ix_hndb) - sttsmean(ix_hnda);
            ncount = sttscount(ix_hndb) + sttscount(ix_hnda);
            nmean = (sttsmean(ix_hnda) + delta
                  * (sttscount(ix_hndb) / ncount));
            nmsqr = (sttsmsq(ix_hnda) + sttsmsq(ix_hndb)
                  + delta * delta * (sttscount(ix_hnda)
                  * sttscount(ix_hndb)) / ncount);
            # update max / mins
            amin = sttsmin(ix_hnda);
            amax = sttsmax(ix_hnda);
            bmin = sttsmin(ix_hndb);
            bmax = sttsmax(ix_hndb);
            IF amax < amin:
               amin = bmin;
               amax = bmax;
            ELSE:
               IF bmin < amin:
                  amin = bmin;
               IF_END
               IF amax < bmax:
                  amax = bmax;
               IF_END
            IF_END
            CALL stts_init(ix_hnda, ncount, nmean, nmsqr
                  / (ncount - 1.0), amin, amax);
         IF_END
      IF_END
      RETURN ix_hnda;
   FUNC_END
   BLOCK:# Correlation Statistics block
      BLOCK_DEF CONST LC_STTSC_XX 0;
      BLOCK_DEF CONST LC_STTSC_YY 1;
      BLOCK_DEF CONST LC_STTSC_COVAR 2;
      BLOCK_DEF CONST LC_STTSC_MAGIC 3;
      BLOCK_DEF CONST LC_STTSC_COUNT 4;
      BLOCK_DEF DBL lv_crx_mtrx[LC_STTS_MAX_KEY][LC_STTSC_COUNT];
      #   FFFFFFFFFFunction ------------------- lf_corr_is_init #
      BLOCK_DEF FUNC BOL lf_corr_is_init(INT ix_chnd):
         BLOCK_USE lv_crx_mtrx[];
         BOL retvalu_bol;
         DBL vll;
         IF LC_STTS_MAX_KEY <= ix_chnd:
            retvalu_bol = FALSE;
         ELSE:
            vll = lv_crx_mtrx[ix_chnd][LC_STTSC_MAGIC];
            retvalu_bol = Kw.ismagic(vll);
         IF_END
         RETURN retvalu_bol;
      FUNC_END
      #   FFFFFFFFFFunction ---------------- lf_corr_find_empty #
      BLOCK_DEF FUNC INT lf_corr_find_empty(NUL):
         INT ix_chnd;
         ix_chnd = 0;
         WHILE lf_corr_is_init(ix_chnd):
            ix_chnd += 1;
         WHILE_END
         IF LC_STTS_MAX_KEY <= ix_chnd:
            DIE "STTS-No-empty-handle";
         IF_END
         RETURN ix_chnd;
      FUNC_END
      #   FFFFFFFFFFunction -------------------------- corr_new #
      FUNC INT corr_new(NUL):
         # handle for a new correlation calc
         BLOCK_USE lv_crx_mtrx[];
         INT ix_chnd;
         ix_chnd = lf_corr_find_empty();
         lv_crx_mtrx[ix_chnd][LC_STTSC_XX] = stts_new();
         lv_crx_mtrx[ix_chnd][LC_STTSC_YY] = stts_new();
         lv_crx_mtrx[ix_chnd][LC_STTSC_COVAR] = 0.0;
         lv_crx_mtrx[ix_chnd][LC_STTSC_MAGIC] = Kw.magicset();
         RETURN ix_chnd;
      FUNC_END
      #   FFFFFFFFFFunction ----------------------- corr_delete #
      FUNC INT corr_delete(INT ix_chnd):
         # delete data of LC_CHNDth correlation calc
         BLOCK_USE lv_crx_mtrx[];
         lv_crx_mtrx[ix_chnd][LC_STTSC_MAGIC] = Kw.magicnot();
         CALL stts_delete(lv_crx_mtrx[ix_chnd][LC_STTSC_XX]);
         CALL stts_delete(lv_crx_mtrx[ix_chnd][LC_STTSC_YY]);
         RETURN ix_chnd;
      FUNC_END
      #   FFFFFFFFFFunction ---------------------- corr_handlex #
      FUNC INT corr_handlex(INT ix_chnd):
         BLOCK_USE lv_crx_mtrx[];
         RETURN lv_crx_mtrx[ix_chnd][LC_STTSC_XX];
      FUNC_END
      #   FFFFFFFFFFunction ---------------------- corr_handley #
      FUNC INT corr_handley(INT ix_chnd):
         BLOCK_USE lv_crx_mtrx[];
         RETURN lv_crx_mtrx[ix_chnd][LC_STTSC_YY];
      FUNC_END
      #   FFFFFFFFFFunction ----------------------- corr_update #
      FUNC DBL corr_update(INT ix_chnd
            , DBL xx
            , DBL yy):
         # update LC_CHNDth corr calc with point(XX,YY)
         BLOCK_USE lv_crx_mtrx[];
         INT num;
         DBL ddxx;
         DBL ddyy;
         INT yyhnd;
         INT xxhnd;
         yyhnd = lv_crx_mtrx[ix_chnd][LC_STTSC_YY];
         xxhnd = lv_crx_mtrx[ix_chnd][LC_STTSC_XX];
         num = sttscount(xxhnd);
         ddxx = stts_update(xxhnd, xx);
         ddyy = stts_update(yyhnd, yy);
         lv_crx_mtrx[ix_chnd][LC_STTSC_COVAR] += (ddxx * ddyy
               * num / (num + 1.0));
         RETURN lv_crx_mtrx[ix_chnd][LC_STTSC_COVAR];
      FUNC_END
      #   FFFFFFFFFFunction ------------------------- corrslope #
      FUNC DBL corrslope(INT ix_chnd):
         # slope of least squares line of LC_CHNDth corr calc
         BLOCK_USE lv_crx_mtrx[];
         DBL den;
         DBL retvalu;
         INT xxhnd;
         xxhnd = lv_crx_mtrx[ix_chnd][LC_STTSC_XX];
         den = sttsmsq(xxhnd);
         IF Kw.iszero(den):
            retvalu = 0.0;
         ELSE:
            retvalu = lv_crx_mtrx[ix_chnd][LC_STTSC_COVAR] / den;
         IF_END
         RETURN retvalu;
      FUNC_END
      #   FFFFFFFFFFunction ---------------------------- corry0 #
      FUNC DBL corry0(INT ix_chnd):
         # y-intercept of least squares line of LC_CHNDth corr
         BLOCK_USE lv_crx_mtrx[];
         DBL retvalu;
         INT yyhnd;
         INT xxhnd;
         yyhnd = lv_crx_mtrx[ix_chnd][LC_STTSC_YY];
         xxhnd = lv_crx_mtrx[ix_chnd][LC_STTSC_XX];
         retvalu = (sttsmean(yyhnd) - corrslope(ix_chnd)
               * sttsmean(xxhnd));
         RETURN retvalu;
      FUNC_END
      #   FFFFFFFFFFunction -------------------------- corrcorr #
      FUNC DBL corrcorr(INT ix_chnd):
         # Correlation Coefficient[-1,1] of LC_CHNDth corr calc
         BLOCK_USE lv_crx_mtrx[];
         DBL retvalu;
         DBL xxmsq;
         DBL yymsq;
         DBL den;
         xxmsq = sttsmsq(lv_crx_mtrx[ix_chnd][LC_STTSC_XX]);
         yymsq = sttsmsq(lv_crx_mtrx[ix_chnd][LC_STTSC_YY]);
         den = xxmsq * yymsq;
         IF Kw.iszero(den):
            retvalu = 0.0;
         ELSE:
            retvalu = (lv_crx_mtrx[ix_chnd][LC_STTSC_COVAR]
                  / SQRT(den));
         IF_END
         RETURN retvalu;
      FUNC_END
      #   FFFFFFFFFFunction ------------------------ corrstderr #
      FUNC DBL corrstderr(INT ix_chnd):
         # stderr of least squares line of LC_CHNDth corr calc
         BLOCK_USE lv_crx_mtrx[];
         INT yyhnd;
         DBL diff;
         DBL retvalu;
         yyhnd = lv_crx_mtrx[ix_chnd][LC_STTSC_YY];
         diff = sttsmsq(yyhnd) - (corrslope(ix_chnd)
               * lv_crx_mtrx[ix_chnd][LC_STTSC_COVAR]);
         IF diff < 0:
            retvalu = 0;
         ELSE:
            retvalu = SQRT(diff / (sttscount(yyhnd) - 2));
         IF_END
         RETURN retvalu;
      FUNC_END
   BLOCK_END# Correlation Statistics block
BLOCK_END# Statistics block
#   IIIIIIIIIInsert-End ----------------------------- stts.fwip #
#   IIIIIIIIIInsert-Begin ---------------------------- fit.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-07-27 kdw  fit:block syntax
# 2020-07-24 kdw  fit:comment cleanup
# 2020-06-22 kdw  fit:local-use mved before var decls
# 2020-06-03 kdw  fit:writeonly keyword
# 2020-05-30 kdw  fit:CONST syntax change
# 2020-05-11 kdw  fit:BL[O]CK work
# 2020-05-06 kdw  fit:rmed boolean vars
# 2020-04-28 kdw  fit:tweaks here and there
# 2020-04-23 kdw  fit:const format change
# 2020-04-17 kdw  fit:fit_poly: arg renam
# 2020-04-16 kdw  fit:fit_minmax: free chi array
# 2020-04-12 kdw  fit:comment change
# 2020-04-10 kdw  fit:comment change
# 2020-04-08 kdw  fit:proprocess sigil change
# 2020-03-10 kdw  fit:LO[C]AL_USE more consistent
# 2020-03-09 kdw  fit:LO[C]AL_.* keywords
# 2020-03-06 kdw  fit:RE[P]LACE / IN[D]EX changes
# 2020-03-05 kdw  fit:s/TRU[E]VAL/TR[U]E/;s/FALS[E]VAL/FA[L]SE/;
# 2020-03-03 kdw  fit:comment changed odd chars
# 2020-03-01 kdw  fit:rmed useless semicolons
# 2020-02-25 kdw  fit:function descriptions
# 2020-02-21 kdw  fit:spacing tweak
# 2020-02-20 kdw  fit:min-max var renam
# 2020-02-03 kdw  fit:one return / function
# 2020-01-30 kdw  fit:slope/intercept var name change
# 2020-01-29 kdw  fit:func name change s/para_/parabola_/
# 2020-01-28 kdw  fit:work on funcs w/ array args
# 2020-01-27 kdw  fit:fitt_.* renamed to fit_.* and visa versa
# 2020-01-26 kdw  fit:no array rets
# 2019-12-26 kdw  fit:module name addded to funcs
# 2019-12-06 kdw  fit:rmed print statments
# 2019-11-17 kdw  fit:modules on constants
# 2019-10-04 kdw  fit:comment change
# 2019-08-24 kdw  fit:for and count loops have from clause
# 2019-08-18 kdw  fit:B[O]OL to B[O]L
# 2019-08-11 kdw  fit:comment cleanup
# 2019-08-06 kdw  fit:rmed backslashes, macro arg renam
# 2019-07-21 kdw  fit:func descriptions
# 2019-07-03 kdw  fit:i[n]d vars renamd
# 2019-05-24 kdw  fit:local replaced private
# 2019-05-22 kdw  fit:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-05-01 kdw  fit:consts explicit module name
# 2019-03-28 kdw  fit:x-product work
# 2019-03-19 kdw  fit:re[t]_val to re[t]valu
# 2019-03-14 kdw  fit:.*_lsz_.* to .*_ls0_.* func name change
# 2018-12-07 kdw  fit:comment tweak
# 2018-10-23 kdw  fit:spurious() rmed in if statements
# 2018-07-23 kdw  fit:func renam
# 2018-07-17 kdw  fit:private lf_.* funcs
# 2018-05-22 kdw  fit:comment changed
# 2018-05-14 kdw  fit:BLO?CK syntax change
# 2018-04-03 kdw  fit:rm() from return
# 2018-03-26 kdw  fit:macro redef
# 2018-03-12 kdw  fit:made PP statements not need semicolon
# 2017-11-26 kdw  fit:FR[O]M and B[Y] keywords
# 2017-11-23 kdw  fit:rm digits from var names
# 2017-11-22 kdw  fit:var renam
# 2017-10-21 kdw  fit:macros start with "at""at"
# 2017-10-20 kdw  fit:var renam(no triple letters)
# 2017-10-06 kdw  fit:comment changed; index vars
# 2017-08-30 kdw  fit:s/DBL_/DBL/;s/FLT_/FLT/
# 2017-08-24 kdw  fit:var renam
# 2017-07-03 kdw  fit:comment changed
# 2017-06-29 kdw  fit:comment changed; spacing after func line
# 2017-06-21 kdw  fit:comment changed
# 2017-06-19 kdw  fit:comment changed
# 2017-06-15 kdw  fit:fit_* debugging
# 2017-06-13 kdw  fit:fit_* debugging
# 2017-06-08 kdw  fit:fitt_minmax stuff
# 2017-06-03 kdw  fit:fitt_minmax eps[xy] stuff
# 2017-06-02 kdw  fit:fitt_minmax debug
# 2017-06-01 kdw  fit:fitt_ls*
# 2017-04-30 kdw  fit:func to function
# 2017-03-12 kdw  fit:shorten long comments
# 2017-03-06 kdw  fit:sigils rmed
# 2017-02-25 kdw  fit:var names
# 2017-02-21 kdw  fit:array var names
# 2017-02-20 kdw  fit:array var names
# 2017-02-14 kdw  fit:FWIP Loop syntax changed
# 2017-02-12 kdw  fit:FWIP language change
# 2016-11-23 kdw  fit:CN?ST to REA?DON?LY
# 2016-11-21 kdw  fit:DE?F to FU?NC
# 2016-11-20 kdw  fit:language change
# 2016-10-14 kdw  fit:_pc added to var names
# 2016-10-13 kdw  fit:_p added to var names
# 2016-09-15 kdw  fit:lang change
# 2016-09-13 kdw  fit:lang change
# 2016-04-27 kdw  fit:_[_]BL?OCK* change
# 2016-04-11 kdw  fit:oopsy in fitt_poi?nts
# 2015-12-28 kdw  fit:pa?rab?ola_.* to pa?ra_.*
# 2015-12-14 kdw  fit:refactor f[i]t_po[i]nts wrt *para*
# 2015-12-11 kdw  fit:parabola_solve
# 2015-12-02 kdw  fit:renamed functions; requires stuff
# 2015-11-26 kdw  fit:long lines
# 2015-11-25 kdw  fit:variables name shortened
# 2015-11-17 kdw  fit:F[O]R format changed
# 2015-11-10 kdw  fit:refactor interp[o]late_[p]oints
# 2015-11-05 kdw  fit:cleanup
# 2015-11-02 kdw  fit:spacing fixed
# 2015-11-01 kdw  fit:created
#   FFFFFFFFFFunction -------------------------------- fit_poly #
FUNC DBL fit_poly(INT num_points
      , READONLY DBL pts_arr_pc[]
      , WRITEONLY DBL ret_coeff_arr_p[]):
   # compute a polynomial of degree NUM_POINTS - 1 that passes
   # through the points(PTS_ARR_PC[2*kk],PTS_ARR_PC[2*kk+1])
   INT i_ind;
   INT j_ind;
   INT k_ind;
   DBL prod;
   DBL cc_arr[];
   REDIM cc_arr[], num_points;
   FOR j_ind FROM 0 TO num_points - 1:
      # init cc_arr[] to the y-values
      cc_arr[j_ind] = pts_arr_pc[2 * j_ind + 1];
   FOR_END
   # From Algorithm 4.3 of Conte and de Boors
   # "Elementary Numerical Analysis", 2nd edition, pg 204
   FOR j_ind FROM 1 TO num_points - 1:
      k_ind = num_points - 1 - j_ind;
      FOR i_ind FROM num_points - 1 TO j_ind BY - 1:
         cc_arr[i_ind] = ((cc_arr[i_ind - 1] - cc_arr[i_ind])
               / (pts_arr_pc[2 * k_ind] - pts_arr_pc[2
               * i_ind]));
         k_ind -= 1;
      FOR_END
   FOR_END
   # Jeff Stetekluhs method for combining the terms to
   # form the coefficients of the polynomial.
   FOR j_ind FROM 0 TO num_points - 2:
      FOR i_ind FROM num_points - 2 TO j_ind BY - 1:
         prod = cc_arr[i_ind + 1] * pts_arr_pc[2 * (i_ind
               - j_ind)];
         cc_arr[i_ind] -= prod;
      FOR_END
   FOR_END
   FOR j_ind FROM 0 TO num_points - 1:
      ret_coeff_arr_p[j_ind] = cc_arr[j_ind];
   FOR_END
   REDIM cc_arr[];
   RETURN num_points;
FUNC_END
BLOCK:# parabola info
   BLOCK_DEF CONST LC_PARABOLA_X_AXIS 0;
   BLOCK_DEF CONST LC_PARABOLA_Y_EXTREMA 1;
   BLOCK_DEF CONST LC_PARABOLA_REAL_ROOTS 2;
   BLOCK_DEF CONST LC_PARABOLA_ROOT_A 3;
   BLOCK_DEF CONST LC_PARABOLA_ROOT_B 4;
   BLOCK_DEF CONST LC_PARABOLA_COEFF_C 5;
   BLOCK_DEF CONST LC_PARABOLA_COEFF_B 6;
   BLOCK_DEF CONST LC_PARABOLA_COEFF_A 7;
   BLOCK_DEF DBL lv_parabola_arr[8];
   #   FFFFFFFFFFunction ----------------------- parabola_solve #
   FUNC DBL parabola_solve(DBL xx_a
         , DBL yy_a
         , DBL xx_b
         , DBL yy_b
         , DBL xx_c
         , DBL yy_c):
      # return the x-axis of the vertically aligned parabola
      #   passing through the points
      #      (xx_a,yy_a) (xx_b,yy_b) and(xx_c,yy_c)
      # subsequently use parabola_get(IND) to recieve other
      #   information about said parabola
      BLOCK_USE lv_parabola_arr[];
      DBL pts_arr[8];
      DBL cc_arr[4];
      DBL disc;
      DBL axis;
      DBL yyextrema;
      INT real_roots;
      DBL roots_arr[2];
      pts_arr[0] = xx_a;
      pts_arr[1] = yy_a;
      pts_arr[2] = xx_b;
      pts_arr[3] = yy_b;
      pts_arr[4] = xx_c;
      pts_arr[5] = yy_c;
      CALL fit_poly(3, pts_arr[], cc_arr[]);
      roots_arr[0] = Kw.DBLMAX;
      roots_arr[1] = Kw.DBLMAX;
      IF Kw.iszero(cc_arr[2]):
         axis = Kw.DBLMAX;
         IF Kw.iszero(cc_arr[1]):
            yyextrema = cc_arr[0];
            real_roots = 0;
         ELSE:
            yyextrema = Kw.DBLMAX;
            real_roots = 1;
            roots_arr[0] = (-cc_arr[0] / cc_arr[1]);
         IF_END
      ELSE:
         axis = (-cc_arr[1] / (2.0 * cc_arr[2]));
         yyextrema = (cc_arr[0] + xx_a * (cc_arr[1] + xx_a
               * cc_arr[2]));
         disc = (cc_arr[1] * cc_arr[1] - 4.0 * cc_arr[2]
               * cc_arr[0]);
         IF Kw.iszero(disc):
            real_roots = 1;
            roots_arr[0] = axis;
         ELSIF 0 < disc:
            disc = SQRT(disc) / (2.0 * cc_arr[2]);
            real_roots = 2;
            roots_arr[0] = axis - disc;
            roots_arr[1] = axis + disc;
         ELSE:
            real_roots = 0;
         IF_END
      IF_END
      lv_parabola_arr[LC_PARABOLA_X_AXIS] = axis;
      lv_parabola_arr[LC_PARABOLA_Y_EXTREMA] = yyextrema;
      lv_parabola_arr[LC_PARABOLA_REAL_ROOTS] = real_roots;
      lv_parabola_arr[LC_PARABOLA_ROOT_A] = roots_arr[0];
      lv_parabola_arr[LC_PARABOLA_ROOT_B] = roots_arr[1];
      lv_parabola_arr[LC_PARABOLA_COEFF_C] = cc_arr[0];
      lv_parabola_arr[LC_PARABOLA_COEFF_B] = cc_arr[1];
      lv_parabola_arr[LC_PARABOLA_COEFF_A] = cc_arr[2];
      RETURN axis;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------- parabola_get #
   FUNC DBL parabola_get(INT ii_ind):
      # get the results of the previous call to parabola_solve
      #    0  x-axis
      #    1  y extrema
      #    2  number of real roots
      #    3  Root 1(if 0 < parabola_get(2))
      #    4  Root 2(if 1 < parabola_get(2))
      #    5  Coeff C
      #    6  Coeff B
      #    7  Coeff A
      BLOCK_USE lv_parabola_arr[];
      DBL retvalu;
      IF 0 <= ii_ind AND ii_ind <= 7:
         retvalu = lv_parabola_arr[ii_ind];
      ELSE:
         retvalu = 0;
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ----------------------- parabola_roots #
   FUNC DBL parabola_roots(INT ii_ind):
      # retun the II_INDth root of the parabola computed
      # by a previous call to parabola_solve
      DBL retvalu;
      IF 0 <= ii_ind AND ii_ind <= 1:
         retvalu = parabola_get(ii_ind + LC_PARABOLA_ROOT_A);
      ELSE:
         retvalu = Kw.DBLMAX;
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction -------------------- parabola_yextrema #
   FUNC DBL parabola_yextrema(NUL):
      # retun the Y extrema of the parabola computed
      # by a previous call to parabola_solve
      RETURN parabola_get(LC_PARABOLA_Y_EXTREMA);
   FUNC_END
   #   FFFFFFFFFFunction ----------------------- parabola_xaxis #
   FUNC DBL parabola_xaxis(NUL):
      # retun the x-axis of the parabola computed
      # by a previous call to parabola_solve
      RETURN parabola_get(LC_PARABOLA_X_AXIS);
   FUNC_END
   #   FFFFFFFFFFunction ------------------- parabola_realroots #
   FUNC DBL parabola_realroots(NUL):
      # retun the number of real roots of the parabola computed
      # by a previous call to parabola_solve
      RETURN parabola_get(LC_PARABOLA_REAL_ROOTS);
   FUNC_END
BLOCK_END# parabola info
BLOCK:# circle info
   BLOCK_DEF CONST LC_CIRCLE_X 0;
   BLOCK_DEF CONST LC_CIRCLE_Y 1;
   BLOCK_DEF CONST LC_CIRCLE_RADIUS 2;
   BLOCK_DEF DBL lv_circle_arr[3];
   #   FFFFFFFFFFunction ------------------------- circle_solve #
   FUNC DBL circle_solve(DBL aa_x
         , DBL aa_y
         , DBL bb_x
         , DBL bb_y
         , DBL cc_x
         , DBL cc_y):
      # return the radius of the circle going through the points
      # (aa_x,aa_y) (bb_x,bb_y) (cc_x,cc_y)
      # subsequently use with
      #   circle_get(0) to get the x-coordinate of the center and
      #   circle_get(1) to get the y-coordinate of the center
      BLOCK_USE lv_circle_arr[];
      DBL ca_a;
      DBL cb_a;
      DBL ca_b;
      DBL cb_b;
      DBL det;
      DBL cc_a;
      DBL cc_b;
      DBL center_x;
      DBL center_y;
      DBL radius;
      ca_a = bb_y - aa_y;
      cb_a = bb_x - aa_x;
      ca_b = cc_y - aa_y;
      cb_b = cc_x - aa_x;
      det = 2.0 * (ca_a * cb_b - ca_b * cb_a);
      IF NOT Kw.iszero(det):
         cc_a = -ca_a * (aa_y + bb_y) - cb_a * (aa_x + bb_x);
         cc_b = -ca_b * (aa_y + cc_y) - cb_b * (aa_x + cc_x);
         center_x = (ca_b * cc_a - ca_a * cc_b) / det;
         center_y = (cb_a * cc_b - cb_b * cc_a) / det;
         radius = Kw.hypot(center_x - aa_x, center_y - aa_y);
      ELSE:
         center_x = Kw.DBLMAX;
         center_y = Kw.DBLMAX;
         radius = Kw.DBLMAX;
      IF_END
      lv_circle_arr[LC_CIRCLE_X] = center_x;
      lv_circle_arr[LC_CIRCLE_Y] = center_y;
      lv_circle_arr[LC_CIRCLE_RADIUS] = radius;
      RETURN radius;
   FUNC_END
   #   FFFFFFFFFFunction --------------------------- circle_get #
   FUNC DBL circle_get(INT ii_ind):
      # get the results of the previous call to circle_solve
      #    0  x-center
      #    1  y-canter
      #    2  radius
      BLOCK_USE lv_circle_arr[];
      DBL retvalu;
      IF 0 <= ii_ind AND ii_ind <= 2:
         retvalu = lv_circle_arr[ii_ind];
      ELSE:
         retvalu = 0;
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END# circle info
#   FFFFFFFFFFunction ------------------------------ fit_minmax #
FUNC DBL fit_minmax(INT num_points
      , READONLY DBL pt_arr_pc[]
      , WRITEONLY DBL ret_coeff_arr_p[]):
   # USES AN O(N**3) ALGORITHM; The N*log(N) algorithm via
   #   a Graham scan is numerically unstable for nearly
   #   linear data
   # Given
   #   NUM_POINTS = number of points
   #   points(PT_ARR_PC[2*kk],PT_ARR_PC[2*kk+1])
   # Compute a minmax-line to thePT_ARR_PC[] data
   #   With the properties(** assuming generic data **)
   #      1) The maximum linear deviation, M_y, from the
   #         minmax-line to the data points is minimized
   #         among ALL lines in the X-Y plane;
   #      2) There exists three data points whose distance
   #         to the minmax-line is equal to M_y; and
   #      3) The minmax-line has the largest slope amongst
   #         all lines satisfying properties 1 and 2.
   # returns the max deviation from the found line
   #    RET_COEFF_ARR_P[0] = y-intercept
   #    RET_COEFF_ARR_P[1] = slope
   #    RET_COEFF_ARR_P[2] = max-deviation
   DBL xxp_arr[];
   DBL yyp_arr[];
   INT i_ind;
   INT j_ind;
   INT k_ind;
   DBL this_spread;
   DBL nx_spr;
   DBL nx_a;
   DBL nx_b;
   DBL dxx;
   DBL dyy;
   DBL pty;
   DBL epsxx;
   DBL epsyy;
   DBL slope_t;
   DBL intercept_t;
   DBL max_dyy;
   DBL min_dyy;
   REDIM xxp_arr[], num_points;
   REDIM yyp_arr[], num_points;
   epsxx = 0.0;
   epsyy = 0.0;
   FOR j_ind FROM 0 TO num_points - 1:
      xxp_arr[j_ind] = pt_arr_pc[2 * j_ind];
      yyp_arr[j_ind] = pt_arr_pc[2 * j_ind + 1];
      IF epsxx < ABS(xxp_arr[j_ind]):
         epsxx = ABS(xxp_arr[j_ind]);
      IF_END
      IF epsyy < ABS(yyp_arr[j_ind]):
         epsyy = ABS(yyp_arr[j_ind]);
      IF_END
   FOR_END
   nx_spr = -1;
   nx_a = 0;
   nx_b = 0;
   epsxx *= 16 * Kw.DBLEPS;
   epsyy *= 16 * Kw.DBLEPS;
   FOR i_ind FROM 1 TO num_points - 1:
      FOR j_ind FROM 0 TO i_ind - 1:
         dxx = xxp_arr[i_ind] - xxp_arr[j_ind];
         IF epsxx < ABS(dxx):
            slope_t = (yyp_arr[i_ind] - yyp_arr[j_ind]) / dxx;
            intercept_t = yyp_arr[i_ind] - slope_t
                  * xxp_arr[i_ind];
            # Y = slope_t * X + intercept_t is the line
            #    through PT(i_ind) and PT(j_ind)
            pty = slope_t * xxp_arr[0] + intercept_t;
            dyy = yyp_arr[0] - pty;
            min_dyy = dyy;
            max_dyy = dyy;
            k_ind = 1;
            WHILE k_ind < num_points:
               pty = slope_t * xxp_arr[k_ind] + intercept_t;
               dyy = yyp_arr[k_ind] - pty;
               IF dyy < min_dyy:
                  min_dyy = dyy;
               IF_END
               IF max_dyy < dyy:
                  max_dyy = dyy;
               IF_END
               this_spread = max_dyy - min_dyy;
               IF (0 < nx_spr AND nx_spr + epsyy < this_spread)
                     OR (min_dyy < - epsyy AND epsyy < max_dyy):
                  WHILE_EXIT;
               IF_END
               k_ind += 1;
            WHILE_END
            IF num_points <= k_ind:
               IF nx_spr < 0 OR this_spread < nx_spr - epsyy
                     OR (this_spread <= nx_spr + epsyy
                     AND ABS(nx_a) < ABS(slope_t)):
                  nx_a = slope_t;
                  nx_b = intercept_t + (min_dyy + max_dyy) / 2.0;
                  nx_spr = this_spread;
               IF_END
            IF_END
         IF_END
      FOR_END
   FOR_END
   REDIM xxp_arr[];
   REDIM yyp_arr[];
   ret_coeff_arr_p[1] = nx_a;
   ret_coeff_arr_p[0] = nx_b;
   ret_coeff_arr_p[2] = nx_spr / 2.0;
   RETURN nx_spr / 2.0;
FUNC_END
BLOCK:
      #   FFFFFFFFFFunction ------------------
   #lf_signcrossproduct #
   BLOCK_DEF FUNC DBL lf_signcrossproduct(DBL aa_x, DBL aa_y
         , DBL bb_x, DBL bb_y, DBL cc_x, DBL cc_y):
      # the z-component of the cross product of the vectors
      #   (bb_x - aa_x, bb_y - aa_y, 0), and
      #   (cc_x - aa_x, cc_y - aa_y, 0)
      DBL cr;
      DBL bbaa_x;
      DBL bbaa_y;
      DBL ccaa_x;
      DBL ccaa_y;
      bbaa_x = bb_x - aa_x;
      bbaa_y = bb_y - aa_y;
      ccaa_x = cc_x - aa_x;
      ccaa_y = cc_y - aa_y;
      cr = bbaa_x * ccaa_y - ccaa_x * bbaa_y;
      RETURN cr;
   FUNC_END
   #   FFFFFFFFFFunction -------------------------- fitx_minmax #
   FUNC DBL fitx_minmax(INT num_points
         , READONLY DBL pt_arr_pc[]
         , WRITEONLY DBL ret_arr_p[]):
      # USES a O(NUM_POINTS*CONVEXHULLSIZE) algorithnm
      # Given
      #   num_points = size of the XXP_ARR and YYP_ARR arrays
      #   PT_ARR_PC = an array of x and y values(0-based)
      # Compute a minmax-line to the XX and YY data
      #   With the properties(** assuming generic data **)
      #      1) The maximum linear deviation, M_y, from the
      #         minmax-line to the data points is minimized
      #         among ALL lines in the X-Y plane;
      #      2) There exists three data points whose distance
      #         to the minmax-line is equal to M_y; and
      #      3) The minmax-line has the largest slope amongst
      #         all lines satisfying properties 1 and 2.
      # returns the max deviation from the found line
      #    RET_ARR_P[0] = y-intercept
      #    RET_ARR_P[1] = slope
      #    RET_ARR_P[2] = max-deviation
      # Pseudo-code for Jarvis march
      # INPUT   S_arr[] array of 2-D points
      # OUTPUT  P_arr[] array of 2-D points
      #      that is the convex hull of S_arr[]
      # jarvis(S_arr[])
      #    # pntH is always a point on the convex hull of S_arr[]
      #    pntH = LeftmostBottommostPointIn(S_arr[])
      #    P_ind = 0
      #    REPEAT
      #       P_arr[P_ind] = pntH
      #       pntX = S_arr[0]
      #       foreach S_pnt IN S_arr[1..len(S_arr[])]:
      #          if(pntX == pntH) OR
      #                (pntX IS CCW_of(S_pnt,P_arr[P_ind]):
      #             pntX = S_pnt
      #       P_ind++;
      #       pntH = pntX
      #    UNTIL pntX == P_arr[0]
      #    return P_arr[] # the convex hull of S_arr
      DBL xxp_arr[];
      DBL yyp_arr[];
      INT chi_arr[];
      INT chisize;
      INT hh;
      INT i_ind;
      INT j_ind;
      INT k_ind;
      DBL this_spread;
      DBL nx_spr;
      DBL nx_a;
      DBL nx_b;
      DBL dxx;
      DBL pty;
      DBL dyy;
      DBL epsxx;
      DBL epsyy;
      DBL slope_t;
      DBL intercept_t;
      DBL max_dyy;
      DBL min_dyy;
      INT e_ind;
      INT t_ind;
      INT poh_ind;
      DBL crx;
      INT lmbm_ind;
      # leftmost, bottommost point index
      REDIM xxp_arr[], num_points;
      REDIM yyp_arr[], num_points;
      REDIM chi_arr[], num_points;
      epsxx = 0.0;
      epsyy = 0.0;
      lmbm_ind = 0;
      FOR j_ind FROM 0 TO num_points - 1:
         xxp_arr[j_ind] = pt_arr_pc[2 * j_ind];
         yyp_arr[j_ind] = pt_arr_pc[2 * j_ind + 1];
         IF epsxx < ABS(xxp_arr[j_ind]):
            epsxx = ABS(xxp_arr[j_ind]);
         IF_END
         IF epsyy < ABS(yyp_arr[j_ind]):
            epsyy = ABS(yyp_arr[j_ind]);
         IF_END
         IF xxp_arr[j_ind] <= xxp_arr[lmbm_ind]:
            IF xxp_arr[j_ind] < xxp_arr[lmbm_ind]
                  OR yyp_arr[j_ind] <= yyp_arr[lmbm_ind]:
               lmbm_ind = j_ind;
            IF_END
         IF_END
      FOR_END
      nx_spr = -1;
      nx_a = 0;
      nx_b = 0;
      epsxx *= 16 * Kw.DBLEPS;
      epsyy *= 16 * Kw.DBLEPS;
      poh_ind = lmbm_ind;
      chisize = 0;
      AWAIT e_ind == chi_arr[0]:
         chi_arr[chisize] = poh_ind;
         e_ind = 0;
         FOR j_ind FROM 0 TO num_points - 1:
            IF e_ind == poh_ind:
               e_ind = j_ind;
            ELSE:
               t_ind = chi_arr[chisize];
               crx = lf_signcrossproduct(xxp_arr[j_ind]
                     , yyp_arr[j_ind], xxp_arr[t_ind]
                     , yyp_arr[t_ind], xxp_arr[e_ind]
                     , yyp_arr[e_ind]);
               IF crx < 0:
                  e_ind = j_ind;
               IF_END
            IF_END
         FOR_END
         chisize += 1;
         IF num_points < chisize:
            DIE "OOPS";
         IF_END
         poh_ind = e_ind;
      AWAIT_END
      chi_arr[chisize] = chi_arr[0];
      chisize += 1;
      FOR hh FROM 0 TO chisize - 2:
         i_ind = chi_arr[hh];
         j_ind = chi_arr[hh + 1];
         dxx = xxp_arr[i_ind] - xxp_arr[j_ind];
         IF epsxx < ABS(dxx):
            slope_t = (yyp_arr[i_ind] - yyp_arr[j_ind]) / dxx;
            intercept_t = yyp_arr[i_ind] - slope_t
                  * xxp_arr[i_ind];
            # Y=slope_t*X+intercept_t is the line through points
            #    (xx[i_ind],yy[i_ind]) and(xx[j_ind],yy[j_ind])
            dyy = yyp_arr[0] - (slope_t * xxp_arr[0]
                  + intercept_t);
            min_dyy = dyy;
            max_dyy = dyy;
            this_spread = 0;
            k_ind = 1;
            WHILE k_ind < num_points:
               pty = (slope_t * xxp_arr[k_ind] + intercept_t);
               dyy = yyp_arr[k_ind] - pty;
               IF dyy < min_dyy:
                  min_dyy = dyy;
               IF_END
               IF max_dyy < dyy:
                  max_dyy = dyy;
               IF_END
               this_spread = max_dyy - min_dyy;
               IF (0 < nx_spr AND nx_spr + epsyy < this_spread)
                     OR (min_dyy < - epsyy AND epsyy < max_dyy):
                  WHILE_EXIT;
               IF_END
               k_ind += 1;
            WHILE_END
            IF num_points <= k_ind:
               IF nx_spr < 0 OR this_spread < nx_spr - epsyy
                     OR (this_spread <= nx_spr + epsyy
                     AND ABS(nx_a) < ABS(slope_t)):
                  nx_a = slope_t;
                  nx_b = intercept_t + (min_dyy + max_dyy) / 2.0;
                  nx_spr = this_spread;
               IF_END
            IF_END
         IF_END
      FOR_END
      REDIM xxp_arr[];
      REDIM yyp_arr[];
      REDIM chi_arr[];
      ret_arr_p[0] = nx_b;
      ret_arr_p[1] = nx_a;
      ret_arr_p[2] = nx_spr / 2.0;
      RETURN ret_arr_p[2];
   FUNC_END
BLOCK_END
      #   FFFFFFFFFFunction -----------------------------
   #fit_minmax0 #
FUNC DBL fit_minmax0(INT num_points
      , READONLY DBL pts_arr_pc[]
      , WRITEONLY DBL ret_arr_p[]):
   # find the minmax line through the given data
   # that passes through the point
   #      (PTS_ARR_PC[0],PTS_ARR_PC[1])
   # returns the max deviation from the found line
   #    RET_ARR_P[0] = y-intercept
   #    RET_ARR_P[1] = slope
   #    RET_ARR_P[2] = max-deviation
   DBL xxp_arr[];
   DBL yyp_arr[];
   INT i_ind;
   INT j_ind;
   INT k_ind;
   DBL this_spread;
   DBL minmaxz_spread;
   DBL minmaxz_slope;
   DBL minmaxz_intercept;
   DBL dxx;
   DBL dyy;
   DBL pty;
   DBL epsxx;
   DBL epsyy;
   DBL slope_t;
   DBL intercept_t;
   DBL midxx;
   DBL midyy;
   DBL max_dyy;
   DBL min_dyy;
   REDIM xxp_arr[], num_points;
   REDIM yyp_arr[], num_points;
   epsxx = 0.0;
   epsyy = 0.0;
   FOR j_ind FROM 0 TO num_points - 1:
      xxp_arr[j_ind] = pts_arr_pc[2 * j_ind];
      yyp_arr[j_ind] = pts_arr_pc[2 * j_ind + 1];
      IF epsxx < ABS(xxp_arr[j_ind]):
         epsxx = ABS(xxp_arr[j_ind]);
      IF_END
      IF epsyy < ABS(yyp_arr[j_ind]):
         epsyy = ABS(yyp_arr[j_ind]);
      IF_END
   FOR_END
   minmaxz_spread = -1;
   minmaxz_slope = 0;
   minmaxz_intercept = yyp_arr[0];
   epsxx *= 8 * Kw.DBLEPS;
   epsyy *= 8 * Kw.DBLEPS;
   FOR i_ind FROM 2 TO num_points - 1:
      FOR j_ind FROM 2 TO i_ind - 1:
         midxx = (xxp_arr[i_ind] + xxp_arr[j_ind]) / 2.0;
         midyy = (yyp_arr[i_ind] + yyp_arr[j_ind]) / 2.0;
         # (midxx,midyy) is the mid-points between
         #   (xxp_arr[i_ind],yyp_arr[i_ind]) and
         #   (xxp_arr[j_ind],yyp_arr[j_ind])
         dxx = xxp_arr[0] - midxx;
         IF epsxx < ABS(dxx):
            slope_t = (yyp_arr[0] - midyy) / dxx;
            intercept_t = yyp_arr[0] - slope_t * xxp_arr[0];
            # Now the line Y=slope_t*X+intercept_t is the line
            # through(xx[0],yy[0]) and(midxx,midyy)
            min_dyy = 0;
            max_dyy = 0;
            FOR k_ind FROM 0 TO num_points - 1:
               pty = slope_t * xxp_arr[k_ind] + intercept_t;
               dyy = yyp_arr[k_ind] - pty;
               IF dyy < min_dyy:
                  min_dyy = dyy;
               IF_END
               IF max_dyy < dyy:
                  max_dyy = dyy;
               IF_END
               this_spread = max_dyy - min_dyy;
               IF 0 < minmaxz_spread AND minmaxz_spread
                     + epsyy < this_spread:
                  FOR_EXIT;
               IF_END
            FOR_END
            IF minmaxz_spread < 0
                  OR this_spread < minmaxz_spread - epsyy:
               minmaxz_slope = slope_t;
               minmaxz_intercept = intercept_t;
               minmaxz_spread = this_spread;
            IF_END
         IF_END
      FOR_END
   FOR_END
   IF 0 <= minmaxz_spread:
      ret_arr_p[1] = minmaxz_slope;
      ret_arr_p[0] = minmaxz_intercept;
      ret_arr_p[2] = minmaxz_spread / 2.0;
   IF_END
   REDIM xxp_arr[];
   REDIM yyp_arr[];
   RETURN minmaxz_spread / 2.0;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- fit_ls #
FUNC DBL fit_ls(INT num_points
      , READONLY DBL pts_arr_pc[]
      , WRITEONLY DBL ret_arr_p[]):
   # Find the least square fit LINE to the NUM_POINTS
   # in the array PTS_ARR_PC[]
   #    RET_ARR_P[0] = y-intercept
   #    RET_ARR_P[1] = slope
   #    RET_ARR_P[2] = correlation
   #    RET_ARR_P[3] = stderr
   INT i_ind;
   DBL dxx;
   DBL dyy;
   DBL xx;
   DBL yy;
   DBL slope;
   DBL mean_yy;
   DBL ssq_yy;
   DBL mean_xx;
   DBL ssq_xx;
   DBL covariance_xy;
   mean_xx = 0.0;
   ssq_xx = 0.0;
   mean_yy = 0.0;
   ssq_yy = 0.0;
   covariance_xy = 0.0;
   FOR i_ind FROM 0 TO num_points - 1:
      xx = pts_arr_pc[2 * i_ind];
      dxx = xx - mean_xx;
      mean_xx += dxx / (i_ind + 1);
      ssq_xx += dxx * (xx - mean_xx);
      yy = pts_arr_pc[2 * i_ind + 1];
      dyy = yy - mean_yy;
      mean_yy += dyy / (i_ind + 1);
      ssq_yy += dyy * (yy - mean_yy);
      covariance_xy += dxx * dyy * i_ind / (i_ind + 1.0);
   FOR_END
   slope = covariance_xy / ssq_xx;
   ret_arr_p[1] = slope;
   ret_arr_p[0] = mean_yy - slope * mean_xx;
   ret_arr_p[2] = covariance_xy / SQRT(ssq_xx * ssq_yy);
   ret_arr_p[3] = SQRT((ssq_yy - slope * covariance_xy)
         / (num_points - 2));
   RETURN ret_arr_p[2];
FUNC_END
#   FFFFFFFFFFunction --------------------------------- fit_ls0 #
FUNC DBL fit_ls0(INT num_points
      , READONLY DBL pts_arr_pc[]
      , WRITEONLY DBL ret_lsz_arr_p[]):
   # Given
   #   NUM_POINTS = points in PTS_ARR_PC array
   #   PTS_ARR_PC = array of x,y values(0-based)
   # Compute the least squares fit line to the
   #    XX and YY data
   #    y = ret_SLOPE * x + ret_INTERCEPT
   #    that passes through the first data point
   #    RET_ARR_P[0]  y-intercept of LS0 line
   #    RET_ARR_P[1]  slope       of LS0 line
   # returns the slope of said line
   DBL xxsum;
   DBL xysum;
   DBL dxx;
   DBL slope;
   INT j_ind;
   INT i_ind;
   xxsum = 0.0;
   xysum = 0.0;
   FOR i_ind FROM 1 TO num_points - 1:
      j_ind = 2 * i_ind;
      dxx = (pts_arr_pc[j_ind] - pts_arr_pc[0]);
      xxsum += dxx * dxx;
      xysum += dxx * (pts_arr_pc[j_ind + 1] - pts_arr_pc[1]);
   FOR_END
   slope = xysum / xxsum;
   ret_lsz_arr_p[1] = slope;
   ret_lsz_arr_p[0] = (pts_arr_pc[1] - slope * pts_arr_pc[0]);
   RETURN slope;
FUNC_END
#   IIIIIIIIIInsert-End ------------------------------ fit.fwip #
# must come after stts
#   IIIIIIIIIInsert-Begin ------------------------- approx.fwip #
#    COPYRIGHT C 2015-2020 by Kevin D. Woerner
# 2020-08-25 kdw  approx:var renam II
# 2020-08-24 kdw  approx:var renam
# 2020-08-17 kdw  approx:macro syntax changed
# 2020-07-27 kdw  approx:block syntax
# 2020-07-24 kdw  approx:comment cleanup
# 2020-07-16 kdw  approx:git/comment playing
# 2020-07-14 kdw  approx:cos[m]1 func
# 2020-07-12 kdw  approx:sqrttwo const
# 2020-07-10 kdw  approx:funcs mved out
# 2020-07-09 kdw  approx:mode-extended rmd
# 2020-07-08 kdw  approx:mode-exteneded rm test
# 2020-07-01 kdw  approx:tests modified
# 2020-06-30 kdw  approx:tests changed
# 2020-06-16 kdw  approx:comment added
# 2020-06-09 kdw  approx:comment changed
# 2020-06-08 kdw  approx:integral function stuff
# 2020-05-13 kdw  approx:comment trivially changed
# 2020-04-12 kdw  approx:comment change
# 2020-04-10 kdw  approx:comment change
# 2020-04-09 kdw  approx:MO[D]E syntax change
# 2020-04-08 kdw  approx:preprocess sigil change
# 2020-03-29 kdw  approx:ap[p]roxtga[m]ma.* mved to gamma
# 2020-03-27 kdw  approx:more tests added
# 2020-03-25 kdw  approx:tests added
# 2020-03-05 kdw  approx:appr[o]xexp.* refactor
# 2020-03-01 kdw  approx:rmed useless semicolons
# 2020-02-28 kdw  approx:poly eval work
# 2020-02-26 kdw  approx:comment change
# 2020-02-24 kdw  approx:function comments
# 2020-02-03 kdw  approx:.*_LOOP changed
# 2019-12-27 kdw  approx:eplicit K[w] module
# 2019-12-26 kdw  approx:module name addded to funcs
# 2019-11-17 kdw  approx:include Macros file
# 2019-10-23 kdw  approx:lntwo const
# 2019-08-24 kdw  approx:for and count loops have from clause
# 2019-08-22 kdw  approx:comment changed
# 2019-08-18 kdw  approx:B[O]OL to B[O]L
# 2019-08-17 kdw  approx:L[O]G to L[N]
# 2019-08-11 kdw  approx:comment cleanup
# 2019-08-06 kdw  approx:added "+" to array values
# 2019-06-02 kdw  approx:NR_ to RAPHSON_
# 2019-05-31 kdw  approx:NR_DO to RAPHSON_LOOP; et al
# 2019-05-29 kdw  approx:comment changed
# 2019-05-22 kdw  approx:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-05-01 kdw  approx:consts explicit module name
# 2019-04-22 kdw  approx:F[U]NC keyword
# 2019-03-28 kdw  approx:tg[a]mma approximation
# 2019-03-19 kdw  approx:re[t]_val to re[t]valu
# 2019-03-18 kdw  approx:macro syntax changed
# 2019-03-09 kdw  approx:.*mean() func renam
# 2019-03-08 kdw  approx:is[e]qual to is[e]q, et al.
# 2019-03-06 kdw  approx:is.* funcs changed
# 2019-01-13 kdw  approx:var rena; reorg
# 2019-01-03 kdw  approx:Await counter changed
# 2018-12-10 kdw  approx:approx-sqrt-2 func
# 2018-10-27 kdw  approx:secnt decl must be first decl
# 2018-09-26 kdw  approx:blank line; comment; var renam
# 2018-09-25 kdw  approx:a[p]prox[s]qrt_[_]1
# 2018-07-24 kdw  approx:func renam
# 2018-07-23 kdw  approx:func erf work
# 2018-07-18 kdw  approx:func renam
# 2018-05-16 kdw  approx:AR?RAY syntax
# 2018-05-13 kdw  approx:MO?DE.* syntax change
# 2018-04-23 kdw  approx:ap?proxn?thro?ot
# 2018-04-03 kdw  approx:rm() from return
# 2018-04-02 kdw  approx:Prototype, et al.
# 2018-03-26 kdw  approx:macro redef
# 2018-03-12 kdw  approx:made PP statements not need semicolon
# 2018-01-08 kdw  approx:appro[x]exp2
# 2017-11-26 kdw  approx:FR[O]M and B[Y] keywords
# 2017-11-22 kdw  approx:var renam
# 2017-11-21 kdw  approx:FR[O]M
# 2017-10-21 kdw  approx:macros start with "at""at"
# 2017-10-20 kdw  approx:COM[M]ENT syntax change
# 2017-09-20 kdw  approx:COM[M]ENT format change
# 2017-09-06 kdw  approx:UN[I]TS support
# 2017-08-30 kdw  approx:s/DBL_/DBL/;s/FLT_/FLT/
# 2017-08-22 kdw  approx:rmed REQ[U]IRES
# 2017-08-20 kdw  approx:rmed/renamd .*_P[E]R_.* vars
# 2017-04-26 kdw  approx:keyword COMMENT.*
# 2017-04-21 kdw  approx:var rename
# 2017-04-20 kdw  approx:func to function
# 2017-03-17 kdw  approx:space after comma
# 2017-03-10 kdw  approx:get Fw[i]p_Pa[r]se to work
# 2017-03-06 kdw  approx:sigils rmed
# 2017-03-01 kdw  approx:var[y]log-a[d]d space messup
# 2017-02-28 kdw  approx:REQ[U]IRE function()
# 2017-02-24 kdw  approx:REP[L]ACE rework, et al
# 2017-02-14 kdw  approx:FWIP Loop syntax changed
# 2017-02-13 kdw  approx:FWIP language change
# 2017-02-12 kdw  approx:FWIP language change
# 2017-02-08 kdw  approx:SE[C]ANT  syntax
# 2017-02-07 kdw  approx:comment rmed
# 2017-02-06 kdw  approx:COUNT syntax change
# 2017-01-06 kdw  approx:?[?]USE.* to ?[?].*_MODE
# 2016-12-02 kdw  approx:rmed def?ine
# 2016-11-23 kdw  approx:no postfix increment
# 2016-11-22 kdw  approx:eu?ler, cd?fno?rmal added
# 2016-11-22 kdw  approx:squareroot improved
# 2016-11-21 kdw  approx:DE?F to FU?NC
# 2016-11-20 kdw  approx:language change
# 2016-11-18 kdw  approx:_?_P?OD_?_
# 2016-11-16 kdw  approx:## comments
# 2016-11-15 kdw  approx:comments
# 2016-11-14 kdw  approx:LA[N]G stuff
# 2016-11-11 kdw  approx:seca?nt algorithm refactor
# 2016-11-08 kdw  approx:AW?AIT.*COU?NT syntax
# 2016-11-07 kdw  approx:LC_?EPI
# 2016-11-06 kdw  approx:isz?ero to iseq?ual
# 2016-10-31 kdw  approx:AW?AIT
# 2016-09-15 kdw  approx:lang change
# 2016-09-13 kdw  approx:lang change
# 2016-05-24 kdw  approx:long lines
# 2016-04-27 kdw  approx:_[_]USE* change
# 2016-03-12 kdw  approx:BC scale changed
# 2016-01-11 kdw  approx:l?og / ex?p work
# 2015-12-29 kdw  approx:tweak
# 2015-12-25 kdw  approx:er?fap?prox
# 2015-12-21 kdw  approx:ex[p]appro[x]2 deleted
# 2015-12-14 kdw  approx:long line
# 2015-12-11 kdw  approx:_[_]EN[D]IF_[_] obsoleted
# 2015-12-10 kdw  approx:improvements
# 2015-12-09 kdw  approx:sqrta[p]prox improvements
# 2015-12-08 kdw  approx:sqrta[p]prox
# 2015-12-04 kdw  approx:loga[p]prox
# 2015-12-02 kdw  approx:created
#   IIIIIIIIIInsert-Begin ------------------------- Macros.fwip #
#   IIIIIIIIIInsert-End --------------------------- Macros.fwip #
## Approximations of various functions calculated
## only with elementary operations(, -, *, /)
#   FFFFFFFFFFunction --------------------------------- sqrt__1 #
FUNC DBL sqrt__1(DBL xx):
   # calculate the YY=sqrt(XX) via
   #     Newtons method on f(x) = x**2 - XX
   #      x__n+1_ = x__n_ - f(x__n_) / df(x__n_)
   # Step A) Find ZZ in[1,4), and integer NN such that
   #           sqrt(XX) = 2**NN * sqrt(ZZ * 4**-NN)
   # Step B) find YY_0 such that 0 about YY_0**2 - ZZ
   # Step C) iterate Newtons method on F(YY) = YY ** 2 - ZZ
   #            YY_n+1 = (YY_n + ZZ / YY_n) / 2.0
   # Step D) return YY_n+1 * 2**NN about SQRT(XX)
   DBL yy_curr;
   DBL yy_prev;
   DBL zz;
   DBL power_of_two;
   IF xx <= 0.0:
      yy_curr = 0;
   ELSE:
      # Use SQRT(XX) = 2**n * SQRT(XX / 4**n)
      # to reduce arg to[1.0, 4.0)
      power_of_two = 1.0;
      zz = xx;
      WHILE 4.0 <= zz:
         zz /= 4;
         power_of_two *= 2.0;
      WHILE_END
      WHILE zz < 1.0:
         zz *= 4;
         power_of_two /= 2.0;
      WHILE_END
      # init guess via Least squares quadratic
      # on data(x, sqrt(x)) with x = 1 to 4 step 0.01
      yy_curr = (0.546382637992462 + zz * (0.502513025246083
            + zz * (-0.0353026277858345)));
      AWAIT Kw.iseq(yy_prev, yy_curr):
         # Newton loop
         yy_prev = yy_curr;
         yy_curr = (yy_curr + zz / yy_curr) / 2.0;
      AWAIT_END
      yy_curr *= power_of_two;
   IF_END
   RETURN yy_curr;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- sqrt__2 #
FUNC DBL sqrt__2(DBL xx):
   # calculate the YY=sqrt(XX) via explicitly
   # inverting the function XX=YY**2
   DBL scvx_xp;
   DBL scvx_xx;
   DBL scvx_yp;
   DBL scvx_yy;
   DBL scvx_dx;
   DBL scvx_dy;
   INT scvx_ii;
   DBL ini;
   IF xx <= 0.0:
      scvx_xx = 0.0;
   ELSE:
      IF 1 < xx:
         ini = xx / 2.0;
      ELSE:
         ini = 2.0 * xx;
      IF_END
      # return XX where
      #   xx - scvx_xx * scvx_xx(XX) == 0
      # BEG Secant Calculation
      scvx_dx = ini / 10.0;
      scvx_xx = ini;
      scvx_yy = xx - scvx_xx * scvx_xx;
      FOR scvx_ii FROM 0 TO 20:
         scvx_xp = scvx_xx;
         scvx_yp = scvx_yy;
         scvx_xx += scvx_dx;
         IF Kw.iseq(scvx_xp, scvx_xx):
            FOR_EXIT;
         IF_END
         scvx_yy = xx - scvx_xx * scvx_xx;
         scvx_dy = (scvx_yy - scvx_yp);
         IF Kw.iszero(scvx_dy):
            FOR_EXIT;
         IF_END
         scvx_dx *= - scvx_yy / scvx_dy;
      FOR_END
      # END Secant Calculation
   IF_END
   RETURN scvx_xx;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- sqrt__3 #
FUNC DBL sqrt__3(DBL yy):
   # calculate the XX=sqrt(YY) via
   # finding the zero of F(XX) = XX * XX - YY
   INT nrvx_ii;
   DBL nrvx_yy;
   DBL nrvx_xx;
   DBL nrvx_dy;
   DBL nrvx_xp;
   DBL ini;
   IF yy <= 0.0:
      nrvx_xx = 0.0;
   ELSE:
      IF 1 < yy:
         ini = yy / 2.0;
      ELSE:
         ini = 2.0 * yy;
      IF_END
      # return XX where
      #    nrvx_xx * nrvx_xx - yy(XX) == 0
      # BEG Newton-Raphson Calculation
      nrvx_xx = ini;
      FOR nrvx_ii FROM 0 TO 20:
         nrvx_xp = nrvx_xx;
         nrvx_dy = 2 * nrvx_xx;
         IF Kw.iszero(nrvx_dy):
            FOR_EXIT;
         IF_END
         nrvx_yy = nrvx_xx * nrvx_xx - yy;
         nrvx_xx -= nrvx_yy / nrvx_dy;
         IF Kw.iseq(nrvx_xp, nrvx_xx):
            FOR_EXIT;
         IF_END
      FOR_END
      # END Newton-Raphson Calculation
   IF_END
   RETURN nrvx_xx;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ nthroot__1 #
FUNC DBL nthroot__1(DBL xx
      , INT kk):
   # calculate the YY=XX**(1/KK) via
   #     Newtons method on f(x) = x**KK - XX
   #      x__n+1_ = x__n_ - f(x__n_) / df(x__n_)
   # Step A) find YY_0 such that 0 about YY_0**KK - XX
   # Step B) iterate Newtons method on F(YY) = YY ** KK - XX
   #      YY__n+1_ = (YY__n_ * (KK - 1)
   #               + XX / YY__n_ ** (KK - 1)) / KK
   # Step C) return YY_n+1
   DBL yy_curr;
   DBL yy_prev;
   DBL pp;
   INT ii;
   IF xx <= 0.0:
      yy_curr = 0;
   ELSE:
      yy_curr = xx / 2.0;
      AWAIT Kw.iseq(yy_prev, yy_curr):
         # Newton loop
         yy_prev = yy_curr;
         pp = yy_curr;
         FOR ii FROM 2 TO kk - 1:
            pp *= yy_curr;
         FOR_END
         yy_curr = (yy_curr * (kk - 1) + xx / pp) / kk;
      AWAIT_END
   IF_END
   RETURN yy_curr;
FUNC_END
BLOCK:
   BLOCK_DEF CONST LC_EPS Kw.DBLEPS / 16.0;
   #   FFFFFFFFFFunction ---------------------------- cossin_ev #
   FUNC DBL cossin_ev(INT init_ii
         , DBL xx_rad
         , BOL addone_mult):
      #         +INF(-1)**N * XX_RAD**(2*N+INIT_II)
      #          SUM ---------------------------------
      # N=init_ii+1      factorial(2*N+INIT_II)
      DBL cval;
      INT ii;
      DBL trig_sum;
      DBL xr_rad;
      DBL xr_sqr;
      IF Kw.iszero(xx_rad):
         trig_sum = 0.0;
      ELSE:
         xr_rad = Kw.fmods(xx_rad, Kw.TAU);
         xr_sqr = -xr_rad * xr_rad;
         cval = 1;
         ii = init_ii;
         WHILE LC_EPS < ABS(cval):
            ii += 2;
            cval *= xr_sqr / (ii * (ii - 1));
         WHILE_END
         # use Horners method
         trig_sum = 1.0 / (ii * (ii + 1.0));
         WHILE 1 < ii:
            trig_sum += 1.0;
            trig_sum *= xr_sqr / (ii * (ii - 1));
            ii -= 2;
         WHILE_END
         IF addone_mult:
            trig_sum += 1.0;
            trig_sum *= xr_rad;
         IF_END
      IF_END
      RETURN trig_sum;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------- cos__1 #
   FUNC DBL cos__1(DBL xx_rad):
      # calculate COS(XX) via Taylor series
      RETURN cossin_ev(0, xx_rad, FALSE) + 1.0;
   FUNC_END
   #   FFFFFFFFFFunction ----------------------------- cosm1__1 #
   FUNC DBL cosm1__1(DBL xx_rad):
      # calculate COS(XX) via Taylor series
      RETURN cossin_ev(0, xx_rad, FALSE);
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------- sin__1 #
   FUNC DBL sin__1(DBL xx_rad):
      # calculate SIN(XX) via Taylor series
      RETURN cossin_ev(1, xx_rad, TRUE);
   FUNC_END
   #   FFFFFFFFFFunction ------------------------------ sinc__1 #
   FUNC DBL sinc__1(DBL xx_rad):
      # calculate SINC(XX) via Taylor series
      DBL retvalu;
      IF Kw.iszero(xx_rad):
         retvalu = 1.0;
      ELSE:
         IF Kw.TAU / 2 < ABS(xx_rad):
            retvalu = cossin_ev(1, xx_rad, TRUE);
            retvalu /= xx_rad;
         ELSE:
            retvalu = cossin_ev(1, xx_rad, FALSE) + 1.0;
         IF_END
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END
      #   FFFFFFFFFFunction ----------------------------------
   #exp__1 #
FUNC DBL exp__1(DBL xx):
   # calculate the YY=EXP(XX) via Taylor series
   INT ii;
   DBL vale;
   DBL axx;
   DBL exp_sum;
   DBL retvalu;
   INT squarings;
   # Calculate the absolute value of XX,
   IF xx < 0:
      axx = -xx;
   ELSE:
      axx = xx;
   IF_END
   # Now 0 <= XX; Use the fact that exp(2*x) = exp(x)**2
   # to reduce AXX to < 1
   squarings = 0;
   WHILE 1.0 < axx:
      axx /= 2.0;
      squarings += 1;
   WHILE_END
   # figure out how many term of the Taylor series of exp(axx)
   # we need to get the desired precision
   vale = 1.0;
   ii = 1;
   WHILE Kw.DBLEPS / 10.0 < vale:
      ii += 1;
      vale *= axx / ii;
   WHILE_END
   # use Horners method to evaluate the Taylor series at AXX
   exp_sum = 1.0 / (ii + 1.0);
   WHILE 0 < ii:
      exp_sum = 1.0 + axx * (exp_sum / ii);
      ii -= 1;
   WHILE_END
   # take care of negative arguments
   IF xx < 0.0:
      retvalu = 1.0 / exp_sum;
   ELSE:
      retvalu = exp_sum;
   IF_END
   # Use exp(2*x) = exp(x)**2 to calculate exp(XX)
   WHILE 0 < squarings:
      retvalu *= retvalu;
      squarings -= 1;
   WHILE_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- exp__2 #
FUNC DBL exp__2(DBL xx):
   # calculate the YY=EXP(XX) via Taylor series
   INT ii;
   DBL axx;
   DBL expmo_sum;
   DBL retvalu;
   INT squarings;
   DBL vale;
   IF xx < 0:
      axx = -xx;
   ELSE:
      axx = xx;
   IF_END
   squarings = 0;
   WHILE 1 < axx:
      axx /= 2.0;
      squarings += 1;
   WHILE_END
   # Now 0 <= AXX < 1
   # figure out how many term of the Taylor series of exp(axx)
   # we need to get the desired precision
   vale = 1.0;
   ii = 1;
   WHILE Kw.DBLEPS / 4.0 < vale:
      ii += 1;
      vale *= axx / ii;
   WHILE_END
   expmo_sum = 0;
   WHILE 0 < ii:
      expmo_sum = axx * (expmo_sum + 1.0) / ii;
      ii -= 1;
   WHILE_END
   FOR ii FROM 1 TO squarings:
      expmo_sum *= (2.0 + expmo_sum);
   FOR_END
   IF xx < 0:
      retvalu = 1.0 / (expmo_sum + 1.0);
   ELSE:
      retvalu = expmo_sum + 1.0;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- ln__1 #
FUNC DBL ln__1(DBL xx):
   # Wikipedia/Logarithm/Arithmetic-geometric mean
   # approximation
   DBL yy_curr;
   INT logstep;
   DBL retvalu;
   DBL tmp;
   LANGUAGE LANG_BC:# extended resolution
      scale *= 2;
   LANGUAGE_END# extended resolution
   logstep = 0;
   yy_curr = 8.0 / xx;
   # YY_CURR = 2**(3 - LOGSTEP) / XX
   tmp = (Kw.DBLEPS);
   WHILE tmp < yy_curr:
      logstep -= 16;
      # LOGSTEP -= LOGSTEPINC
      yy_curr /= 65536.0;
      # YY_CURR /= 2**LOGSTEPINC
   WHILE_END
   retvalu = (Kw.PI / Kw.agmean(2.0, yy_curr) + logstep
         * Kw.LNTWO);
   LANGUAGE LANG_BC:# extended resolution
      scale /= 2;
   LANGUAGE_END# extended resolution
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ----------------------------------- ln__2 #
FUNC DBL ln__2(DBL xx):
   # Wikipedia/Logarithm
   DBL yy_curr;
   DBL ptwo;
   DBL term;
   DBL nn;
   DBL sum_curr;
   DBL sum_prev;
   DBL mant;
   yy_curr = xx;
   ptwo = 0.0;
   WHILE Kw.SQRTTWO < yy_curr:
      ptwo += 1;
      yy_curr /= 2.0;
   WHILE_END
   WHILE yy_curr < 1.0 / Kw.SQRTTWO:
      ptwo -= 1;
      yy_curr *= 2.0;
   WHILE_END
   # Now YY_CURR is in[1 / SQRTTWO,SQRTTWO],
   #      and XX = YY_CURR * 2 ** PTWO
   mant = (yy_curr - 1.0) / (yy_curr + 1.0);
   sum_curr = 2.0 * mant;
   term = sum_curr;
   mant *= mant;
   AWAIT Kw.iseq(sum_curr, sum_prev) COUNT nn FROM 3 BY 2:
      term *= mant;
      sum_prev = sum_curr;
      sum_curr += term / nn;
   AWAIT_END
   RETURN ptwo * Kw.LNTWO + sum_curr;
FUNC_END
#   FFFFFFFFFFunction -------------------------------- euler__1 #
FUNC DBL euler__1(NUL):
   # approximate the Euler constant
   DBL twon;
   DBL exptwon;
   INT nn;
   DBL term;
   DBL subsum;
   DBL sum_curr;
   DBL sum_prev;
   INT mm;
   twon = 1.0;
   exptwon = Kw.E;
   AWAIT 0.1 < Kw.DBLEPS * exptwon COUNT nn FROM 0:
      twon *= 2.0;
      exptwon *= exptwon;
   AWAIT_END
   term = 1.0 / twon;
   subsum = 0.0;
   sum_curr = 0.0;
   AWAIT Kw.iseq(sum_prev, sum_curr) COUNT mm FROM 1:
      subsum += 1.0 / mm;
      term *= twon / mm;
      sum_prev = sum_curr;
      sum_curr += term * subsum;
   AWAIT_END
   RETURN twon * sum_curr / exptwon - (nn + 1) * Kw.LNTWO;
FUNC_END
#TEST:ln__1(exp__1(8.6))==8.6;
#TEST:exp__1(ln__1(8.6))==8.6;
#TEST:cos__1(1)==0.54030230586813971740093660744297660373231;
#TEST:sin__1(1)==0.84147098480789650665250232163029899962256;
#TEST:exp__1(2)==7.38905609893065022723042746057500781318032;
#TEST:euler__1()==0.5772156649015328606065120900824024310422;
#   IIIIIIIIIInsert-End --------------------------- approx.fwip #
#   IIIIIIIIIInsert-Begin ------------------------- sphere.fwip #
#    COPYRIGHT C 2016-2020 by Kevin D. Woerner
# 2020-08-17 kdw  sphere:comment change
# 2020-08-03 kdw  sphere:explicit module for pi and tau
# 2020-07-27 kdw  sphere:block syntax
# 2020-07-24 kdw  sphere:comment cleanup
# 2020-06-03 kdw  sphere:writeonly keyword
# 2020-05-11 kdw  sphere:local-func syntax changed
# 2020-05-08 kdw  sphere:local function block
# 2020-04-12 kdw  sphere:comment change
# 2020-04-08 kdw  sphere:preprocess sigil change
# 2020-03-09 kdw  sphere:LO[C]AL_.* keywords
# 2020-03-03 kdw  sphere:comment changed:odd chars
# 2020-03-02 kdw  sphere:s/_N[E]XT/_E[N]D/
# 2020-01-28 kdw  sphere:updated w/ new ellisp.* funcs
# 2020-01-17 kdw  sphere:rmed useless funcs
# 2020-01-16 kdw  sphere:ell.*_dist.* inf loop protection
# 2019-12-27 kdw  sphere:eplicit K[w] module
# 2019-12-26 kdw  sphere:module name addded to funcs
# 2019-10-04 kdw  sphere:comment change
# 2019-08-11 kdw  sphere:comment cleanup
# 2019-08-06 kdw  sphere:rmed backslashes, macro arg renam
# 2019-07-04 kdw  sphere:comment change
# 2019-07-01 kdw  sphere:desc of el[l]ipsoid_get func
# 2019-06-04 kdw  sphere:func comments added
# 2019-05-29 kdw  sphere:comment changed
# 2019-05-24 kdw  sphere:local replaced private
# 2019-05-22 kdw  sphere:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-05-01 kdw  sphere:consts explicit module name
# 2019-03-19 kdw  sphere:re[t]_val to re[t]valu
# 2019-03-08 kdw  sphere:is[e]qual to is[e]q, et al.
# 2019-03-06 kdw  sphere:is.* funcs changed
# 2019-02-28 kdw  sphere:REP[L]ACE/DE[F]INE work
# 2019-01-13 kdw  sphere:var rena; reorg
# 2018-12-29 kdw  sphere:backslash reposition
# 2018-12-16 kdw  sphere:BC: func args starting with " -"
# 2018-11-05 kdw  sphere:ellipsoid_get_.* rearrange
# 2018-10-04 kdw  sphere:uppercased fwip trig funcs
# 2018-07-13 kdw  sphere:minor tweak
# 2018-05-14 kdw  sphere:var renam
# 2018-04-03 kdw  sphere:rm() from return
# 2018-03-27 kdw  sphere:continuation lines
# 2018-03-20 kdw  sphere:replaced index w/ "at"replace
# 2018-03-16 kdw  sphere:format of constant and index change
# 2018-02-21 kdw  sphere:inv trig func renam: s/a(.*)/inv/
# 2018-02-14 kdw  sphere:IN[D]EX stuff
# 2017-11-22 kdw  sphere:var renam
# 2017-10-21 kdw  sphere:macros start with "at"
# 2017-10-20 kdw  sphere:RE[P]LACE syntax changed
# 2017-09-13 kdw  sphere:destination function
# 2017-09-12 kdw  sphere:heading function changed
# 2017-08-22 kdw  sphere:rmed REQ[U]IRES
# 2017-04-21 kdw  sphere:func to function
# 2017-03-12 kdw  sphere:shorten long comments
# 2017-03-06 kdw  sphere:sigils rmed
# 2017-03-01 kdw  sphere:var[y]log-a[d]d space messup
# 2017-02-28 kdw  sphere:REQ[U]IRE function()
# 2017-02-14 kdw  sphere:FWIP Loop syntax changed
# 2017-02-13 kdw  sphere:FWIP language change
# 2017-02-12 kdw  sphere:FWIP language change
# 2017-01-04 kdw  sphere:rmed ref to at[a]n
# 2016-12-31 kdw  sphere:var rename
# 2016-12-27 kdw  sphere:ellipsoid_* functions
# 2016-12-26 kdw  sphere:created
#   FFFFFFFFFFunction -------------------------------- sphere_d #
FUNC DBL sphere_d(DBL lata_rad
      , DBL lona_rad
      , DBL latb_rad
      , DBL lonb_rad):
   # great circle distance on a sphere of radius 1
   # from https://en.wikipedia.org/wiki/Great-circle_distance
   DBL xc;
   DBL xd;
   DBL xe;
   DBL c_lond;
   DBL s_lond;
   DBL c_lata;
   DBL c_latb;
   DBL s_lata;
   DBL s_latb;
   DBL retvalu;
   c_lata = COS(lata_rad);
   c_latb = COS(latb_rad);
   s_lata = SIN(lata_rad);
   s_latb = SIN(latb_rad);
   s_lond = SIN(lonb_rad - lona_rad);
   c_lond = COS(lonb_rad - lona_rad);
   xc = c_lata * s_latb - s_lata * c_latb * c_lond;
   xd = c_latb * s_lond;
   xe = s_lata * s_latb + c_lata * c_latb * c_lond;
   retvalu = ATAN2(Kw.hypot(xd, xc), xe);
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------- great_circle_distance #
FUNC DBL great_circle_distance(DBL lata_rad
      , DBL lona_rad
      , DBL latb_rad
      , DBL lonb_rad):
   # great circle distance on the unit sphere
   # between the two sets of latitude and longitude
   RETURN sphere_d(lata_rad, lona_rad, latb_rad, lonb_rad);
FUNC_END
#   FFFFFFFFFFunction ------------------------- sphere_distance #
FUNC DBL sphere_distance(DBL lata_rad
      , DBL lona_rad
      , DBL latb_rad
      , DBL lonb_rad
      , WRITEONLY DBL ret_dirs_arr_p[]):
   # distance on an sphere with radius 1,
   # between the two given points
   # RET_DIRS_ARR_P[0] = direction from A to B
   # RET_DIRS_ARR_P[1] = direction from B to A
   # See https://en.wikipedia.org/wiki/Vincentys_formulae
   DBL xc;
   DBL xd;
   DBL xe;
   DBL s_lond;
   DBL c_lond;
   DBL c_lata;
   DBL c_latb;
   DBL s_lata;
   DBL s_latb;
   DBL dist;
   c_lata = COS(lata_rad);
   c_latb = COS(latb_rad);
   s_lata = SIN(lata_rad);
   s_latb = SIN(latb_rad);
   s_lond = SIN(lonb_rad - lona_rad);
   c_lond = COS(lonb_rad - lona_rad);
   # heading from pointA to pointB
   xc = c_lata * s_latb - s_lata * c_latb * c_lond;
   xd = c_latb * s_lond;
   ret_dirs_arr_p[0] = ATAN2(xd, xc);
   xe = s_lata * s_latb + c_lata * c_latb * c_lond;
   dist = ATAN2(Kw.hypot(xd, xc), xe);
   # heading from pointB to pointA
   xc = c_latb * s_lata - s_latb * c_lata * c_lond;
   xd = c_lata * s_lond;
   ret_dirs_arr_p[1] = -ATAN2(xd, xc);
   RETURN dist;
FUNC_END
BLOCK:# ellipsiod funcitons
   #   FFFFFFFFFFunction -------------------------------- lf_ka #
   BLOCK_DEF FUNC DBL lf_ka(DBL usq):
      DBL hyp;
      hyp = SQRT(1.0 + usq);
      RETURN (hyp - 1.0) / (hyp + 1.0);
   FUNC_END
   #   FFFFFFFFFFunction ----------------------------- lf_cap_a #
   BLOCK_DEF FUNC DBL lf_cap_a(DBL usq):
      DBL ka;
      ka = lf_ka(usq);
      RETURN (1.0 + Kw.square(ka / 2.0)) / (1.0 - ka);
   FUNC_END
   #   FFFFFFFFFFunction ----------------------------- lf_cap_b #
   BLOCK_DEF FUNC DBL lf_cap_b(DBL usq):
      DBL ka;
      ka = lf_ka(usq);
      RETURN ka * (1.0 - 3.0 * Kw.square(ka) / 8.0);
   FUNC_END
   #   FFFFFFFFFFunction ------------------- ellipsoid_distance #
   FUNC DBL ellipsoid_distance(DBL flat
         , DBL lata_rad
         , DBL lona_rad
         , DBL latb_rad
         , DBL lonb_rad
         , WRITEONLY DBL ret_dirs_arr_p[]):
      # distance on an ellipsoid with radius 1,
      # flattening FLAT between the two given points
      # RET_DIRS_ARR_P[0] = direction from A to B
      # RET_DIRS_ARR_P[1] = direction from B to A
      # See https://en.wikipedia.org/wiki/Vincentys_formulae
      DBL iflat;
      DBL cap_ua;
      DBL cap_ub;
      DBL lon_diff;
      DBL c_cap_ua;
      DBL s_cap_ua;
      DBL c_cap_ub;
      DBL s_cap_ub;
      DBL xx_curr;
      DBL xx_prev;
      DBL xc;
      DBL xd;
      DBL s_xx;
      DBL c_xx;
      DBL c_sig;
      DBL s_sig;
      DBL sig;
      DBL s_alpha;
      DBL c_alpha_sq;
      DBL cbsigm;
      DBL cap_c;
      DBL usq;
      DBL cap_a;
      DBL cap_b;
      DBL deltasig;
      INT ii;
      DBL dist;
      iflat = 1.0 - flat;
      cap_ua = ATAN2(iflat * SIN(lata_rad), COS(lata_rad));
      cap_ub = ATAN2(iflat * SIN(latb_rad), COS(latb_rad));
      lon_diff = lonb_rad - lona_rad;
      xx_curr = lon_diff;
      c_cap_ua = COS(cap_ua);
      c_cap_ub = COS(cap_ub);
      s_cap_ua = SIN(cap_ua);
      s_cap_ub = SIN(cap_ub);
      AWAIT ABS(xx_curr - xx_prev) < 1.0E-12 COUNT ii FROM 0:
         s_xx = SIN(xx_curr);
         c_xx = COS(xx_curr);
         s_sig = Kw.hypot(c_cap_ub * s_xx, c_cap_ua * s_cap_ub
               - s_cap_ua * c_cap_ub * c_xx);
         c_sig = s_cap_ua * s_cap_ub + c_cap_ua * c_cap_ub
               * c_xx;
         sig = ATAN2(s_sig, c_sig);
         s_alpha = c_cap_ua * c_cap_ub * s_xx / s_sig;
         c_alpha_sq = 1.0 - Kw.square(s_alpha);
         cbsigm = c_sig - Kw.divi(2.0 * s_cap_ua * s_cap_ub
               , c_alpha_sq, 0);
         cap_c = ((flat / 16.0) * c_alpha_sq * (4.0 + flat
               * (4.0 - 3.0 * c_alpha_sq)));
         xx_prev = xx_curr;
         xx_curr = (lon_diff + (1.0 - cap_c) * flat * s_alpha
               * (sig + cap_c * s_sig * (cbsigm + cap_c * c_sig
               * (2.0 * Kw.square(cbsigm) - 1.0))));
         IF 10 < ii AND Kw.iseq(ABS(xx_prev + xx_curr), Kw.TAU):
            xx_curr = Kw.TAU / 2.0;
            AWAIT_EXIT;
         IF_END
      AWAIT_END
      usq = c_alpha_sq * (1.0 / Kw.square(iflat) - 1.0);
      cap_a = iflat * lf_cap_a(usq);
      cap_b = lf_cap_b(usq);
      deltasig = cap_b * s_sig * (cbsigm + 0.25 * cap_b
            * (c_sig * (-1.0 + 2.0 * Kw.square(cbsigm)) - (1.0
            / 6.0) * cap_b * cbsigm * (3.0 + 4.0
            * Kw.square(s_sig)) * (-3.0 + 4.0
            * Kw.square(cbsigm))));
      dist = cap_a * (sig - deltasig);
      # heading from point0 to point1
      xc = c_cap_ua * s_cap_ub - s_cap_ua * c_cap_ub * c_xx;
      xd = c_cap_ub * s_xx;
      ret_dirs_arr_p[0] = ATAN2(xd, xc);
      # heading from point1 to point0
      xc = c_cap_ub * s_cap_ua - s_cap_ub * c_cap_ua * c_xx;
      xd = c_cap_ua * s_xx;
      ret_dirs_arr_p[1] = -ATAN2(xd, xc);
      RETURN dist;
   FUNC_END
   #   FFFFFFFFFFunction ---------------- ellipsoid_destination #
   FUNC DBL ellipsoid_destination(DBL flat
         , DBL lata_rad
         , DBL lona_rad
         , DBL heading_rad
         , DBL distance
         , WRITEONLY DBL ret_loc_arr_p[]):
      # calculate the endpoint(and bearing) of a geodesic
      #    on an ellipsoid with radius 1, and flattening FLAT:
      #    starting at(LAT_A, LON_A) w/ heading HEADING
      #    and going distance DISTANCE
      # See https://en.wikipedia.org/wiki/Vincentys_formulae
      DBL iflat;
      DBL cap_ua;
      DBL c_cap_ua;
      DBL s_cap_ua;
      DBL sig_rad;
      DBL sig_rad_prev;
      DBL sig_rad_delta;
      DBL c_sig;
      DBL s_sig;
      DBL aa;
      DBL bb;
      DBL sig_b_rad;
      DBL s_alpha;
      DBL c_alpha_sq;
      DBL twosigm_rad;
      DBL c_twosigm;
      DBL c_twosigm_sq;
      DBL cap_c;
      DBL usq;
      DBL cap_a;
      DBL cap_b;
      DBL cap_l;
      DBL alpha_rad;
      DBL c_heading;
      DBL s_heading;
      DBL lamda;
      DBL xd;
      DBL xc;
      iflat = 1.0 - flat;
      aa = 1.0;
      bb = iflat * aa;
      cap_ua = ATAN2(iflat * SIN(lata_rad), COS(lata_rad));
      c_cap_ua = COS(cap_ua);
      s_cap_ua = SIN(cap_ua);
      c_heading = COS(heading_rad);
      s_heading = SIN(heading_rad);
      sig_b_rad = ATAN2(s_cap_ua, c_cap_ua * c_heading);
      s_alpha = COS(cap_ua) * SIN(heading_rad);
      c_alpha_sq = 1.0 - Kw.square(s_alpha);
      usq = c_alpha_sq * (Kw.square(aa / bb) - 1.0);
      cap_a = lf_cap_a(usq);
      cap_b = lf_cap_b(usq);
      sig_rad_delta = 0.0;
      sig_rad = -10.0;
      AWAIT Kw.iseq(sig_rad, sig_rad_prev):
         sig_rad_prev = sig_rad;
         sig_rad = distance / (bb * cap_a) + sig_rad_delta;
         # the following vars are used later, so calc them here
         s_sig = SIN(sig_rad);
         c_sig = COS(sig_rad);
         twosigm_rad = 2.0 * sig_b_rad + sig_rad;
         c_twosigm = COS(twosigm_rad);
         c_twosigm_sq = Kw.square(c_twosigm);
         sig_rad_delta = cap_b * s_sig * (c_twosigm + 0.25
               * cap_b * (c_sig * (2.0 * c_twosigm_sq - 1.0)
               - (cap_b / 6.0) * c_twosigm * (4.0
               * Kw.square(s_sig) - 3.0) * (4.0 * c_twosigm_sq
               - 3.0)));
      AWAIT_END
      xd = s_cap_ua * c_sig + c_cap_ua * s_sig * c_heading;
      xc = iflat * Kw.hypot(s_alpha, s_cap_ua * s_sig
            - c_cap_ua * c_sig * c_heading);
      ret_loc_arr_p[0] = ATAN2(xd, xc);
      xd = s_sig * s_heading;
      xc = c_cap_ua * c_sig - s_cap_ua * s_sig * c_heading;
      lamda = ATAN2(xd, xc);
      cap_c = ((flat / 16.0) * c_alpha_sq * (4.0 + flat * (4.0
            - 3.0 * c_alpha_sq)));
      cap_l = lamda - (1.0 - cap_c) * flat * s_alpha * (sig_rad
            + cap_c * s_sig * (c_twosigm + cap_c * c_sig * (2.0
            * c_twosigm_sq - 1.0)));
      ret_loc_arr_p[1] = cap_l + lona_rad;
      alpha_rad = Kw.fmodu(Kw.PI + ATAN2(s_alpha, c_cap_ua
            * c_sig * c_heading - s_cap_ua * s_sig), Kw.TAU);
      RETURN alpha_rad;
   FUNC_END
BLOCK_END# ellipsiod funcitons
#   IIIIIIIIIInsert-End --------------------------- sphere.fwip #
#   IIIIIIIIIInsert-Begin ---------------------------- shc.fwip #
#    COPYRIGHT C 2017-2020 by Kevin D. Woerner
# 2020-07-24 kdw  shc:comment cleanup
# 2020-04-12 kdw  shc:comment change
# 2020-03-01 kdw  shc:reorg
# 2020-02-26 kdw  shc:comment change
# 2020-02-03 kdw  shc:single return statment
# 2019-12-27 kdw  shc:eplicit K[w] module
# 2019-08-11 kdw  shc:comment cleanup
# 2019-05-22 kdw  shc:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-03-19 kdw  shc:re[t]_val to re[t]valu
# 2019-03-11 kdw  shc:comments to array dcls
# 2018-10-08 kdw  shc:vbdotnet stuff
# 2018-07-20 kdw  shc:array reformat("+" added)
# 2018-07-19 kdw  shc:comments; array reformat
# 2018-07-13 kdw  shc:minor tweak
# 2018-05-17 kdw  shc:ARR?AY.* and HOR[N]ER syntax
# 2018-05-16 kdw  shc:AR?RAY syntax
# 2018-04-03 kdw  shc:rm() from return
# 2018-01-27 kdw  shc:majopr refactor; poles=5
# 2017-12-13 kdw  shc:created
#   FFFFFFFFFFunction --------------------- shc_shftpoles2steps #
FUNC DBL shc_shftpoles2steps(INT shft
      , INT poles):
   DBL step_arr[20];
   DBL retvalu;
   IF poles <= 0:
      retvalu = 0.0;
   ELSIF shft < 0:
      retvalu = 0.0;
   ELSIF 16 < shft:
      retvalu = 1000000000.0;
   ELSIF poles == 1:
      # step_arr(ii) is approximately 6.297 * 2 ** ii
      ARRAY step_arr[]:# 1 pole step array
         + 1.00000000E+0;
         + 8.75664018E+0;
         + 2.174418277E+1;
         + 4.709615109E+1;
         + 9.755325605E+1;
         + 1.983575685E+2;
         + 3.9991425188E+2;
         + 8.0300236937E+2;
         + 1.60916613901E+3;
         + 3.22148750069E+3;
         + 6.44612712926E+3;
         + 1.289540487229E+4;
         + 2.579395961911E+4;
         + 5.159106828928E+4;
         + 1.0318528839545E+5;
         + 2.0637372529029E+5;
         + 4.1275053067337E+5;
      ARRAY_END
      retvalu = step_arr[shft];
   ELSIF poles == 2:
      # step_arr(ii) is approximately 9.778 * 2 ** ii
      ARRAY step_arr[]:# 2 pole step array
         + 1.000000000E+0;
         + 1.372295755E+1;
         + 3.383938971E+1;
         + 7.318281398E+1;
         + 1.5153838699E+2;
         + 3.0810336456E+2;
         + 6.2116437416E+2;
         + 1.24725288016E+3;
         + 2.49941335432E+3;
         + 5.00372613671E+3;
         + 1.001234749878E+4;
         + 2.002958840334E+4;
         + 4.006406905172E+4;
         + 8.013303000155E+4;
         + 1.6027095510986E+5;
         + 3.2054680443102E+5;
         + 6.4109851712798E+5;
      ARRAY_END
      retvalu = step_arr[shft];
   ELSIF poles == 3:
      # step_arr(ii) is approximately 12.34255 * 2 ** ii
      ARRAY step_arr[]:# 3 pole step array
         + 1.000000000E+0;
         + 1.737173781E+1;
         + 4.273609545E+1;
         + 9.238532150E+1;
         + 1.9128399554E+2;
         + 3.8890510497E+2;
         + 7.8406421045E+2;
         + 1.57434201644E+3;
         + 3.15487771808E+3;
         + 6.31593923478E+3;
         + 1.263805730898E+4;
         + 2.528229097067E+4;
         + 5.057075779500E+4;
         + 1.0114768912723E+5;
         + 2.0230154729287E+5;
         + 4.0460928016924E+5;
         + 8.0922476138170E+5;
      ARRAY_END
      retvalu = step_arr[shft];
   ELSIF poles == 4:
      # step_arr(ii) is approximately 14.4655 * 2 ** ii
      ARRAY step_arr[]:# 4 pole step array
         + 1.00000000E+0;
         + 2.03878236E+1;
         + 5.009900279E+1;
         + 1.0828162825E+2;
         + 2.2418834788E+2;
         + 4.5579968748E+2;
         + 9.189270663E+2;
         + 1.84513549236E+3;
         + 3.69752950942E+3;
         + 7.40230620593E+3;
         + 1.48118537839E+4;
         + 2.963094667636E+4;
         + 5.926913086318E+4;
         + 1.1854549900613E+5;
         + 2.3709822433702E+5;
         + 4.7420371217077E+5;
         + 9.4841452431326E+5;
      ARRAY_END
      retvalu = step_arr[shft];
   ELSIF poles == 5:
      # step_arr(ii) is approximately 16.3168 * 2 ** ii
      ARRAY step_arr[]:# 5 pole step array
         + 1.000000000E+0;
         + 2.301559338E+1;
         + 5.651862690E+1;
         + 1.2214337218E+2;
         + 2.5288215751E+2;
         + 5.1413464355E+2;
         + 1.03653347249E+3;
         + 2.08127953713E+3;
         + 4.17074621528E+3;
         + 8.34966697295E+3;
         + 1.670750214140E+4;
         + 3.342316957219E+4;
         + 6.685449836446E+4;
         + 1.3371716646729E+5;
         + 2.6744248565129E+5;
         + 5.3489319815476E+5;
         + 1.06979462735136E+6;
      ARRAY_END
      retvalu = step_arr[shft];
   ELSE:
      retvalu = 0.0;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------- shc_steps2shft #
FUNC DBL shc_steps2shft(DBL steps):
   RETURN Kw.lg(steps + 8.5) - 3.85514;
FUNC_END
#   FFFFFFFFFFunction ----------------------- shc_steps2shftinv #
FUNC DBL shc_steps2shftinv(DBL shft):
   RETURN POW(2.0, (shft + 3.85514)) - 8.5;
FUNC_END
#   FFFFFFFFFFunction -------------------------- shc_shft2steps #
FUNC DBL shc_shft2steps(INT shft):
   RETURN shc_shftpoles2steps(shft, 4);
FUNC_END
#   IIIIIIIIIInsert-End ------------------------------ shc.fwip #
#   IIIIIIIIIInsert-Begin ----------------------- elliptic.fwip #
#    COPYRIGHT C 2018-2020 by Kevin D. Woerner
# 2020-08-17 kdw  elliptic:macro syntax changed
# 2020-08-12 kdw  elliptic:peak value for elliptic1
# 2020-08-11 kdw elliptic:botched extending elliptic1 to 1 < m II
# 2020-08-10 kdw  elliptic:k,a parameter funcs
# 2020-08-07 kdw  elliptic:botched extending elliptic1 to 1 < m
# 2020-08-03 kdw  elliptic:explicit module for pi and tau
# 2020-07-27 kdw  elliptic:block syntax
# 2020-07-24 kdw  elliptic:comment cleanup
# 2020-07-23 kdw  elliptic:minor reorg
# 2020-07-07 kdw  elliptic:extend to m<0 and 1<m II
# 2020-07-05 kdw  elliptic:extend to m<0 and 1<m
# 2020-07-03 kdw  elliptic:cir[2]ell and ell[2]cir funcs
# 2020-07-02 kdw  elliptic:debugging
# 2020-06-30 kdw  elliptic:tests changed
# 2020-06-26 kdw  elliptic:more theta functions#
# 2020-06-25 kdw  elliptic:theta functions
# 2020-06-23 kdw  elliptic:comment correction
# 2020-06-20 kdw  elliptic:jacobi pq funcs renam
# 2020-06-15 kdw  elliptic:rework of jacobi funcs
# 2020-06-12 kdw  elliptic:more jacobi funcs
# 2020-06-10 kdw  elliptic:tests: more sig figs
# 2020-06-09 kdw  elliptic:elli[p]ticEi debugging
# 2020-06-08 kdw  elliptic:integral function stuff
# 2020-06-06 kdw  elliptic:comment change
# 2020-05-20 kdw  elliptic:module for pi made explicit
# 2020-04-26 kdw  elliptic:block indentation
# 2020-04-12 kdw  elliptic:comment change
# 2020-04-02 kdw  elliptic:re[t]urn rework
# 2020-04-01 kdw  elliptic:t[a]n to TA[N]
# 2020-03-03 kdw  elliptic:comment change
# 2020-03-02 kdw  elliptic:s/_N[E]XT/_[E]ND/
# 2020-02-24 kdw  elliptic:function comments
# 2020-02-21 kdw  elliptic:car[l]sonR[FCDJ] funcs
# 2020-02-19 kdw  elliptic:e[l]liptic[3P] funcs
# 2020-02-18 kdw  elliptic:e[l]liptic[1KF]i? funcs
# 2019-12-27 kdw  elliptic:explicit K[w] module
# 2019-12-26 kdw  elliptic:module name addded to funcs
# 2019-10-04 kdw  elliptic:comment change
# 2019-08-24 kdw  elliptic:for and count loops have from clause
# 2019-08-06 kdw  elliptic:rmed backslahses;macro arg renam
# 2019-06-02 kdw  elliptic:elliptic1 wtf?; no net change
# 2019-05-29 kdw  elliptic:comment changed
# 2019-05-22 kdw  elliptic:s/FU[N]CT[I]ON/FU[N]C/g
# 2019-05-16 kdw  elliptic:loop limit def mved
# 2019-05-01 kdw  elliptic:consts explicit module name
# 2019-03-15 kdw  elliptic:use to[p]yh1
# 2019-03-09 kdw  elliptic:.*mean() func renam
# 2019-03-08 kdw  elliptic:is[e]qual to is[e]q, et al.
# 2019-03-06 kdw  elliptic:is.* funcs changed
# 2019-03-04 kdw  elliptic:loop-limit work
# 2018-10-04 kdw  elliptic:uppercased fwip trig funcs
# 2018-07-14 kdw  elliptic:float num format
# 2018-04-03 kdw  elliptic:rm() from return
# 2018-01-08 kdw  elliptic:AGM formulas
# 2018-01-06 kdw  elliptic:AGM formulas
# 2018-01-04 kdw  elliptic:created
# A lot of the following code was snarfed from:
# Cephes Math Library Release 2.8:  June, 2000
# COPYRIGHT 1984, 1987, 1993, 2000 by Stephen L. Moshier
#   FFFFFFFFFFunction ------------------------------------- m2k #
FUNC DBL m2k(DBL mm):
   RETURN SQRT(mm);
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- k2m #
FUNC DBL k2m(DBL kk):
   # m == kk * kk
   RETURN kk * kk;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- a2k #
FUNC DBL a2k(DBL aa):
   RETURN SIN(aa);
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- k2a #
FUNC DBL k2a(DBL kk):
   RETURN Kw.sininv(kk);
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- a2m #
FUNC DBL a2m(DBL aa):
   RETURN Kw.square(SIN(aa));
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- m2a #
FUNC DBL m2a(DBL mm):
   RETURN Kw.sininv(SQRT(mm));
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- m2b #
FUNC DBL m2b(DBL mm):
   RETURN 1.0 / SQRT(1 - mm);
FUNC_END
#   FFFFFFFFFFunction ------------------------------------- b2m #
FUNC DBL b2m(DBL bb):
   RETURN 1.0 - 1.0 / (bb * bb);
FUNC_END
#   FFFFFFFFFFunction ------------------------------ elliptic1m #
FUNC DBL elliptic1m(DBL mm):
   # Complete Elliptic Integral of the 1th kind.
   #      PI/2          1
   # INTEGRATE  ------------------- dt
   #         0    -----------------
   #             / 1 - mm SIN(t)**2
   #            V
   DBL retvalu;
   DBL aa_arr[2];
   DBL bb_arr[2];
   DBL cc_arr[2];
   DBL dd;
   IF mm < 1.0:
      retvalu = Kw.PI / (2.0 * Kw.agmean(1.0, SQRT(1.0 - mm)));
   ELSIF 1.0 < mm:
      aa_arr[0] = 1;
      aa_arr[1] = 0;
      bb_arr[0] = 0;
      bb_arr[1] = SQRT(mm - 1.0);
      dd = Kw.agcmean(aa_arr[], bb_arr[], cc_arr[]);
      retvalu = Kw.PI / (2.0 * dd);
   ELSE:
      retvalu = 20.0;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:elliptic1m(0.01)==carlsonRF(0,0.99,1);
#TEST:elliptic1m(0.49)==1.8456939983747235175865286548842198353;
#   FFFFFFFFFFunction ------------------------------- ellipticK #
FUNC DBL ellipticK(DBL kk):
   # Complete Elliptic Integral of the 1th kind.
   RETURN elliptic1m(k2m(kk));
FUNC_END
#   FFFFFFFFFFunction --------------------------- elliptic1m__1 #
FUNC DBL elliptic1m__1(DBL mm):
   # Complete Elliptic Integral of the 1th kind
   #   == RF(0, 1-MM, 1)
   RETURN Kw.carlsonRF(0.0, 1.0 - mm, 1.0);
FUNC_END
#   FFFFFFFFFFunction --------------------------- elliptic1m__2 #
FUNC DBL elliptic1m__2(DBL mm):
   # Complete Elliptic Integral of the 1th kind
   DBL term;
   DBL sum_curr;
   DBL sum_prev;
   INT ii;
   term = Kw.TAU / 4.0;
   sum_curr = 0;
   AWAIT Kw.iseq(sum_curr, sum_prev) COUNT ii FROM 1 BY 2:
      term *= Kw.square(mm * ii / (ii + 1));
      sum_prev = sum_curr;
      sum_curr += term;
   AWAIT_END
   RETURN sum_curr;
FUNC_END
#   FFFFFFFFFFunction ----------------------------- elliptic1im #
FUNC DBL elliptic1im(DBL mm
      , DBL circ_rad):
   # Incomplete Elliptic Integral of the 1th kind.
   #       PHI           1
   # INTEGRATE  ------------------- dt
   #         0    -----------------
   #             / 1 - mm SIN(t)**2
   #            V
   DBL aan;
   DBL ggn;
   DBL cc;
   BOL skip_flag;
   DBL temp;
   DBL retvalu;
   DBL tt;
   DBL kresult;
   DBL lcirc_rad;
   DBL mc;
   INT ii;
   INT modd;
   INT signof;
   INT npihlfs;
   DBL ee;
   mc = 1.0 - mm;
   IF Kw.iszero(mm):
      retvalu = circ_rad;
   ELSIF Kw.iszero(mc):
      IF Kw.PI / 2 <= ABS(circ_rad):
         retvalu = DBLMAX;
      ELSE:
         retvalu = LN(TAN((Kw.PI / 2 + circ_rad) / 2.0));
      IF_END
   ELSE:
      npihlfs = FLOOR(circ_rad / (Kw.PI / 2));
      IF Kw.isodd(npihlfs):
         npihlfs += 1;
      IF_END
      # now npihlfs is even
      lcirc_rad = circ_rad;
      IF npihlfs == 0:
         kresult = 0.0;
      ELSE:
         kresult = Kw.elliptic1m(mm);
         lcirc_rad -= npihlfs * Kw.PI / 2;
      IF_END
      IF lcirc_rad < 0.0:
         lcirc_rad = -lcirc_rad;
         signof = -1;
      ELSE:
         signof = 1;
      IF_END
      tt = TAN(lcirc_rad);
      ggn = SQRT(mc);
      skip_flag = FALSE;
      IF 10.0 < ABS(tt):
         ee = 1.0 / (ggn * tt);
         IF ABS(ee) < 10.0:
            IF npihlfs == 0:
               kresult = Kw.elliptic1m(mm);
            IF_END
            temp = kresult - Kw.elliptic1im(mm, ATAN2(ee, 1));
            skip_flag = TRUE;
         IF_END
      IF_END
      IF NOT skip_flag:
         aan = 1.0;
         ii = 1;
         modd = 0;
         AWAIT ABS(cc / aan) <= DBLEPS:
            temp = ggn / aan;
            lcirc_rad += ATAN2(tt * temp, 1) + modd * Kw.PI;
            modd = FLOOR(lcirc_rad / Kw.PI + 0.5);
            tt *= (1.0 + temp) / (1.0 - temp * tt * tt);
            cc = (aan - ggn) / 2.0;
            temp = SQRT(aan * ggn);
            aan = (aan + ggn) / 2.0;
            ggn = temp;
            ii += ii;
         AWAIT_END
         temp = (ATAN2(tt, 1.0) + modd * Kw.PI) / (ii * aan);
      IF_END
      IF signof < 0:
         temp = -temp;
      IF_END
      retvalu = temp + npihlfs * kresult;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:elliptic1im(0.81,1)==1.15966107073219896613246347782023808;
#   FFFFFFFFFFunction ------------------------------ elliptic1k #
FUNC DBL elliptic1k(DBL kk):
   # Complete Elliptic Integral of the 1th kind.
   RETURN elliptic1m(k2m(kk));
FUNC_END
#   FFFFFFFFFFunction ----------------------------- elliptic1ik #
FUNC DBL elliptic1ik(DBL kk
      , DBL circ_rad):
   # Incomplete Elliptic Integral of the 1th kind.
   RETURN elliptic1im(k2m(kk), circ_rad);
FUNC_END
#   FFFFFFFFFFunction ------------------------------ elliptic1a #
FUNC DBL elliptic1a(DBL aa):
   # Complete Elliptic Integral of the 1th kind.
   RETURN elliptic1m(a2m(aa));
FUNC_END
#   FFFFFFFFFFunction ----------------------------- elliptic1ia #
FUNC DBL elliptic1ia(DBL aa
      , DBL circ_rad):
   # Incomplete Elliptic Integral of the 1th kind.
   RETURN elliptic1im(a2m(aa), circ_rad);
FUNC_END
#   FFFFFFFFFFunction ------------------------------- ellipticF #
FUNC DBL ellipticF(DBL kk
      , DBL circ_rad):
   # Incomplete Elliptic Integral of the 1th kind.
   RETURN elliptic1im(k2m(kk), circ_rad);
FUNC_END
#   FFFFFFFFFFunction -------------------------- elliptic1im__1 #
FUNC DBL elliptic1im__1(DBL mm
      , DBL circ_rad):
   # Incomplete Elliptic Integral of the 1th kind.
   #   ==SIN(PHI) * RF(COS(PHI)**2, 1 - MM * SIN(PHI)**2, 1)
   DBL sinphi;
   INT npihlfs;
   DBL lcirc_rad;
   DBL kresult;
   npihlfs = FLOOR(circ_rad / (Kw.PI / 2));
   IF Kw.isodd(npihlfs):
      npihlfs += 1;
   IF_END
   # now npihlfs is even
   lcirc_rad = circ_rad;
   IF npihlfs == 0:
      kresult = 0.0;
   ELSE:
      kresult = Kw.elliptic1m(mm) * npihlfs;
      lcirc_rad -= npihlfs * Kw.PI / 2;
   IF_END
   sinphi = SIN(lcirc_rad);
   RETURN sinphi * Kw.carlsonRF(Kw.square(COS(lcirc_rad)), 1
         - mm * Kw.square(sinphi), 1) + kresult;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ elliptic2m #
FUNC DBL elliptic2m(DBL mm):
   # Complete Elliptic Integral of the 2th kind.
   #      PI/2    -----------------
   # INTEGRATE   / 1 - mm SIN(t)**2 dt
   #         0  V
   DBL aan;
   DBL ggn;
   DBL tn;
   DBL twon;
   DBL sum;
   DBL sum_prev;
   INT ii;
   DBL amm;
   DBL retvalu;
   amm = ABS(mm);
   IF amm < 1.0:
      twon = 0.5;
      aan = 1.0;
      ggn = SQRT(1 - mm);
      sum = 1.0 - mm / 2.0;
      AWAIT Kw.iseq(sum, sum_prev) COUNT ii FROM 0 TO 20:
         twon *= 2.0;
         tn = aan;
         # temporary variable
         aan = (aan + ggn) / 2.0;
         ggn = SQRT(tn * ggn);
         sum_prev = sum;
         sum -= twon * (aan * aan - ggn * ggn);
      AWAIT_END
      retvalu = Kw.PI * sum / (2.0 * aan);
   ELSE:
      retvalu = 1.0;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------- ellipticE #
FUNC DBL ellipticE(DBL kk):
   # Complete Elliptic Integral of the 2th kind.
   RETURN elliptic2m(k2m(kk));
FUNC_END
#   FFFFFFFFFFunction --------------------------- elliptic2m__1 #
FUNC DBL elliptic2m__1(DBL mm):
   # Complete Elliptic Integral of the 2th kind.
   #   == RF(0, 1-MM, 1) - MM * RD(0, 1-MM, 1) / 3
   RETURN Kw.carlsonRF(0, 1 - mm, 1) - mm * Kw.carlsonRD(0, 1
         - mm, 1) / 3.0;
FUNC_END
#   FFFFFFFFFFunction ----------------------------- elliptic2im #
FUNC DBL elliptic2im(DBL mm
      , DBL circ_rad):
   # Incomplete Elliptic Integral of the 2th kind.
   #       PHI    -----------------
   # INTEGRATE   / 1 - mm SIN(t)**2 dt
   #         0  V
   DBL aan;
   DBL ggn;
   DBL cc;
   DBL errsum;
   DBL temp;
   DBL tt;
   DBL eliptwomm;
   DBL mmc;
   INT ii;
   INT modd;
   INT npihalfs;
   INT signof;
   DBL lcirc_rad;
   DBL retvalu;
   IF Kw.iszero(mm):
      retvalu = circ_rad;
   ELSE:
      mmc = 1.0 - mm;
      eliptwomm = elliptic2m(mm);
      npihalfs = FLOOR(circ_rad / (Kw.PI / 2));
      IF Kw.isodd(npihalfs):
         npihalfs += 1;
      IF_END
      lcirc_rad = circ_rad - npihalfs * Kw.PI / 2;
      IF Kw.iszero(mmc):
         retvalu = SIN(lcirc_rad) + npihalfs * eliptwomm;
      ELSE:
         IF lcirc_rad < 0.0:
            lcirc_rad = -lcirc_rad;
            signof = -1;
         ELSE:
            signof = 1;
         IF_END
         tt = TAN(lcirc_rad);
         ggn = SQRT(mmc);
         IF ABS(tt) < - 1:
            errsum = 1.0 / (ggn * tt);
         ELSE:
            errsum = 0.0;
         IF_END
         IF 0.0 < ABS(errsum) AND ABS(errsum) < 1000.0:
            errsum = ATAN2(1.0, ggn * tt);
            temp = eliptwomm - elliptic2im(mm, errsum) + mm
                  * SIN(circ_rad) * SIN(errsum);
         ELSE:
            cc = SQRT(mm);
            aan = 1.0;
            ii = 1;
            modd = 0;
            WHILE DBLEPS < ABS(cc / aan):
               temp = ggn / aan;
               lcirc_rad += ATAN2(tt * temp, 1) + modd * Kw.PI;
               modd = FLOOR(lcirc_rad / Kw.PI + 0.5);
               tt *= (1.0 + temp) / (1.0 - temp * tt * tt);
               cc = (aan - ggn) / 2.0;
               temp = SQRT(aan * ggn);
               aan = (aan + ggn) / 2.0;
               ggn = temp;
               ii += ii;
               errsum += cc * SIN(lcirc_rad);
            WHILE_END
            temp = eliptwomm * (ATAN2(tt, 1) + modd * Kw.PI)
                  / (ii * aan * elliptic1m(mm)) + errsum;
         IF_END
         IF signof < 0:
            temp = -temp;
         IF_END
         retvalu = temp + npihalfs * eliptwomm;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:elliptic2im(0.8,0.7)==0.6561074299024282883936795755843049;
#   FFFFFFFFFFunction ------------------------------ ellipticEi #
FUNC DBL ellipticEi(DBL kk
      , DBL circ_rad):
   # Incomplete Elliptic Integral of the 2th kind.
   RETURN elliptic2im(k2m(kk), circ_rad);
FUNC_END
#   FFFFFFFFFFunction -------------------------- elliptic2im__1 #
FUNC DBL elliptic2im__1(DBL mm
      , DBL circ_rad):
   # Incomplete Elliptic Integral of the 2th kind.
   #   == SIN(PHI) * RF(CPQ, 1 - MM * SPQ, 1)
   #      - MM * SIN(PHI) * SPQ / 3 * RD(CPQ, 1 - MM * SPQ, 1)
   # Where SPQ = SIN(PHI)**2, and CPQ = COS(PHI)**2
   DBL sinphi;
   DBL sinphisq;
   DBL sinphicu;
   DBL cosphisq;
   DBL argb;
   INT npihlfs;
   DBL lcirc_rad;
   DBL kresult;
   npihlfs = FLOOR(circ_rad / (Kw.PI / 2));
   IF Kw.isodd(npihlfs):
      npihlfs += 1;
   IF_END
   # now npihlfs is even
   lcirc_rad = circ_rad;
   IF npihlfs == 0:
      kresult = 0.0;
   ELSE:
      kresult = Kw.elliptic2m(mm) * npihlfs;
      lcirc_rad -= npihlfs * Kw.PI / 2;
   IF_END
   sinphi = SIN(lcirc_rad);
   sinphisq = sinphi * sinphi;
   sinphicu = sinphi * sinphisq;
   cosphisq = Kw.square(COS(lcirc_rad));
   argb = 1 - mm * sinphisq;
   RETURN sinphi * carlsonRF(cosphisq, argb, 1) - mm * sinphicu
         * carlsonRD(cosphisq, argb, 1) / 3.0 + kresult;
FUNC_END
#TEST:elliptic2im__1(0.8,0.7)==0.656107429902428288393679575584;
#   FFFFFFFFFFunction ------------------------------ elliptic2k #
FUNC DBL elliptic2k(DBL kk):
   # Complete Elliptic Integral of the 2th kind.
   RETURN elliptic2m(k2m(kk));
FUNC_END
#   FFFFFFFFFFunction ----------------------------- elliptic2ik #
FUNC DBL elliptic2ik(DBL kk
      , DBL circ_rad):
   # Incomplete Elliptic Integral of the 2th kind.
   RETURN elliptic2im(k2m(kk), circ_rad);
FUNC_END
#   FFFFFFFFFFunction ------------------------------ elliptic2a #
FUNC DBL elliptic2a(DBL aa):
   # Complete Elliptic Integral of the 2th kind.
   RETURN elliptic2m(a2m(aa));
FUNC_END
#   FFFFFFFFFFunction ----------------------------- elliptic2ia #
FUNC DBL elliptic2ia(DBL aa
      , DBL circ_rad):
   # Incomplete Elliptic Integral of the 2th kind.
   RETURN elliptic2im(a2m(aa), circ_rad);
FUNC_END
#   FFFFFFFFFFunction ------------------------------ elliptic3m #
FUNC DBL elliptic3m(DBL nn
      , DBL mm):
   # Complete Elliptic Integral of the 3th kind.
   #      PI/2                    1
   # INTEGRATE  -------------------------------------- dt
   #         0                       -----------------
   #            (1 - nn SIN(t)**2)  / 1 - mm SIN(t)**2
   #                               V
   DBL aan;
   DBL ggn;
   DBL ppn;
   DBL een;
   DBL qqn;
   DBL tpp;
   DBL tag;
   DBL tn;
   DBL sum;
   DBL sum_prev;
   INT ii;
   DBL amm;
   DBL retvalu;
   amm = ABS(mm);
   IF amm < 1.0:
      aan = 1.0;
      ggn = SQRT(1.0 - mm);
      IF 1.0 <= ABS(nn):
         ppn = SQRT(1.0 - mm / nn);
      ELSE:
         ppn = SQRT(1.0 - nn);
      IF_END
      qqn = 1.0;
      sum = qqn;
      AWAIT Kw.iseq(sum, sum_prev) AND Kw.iseq(aan
            , ggn) COUNT ii FROM 0 TO 20:
         tpp = ppn * ppn;
         tag = aan * ggn;
         een = (tpp - tag) / (tpp + tag);
         ppn = (tpp + tag) / (2.0 * ppn);
         qqn = qqn * een / 2.0;
         aan = (aan + ggn) / 2.0;
         ggn = SQRT(tag);
         sum_prev = sum;
         sum += qqn;
      AWAIT_END
      IF 1.0 <= ABS(nn):
         tn = mm * sum / (mm - nn);
      ELSE:
         tn = 2.0 + sum * nn / (1.0 - nn);
      IF_END
      retvalu = Kw.PI * tn / (4.0 * aan);
   ELSE:
      retvalu = 1.0;
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:elliptic3m(0.5,.25)==2.41367150420119464066692352053928994;
#   FFFFFFFFFFunction ------------------------------ elliptic3k #
FUNC DBL elliptic3k(DBL nn
      , DBL kk):
   # Complete Elliptic Integral of the 3th kind.
   RETURN elliptic3m(nn, k2m(kk));
FUNC_END
#   FFFFFFFFFFunction ----------------------------- elliptic3ik #
FUNC DBL elliptic3ik(DBL nn
      , DBL kk
      , DBL circ_rad):
   # Incomplete Elliptic Integral of the 3th kind.
   RETURN elliptic3im(nn, k2m(kk), circ_rad);
FUNC_END
#   FFFFFFFFFFunction ------------------------------ elliptic3a #
FUNC DBL elliptic3a(DBL nn
      , DBL aa):
   # Complete Elliptic Integral of the 3th kind.
   RETURN elliptic3m(nn, a2m(aa));
FUNC_END
#   FFFFFFFFFFunction ----------------------------- elliptic3ia #
FUNC DBL elliptic3ia(DBL nn
      , DBL aa
      , DBL circ_rad):
   # Incomplete Elliptic Integral of the 3th kind.
   RETURN elliptic3im(nn, a2m(aa), circ_rad);
FUNC_END
#   FFFFFFFFFFunction ------------------------------- ellipticP #
FUNC DBL ellipticP(DBL kk
      , DBL circ_rad):
   # Complete Elliptic Integral of the 3th kind.
   RETURN elliptic3m(kk, circ_rad);
FUNC_END
#TEST:ellipticP(0.64,0.81)==4.212860995757084216614126072152338;
#   FFFFFFFFFFunction ----------------------------- elliptic3im #
FUNC DBL elliptic3im(DBL nn
      , DBL mm
      , DBL circ_rad):
   # Incomplete Elliptic Integral of the 3th kind.
   #       PHI                      1
   # INTEGRATE  -------------------------------------- dt
   #         0                       -----------------
   #            (1 - nn SIN(t)**2)  / 1 - mm SIN(t)**2
   #                               V
   DBL sp;
   DBL cp;
   DBL spq;
   DBL cpq;
   DBL spm;
   DBL spn;
   sp = SIN(circ_rad);
   cp = COS(circ_rad);
   spq = sp * sp;
   cpq = cp * cp;
   spm = 1 - mm * spq;
   spn = 1 - nn * spq;
   RETURN sp * (Kw.carlsonRF(cpq, spm, 1) + spq * nn
         * Kw.carlsonRJ(cpq, spm, 1, spn) / 3);
FUNC_END
#   FFFFFFFFFFunction ------------------------------ ellipticPi #
FUNC DBL ellipticPi(DBL nn
      , DBL kk
      , DBL circ_rad):
   # Incomplete Elliptic Integral of the 3th kind.
   RETURN elliptic3im(nn, k2m(kk), circ_rad);
FUNC_END
#   FFFFFFFFFFunction --------------------------- elliptic3m__1 #
FUNC DBL elliptic3m__1(DBL nn
      , DBL mm):
   # Complete Elliptic Integral of the 3th kind.
   #   == carlsonRF(0, 1 - MM, 1)
   #         + NN carlsonRJ(0, 1 - MM, 1, 1 - NN) / 3
   RETURN Kw.carlsonRF(0, 1 - mm, 1) + nn * Kw.carlsonRJ(0, 1
         - mm, 1, 1 - nn) / 3.0;
FUNC_END
#   FFFFFFFFFFunction -------------------------- elliptic3im__1 #
FUNC DBL elliptic3im__1(DBL nn
      , DBL mm
      , DBL circ_rad):
   # Incomplete Elliptic Integral of the 3th kind.
   #   == SIN(PHI) * RF(CPQ, 1 - MM * SPQ, 1)
   #         - NN * SIN(PHI) * SPQ / 3
   #               * RJ(CPQ, 1 - MM * SPQ, 1, 1 - NN * SPQ)
   # Where SPQ = SIN(PHI)**2, and CPQ = COS(PHI)**2
   DBL sinphi;
   DBL sinphisq;
   DBL sinphicu;
   DBL cosphisq;
   DBL argb;
   INT npihlfs;
   DBL lcirc_rad;
   DBL kresult;
   npihlfs = FLOOR(circ_rad / (Kw.PI / 2));
   IF Kw.isodd(npihlfs):
      npihlfs += 1;
   IF_END
   # now npihlfs is even
   lcirc_rad = circ_rad;
   IF npihlfs == 0:
      kresult = 0.0;
   ELSE:
      kresult = Kw.elliptic3m(nn, mm) * npihlfs;
      lcirc_rad -= npihlfs * Kw.PI / 2;
   IF_END
   sinphi = SIN(lcirc_rad);
   sinphisq = sinphi * sinphi;
   sinphicu = sinphi * sinphisq;
   cosphisq = Kw.square(COS(lcirc_rad));
   argb = 1 - mm * sinphisq;
   RETURN sinphi * carlsonRF(cosphisq, argb, 1) + (nn / 3.0)
         * sinphicu * carlsonRJ(cosphisq, argb, 1, 1 - nn
         * sinphisq) + kresult;
FUNC_END
####### Jacobi functions
#   FFFFFFFFFFunction ------------------------------- jacobiphi #
FUNC DBL jacobiphi(DBL mm
      , DBL elli_rad):
   # convert ELLI_RAD into CIRC_RAD
   #    SIN(jacobiphi(M,ELLI_RAD)) = sn(M,ELLI_RAD)
   #    COS(jacobiphi(M,ELLI_RAD)) = cn(M,ELLI_RAD)
   DBL ai;
   DBL bb;
   DBL circ_rad;
   DBL geo_mean;
   DBL twon;
   DBL aa_arr[20];
   DBL cc_arr[20];
   INT ii;
   IF mm <= 0.0:
      circ_rad = Kw.taninv(sn(mm, elli_rad) / cn(mm, elli_rad));
   ELSIF mm < 1.0:
      bb = SQRT(1.0 - mm);
      aa_arr[0] = 1.0;
      cc_arr[0] = SQRT(mm);
      twon = 1.0;
      ii = 0;
      WHILE DBLEPS < ABS(cc_arr[ii] / aa_arr[ii]):
         IF ARRAYLAST(aa_arr[]) - 1 < ii:
            WHILE_EXIT;
         IF_END
         ai = aa_arr[ii];
         ii += 1;
         cc_arr[ii] = (ai - bb) / 2.0;
         geo_mean = SQRT(ai * bb);
         aa_arr[ii] = (ai + bb) / 2.0;
         bb = geo_mean;
         twon *= 2.0;
      WHILE_END
      circ_rad = twon * aa_arr[ii] * elli_rad;
      WHILE 0 < ii:
         bb = cc_arr[ii] * SIN(circ_rad) / aa_arr[ii];
         circ_rad = (Kw.sininv(bb) + circ_rad) / 2.0;
         ii -= 1;
      WHILE_END
   ELSE:
      circ_rad = Kw.taninv(sn(mm, elli_rad) / cn(mm, elli_rad));
   IF_END
   RETURN circ_rad;
FUNC_END
#   FFFFFFFFFFunction --------------------------------- ell2cir #
FUNC DBL ell2cir(DBL mm
      , DBL elli_rad):
   # convert an elliptical angle ELLI_RAD
   # into a circular angle CIRC_RAD
   # pseudo-period == (TAU/4)/elliptic1m(mm)
   # LSF Line: y = (TAU/4)/elliptic1m(mm) * x
   RETURN jacobiphi(mm, elli_rad);
FUNC_END
#   FFFFFFFFFFunction --------------------------------- cir2ell #
FUNC DBL cir2ell(DBL mm
      , DBL circ_rad):
   # convert a circular angle CIRC_RAD
   # into an elliptical angle ELLI_RAD
   # pseudo-period == elliptic1m(mm)/(TAU/4)
   # LSF Line: y = elliptic1m(mm)/(TAU/4) * x
   RETURN elliptic1im(mm, circ_rad);
FUNC_END
#   FFFFFFFFFFunction ------------------------------- jacobicir #
FUNC DBL jacobicir(DBL mm):
   # circumference of ellipse w/ minor axis == 1, m == MM
   RETURN 4.0 * elliptic2m(mm) / SQRT(1.0 - mm);
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- dn #
FUNC DBL dn(DBL mm
      , DBL elli_rad):
   DBL ai;
   DBL csx;
   DBL snx;
   DBL kk;
   DBL retvalu;
   # Check for special cases
   IF mm < 0.0:
      retvalu = -dn(-mm, elli_rad) + 2.0;
   ELSIF mm < 1E-9:
      snx = SIN(elli_rad);
      retvalu = 1.0 - mm * snx * snx / 2.0;
   ELSIF mm < 1.0 - 1E-9:
      snx = SIN(jacobiphi(mm, elli_rad));
      retvalu = Kw.sqrtx(1.0 - mm * snx * snx);
   ELSIF mm <= 1.0:
      ai = (1.0 - mm) / 4.0;
      csx = Kw.cosh(elli_rad);
      snx = Kw.sinh(elli_rad);
      retvalu = 1.0 / csx + ai * (csx * snx + elli_rad);
   ELSE:
      kk = m2k(mm);
      retvalu = cn(1.0 / mm, elli_rad * kk);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- cn #
FUNC DBL cn(DBL mm
      , DBL elli_rad):
   # elliptic cosine
   DBL ai;
   DBL csx;
   DBL snx;
   DBL kk;
   DBL retvalu;
   # Check for special cases
   IF mm < 0.0:
      retvalu = -cn(-mm, elli_rad) + 2 * COS(elli_rad);
   ELSIF mm < 1E-9:
      snx = SIN(elli_rad);
      csx = COS(elli_rad);
      ai = mm * (elli_rad - snx * csx) / 4.0;
      retvalu = csx + ai * snx;
   ELSIF mm < 1.0 - 1E-9:
      retvalu = COS(jacobiphi(mm, elli_rad));
   ELSIF mm <= 1.0:
      ai = (1.0 - mm) / 4.0;
      csx = Kw.cosh(elli_rad);
      snx = Kw.sinh(elli_rad);
      retvalu = 1.0 / csx - ai * (csx * snx + elli_rad);
   ELSE:
      kk = m2k(mm);
      retvalu = dn(1.0 / mm, elli_rad * kk);
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- sn #
FUNC DBL sn(DBL mm
      , DBL elli_rad):
   # elliptic sine
   DBL ai;
   DBL csx;
   DBL snx;
   DBL kk;
   DBL retvalu;
   # Check for special cases
   IF mm < 0.0:
      retvalu = -sn(1.0 - mm, elli_rad) + SIN(elli_rad)
            + Kw.tanh(elli_rad);
   ELSIF mm < 1E-9:
      snx = SIN(elli_rad);
      csx = COS(elli_rad);
      ai = mm * (elli_rad - snx * csx) / 4.0;
      retvalu = snx - ai * csx;
   ELSIF mm < 1.0 - 1E-9:
      retvalu = SIN(jacobiphi(mm, elli_rad));
   ELSIF mm <= 1.0:
      ai = (1.0 - mm) / 4.0;
      csx = Kw.cosh(elli_rad);
      snx = Kw.sinh(elli_rad);
      retvalu = (snx + snx * ai - ai * elli_rad / csx) / csx;
   ELSE:
      kk = m2k(mm);
      retvalu = sn(1.0 / mm, elli_rad * kk) / kk;
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- cd #
FUNC DBL cd(DBL mm
      , DBL elli_rad):
   RETURN cn(mm, elli_rad) / dn(mm, elli_rad);
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- sd #
FUNC DBL sd(DBL mm
      , DBL elli_rad):
   RETURN sn(mm, elli_rad) / dn(mm, elli_rad);
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- nd #
FUNC DBL nd(DBL mm
      , DBL elli_rad):
   RETURN 1.0 / dn(mm, elli_rad);
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- dc #
FUNC DBL dc(DBL mm
      , DBL elli_rad):
   RETURN dn(mm, elli_rad) / cn(mm, elli_rad);
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- nc #
FUNC DBL nc(DBL mm
      , DBL elli_rad):
   # elliptic cosecant
   RETURN 1.0 / cn(mm, elli_rad);
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- sc #
FUNC DBL sc(DBL mm
      , DBL elli_rad):
   # elliptic tangent
   RETURN sn(mm, elli_rad) / cn(mm, elli_rad);
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- ds #
FUNC DBL ds(DBL mm
      , DBL elli_rad):
   RETURN dn(mm, elli_rad) / sn(mm, elli_rad);
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- cs #
FUNC DBL cs(DBL mm
      , DBL elli_rad):
   # elliptic cotangent
   RETURN cn(mm, elli_rad) / sn(mm, elli_rad);
FUNC_END
#   FFFFFFFFFFunction -------------------------------------- ns #
FUNC DBL ns(DBL mm
      , DBL elli_rad):
   # elliptic cosecant
   RETURN 1.0 / sn(mm, elli_rad);
FUNC_END
BLOCK:# Jacobi elliptic functions
   BLOCK_DEF DBL lv_mm = -10.0;
   BLOCK_DEF DBL lv_elli_rad = -10.0;
   BLOCK_DEF DBL lv_arr_arr[4];
   #   FFFFFFFFFFunction ----------------------------- lv_ellpj #
   BLOCK_DEF FUNC INT lv_ellpj(DBL mm, DBL elli_rad
         , WRITEONLY DBL ret_arr_p[]):
      # compute the Jacobian function sn, cn, dn and ph
      # sn = RET_ARR_P[0]
      # cn = RET_ARR_P[1]
      # dn = RET_ARR_P[2]
      # ph = RET_ARR_P[3]
      BLOCK_USE lv_mm;
      BLOCK_USE lv_elli_rad;
      DBL ai;
      DBL csx;
      DBL snx;
      DBL circ_rad;
      DBL twon;
      DBL junk_arr[4];
      # Check for special cases
      IF mm < 0.0:
         snx = -sn(1.0 - mm, elli_rad) + SIN(elli_rad)
               + Kw.tanh(elli_rad);
         csx = -cn(-mm, elli_rad) + 2 * COS(elli_rad);
         ret_arr_p[0] = snx;
         ret_arr_p[1] = csx;
         ret_arr_p[2] = -dn(-mm, elli_rad) + 2.0;
         ret_arr_p[3] = ATAN2(snx, csx);
      ELSIF mm < 1E-9:
         snx = SIN(elli_rad);
         csx = COS(elli_rad);
         ai = mm * (elli_rad - snx * csx) / 4.0;
         ret_arr_p[0] = snx - ai * csx;
         ret_arr_p[1] = csx + ai * snx;
         ret_arr_p[2] = 1.0 - mm * snx * snx / 2.0;
         ret_arr_p[3] = elli_rad - ai;
      ELSIF mm < 1.0 - 1E-9:
         circ_rad = Kw.jacobiphi(mm, elli_rad);
         snx = SIN(circ_rad);
         ret_arr_p[0] = snx;
         ret_arr_p[1] = COS(circ_rad);
         ret_arr_p[2] = Kw.sqrtx(1.0 - mm * snx * snx);
         ret_arr_p[3] = circ_rad;
      ELSIF mm <= 1.0:
         ai = (1.0 - mm) / 4.0;
         csx = Kw.cosh(elli_rad);
         snx = Kw.tanh(elli_rad);
         twon = csx * Kw.sinh(elli_rad);
         ret_arr_p[0] = snx + ai * (twon - elli_rad) / (csx
               * csx);
         ret_arr_p[3] = 2.0 * ATAN2(EXP(elli_rad), 1.0) - Kw.PI
               / 2.0 + ai * (twon - elli_rad) / csx;
         ai *= snx / csx;
         ret_arr_p[1] = 1.0 / csx - ai * (twon - elli_rad);
         ret_arr_p[2] = 1.0 / csx + ai * (twon + elli_rad);
      ELSE:
         ai = m2k(mm);
         CALL lv_ellpj(1.0 / mm, elli_rad * ai, junk_arr[]);
         ret_arr_p[0] = junk_arr[0] / ai;
         ret_arr_p[1] = junk_arr[2];
         ret_arr_p[2] = junk_arr[1];
         ret_arr_p[3] = junk_arr[3];
      IF_END
      lv_mm = mm;
      lv_elli_rad = elli_rad;
      RETURN 0;
   FUNC_END
   #   FFFFFFFFFFunction -------------------------------- sn__1 #
   FUNC DBL sn__1(DBL mm
         , DBL elli_rad):
      BLOCK_USE lv_mm;
      BLOCK_USE lv_elli_rad;
      BLOCK_USE lv_arr_arr[];
      IF Kw.isneq(mm, lv_mm) OR Kw.isneq(elli_rad, lv_elli_rad):
         CALL lv_ellpj(mm, elli_rad, lv_arr_arr[]);
      IF_END
      RETURN lv_arr_arr[0];
   FUNC_END
   #   FFFFFFFFFFunction -------------------------------- cn__1 #
   FUNC DBL cn__1(DBL mm
         , DBL elli_rad):
      BLOCK_USE lv_mm;
      BLOCK_USE lv_elli_rad;
      BLOCK_USE lv_arr_arr[];
      IF Kw.isneq(mm, lv_mm) OR Kw.isneq(elli_rad, lv_elli_rad):
         CALL lv_ellpj(mm, elli_rad, lv_arr_arr[]);
      IF_END
      RETURN lv_arr_arr[1];
   FUNC_END
   #   FFFFFFFFFFunction -------------------------------- dn__1 #
   FUNC DBL dn__1(DBL mm
         , DBL elli_rad):
      BLOCK_USE lv_mm;
      BLOCK_USE lv_elli_rad;
      BLOCK_USE lv_arr_arr[];
      IF Kw.isneq(mm, lv_mm) OR Kw.isneq(elli_rad, lv_elli_rad):
         CALL lv_ellpj(mm, elli_rad, lv_arr_arr[]);
      IF_END
      RETURN lv_arr_arr[2];
   FUNC_END
BLOCK_END# Jacobi elliptic functions
#   FFFFFFFFFFunction ------------------------------------- nom #
FUNC DBL nom(DBL mm):
   RETURN EXP(-Kw.PI * Kw.elliptic1m(1.0 - mm)
         / Kw.elliptic1m(mm));
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- theta1 #
FUNC DBL theta1(DBL mm
      , DBL zz):
   # See https://dlmf.nist.gov/20.2#i
   DBL sum_curr;
   DBL sum_prev;
   INT nn;
   DBL sig;
   DBL ang;
   DBL ang_inc;
   DBL qq;
   sig = 1;
   qq = nom(mm);
   sum_curr = 0;
   ang = zz;
   ang_inc = 2 * zz;
   AWAIT Kw.iseq(sum_curr, sum_prev) COUNT nn FROM 0:
      sum_prev = sum_curr;
      sum_curr += sig * POW(qq, Kw.square(nn + 0.5)) * SIN(ang);
      ang += ang_inc;
      sig = -sig;
   AWAIT_END
   RETURN 2 * sum_curr;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- theta2 #
FUNC DBL theta2(DBL mm
      , DBL zz):
   # See https://dlmf.nist.gov/20.2#i
   DBL sum_curr;
   DBL sum_prev;
   INT nn;
   DBL ang;
   DBL ang_inc;
   DBL qq;
   qq = nom(mm);
   sum_curr = 0;
   ang = zz;
   ang_inc = 2 * zz;
   AWAIT Kw.iseq(sum_curr, sum_prev) COUNT nn FROM 0:
      sum_prev = sum_curr;
      sum_curr += POW(qq, Kw.square(nn + 0.5)) * COS(ang);
      ang += ang_inc;
   AWAIT_END
   RETURN 2 * sum_curr;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- theta3 #
FUNC DBL theta3(DBL mm
      , DBL zz):
   # See https://dlmf.nist.gov/20.2#i
   DBL sum_curr;
   DBL sum_prev;
   INT nn;
   DBL ang;
   DBL ang_inc;
   DBL qq;
   qq = nom(mm);
   sum_curr = 0;
   ang = 2 * zz;
   ang_inc = ang;
   AWAIT Kw.iseq(sum_curr, sum_prev) COUNT nn FROM 1:
      sum_prev = sum_curr;
      sum_curr += POW(qq, nn * nn) * COS(ang);
      ang += ang_inc;
   AWAIT_END
   RETURN 1 + 2 * sum_curr;
FUNC_END
#   FFFFFFFFFFunction ---------------------------------- theta4 #
FUNC DBL theta4(DBL mm
      , DBL zz):
   # See https://dlmf.nist.gov/20.2#i
   DBL sum_curr;
   DBL sum_prev;
   INT nn;
   DBL ang;
   DBL ang_inc;
   DBL qq;
   DBL sig;
   sig = 1;
   qq = nom(mm);
   sum_curr = 0;
   ang = 2 * zz;
   ang_inc = ang;
   AWAIT Kw.iseq(sum_curr, sum_prev) COUNT nn FROM 1:
      sum_prev = sum_curr;
      sum_curr += sig * POW(qq, nn * nn) * COS(ang);
      ang += ang_inc;
      sig = -sig;
   AWAIT_END
   RETURN 1 + 2 * sum_curr;
FUNC_END
#   FFFFFFFFFFunction --------------------------- nevillethetac #
FUNC DBL nevillethetac(DBL mm
      , DBL zz):
   DBL sum_curr;
   DBL sum_prev;
   INT nn;
   DBL qq;
   DBL km;
   DBL cos_of;
   DBL cos_inc;
   km = Kw.elliptic1m(mm);
   qq = EXP(-Kw.PI * Kw.elliptic1m(1.0 - mm) / km);
   sum_curr = 0;
   cos_inc = Kw.PI * zz / km;
   cos_of = Kw.PI * zz / (2 * km);
   AWAIT Kw.iseq(sum_curr, sum_prev) COUNT nn FROM 0:
      sum_prev = sum_curr;
      sum_curr += POW(qq, nn * nn + nn) * COS(cos_of);
      cos_of += cos_inc;
   AWAIT_END
   RETURN sum_curr * SQRT(Kw.TAU * SQRT(qq / mm) / km);
FUNC_END
#   FFFFFFFFFFunction --------------------------- nevillethetad #
FUNC DBL nevillethetad(DBL mm
      , DBL zz):
   DBL sum_curr;
   DBL sum_prev;
   INT nn;
   DBL qq;
   DBL km;
   DBL cos_of;
   DBL cos_inc;
   km = Kw.elliptic1m(mm);
   qq = EXP(-Kw.PI * Kw.elliptic1m(1.0 - mm) / km);
   sum_curr = 0;
   cos_inc = Kw.PI * zz / km;
   cos_of = Kw.PI * zz / km;
   AWAIT Kw.iseq(sum_curr, sum_prev) COUNT nn FROM 1:
      sum_prev = sum_curr;
      sum_curr += POW(qq, nn * nn) * COS(cos_of);
      cos_of += cos_inc;
   AWAIT_END
   RETURN (1 + 2 * sum_curr) * SQRT(Kw.TAU / km) / 2.0;
FUNC_END
#   FFFFFFFFFFunction --------------------------- nevillethetan #
FUNC DBL nevillethetan(DBL mm
      , DBL zz):
   DBL sum_curr;
   DBL sum_prev;
   INT nn;
   DBL qq;
   DBL km;
   DBL sig;
   DBL cos_of;
   DBL cos_inc;
   km = Kw.elliptic1m(mm);
   qq = EXP(-Kw.PI * Kw.elliptic1m(1.0 - mm) / km);
   sum_curr = 0;
   sig = -1;
   cos_inc = Kw.PI * zz / km;
   cos_of = Kw.PI * zz / km;
   AWAIT Kw.iseq(sum_curr, sum_prev) COUNT nn FROM 1:
      sum_prev = sum_curr;
      sum_curr += sig * POW(qq, nn * nn) * COS(cos_of);
      cos_of += cos_inc;
      sig = -sig;
   AWAIT_END
   RETURN (1 + 2 * sum_curr) * SQRT(Kw.TAU / (km * SQRT(1.0
         - mm))) / 2.0;
FUNC_END
#   FFFFFFFFFFunction --------------------------- nevillethetas #
FUNC DBL nevillethetas(DBL mm
      , DBL zz):
   DBL sum_curr;
   DBL sum_prev;
   INT nn;
   DBL qq;
   DBL km;
   DBL sig;
   DBL cos_of;
   DBL cos_inc;
   km = Kw.elliptic1m(mm);
   qq = EXP(-Kw.PI * Kw.elliptic1m(1.0 - mm) / km);
   sum_curr = 0;
   sig = 1;
   cos_inc = Kw.PI * zz / km;
   cos_of = Kw.PI * zz / (2 * km);
   AWAIT Kw.iseq(sum_curr, sum_prev) COUNT nn FROM 0:
      sum_prev = sum_curr;
      sum_curr += sig * POW(qq, nn * nn + nn) * SIN(cos_of);
      sig = -sig;
      cos_of += cos_inc;
   AWAIT_END
   RETURN sum_curr * SQRT(Kw.TAU * SQRT(qq / (mm * (1 - mm)))
         / km);
FUNC_END
# In general:
#   pq qr = pr
#   sn(m,elli_rad) == SIN(jacobiphi(m,elli_rad))
#   elliptic1im(m,jacobiphi(m,elli_rad)) == elli_rad
#         in[0,elliptic1m(m)]
#   jacobiphi(m,elliptic1im(m,circ_rad)) == circ_rad in[0,PI/2]
#   cX**2 + sX**2 = nX**2 for X in s,d,c,n
#   sn(m,elliptic1im(m,circ_rad)) == SIN(circ_rad)
#   cn(m,elliptic1im(m,circ_rad)) == COS(circ_rad)
#   sc(m,elliptic1im(m,circ_rad)) == TAN(circ_rad)
#   dn(m,elliptic1im(m,circ_rad)) == SQRT(1 - m*SIN(circ_rad)**2)
#   The quarter-period of pq(m,elli_rad) is elliptic1m(m)
#TEST:sn(0.87,elliptic1im(0.87,0.44))==sin(0.44);
#TEST:cn(0.44,elliptic1im(0.44,0.87))==cos(0.87);
#TEST:sn(0.34,1.2)==sin(jacobiphi(0.34,1.2));
#TEST:sc(0.94,1.2)==tan(jacobiphi(0.94,1.2));
#   IIIIIIIIIInsert-End ------------------------- elliptic.fwip #
#   IIIIIIIIIInsert-Begin ------------------------ ellipse.fwip #
#    COPYRIGHT C 2020 by Kevin D. Woerner
# 2020-08-11 kdw  ellipse:ell[i]ptic function renam
# 2020-08-03 kdw  ellipse:explicit module for pi and tau
# 2020-07-02 kdw  ellipse:more tests; circ computed
# 2020-06-25 kdw  ellipse:func renam
# 2020-06-15 kdw  ellipse:ell[i]psem func
# 2020-06-09 kdw  ellipse:ell[i]ptic func renam
# 2020-06-01 kdw  ellipse:flat2ecc and ecc2flat funcs
# 2020-02-21 kdw  ellipse:created
# 0 <= m == eccentricity**2 <= 1
#   FFFFFFFFFFunction ----------------------------- ellipsearea #
FUNC DBL ellipsearea(DBL aa
      , DBL bb):
   # area of an ellipse with semi-axes AA and BB
   RETURN Kw.PI * aa * bb;
FUNC_END
#   FFFFFFFFFFunction ------------------------------ ellipseecc #
FUNC DBL ellipseecc(DBL aa
      , DBL bb):
   # eccentricity of an ellipse with semi-axes AA and BB
   DBL rati;
   rati = Kw.ratio(aa, bb);
   RETURN SQRT(1.0 - rati * rati);
FUNC_END
#   FFFFFFFFFFunction -------------------------------- ellipsem #
FUNC DBL ellipsem(DBL aa
      , DBL bb):
   # m parameter of an ellipse with semi-axes AA and BB
   DBL rati;
   rati = Kw.ratio(aa, bb);
   RETURN 1.0 - rati * rati;
FUNC_END
#   FFFFFFFFFFunction ------------------------- ellipseflatness #
FUNC DBL ellipseflatness(DBL aa
      , DBL bb):
   # flatness of an ellipse with semi-axes AA and BB
   RETURN 1.0 - Kw.ratio(aa, bb);
FUNC_END
#   FFFFFFFFFFunction -------------------------------- flat2ecc #
FUNC DBL flat2ecc(DBL flt):
   RETURN SQRT(flt * (2.0 - flt));
FUNC_END
#   FFFFFFFFFFunction -------------------------------- ecc2flat #
FUNC DBL ecc2flat(DBL ecc):
   RETURN 1.0 - SQRT(1.0 - ecc * ecc);
FUNC_END
#   FFFFFFFFFFunction --------------------------- ellipsecir__1 #
FUNC DBL ellipsecir__1(DBL aa
      , DBL bb):
   # circumference of an ellipse with semi-axes AA and BB
   DBL major_axis;
   DBL minor_axis;
   DBL rati;
   IF aa < bb:
      major_axis = bb;
      minor_axis = aa;
   ELSE:
      major_axis = aa;
      minor_axis = bb;
   IF_END
   rati = minor_axis / major_axis;
   # now major_axis = max(AA, BB)
   RETURN 4.0 * major_axis * Kw.elliptic2m(1.0 - rati * rati);
FUNC_END
#   FFFFFFFFFFunction ------------------------------ ellipsecir #
FUNC DBL ellipsecir(DBL aa
      , DBL bb):
   # circumference of an ellipse with semi-axes AA and BB
   DBL xx;
   DBL yy;
   DBL mm;
   DBL suma;
   DBL temp;
   INT ii;
   DBL retvalu;
   IF aa < bb:
      xx = bb;
      yy = aa;
   ELSE:
      xx = aa;
      yy = bb;
   IF_END
   IF yy <= SQRT(DBLEPS) * xx:
      retvalu = 4.0 * xx;
   ELSE:
      suma = 0.0;
      mm = 1.0;
      AWAIT Kw.iseq(xx, yy) COUNT ii FROM 0 TO 20:
         temp = (xx + yy) / 2.0;
         yy = SQRT(xx * yy);
         xx = temp;
         mm += mm;
         suma += mm * Kw.square(xx - yy);
      AWAIT_END
      retvalu = Kw.PI * (Kw.square(aa + bb) - suma) / (xx + yy);
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:ellipsecir(1,10)==40.639741801008957425577931011816563791;
#TEST:ellipsearea(1,10)==31.41592653589793238462643383279502884;
#   IIIIIIIIIInsert-End -------------------------- ellipse.fwip #
#   IIIIIIIIIInsert-Begin ---------------------------- cdf.fwip #
#    COPYRIGHT C 2019-2020 by Kevin D. Woerner
# 2020-06-03 kdw  cdf:writeonly keyword
# 2020-05-12 kdw  cdf:nul rets changed
# 2020-03-02 kdw  cdf:s/_N[E]XT/_E[N]D/
# 2020-02-24 kdw  cdf:function comments
# 2020-02-07 kdw  cdf:funcs renamd; ep[d]f2cdf
# 2020-01-26 kdw  cdf:var renam
# 2019-09-17 kdw  cdf:rmed c[n]v_db[l]2i32
# 2019-08-13 kdw  cdf:function pdf created
# 2019-08-12 kdw  cdf:created
#   FFFFFFFFFFunction ------------------------------------ epdf #
FUNC DBL epdf(DBL minvalx
      , DBL maxvalx
      , INT nn
      , READONLY DBL data_arr_pc[]
      , INT mm
      , WRITEONLY DBL ret_pdf_arr_p[]):
   # compute the Empirical PDF of DATA_ARR_PC[] over the
   # interval MINVALX to MAXVALX in MM steps
   # I.E. let LEN = (MAXVALX - MINVALX) / MM
   #    RET_PDF_ARR_P[0] = (# of DATA_ARR_PC[] < MINVALX) / nn
   # IF 0 < II < MM:
   #    RET_PDF_ARR_P[II] = (# of DATA_ARR_PC[] in the interval
   #[MINVALX + (II - 1) * LEN, MINVALX + II * LEN)) / NN
   # ELSIF II == 0
   #    RET_PDF_ARR_P[0] = (# of DATA_ARR_PC[] < MINVAL) / NN
   # returns(# of DATA_ARR_PC[] >= MAXVALX) / NN
   INT ii;
   INT indi;
   DBL gap_size;
   DBL retvalu;
   DBL inc;
   FOR ii FROM 0 TO mm - 1:
      ret_pdf_arr_p[ii] = 0;
   FOR_END
   inc = 1.0 / nn;
   gap_size = (maxvalx - minvalx) / (mm - 1);
   retvalu = 0;
   FOR ii FROM 0 TO nn - 1:
      IF data_arr_pc[ii] < minvalx:
         ret_pdf_arr_p[0] += inc;
      ELSIF data_arr_pc[ii] < maxvalx:
         indi = CEIL((data_arr_pc[ii] - minvalx) / gap_size);
         ret_pdf_arr_p[indi] += inc;
      ELSE:
         retvalu += inc;
      IF_END
   FOR_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction ------------------------------------ ecdf #
FUNC DBL ecdf(DBL minvalx
      , DBL maxvalx
      , INT nn
      , READONLY DBL data_arr_pc[]
      , INT mm
      , WRITEABLE DBL ret_cdf_arr_p[]):
   # compute the Empirical CDF of DATA_ARR_PC[] over the
   # interval MINVALX to MAXVALX in MM steps
   # Let LEN = (MAXVALX - MINVALX) / MM
   #    RET_CDF_ARR_P[II] = (# of DATA_ARR_PC[]
   #         < MINVALX + II * LEN)) / NN
   INT ii;
   CALL epdf(minvalx, maxvalx, nn, data_arr_pc[], mm
         , ret_cdf_arr_p[]);
   FOR ii FROM 1 TO mm - 1:
      ret_cdf_arr_p[ii] += ret_cdf_arr_p[ii - 1];
   FOR_END
   RETURN ret_cdf_arr_p[mm - 1];
FUNC_END
#   FFFFFFFFFFunction -------------------------------- epdf2cdf #
FUNC DBL epdf2cdf(INT nn
      , READONLY DBL pdf_arr_pc[]
      , WRITEONLY DBL ret_cdf_arr_p[]):
   # convert an Empirical PDF into a CDF
   INT ii;
   DBL sumcurr;
   sumcurr = 0.0;
   FOR ii FROM 0 TO nn - 1:
      sumcurr += pdf_arr_pc[ii];
      ret_cdf_arr_p[ii] = sumcurr;
   FOR_END
   RETURN ret_cdf_arr_p[nn - 1];
FUNC_END
#   IIIIIIIIIInsert-End ------------------------------ cdf.fwip #
#   IIIIIIIIIInsert-Begin ------------------------- search.fwip #
#    COPYRIGHT C 2018-2020 by Kevin D. Woerner
# 2020-07-27 kdw  search:block syntax
# 2020-07-24 kdw  search:comment cleanup
# 2020-06-22 kdw  search:local-use mved before var decls
# 2020-05-11 kdw  search:local-decl syntx change
# 2020-04-26 kdw  search:BL[O]CK indentation work
# 2020-04-12 kdw  search:comment change
# 2020-03-09 kdw  search:LO[C]AL_.* keywords
# 2020-03-05 kdw  search:minor tweak
# 2020-03-02 kdw  search:s/_N[E]XT/_E[N]D/
# 2020-02-03 kdw  search:single reeturn from each func
# 2019-12-06 kdw  search:rmed print; streamlined
# 2019-10-02 kdw  search:block comment
# 2019-08-26 kdw  search:PRI[N]TS to PR[I]NTSTR
# 2019-08-24 kdw  search:for and count loops have from clause
# 2019-08-18 kdw  search:B[O]OL to B[O]L
# 2019-05-24 kdw  search:local replaced private
# 2019-05-22 kdw  search:s/FU[N]CT[I]ON/FU[N]C/g
# 2018-12-17 kdw  search:created
BLOCK:# search
   BLOCK_DEF INT lv_search_target = 0;
   #   FFFFFFFFFFunction ------------------------- search_check #
   FUNC INT search_check(INT gg):
      BLOCK_USE lv_search_target;
      INT retvalu;
      IF gg < lv_search_target:
         retvalu = -1;
      ELSIF lv_search_target < gg:
         retvalu = 1;
      ELSE:
         retvalu = 0;
      IF_END
      RETURN retvalu;
   FUNC_END
   #   FFFFFFFFFFunction ------------------------ search_search #
   FUNC INT search_search(INT gg):
      BLOCK_USE lv_search_target;
      INT curr;
      INT delta;
      INT result;
      lv_search_target = gg;
      curr = 1;
      FOR delta FROM 0:
         result = search_check(curr);
         IF 0 <= result:
            FOR_EXIT;
         IF_END
         curr += curr;
      FOR_END
      IF 4 <= curr:
         delta = curr / 4;
         # NOW curr and delta are powers of 2.
         #    check(curr) is good; check(curr / 2) is bad
         WHILE 1 <= delta:
            IF 0 < result:
               # CURR is too large
               curr -= delta;
            ELSIF result < 0:
               # CURR is too small
               curr += delta;
            ELSE:
               # CURR is just right
               WHILE_EXIT;
            IF_END
            result = search_check(curr);
            IF delta < 2:
               IF 0 < result AND 1 < curr:
                  curr -= 1;
               IF_END
               WHILE_EXIT;
            IF_END
            delta /= 2;
         WHILE_END
      IF_END
      RETURN curr;
   FUNC_END
BLOCK_END# search
#   IIIIIIIIIInsert-End --------------------------- search.fwip #
#   FFFFFFFFFFunction ------------------------------- blackbody #
FUNC DBL blackbody(DBL wavelength
      , DBL temperk):
   # spectral radiance at WAVELENGTH and TEMPERK
   # returns WATT / (STERADIAN METER**3)
   # == (2.0 * PI**4 * BOLTZMANN**5 * temperk**5)
   #                    / (15 * PLANCK**4 * LIGHT**3)
   #         * bb_pdf(temperk * wavelength * BOLTZMANN
   #                           / (LIGHT * PLANCK))
   DBL hc;
   DBL hc_kt;
   DBL retvalu;
   IF wavelength <= 0.0 OR temperk <= 0.0:
      retvalu = 0.0;
   ELSE:
      hc = Kw.PLANCK * Kw.LIGHT;
      hc_kt = hc / (Kw.BOLTZMANN * temperk);
      retvalu = 2.0 * hc * Kw.LIGHT / (POW(wavelength, 5)
            * (EXP(hc_kt / wavelength) - 1));
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction --------------------------- blackbodymode #
FUNC DBL blackbodymode(DBL temperk):
   # Wavelength at mode of black body spectral radiance
   # at TEMPERK
   DBL hc_kt;
   DBL retvalu;
   IF temperk <= 0.0:
      retvalu = 0.0;
   ELSE:
      hc_kt = Kw.PLANCK * Kw.LIGHT / (Kw.BOLTZMANN * temperk);
      retvalu = hc_kt / (5 + Kw.wp(-5 * EXP(-5)));
   IF_END
   RETURN retvalu;
FUNC_END
#   FFFFFFFFFFunction -------------------------- blackbodypower #
FUNC DBL blackbodypower(DBL temperk):
   # power output by a blackbody at temperature TEMPERK
   # Also known as Stefan-Boltzmann Law
   RETURN Kw.STEFAN * POW(temperk, 4.0);
FUNC_END
#   FFFFFFFFFFunction -------------------------------- pendulum #
FUNC DBL pendulum(DBL len_m
      , DBL ang_offset_rad
      , DBL grav):
   # Period of a pendulum of length LEN_M,
   #      initial angle offset ANG_OFFSET_RAD,
   #      and acceleration due to gravity GRAV.
   RETURN TAU * SQRT(len_m / grav) / Kw.agmean(1
         , COS(ang_offset_rad / 2.0));
FUNC_END
